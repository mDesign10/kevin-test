;(function () {
    'use strict';

    /**
     * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
     *
     * @codingstandard ftlabs-jsv2
     * @copyright The Financial Times Limited [All Rights Reserved]
     * @license MIT License (see LICENSE.txt)
     */

    /*jslint browser:true, node:true*/
    /*global define, Event, Node*/


    /**
     * Instantiate fast-clicking listeners on the specified layer.
     *
     * @constructor
     * @param {Element} layer The layer to listen on
     * @param {Object} [options={}] The options to override the defaults
     */
    function FastClick(layer, options) {
        var oldOnClick;

        options = options || {};

        /**
         * Whether a click is currently being tracked.
         *
         * @type boolean
         */
        this.trackingClick = false;


        /**
         * Timestamp for when click tracking started.
         *
         * @type number
         */
        this.trackingClickStart = 0;


        /**
         * The element being tracked for a click.
         *
         * @type EventTarget
         */
        this.targetElement = null;


        /**
         * X-coordinate of touch start event.
         *
         * @type number
         */
        this.touchStartX = 0;


        /**
         * Y-coordinate of touch start event.
         *
         * @type number
         */
        this.touchStartY = 0;


        /**
         * ID of the last touch, retrieved from Touch.identifier.
         *
         * @type number
         */
        this.lastTouchIdentifier = 0;


        /**
         * Touchmove boundary, beyond which a click will be cancelled.
         *
         * @type number
         */
        this.touchBoundary = options.touchBoundary || 10;


        /**
         * The FastClick layer.
         *
         * @type Element
         */
        this.layer = layer;

        /**
         * The minimum time between tap(touchstart and touchend) events
         *
         * @type number
         */
        this.tapDelay = options.tapDelay || 200;

        /**
         * The maximum time for a tap
         *
         * @type number
         */
        this.tapTimeout = options.tapTimeout || 700;

        if (FastClick.notNeeded(layer)) {
            return;
        }

        // Some old versions of Android don't have Function.prototype.bind
        function bind(method, context) {
            return function() { return method.apply(context, arguments); };
        }


        var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
        var context = this;
        for (var i = 0, l = methods.length; i < l; i++) {
            context[methods[i]] = bind(context[methods[i]], context);
        }

        // Set up event handlers as required
        if (deviceIsAndroid) {
            layer.addEventListener('mouseover', this.onMouse, true);
            layer.addEventListener('mousedown', this.onMouse, true);
            layer.addEventListener('mouseup', this.onMouse, true);
        }

        layer.addEventListener('click', this.onClick, true);
        layer.addEventListener('touchstart', this.onTouchStart, false);
        layer.addEventListener('touchmove', this.onTouchMove, false);
        layer.addEventListener('touchend', this.onTouchEnd, false);
        layer.addEventListener('touchcancel', this.onTouchCancel, false);

        // Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
        // which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
        // layer when they are cancelled.
        if (!Event.prototype.stopImmediatePropagation) {
            layer.removeEventListener = function(type, callback, capture) {
                var rmv = Node.prototype.removeEventListener;
                if (type === 'click') {
                    rmv.call(layer, type, callback.hijacked || callback, capture);
                } else {
                    rmv.call(layer, type, callback, capture);
                }
            };

            layer.addEventListener = function(type, callback, capture) {
                var adv = Node.prototype.addEventListener;
                if (type === 'click') {
                    adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
                            if (!event.propagationStopped) {
                                callback(event);
                            }
                        }), capture);
                } else {
                    adv.call(layer, type, callback, capture);
                }
            };
        }

        // If a handler is already declared in the element's onclick attribute, it will be fired before
        // FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
        // adding it as listener.
        if (typeof layer.onclick === 'function') {

            // Android browser on at least 3.2 requires a new reference to the function in layer.onclick
            // - the old one won't work if passed to addEventListener directly.
            oldOnClick = layer.onclick;
            layer.addEventListener('click', function(event) {
                oldOnClick(event);
            }, false);
            layer.onclick = null;
        }
    }

    /**
     * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
     *
     * @type boolean
     */
    var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

    /**
     * Android requires exceptions.
     *
     * @type boolean
     */
    var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


    /**
     * iOS requires exceptions.
     *
     * @type boolean
     */
    var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


    /**
     * iOS 4 requires an exception for select elements.
     *
     * @type boolean
     */
    var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


    /**
     * iOS 6.0-7.* requires the target element to be manually derived
     *
     * @type boolean
     */
    var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

    /**
     * BlackBerry requires exceptions.
     *
     * @type boolean
     */
    var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

    /**
     * Determine whether a given element requires a native click.
     *
     * @param {EventTarget|Element} target Target DOM element
     * @returns {boolean} Returns true if the element needs a native click
     */
    FastClick.prototype.needsClick = function(target) {
        switch (target.nodeName.toLowerCase()) {

            // Don't send a synthetic click to disabled inputs (issue #62)
            case 'button':
            case 'select':
            case 'textarea':
                if (target.disabled) {
                    return true;
                }

                break;
            case 'input':

                // File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
                if ((deviceIsIOS && target.type === 'file') || target.disabled) {
                    return true;
                }

                break;
            case 'label':
            case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
            case 'video':
                return true;
        }

        return (/\bneedsclick\b/).test(target.className);
    };


    /**
     * Determine whether a given element requires a call to focus to simulate click into element.
     *
     * @param {EventTarget|Element} target Target DOM element
     * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
     */
    FastClick.prototype.needsFocus = function(target) {
        switch (target.nodeName.toLowerCase()) {
            case 'textarea':
                return true;
            case 'select':
                return !deviceIsAndroid;
            case 'input':
                switch (target.type) {
                    case 'button':
                    case 'checkbox':
                    case 'file':
                    case 'image':
                    case 'radio':
                    case 'submit':
                        return false;
                }

                // No point in attempting to focus disabled inputs
                return !target.disabled && !target.readOnly;
            default:
                return (/\bneedsfocus\b/).test(target.className);
        }
    };


    /**
     * Send a click event to the specified element.
     *
     * @param {EventTarget|Element} targetElement
     * @param {Event} event
     */
    FastClick.prototype.sendClick = function(targetElement, event) {
        var clickEvent, touch;

        // On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
        if (document.activeElement && document.activeElement !== targetElement) {
            document.activeElement.blur();
        }

        touch = event.changedTouches[0];

        // Synthesise a click event, with an extra attribute so it can be tracked
        clickEvent = document.createEvent('MouseEvents');
        clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
        clickEvent.forwardedTouchEvent = true;
        targetElement.dispatchEvent(clickEvent);
    };

    FastClick.prototype.determineEventType = function(targetElement) {

        //Issue #159: Android Chrome Select Box does not open with a synthetic click event
        if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
            return 'mousedown';
        }

        return 'click';
    };


    /**
     * @param {EventTarget|Element} targetElement
     */
    FastClick.prototype.focus = function(targetElement) {
        var length;

        // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
        if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
            length = targetElement.value.length;
            targetElement.setSelectionRange(length, length);
        } else {
            targetElement.focus();
        }
    };


    /**
     * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
     *
     * @param {EventTarget|Element} targetElement
     */
    FastClick.prototype.updateScrollParent = function(targetElement) {
        var scrollParent, parentElement;

        scrollParent = targetElement.fastClickScrollParent;

        // Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
        // target element was moved to another parent.
        if (!scrollParent || !scrollParent.contains(targetElement)) {
            parentElement = targetElement;
            do {
                if (parentElement.scrollHeight > parentElement.offsetHeight) {
                    scrollParent = parentElement;
                    targetElement.fastClickScrollParent = parentElement;
                    break;
                }

                parentElement = parentElement.parentElement;
            } while (parentElement);
        }

        // Always update the scroll top tracker if possible.
        if (scrollParent) {
            scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
        }
    };


    /**
     * @param {EventTarget} targetElement
     * @returns {Element|EventTarget}
     */
    FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

        // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
        if (eventTarget.nodeType === Node.TEXT_NODE) {
            return eventTarget.parentNode;
        }

        return eventTarget;
    };


    /**
     * On touch start, record the position and scroll offset.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.onTouchStart = function(event) {
        var targetElement, touch, selection;

        // Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
        if (event.targetTouches.length > 1) {
            return true;
        }

        targetElement = this.getTargetElementFromEventTarget(event.target);
        touch = event.targetTouches[0];

        if (deviceIsIOS) {

            // Only trusted events will deselect text on iOS (issue #49)
            selection = window.getSelection();
            if (selection.rangeCount && !selection.isCollapsed) {
                return true;
            }

            if (!deviceIsIOS4) {

                // Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
                // when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
                // with the same identifier as the touch event that previously triggered the click that triggered the alert.
                // Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
                // immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
                // Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
                // which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
                // random integers, it's safe to to continue if the identifier is 0 here.
                if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
                    event.preventDefault();
                    return false;
                }

                this.lastTouchIdentifier = touch.identifier;

                // If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
                // 1) the user does a fling scroll on the scrollable layer
                // 2) the user stops the fling scroll with another tap
                // then the event.target of the last 'touchend' event will be the element that was under the user's finger
                // when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
                // is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
                this.updateScrollParent(targetElement);
            }
        }

        this.trackingClick = true;
        this.trackingClickStart = event.timeStamp;
        this.targetElement = targetElement;

        this.touchStartX = touch.pageX;
        this.touchStartY = touch.pageY;

        // Prevent phantom clicks on fast double-tap (issue #36)
        if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
            event.preventDefault();
        }

        return true;
    };


    /**
     * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.touchHasMoved = function(event) {
        var touch = event.changedTouches[0], boundary = this.touchBoundary;

        if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
            return true;
        }

        return false;
    };


    /**
     * Update the last position.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.onTouchMove = function(event) {
        if (!this.trackingClick) {
            return true;
        }

        // If the touch has moved, cancel the click tracking
        if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
            this.trackingClick = false;
            this.targetElement = null;
        }

        return true;
    };


    /**
     * Attempt to find the labelled control for the given label element.
     *
     * @param {EventTarget|HTMLLabelElement} labelElement
     * @returns {Element|null}
     */
    FastClick.prototype.findControl = function(labelElement) {

        // Fast path for newer browsers supporting the HTML5 control attribute
        if (labelElement.control !== undefined) {
            return labelElement.control;
        }

        // All browsers under test that support touch events also support the HTML5 htmlFor attribute
        if (labelElement.htmlFor) {
            return document.getElementById(labelElement.htmlFor);
        }

        // If no for attribute exists, attempt to retrieve the first labellable descendant element
        // the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
        return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
    };


    /**
     * On touch end, determine whether to send a click event at once.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.onTouchEnd = function(event) {
        var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

        if (!this.trackingClick) {
            return true;
        }

        // Prevent phantom clicks on fast double-tap (issue #36)
        if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
            this.cancelNextClick = true;
            return true;
        }

        if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
            return true;
        }

        // Reset to prevent wrong click cancel on input (issue #156).
        this.cancelNextClick = false;

        this.lastClickTime = event.timeStamp;

        trackingClickStart = this.trackingClickStart;
        this.trackingClick = false;
        this.trackingClickStart = 0;

        // On some iOS devices, the targetElement supplied with the event is invalid if the layer
        // is performing a transition or scroll, and has to be re-detected manually. Note that
        // for this to function correctly, it must be called *after* the event target is checked!
        // See issue #57; also filed as rdar://13048589 .
        if (deviceIsIOSWithBadTarget) {
            touch = event.changedTouches[0];

            // In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
            targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
            targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
        }

        targetTagName = targetElement.tagName.toLowerCase();
        if (targetTagName === 'label') {
            forElement = this.findControl(targetElement);
            if (forElement) {
                this.focus(targetElement);
                if (deviceIsAndroid) {
                    return false;
                }

                targetElement = forElement;
            }
        } else if (this.needsFocus(targetElement)) {

            // Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
            // Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
            if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
                this.targetElement = null;
                return false;
            }

            this.focus(targetElement);
            this.sendClick(targetElement, event);

            // Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
            // Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
            if (!deviceIsIOS || targetTagName !== 'select') {
                this.targetElement = null;
                event.preventDefault();
            }

            return false;
        }

        if (deviceIsIOS && !deviceIsIOS4) {

            // Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
            // and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
            scrollParent = targetElement.fastClickScrollParent;
            if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
                return true;
            }
        }

        // Prevent the actual click from going though - unless the target node is marked as requiring
        // real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
        if (!this.needsClick(targetElement)) {
            event.preventDefault();
            this.sendClick(targetElement, event);
        }

        return false;
    };


    /**
     * On touch cancel, stop tracking the click.
     *
     * @returns {void}
     */
    FastClick.prototype.onTouchCancel = function() {
        this.trackingClick = false;
        this.targetElement = null;
    };


    /**
     * Determine mouse events which should be permitted.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.onMouse = function(event) {

        // If a target element was never set (because a touch event was never fired) allow the event
        if (!this.targetElement) {
            return true;
        }

        if (event.forwardedTouchEvent) {
            return true;
        }

        // Programmatically generated events targeting a specific element should be permitted
        if (!event.cancelable) {
            return true;
        }

        // Derive and check the target element to see whether the mouse event needs to be permitted;
        // unless explicitly enabled, prevent non-touch click events from triggering actions,
        // to prevent ghost/doubleclicks.
        if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

            // Prevent any user-added listeners declared on FastClick element from being fired.
            if (event.stopImmediatePropagation) {
                event.stopImmediatePropagation();
            } else {

                // Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
                event.propagationStopped = true;
            }

            // Cancel the event
            event.stopPropagation();
            event.preventDefault();

            return false;
        }

        // If the mouse event is permitted, return true for the action to go through.
        return true;
    };


    /**
     * On actual clicks, determine whether this is a touch-generated click, a click action occurring
     * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
     * an actual click which should be permitted.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.onClick = function(event) {
        var permitted;

        // It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
        if (this.trackingClick) {
            this.targetElement = null;
            this.trackingClick = false;
            return true;
        }

        // Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
        if (event.target.type === 'submit' && event.detail === 0) {
            return true;
        }

        permitted = this.onMouse(event);

        // Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
        if (!permitted) {
            this.targetElement = null;
        }

        // If clicks are permitted, return true for the action to go through.
        return permitted;
    };


    /**
     * Remove all FastClick's event listeners.
     *
     * @returns {void}
     */
    FastClick.prototype.destroy = function() {
        var layer = this.layer;

        if (deviceIsAndroid) {
            layer.removeEventListener('mouseover', this.onMouse, true);
            layer.removeEventListener('mousedown', this.onMouse, true);
            layer.removeEventListener('mouseup', this.onMouse, true);
        }

        layer.removeEventListener('click', this.onClick, true);
        layer.removeEventListener('touchstart', this.onTouchStart, false);
        layer.removeEventListener('touchmove', this.onTouchMove, false);
        layer.removeEventListener('touchend', this.onTouchEnd, false);
        layer.removeEventListener('touchcancel', this.onTouchCancel, false);
    };


    /**
     * Check whether FastClick is needed.
     *
     * @param {Element} layer The layer to listen on
     */
    FastClick.notNeeded = function(layer) {
        var metaViewport;
        var chromeVersion;
        var blackberryVersion;
        var firefoxVersion;

        // Devices that don't support touch don't need FastClick
        if (typeof window.ontouchstart === 'undefined') {
            return true;
        }

        // Chrome version - zero for other browsers
        chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

        if (chromeVersion) {

            if (deviceIsAndroid) {
                metaViewport = document.querySelector('meta[name=viewport]');

                if (metaViewport) {
                    // Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
                    if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
                        return true;
                    }
                    // Chrome 32 and above with width=device-width or less don't need FastClick
                    if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
                        return true;
                    }
                }

                // Chrome desktop doesn't need FastClick (issue #15)
            } else {
                return true;
            }
        }

        if (deviceIsBlackBerry10) {
            blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

            // BlackBerry 10.3+ does not require Fastclick library.
            // https://github.com/ftlabs/fastclick/issues/251
            if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
                metaViewport = document.querySelector('meta[name=viewport]');

                if (metaViewport) {
                    // user-scalable=no eliminates click delay.
                    if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
                        return true;
                    }
                    // width=device-width (or less than device-width) eliminates click delay.
                    if (document.documentElement.scrollWidth <= window.outerWidth) {
                        return true;
                    }
                }
            }
        }

        // IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
        if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
            return true;
        }

        // Firefox version - zero for other browsers
        firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

        if (firefoxVersion >= 27) {
            // Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

            metaViewport = document.querySelector('meta[name=viewport]');
            if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
                return true;
            }
        }

        // IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
        // http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
        if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
            return true;
        }

        return false;
    };


    /**
     * Factory method for creating a FastClick object
     *
     * @param {Element} layer The layer to listen on
     * @param {Object} [options={}] The options to override the defaults
     */
    FastClick.attach = function(layer, options) {
        return new FastClick(layer, options);
    };


    // if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
    //
    //     // AMD. Register as an anonymous module.
    //     define(function() {
    //         return FastClick;
    //     });
    // } else if (typeof module !== 'undefined' && module.exports) {
    //     module.exports = FastClick.attach;
    //     module.exports.FastClick = FastClick;
    // } else {
    //
    // }

    /** Don't want AMD ro require support **/
    window.FastClick = FastClick;

}());

// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// JavaScript Dynamic Content shim for Windows Store apps
(function () {

    if (window.MSApp && MSApp.execUnsafeLocalFunction) {

        // Some nodes will have an "attributes" property which shadows the Node.prototype.attributes property
        //  and means we don't actually see the attributes of the Node (interestingly the VS debug console
        //  appears to suffer from the same issue).
        //
        var Element_setAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "setAttribute").value;
        var Element_removeAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "removeAttribute").value;
        var HTMLElement_insertAdjacentHTMLPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "insertAdjacentHTML");
        var Node_get_attributes = Object.getOwnPropertyDescriptor(Node.prototype, "attributes").get;
        var Node_get_childNodes = Object.getOwnPropertyDescriptor(Node.prototype, "childNodes").get;
        var detectionDiv = document.createElement("div");

        function getAttributes(element) {
            return Node_get_attributes.call(element);
        }

        function setAttribute(element, attribute, value) {
            try {
                Element_setAttribute.call(element, attribute, value);
            } catch (e) {
                // ignore
            }
        }

        function removeAttribute(element, attribute) {
            Element_removeAttribute.call(element, attribute);
        }

        function childNodes(element) {
            return Node_get_childNodes.call(element);
        }

        function empty(element) {
            while (element.childNodes.length) {
                element.removeChild(element.lastChild);
            }
        }

        function insertAdjacentHTML(element, position, html) {
            HTMLElement_insertAdjacentHTMLPropertyDescriptor.value.call(element, position, html);
        }

        function inUnsafeMode() {
            var isUnsafe = true;
            try {
                detectionDiv.innerHTML = "<test/>";
            }
            catch (ex) {
                isUnsafe = false;
            }

            return isUnsafe;
        }

        function cleanse(html, targetElement) {
            var cleaner = document.implementation.createHTMLDocument("cleaner");
            empty(cleaner.documentElement);
            MSApp.execUnsafeLocalFunction(function () {
                insertAdjacentHTML(cleaner.documentElement, "afterbegin", html);
            });

            var scripts = cleaner.documentElement.querySelectorAll("script");
            Array.prototype.forEach.call(scripts, function (script) {
                switch (script.type.toLowerCase()) {
                    case "":
                        script.type = "text/inert";
                        break;
                    case "text/javascript":
                    case "text/ecmascript":
                    case "text/x-javascript":
                    case "text/jscript":
                    case "text/livescript":
                    case "text/javascript1.1":
                    case "text/javascript1.2":
                    case "text/javascript1.3":
                        script.type = "text/inert-" + script.type.slice("text/".length);
                        break;
                    case "application/javascript":
                    case "application/ecmascript":
                    case "application/x-javascript":
                        script.type = "application/inert-" + script.type.slice("application/".length);
                        break;

                    default:
                        break;
                }
            });

            function cleanseAttributes(element) {
                var attributes = getAttributes(element);
                if (attributes && attributes.length) {
                    // because the attributes collection is live it is simpler to queue up the renames
                    var events;
                    for (var i = 0, len = attributes.length; i < len; i++) {
                        var attribute = attributes[i];
                        var name = attribute.name;
                        if ((name[0] === "o" || name[0] === "O") &&
                            (name[1] === "n" || name[1] === "N")) {
                            events = events || [];
                            events.push({ name: attribute.name, value: attribute.value });
                        }
                    }
                    if (events) {
                        for (var i = 0, len = events.length; i < len; i++) {
                            var attribute = events[i];
                            removeAttribute(element, attribute.name);
                            setAttribute(element, "x-" + attribute.name, attribute.value);
                        }
                    }
                }
                var children = childNodes(element);
                for (var i = 0, len = children.length; i < len; i++) {
                    cleanseAttributes(children[i]);
                }
            }
            cleanseAttributes(cleaner.documentElement);

            var cleanedNodes = [];

            if (targetElement.tagName === 'HTML') {
                cleanedNodes = Array.prototype.slice.call(document.adoptNode(cleaner.documentElement).childNodes);
            } else {
                if (cleaner.head) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.head).childNodes));
                }
                if (cleaner.body) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.body).childNodes));
                }
            }

            return cleanedNodes;
        }

        function cleansePropertySetter(property, setter) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, property);
            var originalSetter = propertyDescriptor.set;
            Object.defineProperty(HTMLElement.prototype, property, {
                get: propertyDescriptor.get,
                set: function (value) {
                    if(window.WinJS && window.WinJS._execUnsafe && inUnsafeMode()) {
                        originalSetter.call(this, value);
                    } else {
                        var that = this;
                        var nodes = cleanse(value, that);
                        MSApp.execUnsafeLocalFunction(function () {
                            setter(propertyDescriptor, that, nodes);
                        });
                    }
                },
                enumerable: propertyDescriptor.enumerable,
                configurable: propertyDescriptor.configurable,
            });
        }
        cleansePropertySetter("innerHTML", function (propertyDescriptor, target, elements) {
            empty(target);
            for (var i = 0, len = elements.length; i < len; i++) {
                target.appendChild(elements[i]);
            }
        });
        cleansePropertySetter("outerHTML", function (propertyDescriptor, target, elements) {
            for (var i = 0, len = elements.length; i < len; i++) {
                target.insertAdjacentElement("afterend", elements[i]);
            }
            target.parentNode.removeChild(target);
        });

    }

}());
(function(){
    window.WebComponents = window.WebComponents || {};
    function annotate(annotations) {
        return function(target) {
            target.annotations = annotations;
        };
    }
    WebComponents.annotate = annotate;

    window.wccontainer = function() {
        return function(target) {
            target.isContainer = true;
        }
    }
})();
//Custom shim for Safari
if (typeof HTMLElement !== 'function') {
    var _HTMLElement = function(){};
    _HTMLElement.prototype = HTMLElement.prototype;
    HTMLElement = _HTMLElement;
}
/*! This file contains the following polyfills
 *  https://github.com/krambuhl/custom-event-polyfill/blob/master/custom-event-polyfill.js (Needed for ShadyDOM to work in IE11)
 *  http://cdnjs.cloudflare.com/ajax/libs/document-register-element/1.1.1/document-register-element.js
 *  https://github.com/webcomponents/shadydom/blob/master/shadydom.min.js (optionally, if ShadowDOM V1 is not natively supported)
 */

// Polyfill for creating CustomEvents on IE9/10/11

// code pulled from:
// https://github.com/d4tocchini/customevent-polyfill
// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill

try {
    var ce = new window.CustomEvent('test');
    ce.preventDefault();
    if (ce.defaultPrevented !== true) {
        // IE has problems with .preventDefault() on custom events
        // http://stackoverflow.com/questions/23349191
        throw new Error('Could not prevent default');
    }
} catch(e) {
    var CustomEvent = function(event, params) {
        var evt, origPrevent;
        params = params || {
                bubbles: false,
                cancelable: false,
                detail: undefined
            };

        evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        origPrevent = evt.preventDefault;
        evt.preventDefault = function () {
            origPrevent.call(this);
            try {
                Object.defineProperty(this, 'defaultPrevented', {
                    get: function () {
                        return true;
                    }
                });
            } catch(e) {
                this.defaultPrevented = true;
            }
        };
        return evt;
    };

    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent; // expose definition to window
}

/*! (C) Andrea Giammarchi - @WebReflection - Mit Style License */
(function(e){"use strict";function Ot(){var e=yt.splice(0,yt.length);bt=0;while(e.length)e.shift().call(null,e.shift())}function Mt(e,t){for(var n=0,r=e.length;n<r;n++)zt(e[n],t)}function _t(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],At(r,L[Pt(r)])}function Dt(e){return function(t){ot(t)&&(zt(t,e),Mt(t.querySelectorAll(A),e))}}function Pt(e){var t=lt.call(e,"is"),n=e.nodeName.toUpperCase(),r=M.call(k,t?T+t.toUpperCase():x+n);return t&&-1<r&&!Ht(n,t)?-1:r}function Ht(e,t){return-1<A.indexOf(e+'[is="'+t+'"]')}function Bt(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target,s=e[g]||2,o=e[b]||3;xt&&(!i||i===t)&&t[c]&&r!=="style"&&(e.prevValue!==e.newValue||e.newValue===""&&(n===s||n===o))&&t[c](r,n===s?null:e.prevValue,n===o?null:e.newValue)}function jt(e){var t=Dt(e);return function(e){yt.push(t,e.target),bt&&clearTimeout(bt),bt=setTimeout(Ot,1)}}function Ft(e){St&&(St=!1,e.currentTarget.removeEventListener(E,Ft)),Mt((e.target||t).querySelectorAll(A),e.detail===f?f:u),it&&Rt()}function It(e,t){var n=this;pt.call(n,e,t),Tt.call(n,{target:n})}function qt(e,t){tt(e,t),kt?kt.observe(e,mt):(Et&&(e.setAttribute=It,e[s]=Ct(e),e[o](S,Tt)),e[o](w,Bt)),e[v]&&xt&&(e.created=!0,e[v](),e.created=!1)}function Rt(){for(var e,t=0,n=ut.length;t<n;t++)e=ut[t],O.contains(e)||(n--,ut.splice(t--,1),zt(e,f))}function Ut(e){throw new Error("A "+e+" type is already registered")}function zt(e,t){var n,r=Pt(e);-1<r&&(Lt(e,L[r]),r=0,t===u&&!e[u]?(e[f]=!1,e[u]=!0,r=1,it&&M.call(ut,e)<0&&ut.push(e)):t===f&&!e[f]&&(e[u]=!1,e[f]=!0,r=1),r&&(n=e[t+a])&&n.call(e))}function Wt(){}function Xt(e,n,r){var s=r&&r[l]||"",o=n.prototype,u=et(o),a=n.observedAttributes||B,f={prototype:u};st(u,v,{value:function(){if(K)K=!1;else if(!this[z]){this[z]=!0,new n(this),o[v]&&o[v].call(this);var e=Q[Y.get(n)];(!X||e.create.length>1)&&Jt(this)}}}),st(u,c,{value:function(e){-1<M.call(a,e)&&o[c].apply(this,arguments)}}),o[p]&&st(u,h,{value:o[p]}),o[d]&&st(u,m,{value:o[d]}),s&&(f[l]=s),e=e.toUpperCase(),Q[e]={constructor:n,create:s?[s,Z(e)]:[e]},Y.set(n,e),t[i](e.toLowerCase(),f),Kt(e),G[e].r()}function Vt(e){var t=Q[e.toUpperCase()];return t&&t.constructor}function $t(e){return typeof e=="string"?e:e&&e.is||""}function Jt(e){var t=e[c],n=t?e.attributes:B,r=n.length,i;while(r--)i=n[r],t.call(e,i.name||i.nodeName,null,i.value||i.nodeValue)}function Kt(e){return e=e.toUpperCase(),e in G||(G[e]={},G[e].p=new J(function(t){G[e].r=t})),G[e].p}function Qt(){W&&delete e.customElements,H(e,"customElements",{configurable:!0,value:new Wt}),H(e,"CustomElementRegistry",{configurable:!0,value:Wt});for(var n=function(n){var r=e[n];if(r){e[n]=function(n){var i,s;return n||(n=this),n[z]||(K=!0,i=Q[Y.get(n.constructor)],s=X&&i.create.length===1,n=s?Reflect.construct(r,B,i.constructor):t.createElement.apply(t,i.create),n[z]=!0,K=!1,s||Jt(n)),n},e[n].prototype=r.prototype;try{r.prototype.constructor=e[n]}catch(i){U=!0,H(r,z,{value:e[n]})}}},i=r.get(/^HTML[A-Z]*[a-z]/),s=i.length;s--;n(i[s]));t.createElement=function(e,t){var n=$t(t);return n?vt.call(this,e,Z(n)):vt.call(this,e)}}var t=e.document,n=e.Object,r=function(e){var t=/^[A-Z]+[a-z]/,r=function(e){var t=[],n;for(n in s)e.test(n)&&t.push(n);return t},i=function(e,t){t=t.toLowerCase(),t in s||(s[e]=(s[e]||[]).concat(t),s[t]=s[t.toUpperCase()]=e)},s=(n.create||n)(null),o={},u,a,f,l;for(a in e)for(l in e[a]){f=e[a][l],s[l]=f;for(u=0;u<f.length;u++)s[f[u].toLowerCase()]=s[f[u].toUpperCase()]=l}return o.get=function(n){return typeof n=="string"?s[n]||(t.test(n)?[]:""):r(n)},o.set=function(n,r){return t.test(n)?i(n,r):i(r,n),o},o}({collections:{HTMLAllCollection:["all"],HTMLCollection:["forms"],HTMLFormControlsCollection:["elements"],HTMLOptionsCollection:["options"]},elements:{Element:["element"],HTMLAnchorElement:["a"],HTMLAppletElement:["applet"],HTMLAreaElement:["area"],HTMLAttachmentElement:["attachment"],HTMLAudioElement:["audio"],HTMLBRElement:["br"],HTMLBaseElement:["base"],HTMLBodyElement:["body"],HTMLButtonElement:["button"],HTMLCanvasElement:["canvas"],HTMLContentElement:["content"],HTMLDListElement:["dl"],HTMLDataElement:["data"],HTMLDataListElement:["datalist"],HTMLDetailsElement:["details"],HTMLDialogElement:["dialog"],HTMLDirectoryElement:["dir"],HTMLDivElement:["div"],HTMLDocument:["document"],HTMLElement:["element","abbr","address","article","aside","b","bdi","bdo","cite","code","command","dd","dfn","dt","em","figcaption","figure","footer","header","i","kbd","mark","nav","noscript","rp","rt","ruby","s","samp","section","small","strong","sub","summary","sup","u","var","wbr"],HTMLEmbedElement:["embed"],HTMLFieldSetElement:["fieldset"],HTMLFontElement:["font"],HTMLFormElement:["form"],HTMLFrameElement:["frame"],HTMLFrameSetElement:["frameset"],HTMLHRElement:["hr"],HTMLHeadElement:["head"],HTMLHeadingElement:["h1","h2","h3","h4","h5","h6"],HTMLHtmlElement:["html"],HTMLIFrameElement:["iframe"],HTMLImageElement:["img"],HTMLInputElement:["input"],HTMLKeygenElement:["keygen"],HTMLLIElement:["li"],HTMLLabelElement:["label"],HTMLLegendElement:["legend"],HTMLLinkElement:["link"],HTMLMapElement:["map"],HTMLMarqueeElement:["marquee"],HTMLMediaElement:["media"],HTMLMenuElement:["menu"],HTMLMenuItemElement:["menuitem"],HTMLMetaElement:["meta"],HTMLMeterElement:["meter"],HTMLModElement:["del","ins"],HTMLOListElement:["ol"],HTMLObjectElement:["object"],HTMLOptGroupElement:["optgroup"],HTMLOptionElement:["option"],HTMLOutputElement:["output"],HTMLParagraphElement:["p"],HTMLParamElement:["param"],HTMLPictureElement:["picture"],HTMLPreElement:["pre"],HTMLProgressElement:["progress"],HTMLQuoteElement:["blockquote","q","quote"],HTMLScriptElement:["script"],HTMLSelectElement:["select"],HTMLShadowElement:["shadow"],HTMLSlotElement:["slot"],HTMLSourceElement:["source"],HTMLSpanElement:["span"],HTMLStyleElement:["style"],HTMLTableCaptionElement:["caption"],HTMLTableCellElement:["td","th"],HTMLTableColElement:["col","colgroup"],HTMLTableElement:["table"],HTMLTableRowElement:["tr"],HTMLTableSectionElement:["thead","tbody","tfoot"],HTMLTemplateElement:["template"],HTMLTextAreaElement:["textarea"],HTMLTimeElement:["time"],HTMLTitleElement:["title"],HTMLTrackElement:["track"],HTMLUListElement:["ul"],HTMLUnknownElement:["unknown","vhgroupv","vkeygen"],HTMLVideoElement:["video"]},nodes:{Attr:["node"],Audio:["audio"],CDATASection:["node"],CharacterData:["node"],Comment:["#comment"],Document:["#document"],DocumentFragment:["#document-fragment"],DocumentType:["node"],HTMLDocument:["#document"],Image:["img"],Option:["option"],ProcessingInstruction:["node"],ShadowRoot:["#shadow-root"],Text:["#text"],XMLDocument:["xml"]}}),i="registerElement",s="__"+i+(e.Math.random()*1e5>>0),o="addEventListener",u="attached",a="Callback",f="detached",l="extends",c="attributeChanged"+a,h=u+a,p="connected"+a,d="disconnected"+a,v="created"+a,m=f+a,g="ADDITION",y="MODIFICATION",b="REMOVAL",w="DOMAttrModified",E="DOMContentLoaded",S="DOMSubtreeModified",x="<",T="=",N=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,C=["ANNOTATION-XML","COLOR-PROFILE","FONT-FACE","FONT-FACE-SRC","FONT-FACE-URI","FONT-FACE-FORMAT","FONT-FACE-NAME","MISSING-GLYPH"],k=[],L=[],A="",O=t.documentElement,M=k.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},_=n.prototype,D=_.hasOwnProperty,P=_.isPrototypeOf,H=n.defineProperty,B=[],j=n.getOwnPropertyDescriptor,F=n.getOwnPropertyNames,I=n.getPrototypeOf,q=n.setPrototypeOf,R=!!n.__proto__,U=!1,z="__dreCEv1",W=e.customElements,X=!!(W&&W.define&&W.get&&W.whenDefined),V=n.create||n,$=e.Map||function(){var t=[],n=[],r;return{get:function(e){return n[M.call(t,e)]},set:function(e,i){r=M.call(t,e),r<0?n[t.push(e)-1]=i:n[r]=i}}},J=e.Promise||function(e){function i(e){n=!0;while(t.length)t.shift()(e)}var t=[],n=!1,r={"catch":function(){return r},then:function(e){return t.push(e),n&&setTimeout(i,1),r}};return e(i),r},K=!1,Q=V(null),G=V(null),Y=new $,Z=String,et=n.create||function Zt(e){return e?(Zt.prototype=e,new Zt):this},tt=q||(R?function(e,t){return e.__proto__=t,e}:F&&j?function(){function e(e,t){for(var n,r=F(t),i=0,s=r.length;i<s;i++)n=r[i],D.call(e,n)||H(e,n,j(t,n))}return function(t,n){do e(t,n);while((n=I(n))&&!P.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),nt=e.MutationObserver||e.WebKitMutationObserver,rt=(e.HTMLElement||e.Element||e.Node).prototype,it=!P.call(rt,O),st=it?function(e,t,n){return e[t]=n.value,e}:H,ot=it?function(e){return e.nodeType===1}:function(e){return P.call(rt,e)},ut=it&&[],at=rt.cloneNode,ft=rt.dispatchEvent,lt=rt.getAttribute,ct=rt.hasAttribute,ht=rt.removeAttribute,pt=rt.setAttribute,dt=t.createElement,vt=dt,mt=nt&&{attributes:!0,characterData:!0,attributeOldValue:!0},gt=nt||function(e){Et=!1,O.removeEventListener(w,gt)},yt,bt=0,wt=!1,Et=!0,St=!0,xt=!0,Tt,Nt,Ct,kt,Lt,At;i in t||(q||R?(Lt=function(e,t){P.call(t,e)||qt(e,t)},At=qt):(Lt=function(e,t){e[s]||(e[s]=n(!0),qt(e,t))},At=Lt),it?(Et=!1,function(){var e=j(rt,o),t=e.value,n=function(e){var t=new CustomEvent(w,{bubbles:!0});t.attrName=e,t.prevValue=lt.call(this,e),t.newValue=null,t[b]=t.attrChange=2,ht.call(this,e),ft.call(this,t)},r=function(e,t){var n=ct.call(this,e),r=n&&lt.call(this,e),i=new CustomEvent(w,{bubbles:!0});pt.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[y]=i.attrChange=1:i[g]=i.attrChange=0,ft.call(this,i)},i=function(e){var t=e.currentTarget,n=t[s],r=e.propertyName,i;n.hasOwnProperty(r)&&(n=n[r],i=new CustomEvent(w,{bubbles:!0}),i.attrName=n.name,i.prevValue=n.value||null,i.newValue=n.value=t[r]||null,i.prevValue==null?i[g]=i.attrChange=0:i[y]=i.attrChange=1,ft.call(t,i))};e.value=function(e,o,u){e===w&&this[c]&&this.setAttribute!==r&&(this[s]={className:{name:"class",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,"propertychange",i)),t.call(this,e,o,u)},H(rt,o,e)}()):nt||(O[o](w,gt),O.setAttribute(s,1),O.removeAttribute(s),Et&&(Tt=function(e){var t=this,n,r,i;if(t===e.target){n=t[s],t[s]=r=Ct(t);for(i in r){if(!(i in n))return Nt(0,t,i,n[i],r[i],g);if(r[i]!==n[i])return Nt(1,t,i,n[i],r[i],y)}for(i in n)if(!(i in r))return Nt(2,t,i,n[i],r[i],b)}},Nt=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,Bt(o)},Ct=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!=="setAttribute"&&(r[n]=t.value);return r})),t[i]=function(n,r){p=n.toUpperCase(),wt||(wt=!0,nt?(kt=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new nt(function(r){for(var i,s,o,u=0,a=r.length;u<a;u++)i=r[u],i.type==="childList"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,xt&&s[c]&&i.attributeName!=="style"&&(o=lt.call(s,i.attributeName),o!==i.oldValue&&s[c](i.attributeName,i.oldValue,o)))})}(Dt(u),Dt(f)),kt.observe(t,{childList:!0,subtree:!0})):(yt=[],t[o]("DOMNodeInserted",jt(u)),t[o]("DOMNodeRemoved",jt(f))),t[o](E,Ft),t[o]("readystatechange",Ft),rt.cloneNode=function(e){var t=at.call(this,!!e),n=Pt(t);return-1<n&&At(t,L[n]),e&&_t(t.querySelectorAll(A)),t}),-2<M.call(k,T+p)+M.call(k,x+p)&&Ut(n);if(!N.test(p)||-1<M.call(C,p))throw new Error("The type "+n+" is invalid");var i=function(){return a?t.createElement(h,p):t.createElement(h)},s=r||_,a=D.call(s,l),h=a?r[l].toUpperCase():p,p,d;return a&&-1<M.call(k,x+h)&&Ut(h),d=k.push((a?T:x)+p)-1,A=A.concat(A.length?",":"",a?h+'[is="'+n.toLowerCase()+'"]':h),i.prototype=L[d]=D.call(s,"prototype")?s.prototype:et(rt),Mt(t.querySelectorAll(A),u),i},t.createElement=vt=function(e,n){var r=$t(n),i=r?dt.call(t,e,Z(r)):dt.call(t,e),s=""+e,o=M.call(k,(r?T:x)+(r||s).toUpperCase()),u=-1<o;return r&&(i.setAttribute("is",r=r.toLowerCase()),u&&(u=Ht(s.toUpperCase(),r))),xt=!t.createElement.innerHTMLHelper,u&&At(i,L[o]),i}),Wt.prototype={constructor:Wt,define:X?function(e,t,n){if(n)Xt(e,t,n);else{var r=e.toUpperCase();Q[r]={constructor:t,create:[r]},Y.set(t,r),W.define(e,t)}}:Xt,get:X?function(e){return W.get(e)||Vt(e)}:Vt,whenDefined:X?function(e){return J.race([W.whenDefined(e),Kt(e)])}:Kt};if(!W)Qt();else try{(function(n,r,i){r[l]="a",n.prototype=et(HTMLAnchorElement.prototype),n.prototype.constructor=n,e.customElements.define(i,n,r);if(lt.call(t.createElement("a",{is:i}),"is")!==i||X&&lt.call(new n,"is")!==i)throw r})(function en(){return Reflect.construct(HTMLAnchorElement,[],en)},{},"document-register-element-a")}catch(Gt){Qt()}try{dt.call(t,"a","a")}catch(Yt){Z=function(e){return{is:e}}}})(window);

if (!!!HTMLElement.prototype.attachShadow && !Object.setPrototypeOf) {
    
    console.warn("ShadyDOM polyfill not applied for this platform: " + navigator.userAgent);
    console.warn("ShadowDOM not available for web components.");
}

if (!!!HTMLElement.prototype.attachShadow && Object.setPrototypeOf) {
    /*
     @license
     Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
     This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
     The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
     The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
     Code distributed by Google as part of the polymer project is also
     subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
     */
    !function(){"use strict";function e(e){return Boolean("ShadyRoot"===e.__localName)}function t(e,t){return $.call(e,t)}function o(e,t,o){var i=Object.getOwnPropertyDescriptor(t,e);i&&Object.defineProperty(o,e,i)}function i(e,t){if(e&&t)for(var i,n=Object.getOwnPropertyNames(t),r=0;r<n.length&&(i=n[r]);r++)o(i,t,e);return e||t}function n(e){for(var t=[],o=arguments.length-1;o-- >0;)t[o]=arguments[o+1];for(var n=0;n<t.length;n++)i(e,t[n]);return e}function r(e,t){for(var o in t)e[o]=t[o];return e}function d(e,t){var o=Object.getPrototypeOf(e);if(!o.hasOwnProperty("__patchProto")){var n=Object.create(o);n.__sourceProto=o,i(n,t),o.__patchProto=n}Object.setPrototypeOf(e,o.__patchProto)}function s(e,t,o){return{index:e,removed:t,addedCount:o}}function a(e,t){return W[t]||(W[t]=Object.getOwnPropertyDescriptor(HTMLElement.prototype,t)||Object.getOwnPropertyDescriptor(Element.prototype,t)||Object.getOwnPropertyDescriptor(Node.prototype,t)),W[t].get.call(e)}function l(e){V||(V=!0,x.then(h)),Z.push(e)}function h(){for(V=!1,ee++;Z.length;)Z.shift()();Y&&Y.flush&&Y.flush();var e=ee>te;if(Z.length&&!e&&h(),ee=0,e)throw new Error("Loop detected in ShadyDOM distribution, aborting.")}function u(e){switch(e){case"&":return"&amp;";case"<":return"&lt;";case">":return"&gt;";case'"':return"&quot;";case" ":return"&nbsp;"}}function _(e){return e.replace(oe,u)}function c(e){return e.replace(ie,u)}function f(e){for(var t={},o=0;o<e.length;o++)t[e[o]]=!0;return t}function m(e,t,o){switch(e.nodeType){case Node.ELEMENT_NODE:for(var i,n=e.localName,r="<"+n,d=e.attributes,s=0;i=d[s];s++)r+=" "+i.name+'="'+_(i.value)+'"';return r+=">",ne[n]?r:r+g(e,o)+"</"+n+">";case Node.TEXT_NODE:var a=e.data;return t&&re[t.localName]?a:c(a);case Node.COMMENT_NODE:return"<!--"+e.data+"-->";default:throw window.console.error(e),new Error("not implemented")}}function g(e,t){"template"===e.localName&&(e=e.content);for(var o,i="",n=t?t(e):e.childNodes,r=0,d=n.length;r<d&&(o=n[r]);r++)i+=m(o,e,t);return i}function p(e,t){var o=ve(t);return e.filter(function(e){var t=o===ve(e.target);if(t&&e.addedNodes){var i=Array.from(e.addedNodes).filter(function(e){return o===ve(e)});Object.defineProperty(e,"addedNodes",{value:i,configurable:!0})}return t&&(!e.addedNodes||e.addedNodes.length)})}function v(e){L.inUse&&!b(e)&&Se.canPatchNode(e)&&(H.saveChildNodes(e),Se.patch(e))}function N(e){Se.unpatch(e)}function b(e){return Boolean(e.__patched)}function C(e,t){for(var o=[],i=e,n=e===window?window:e.getRootNode();i;)o.push(i),i=i.assignedSlot?i.assignedSlot:i.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&i.host&&(t||i!==n)?i.host:i.parentNode;return o[o.length-1]===document&&o.push(window),o}function E(t,o){if(!e)return t;for(var i,n,r,d,s=C(t,!0),a=o,l=0;l<a.length;l++)if(i=a[l],r=i===window?window:i.getRootNode(),r!==n&&(d=s.indexOf(r),n=r),!e(r)||d>-1)return i}function y(e){var t=function(t,o){var i=new e(t,o);return i.__composed=o&&Boolean(o.composed),i};return r(t,e),t.prototype=e.prototype,t}function S(e,t,o){var i=t.__handlers&&t.__handlers[e.type]&&t.__handlers[e.type][o];if(i)for(var n,r=0;n=i[r];r++)if(n.call(t,e),e.__immediatePropagationStopped)return}function P(e){var t,o=e.composedPath();Object.defineProperty(e,"currentTarget",{get:function(){return t},configurable:!0});for(var i=o.length-1;i>=0;i--)if(t=o[i],S(e,t,"capture"),e.__propagationStopped)return;Object.defineProperty(e,"eventPhase",{value:Event.BUBBLING_PHASE});for(var n=0;n<o.length;n++)if(t=o[n],S(e,t,"bubble"),e.__propagationStopped)return}function O(e){return Boolean("object"==typeof e?e.capture:e)}function D(e,t,o){if(t){this.__eventListenerCount||(this.__eventListenerCount=0),this.__eventListenerCount++;var i=function(e){if(e.__target||(e.__target=e.target,e.__relatedTarget=e.relatedTarget,d(e,Te)),e.composed||e.composedPath().indexOf(this)>-1)return e.eventPhase===Event.BUBBLING_PHASE&&e.target===e.relatedTarget?void e.stopImmediatePropagation():t(e)};t.__eventWrapper=i,we[e]?(this.__handlers=this.__handlers||{},this.__handlers[e]=this.__handlers[e]||{capture:[],bubble:[]},O(o)?this.__handlers[e].capture.push(i):this.__handlers[e].bubble.push(i)):Pe.call(this,e,i,o)}}function T(e,t,o){if(t){var i=t.__eventWrapper;if(Oe.call(this,e,i||t,o),i&&(t.__eventWrapper=null,this.__eventListenerCount--,we[e]&&this.__handlers&&this.__handlers[e])){var n;O(o)?(n=this.__handlers[e].capture.indexOf(i),n>-1&&this.__handlers[e].capture.splice(n,1)):(n=this.__handlers[e].bubble.indexOf(i),n>-1&&this.__handlers[e].bubble.splice(n,1))}}}function w(){for(var e in we)window.addEventListener(e,function(e){e.__target||(e.__target=e.target,e.__relatedTarget=e.relatedTarget,d(e,Te),P(e),e.stopImmediatePropagation())},!0)}var L=window.ShadyDOM||{};L.hasNativeShadowDOM=Boolean(Element.prototype.attachShadow&&Node.prototype.getRootNode),L.inUse=L.force||!L.hasNativeShadowDOM;var x,R=Element.prototype,$=R.matches||R.matchesSelector||R.mozMatchesSelector||R.msMatchesSelector||R.oMatchesSelector||R.webkitMatchesSelector,M={};x=window.Promise?Promise.resolve():{then:function(e){var t=document.createTextNode(""),o=new MutationObserver(function(){o.disconnect(),e()});o.observe(t,{characterData:!0})}};var I=0,F=1,A=2,j=3,k={calcEditDistances:function(e,t,o,i,n,r){for(var d=this,s=r-n+1,a=o-t+1,l=new Array(s),h=0;h<s;h++)l[h]=new Array(a),l[h][0]=h;for(var u=0;u<a;u++)l[0][u]=u;for(var _=1;_<s;_++)for(var c=1;c<a;c++)if(d.equals(e[t+c-1],i[n+_-1]))l[_][c]=l[_-1][c-1];else{var f=l[_-1][c]+1,m=l[_][c-1]+1;l[_][c]=f<m?f:m}return l},spliceOperationsFromEditDistances:function(e){for(var t=e.length-1,o=e[0].length-1,i=e[t][o],n=[];t>0||o>0;)if(0!=t)if(0!=o){var r,d=e[t-1][o-1],s=e[t-1][o],a=e[t][o-1];r=s<a?s<d?s:d:a<d?a:d,r==d?(d==i?n.push(I):(n.push(F),i=d),t--,o--):r==s?(n.push(j),t--,i=s):(n.push(A),o--,i=a)}else n.push(j),t--;else n.push(A),o--;return n.reverse(),n},calcSplices:function(e,t,o,i,n,r){var d,a=0,l=0,h=Math.min(o-t,r-n);if(0==t&&0==n&&(a=this.sharedPrefix(e,i,h)),o==e.length&&r==i.length&&(l=this.sharedSuffix(e,i,h-a)),t+=a,n+=a,o-=l,r-=l,o-t==0&&r-n==0)return[];if(t==o){for(d=s(t,[],0);n<r;)d.removed.push(i[n++]);return[d]}if(n==r)return[s(t,[],o-t)];var u=this.spliceOperationsFromEditDistances(this.calcEditDistances(e,t,o,i,n,r));d=void 0;for(var _=[],c=t,f=n,m=0;m<u.length;m++)switch(u[m]){case I:d&&(_.push(d),d=void 0),c++,f++;break;case F:d||(d=s(c,[],0)),d.addedCount++,c++,d.removed.push(i[f]),f++;break;case A:d||(d=s(c,[],0)),d.addedCount++,c++;break;case j:d||(d=s(c,[],0)),d.removed.push(i[f]),f++}return d&&_.push(d),_},sharedPrefix:function(e,t,o){for(var i=this,n=0;n<o;n++)if(!i.equals(e[n],t[n]))return n;return o},sharedSuffix:function(e,t,o){for(var i=e.length,n=t.length,r=0;r<o&&this.equals(e[--i],t[--n]);)r++;return r},calculateSplices:function(e,t){return this.calcSplices(e,0,e.length,t,0,t.length)},equals:function(e,t){return e===t}},B=function(e,t){return k.calculateSplices(e,t)},U=Element.prototype.insertBefore,q=Element.prototype.appendChild,G=Element.prototype.removeChild,H={arrayCopyChildNodes:function(e){for(var t=[],o=0,i=e.firstChild;i;i=i.nextSibling)t[o++]=i;return t},arrayCopyChildren:function(e){for(var t=[],o=0,i=e.firstElementChild;i;i=i.nextElementSibling)t[o++]=i;return t},arrayCopy:function(e){for(var t=e.length,o=new Array(t),i=0;i<t;i++)o[i]=e[i];return o},saveChildNodes:function(e){H.Logical.saveChildNodes(e),H.Composed.hasParentNode(e)||H.Composed.saveComposedData(e),H.Composed.saveChildNodes(e)}};H.Logical={hasParentNode:function(e){return Boolean(e.__dom&&e.__dom.parentNode)},hasChildNodes:function(e){return Boolean(e.__dom&&void 0!==e.__dom.childNodes)},getChildNodes:function(e){return this.hasChildNodes(e)?this._getChildNodes(e):H.Composed.getChildNodes(e)},_getChildNodes:function(e){if(!e.__dom.childNodes){e.__dom.childNodes=[];for(var t=this.getFirstChild(e);t;t=this.getNextSibling(t))e.__dom.childNodes.push(t)}return e.__dom.childNodes},getParentNode:function(e){return e.__dom&&void 0!==e.__dom.parentNode?e.__dom.parentNode:H.Composed.getParentNode(e)},getFirstChild:function(e){return e.__dom&&void 0!==e.__dom.firstChild?e.__dom.firstChild:H.Composed.getFirstChild(e)},getLastChild:function(e){return e.__dom&&void 0!==e.__dom.lastChild?e.__dom.lastChild:H.Composed.getLastChild(e)},getNextSibling:function(e){return e.__dom&&void 0!==e.__dom.nextSibling?e.__dom.nextSibling:H.Composed.getNextSibling(e)},getPreviousSibling:function(e){return e.__dom&&void 0!==e.__dom.previousSibling?e.__dom.previousSibling:H.Composed.getPreviousSibling(e)},getFirstElementChild:function(e){return e.__dom&&void 0!==e.__dom.firstChild?this._getFirstElementChild(e):H.Composed.getFirstElementChild(e)},_getFirstElementChild:function(e){for(var t=e.__dom.firstChild;t&&t.nodeType!==Node.ELEMENT_NODE;)t=t.__dom.nextSibling;return t},getLastElementChild:function(e){return e.__dom&&void 0!==e.__dom.lastChild?this._getLastElementChild(e):H.Composed.getLastElementChild(e)},_getLastElementChild:function(e){for(var t=e.__dom.lastChild;t&&t.nodeType!==Node.ELEMENT_NODE;)t=t.__dom.previousSibling;return t},getNextElementSibling:function(e){return e.__dom&&void 0!==e.__dom.nextSibling?this._getNextElementSibling(e):H.Composed.getNextElementSibling(e)},_getNextElementSibling:function(e){for(var t=this,o=e.__dom.nextSibling;o&&o.nodeType!==Node.ELEMENT_NODE;)o=t.getNextSibling(o);return o},getPreviousElementSibling:function(e){return e.__dom&&void 0!==e.__dom.previousSibling?this._getPreviousElementSibling(e):H.Composed.getPreviousElementSibling(e)},_getPreviousElementSibling:function(e){for(var t=this,o=e.__dom.previousSibling;o&&o.nodeType!==Node.ELEMENT_NODE;)o=t.getPreviousSibling(o);return o},saveChildNodes:function(e){if(!this.hasChildNodes(e)){e.__dom=e.__dom||{},e.__dom.firstChild=e.firstChild,e.__dom.lastChild=e.lastChild;for(var t,o=e.__dom.childNodes=H.arrayCopyChildNodes(e),i=0;i<o.length&&(t=o[i]);i++)t.__dom=t.__dom||{},t.__dom.parentNode=e,t.__dom.nextSibling=o[i+1]||null,t.__dom.previousSibling=o[i-1]||null,M.patchNode(t)}},recordInsertBefore:function(e,t,o){var i=this;if(t.__dom.childNodes=null,e.nodeType===Node.DOCUMENT_FRAGMENT_NODE){for(var n=H.arrayCopyChildNodes(e),r=0;r<n.length;r++)i._linkNode(n[r],t,o);e.__dom=e.__dom||{},e.__dom.firstChild=e.__dom.lastChild=null,e.__dom.childNodes=null}else this._linkNode(e,t,o)},_linkNode:function(e,t,o){M.patchNode(e),o=o||null,e.__dom=e.__dom||{},t.__dom=t.__dom||{},o&&(o.__dom=o.__dom||{}),e.__dom.previousSibling=o?o.__dom.previousSibling:t.__dom.lastChild,e.__dom.previousSibling&&(e.__dom.previousSibling.__dom.nextSibling=e),e.__dom.nextSibling=o,e.__dom.nextSibling&&(e.__dom.nextSibling.__dom.previousSibling=e),e.__dom.parentNode=t,o?o===t.__dom.firstChild&&(t.__dom.firstChild=e):(t.__dom.lastChild=e,t.__dom.firstChild||(t.__dom.firstChild=e)),t.__dom.childNodes=null},recordRemoveChild:function(e,t){e.__dom=e.__dom||{},t.__dom=t.__dom||{},e===t.__dom.firstChild&&(t.__dom.firstChild=e.__dom.nextSibling),e===t.__dom.lastChild&&(t.__dom.lastChild=e.__dom.previousSibling);var o=e.__dom.previousSibling,i=e.__dom.nextSibling;o&&(o.__dom=o.__dom||{},o.__dom.nextSibling=i),i&&(i.__dom=i.__dom||{},i.__dom.previousSibling=o),e.__dom.parentNode=e.__dom.previousSibling=e.__dom.nextSibling=null,t.__dom.childNodes=null}},H.Composed={hasParentNode:function(e){return Boolean(e.__dom&&void 0!==e.__dom.$parentNode)},hasChildNodes:function(e){return Boolean(e.__dom&&void 0!==e.__dom.$childNodes)},getChildNodes:function(e){return this.hasChildNodes(e)?this._getChildNodes(e):!e.__patched&&H.arrayCopy(e.childNodes)},_getChildNodes:function(e){if(!e.__dom.$childNodes){e.__dom.$childNodes=[];for(var t=e.__dom.$firstChild;t;t=t.__dom.$nextSibling)e.__dom.$childNodes.push(t)}return e.__dom.$childNodes},getComposedChildNodes:function(e){return e.__dom.$childNodes},getParentNode:function(e){return this.hasParentNode(e)?e.__dom.$parentNode:!e.__patched&&e.parentNode},getFirstChild:function(e){return e.__patched?e.__dom.$firstChild:e.firstChild},getLastChild:function(e){return e.__patched?e.__dom.$lastChild:e.lastChild},getNextSibling:function(e){return e.__patched?e.__dom.$nextSibling:e.nextSibling},getPreviousSibling:function(e){return e.__patched?e.__dom.$previousSibling:e.previousSibling},getFirstElementChild:function(e){return e.__patched?this._getFirstElementChild(e):e.firstElementChild},_getFirstElementChild:function(e){for(var t=e.__dom.$firstChild;t&&t.nodeType!==Node.ELEMENT_NODE;)t=t.__dom.$nextSibling;return t},getLastElementChild:function(e){return e.__patched?this._getLastElementChild(e):e.lastElementChild},_getLastElementChild:function(e){for(var t=e.__dom.$lastChild;t&&t.nodeType!==Node.ELEMENT_NODE;)t=t.__dom.$previousSibling;return t},getNextElementSibling:function(e){return e.__patched?this._getNextElementSibling(e):e.nextElementSibling},_getNextElementSibling:function(e){for(var t=this,o=e.__dom.$nextSibling;o&&o.nodeType!==Node.ELEMENT_NODE;)o=t.getNextSibling(o);return o},getPreviousElementSibling:function(e){return e.__patched?this._getPreviousElementSibling(e):e.previousElementSibling},_getPreviousElementSibling:function(e){for(var t=this,o=e.__dom.$previousSibling;o&&o.nodeType!==Node.ELEMENT_NODE;)o=t.getPreviousSibling(o);return o},saveChildNodes:function(e){var t=this;if(!this.hasChildNodes(e)){e.__dom=e.__dom||{},e.__dom.$firstChild=e.firstChild,e.__dom.$lastChild=e.lastChild;for(var o,i=e.__dom.$childNodes=H.arrayCopyChildNodes(e),n=0;n<i.length&&(o=i[n]);n++)t.saveComposedData(o)}},saveComposedData:function(e){e.__dom=e.__dom||{},void 0===e.__dom.$parentNode&&(e.__dom.$parentNode=e.parentNode),void 0===e.__dom.$nextSibling&&(e.__dom.$nextSibling=e.nextSibling),void 0===e.__dom.$previousSibling&&(e.__dom.$previousSibling=e.previousSibling)},recordInsertBefore:function(e,t,o){var i=this;if(t.__dom.$childNodes=null,e.nodeType===Node.DOCUMENT_FRAGMENT_NODE)for(var n=this.getFirstChild(e);n;n=this.getNextSibling(n))i._linkNode(n,t,o);else this._linkNode(e,t,o)},_linkNode:function(e,t,o){e.__dom=e.__dom||{},t.__dom=t.__dom||{},o&&(o.__dom=o.__dom||{}),e.__dom.$previousSibling=o?o.__dom.$previousSibling:t.__dom.$lastChild,e.__dom.$previousSibling&&(e.__dom.$previousSibling.__dom.$nextSibling=e),e.__dom.$nextSibling=o,e.__dom.$nextSibling&&(e.__dom.$nextSibling.__dom.$previousSibling=e),e.__dom.$parentNode=t,o?o===t.__dom.$firstChild&&(t.__dom.$firstChild=e):(t.__dom.$lastChild=e,t.__dom.$firstChild||(t.__dom.$firstChild=e)),t.__dom.$childNodes=null},recordRemoveChild:function(e,t){e.__dom=e.__dom||{},t.__dom=t.__dom||{},e===t.__dom.$firstChild&&(t.__dom.$firstChild=e.__dom.$nextSibling),e===t.__dom.$lastChild&&(t.__dom.$lastChild=e.__dom.$previousSibling);var o=e.__dom.$previousSibling,i=e.__dom.$nextSibling;o&&(o.__dom=o.__dom||{},o.__dom.$nextSibling=i),i&&(i.__dom=i.__dom||{},i.__dom.$previousSibling=o),e.__dom.$parentNode=e.__dom.$previousSibling=e.__dom.$nextSibling=null,t.__dom.$childNodes=null},clearChildNodes:function(e){for(var t,o=this,i=this.getChildNodes(e),n=0;n<i.length;n++)t=i[n],o.recordRemoveChild(t,e),G.call(e,t)},saveParentNode:function(e){e.__dom=e.__dom||{},e.__dom.$parentNode=e.parentNode},insertBefore:function(e,t,o){return this.saveChildNodes(e),this._addChild(e,t,o),U.call(e,t,o||null)},appendChild:function(e,t){return this.saveChildNodes(e),this._addChild(e,t),q.call(e,t)},removeChild:function(e,t){var o=this.getParentNode(t);if(this.saveChildNodes(e),this._removeChild(e,t),o===e)return G.call(e,t)},_addChild:function(e,t,o){var i=this,n=t.nodeType===Node.DOCUMENT_FRAGMENT_NODE,r=this.getParentNode(t);if(r&&this._removeChild(r,t),n)for(var d=this.getChildNodes(t),s=0;s<d.length;s++){var a=d[s];i._removeChild(t,a),i.recordInsertBefore(a,e,o)}else this.recordInsertBefore(t,e,o)},_removeChild:function(e,t){this.recordRemoveChild(t,e)}};var W={},z="function"==typeof Event?Event:function(e,t){t=t||{};var o=document.createEvent("Event");return o.initEvent(e,Boolean(t.bubbles),Boolean(t.cancelable)),o},X=function(){function e(e){this.root=e,this.insertionPointTag="slot"}return e.prototype.getInsertionPoints=function(){return this.root.querySelectorAll(this.insertionPointTag)},e.prototype.hasInsertionPoint=function(){return Boolean(this.root._insertionPoints&&this.root._insertionPoints.length)},e.prototype.isInsertionPoint=function(e){return e.localName&&e.localName==this.insertionPointTag},e.prototype.distribute=function(){return this.hasInsertionPoint()?this.distributePool(this.root,this.collectPool()):[]},e.prototype.collectPool=function(){return H.arrayCopy(H.Logical.getChildNodes(this.root.host))},e.prototype.distributePool=function(e,t){for(var o,i=this,n=[],r=this.root._insertionPoints,d=0,s=r.length;d<s&&(o=r[d]);d++){i.distributeInsertionPoint(o,t);var a=H.Logical.getParentNode(o);a&&a.shadyRoot&&i.hasInsertionPoint(a.shadyRoot)&&n.push(a.shadyRoot)}for(var l=0;l<t.length;l++){var h=t[l];if(h){h._assignedSlot=void 0;var u=H.Composed.getParentNode(h);u&&H.Composed.removeChild(u,h)}}return n},e.prototype.distributeInsertionPoint=function(e,t){var o=this,i=e._assignedNodes;i&&this.clearAssignedSlots(e,!0),e._assignedNodes=[];for(var n,r=!1,d=!1,s=0,a=t.length;s<a;s++)n=t[s],n&&o.matchesInsertionPoint(n,e)&&(n.__prevAssignedSlot!=e&&(r=!0),o.distributeNodeInto(n,e),t[s]=void 0,d=!0);if(!d)for(var l,h=H.Logical.getChildNodes(e),u=0;u<h.length;u++)l=h[u],l.__prevAssignedSlot!=e&&(r=!0),o.distributeNodeInto(l,e);if(i){for(var _=0;_<i.length;_++)i[_].__prevAssignedSlot=null;e._assignedNodes.length<i.length&&(r=!0)}this.setDistributedNodesOnInsertionPoint(e),r&&this._fireSlotChange(e)},e.prototype.clearAssignedSlots=function(e,t){var o=e._assignedNodes;if(o)for(var i=0;i<o.length;i++){var n=o[i];t&&(n.__prevAssignedSlot=n._assignedSlot),n._assignedSlot===e&&(n._assignedSlot=null)}},e.prototype.matchesInsertionPoint=function(e,t){var o=t.getAttribute("name");o=o?o.trim():"";var i=e.getAttribute&&e.getAttribute("slot");return i=i?i.trim():"",i==o},e.prototype.distributeNodeInto=function(e,t){t._assignedNodes.push(e),e._assignedSlot=t},e.prototype.setDistributedNodesOnInsertionPoint=function(e){var t=this,o=e._assignedNodes;e._distributedNodes=[];for(var i,n=0;n<o.length&&(i=o[n]);n++)if(t.isInsertionPoint(i)){var r=i._distributedNodes;if(r)for(var d=0;d<r.length;d++)e._distributedNodes.push(r[d])}else e._distributedNodes.push(o[n])},e.prototype._fireSlotChange=function(e){e.dispatchEvent(new z("slotchange")),e._assignedSlot&&this._fireSlotChange(e._assignedSlot)},e.prototype.isFinalDestination=function(e){return!e._assignedSlot},e}(),J=function(e){if(!e)throw"Must provide a host";var t=document.createDocumentFragment();return t.__proto__=Q,t._init(e),t},K={_init:function(e){this.__localName="ShadyRoot",e.shadyRoot=this,this.host=e,H.Logical.saveChildNodes(e),H.Logical.saveChildNodes(this),this._clean=!0,this._hasRendered=!1,this._distributor=new X(this),this.update()},update:function(){var e=this._findDistributionRoot(this.host);e._clean&&(e._clean=!1,l(function(){e.render()}))},_findDistributionRoot:function(e){for(var t=e.shadyRoot;e&&this._elementNeedsDistribution(e);)t=e.getRootNode(),e=t&&t.host;return t},_elementNeedsDistribution:function(e){for(var t,o=this,i=H.Logical.getChildNodes(e),n=0;n<i.length;n++)if(t=i[n],o._distributor.isInsertionPoint(t))return e.getRootNode()},render:function(){this._clean||(this._clean=!0,this._skipUpdateInsertionPoints?this._hasRendered||(this._insertionPoints=[]):this.updateInsertionPoints(),this._skipUpdateInsertionPoints=!1,this.distribute(),this.compose(),this._hasRendered=!0)},forceRender:function(){this._clean=!1,this.render()},distribute:function(){for(var e=this._distributor.distribute(),t=0;t<e.length;t++)e[t].forceRender()},updateInsertionPoints:function(){var e=this,t=this.__insertionPoints;if(t)for(var o,i=0;i<t.length;i++)o=t[i],o.getRootNode()!==e&&e._distributor.clearAssignedSlots(o);t=this._insertionPoints=this._distributor.getInsertionPoints();for(var n,r=0;r<t.length;r++)n=t[r],H.Logical.saveChildNodes(n),H.Logical.saveChildNodes(H.Logical.getParentNode(n))},get _insertionPoints(){return this.__insertionPoints||this.updateInsertionPoints(),this.__insertionPoints||(this.__insertionPoints=[])},set _insertionPoints(e){this.__insertionPoints=e},hasInsertionPoint:function(){return this._distributor.hasInsertionPoint()},compose:function(){this._composeTree()},_composeTree:function(){var e=this;this._updateChildNodes(this.host,this._composeNode(this.host));for(var t,o,i=this._insertionPoints||[],n=0,r=i.length;n<r&&(t=i[n]);n++)o=H.Logical.getParentNode(t),o!==e.host&&o!==e&&e._updateChildNodes(o,e._composeNode(o))},_composeNode:function(e){for(var t=this,o=[],i=H.Logical.getChildNodes(e.shadyRoot||e),n=0;n<i.length;n++){var r=i[n];if(t._distributor.isInsertionPoint(r))for(var d=r._distributedNodes||(r._distributedNodes=[]),s=0;s<d.length;s++){var a=d[s];t.isFinalDestination(r,a)&&o.push(a)}else o.push(r)}return o},isFinalDestination:function(e,t){return this._distributor.isFinalDestination(e,t)},_updateChildNodes:function(e,t){for(var o,i=H.Composed.getChildNodes(e),n=B(t,i),r=0,d=0;r<n.length&&(o=n[r]);r++){for(var s,a=0;a<o.removed.length&&(s=o.removed[a]);a++)H.Composed.getParentNode(s)===e&&H.Composed.removeChild(e,s),i.splice(o.index+d,1);d-=o.addedCount}for(var l,h,u=0;u<n.length&&(l=n[u]);u++){h=i[l.index];for(var _,c=l.index;c<l.index+l.addedCount;c++)_=t[c],H.Composed.insertBefore(e,_,h),i.splice(c,0,_)}},getInsertionPointTag:function(){return this._distributor.insertionPointTag}},Q=Object.create(DocumentFragment.prototype);i(Q,K);var V,Y=window.customElements,Z=[],ee=0,te=100;h.list=Z;var oe=/[&\u00A0"]/g,ie=/[&\u00A0<>]/g,ne=f(["area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"]),re=f(["style","script","xmp","iframe","noembed","noframes","plaintext","noscript"]),de={addNode:function(e,t,o){var i=this.ownerShadyRootForNode(e);if(i){t.__noInsertionPoint&&(i._skipUpdateInsertionPoints=!0);var n=this._maybeAddInsertionPoint(t,e,i);n&&(i._skipUpdateInsertionPoints=!1),this._addedNode(t,i)}H.Logical.hasChildNodes(e)&&H.Logical.recordInsertBefore(t,e,o);var r=this._maybeDistribute(t,e,i)||e.shadyRoot;return r},removeNode:function(e){var t,o=H.Logical.hasParentNode(e)&&H.Logical.getParentNode(e),i=this.ownerShadyRootForNode(e);return o&&(t=this.maybeDistributeParent(e),H.Logical.recordRemoveChild(e,o),i&&(this._removeDistributedChildren(i,e)||o.localName===i.getInsertionPointTag())&&(i._skipUpdateInsertionPoints=!1,i.update())),this._removeOwnerShadyRoot(e),i&&this._removedNode(e,i),t},_scheduleObserver:function(e,t,o){var i=e.__dom&&e.__dom.observer;i&&(t&&i.addedNodes.push(t),o&&i.removedNodes.push(o),i.schedule())},removeNodeFromParent:function(e,t){t?(this._scheduleObserver(t,null,e),this.removeNode(e)):this._removeOwnerShadyRoot(e)},_hasCachedOwnerRoot:function(e){return Boolean(void 0!==e.__ownerShadyRoot)},getRootNode:function(t){if(t&&t.nodeType){var o=t.__ownerShadyRoot;if(void 0===o){if(e(t))o=t;else{var i=H.Logical.getParentNode(t);o=i?this.getRootNode(i):t}document.documentElement.contains(t)&&(t.__ownerShadyRoot=o)}return o}},ownerShadyRootForNode:function(t){var o=this.getRootNode(t);if(e(o))return o},_maybeDistribute:function(e,t,o){var i=o&&o.getInsertionPointTag()||"",n=e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&!e.__noInsertionPoint&&i&&e.querySelector(i),r=n&&H.Logical.getParentNode(n).nodeType!==Node.DOCUMENT_FRAGMENT_NODE,d=n||e.localName===i;(d||t.localName===i)&&o&&o.update();var s=this._nodeNeedsDistribution(t);return s&&t.shadyRoot.update(),s||d&&!r},_maybeAddInsertionPoint:function(e,t,o){var i,n=this,r=o.getInsertionPointTag();if(e.nodeType!==Node.DOCUMENT_FRAGMENT_NODE||e.__noInsertionPoint)e.localName===r&&(H.Logical.saveChildNodes(t),H.Logical.saveChildNodes(e),i=!0);else for(var d,s,a,l=e.querySelectorAll(r),h=0;h<l.length&&(d=l[h]);h++)s=H.Logical.getParentNode(d),s===e&&(s=t),a=n._maybeAddInsertionPoint(d,s,o),i=i||a;return i},_nodeNeedsDistribution:function(e){return e&&e.shadyRoot&&e.shadyRoot.hasInsertionPoint()},_addedNode:function(){},_removedNode:function(){},_removeDistributedChildren:function(e,t){for(var o,i=this,n=e._insertionPoints,r=0;r<n.length;r++){var d=n[r];if(i._contains(t,d))for(var s=d.assignedNodes({flatten:!0}),a=0;a<s.length;a++){o=!0;var l=s[a],h=H.Composed.getParentNode(l);h&&H.Composed.removeChild(h,l)}}return o},_contains:function(e,t){for(;t;){if(t==e)return!0;t=H.Logical.getParentNode(t)}},_removeOwnerShadyRoot:function(e){var t=this;if(this._hasCachedOwnerRoot(e))for(var o,i=H.Logical.getChildNodes(e),n=0,r=i.length;n<r&&(o=i[n]);n++)t._removeOwnerShadyRoot(o);e.__ownerShadyRoot=void 0},firstComposedNode:function(e){for(var t,o=e.assignedNodes({flatten:!0}),i=this.getRootNode(e),n=0,r=o.length;n<r&&(t=o[n]);n++)if(i.isFinalDestination(e,t))return t},clearNode:function(e){for(;e.firstChild;)e.removeChild(e.firstChild)},maybeDistributeParent:function(e){var t=H.Logical.getParentNode(e);if(this._nodeNeedsDistribution(t))return t.shadyRoot.update(),!0},maybeDistributeAttributeChange:function(e,t){var o="slot"===e.localName&&"name"===t;if(o){var i=this.getRootNode(e);i.update&&i.update()}},query:function(e,t,o){var i=[];return this._queryElements(H.Logical.getChildNodes(e),t,o,i),i},_queryElements:function(e,t,o,i){for(var n,r=this,d=0,s=e.length;d<s&&(n=e[d]);d++)if(n.nodeType===Node.ELEMENT_NODE&&r._queryElement(n,t,o,i))return!0},_queryElement:function(e,t,o,i){var n=t(e);return n&&i.push(e),o&&o(n)?n:void this._queryElements(H.Logical.getChildNodes(e),t,o,i)},activeElementForNode:function(t){var o=this,i=document.activeElement;if(!i)return null;var n=!!e(t);if(t!==document){if(!n)return null;if(t.host===i||!t.host.contains(i))return null}for(var r=this.ownerShadyRootForNode(i);r&&r!==t;)i=r.host,r=o.ownerShadyRootForNode(i);return t===document?r?null:i:r===t?i:null}},se=Element.prototype.cloneNode,ae=Document.prototype.importNode,le=Element.prototype.setAttribute,he=Element.prototype.removeAttribute,ue={};Object.defineProperties(ue,{parentElement:{get:function(){return H.Logical.getParentNode(this)},configurable:!0},parentNode:{get:function(){return H.Logical.getParentNode(this)},configurable:!0},nextSibling:{get:function(){return H.Logical.getNextSibling(this)},configurable:!0},previousSibling:{get:function(){return H.Logical.getPreviousSibling(this)},configurable:!0},nextElementSibling:{get:function(){return H.Logical.getNextElementSibling(this)},configurable:!0},previousElementSibling:{get:function(){return H.Logical.getPreviousElementSibling(this)},configurable:!0},assignedSlot:{get:function(){return this._assignedSlot},configurable:!0}});var _e={appendChild:function(e){return this.insertBefore(e)},insertBefore:function(t,o){if(o&&H.Logical.getParentNode(o)!==this)throw Error("The ref_node to be inserted before is not a child of this node");if(t.nodeType!==Node.DOCUMENT_FRAGMENT_NODE){var i=H.Logical.getParentNode(t);de.removeNodeFromParent(t,i)}if(!de.addNode(this,t,o)){if(o){var n=de.ownerShadyRootForNode(o);n&&(o=o.localName===n.getInsertionPointTag()?de.firstComposedNode(o):o)}var r=e(this)?this.host:this;o?H.Composed.insertBefore(r,t,o):H.Composed.appendChild(r,t)}return de._scheduleObserver(this,t),t},removeChild:function(t){if(H.Logical.getParentNode(t)!==this)throw Error("The node to be removed is not a child of this node: "+t);if(!de.removeNode(t)){var o=e(this)?this.host:this,i=H.Composed.getParentNode(t);o===i&&H.Composed.removeChild(o,t)}return de._scheduleObserver(this,null,t),t},replaceChild:function(e,t){return this.insertBefore(e,t),this.removeChild(t),e},querySelector:function(e){var o=de.query(this,function(o){return t(o,e)},function(e){return Boolean(e)})[0];return o||null},querySelectorAll:function(e){return de.query(this,function(o){return t(o,e)})},cloneNode:function(e){if("template"==this.localName)return se.call(this,e);var t=se.call(this,!1);if(e)for(var o,i=this.childNodes,n=0;n<i.length;n++)o=i[n].cloneNode(!0),t.appendChild(o);return t},importNode:function(e,t){var o=this instanceof Document?this:this.ownerDocument,i=ae.call(o,e,!1);if(t){var n=H.Logical.getChildNodes(e);M.patchNode(i);for(var r,d=0;d<n.length;d++)r=o.importNode(n[d],!0),i.appendChild(r)}return i}};Object.defineProperties(_e,{childNodes:{get:function(){var e=H.Logical.getChildNodes(this);return Array.isArray(e)?e:H.arrayCopyChildNodes(this)},configurable:!0},children:{get:function(){return H.Logical.hasChildNodes(this)?Array.prototype.filter.call(this.childNodes,function(e){return e.nodeType===Node.ELEMENT_NODE}):H.arrayCopyChildren(this)},configurable:!0},firstChild:{get:function(){return H.Logical.getFirstChild(this)},configurable:!0},lastChild:{get:function(){return H.Logical.getLastChild(this)},configurable:!0},firstElementChild:{get:function(){return H.Logical.getFirstElementChild(this)},configurable:!0},lastElementChild:{get:function(){return H.Logical.getLastElementChild(this)},configurable:!0},textContent:{get:function(){if(this.childNodes){for(var e,t=[],o=0,i=this.childNodes;e=i[o];o++)e.nodeType!==Node.COMMENT_NODE&&t.push(e.textContent);return t.join("")}return""},set:function(e){de.clearNode(this),e&&this.appendChild(document.createTextNode(e))},configurable:!0},innerHTML:{get:function(){return g(this)},set:function(e){var t=this;de.clearNode(this);var o=document.createElement("div");o.innerHTML=e;for(var i=H.arrayCopyChildNodes(o),n=0;n<i.length;n++)t.appendChild(i[n])},configurable:!0}});var ce={assignedNodes:function(e){return(e&&e.flatten?this._distributedNodes:this._assignedNodes)||[]},setAttribute:function(e,t){le.call(this,e,t),de.maybeDistributeParent(this)||de.maybeDistributeAttributeChange(this,e)},removeAttribute:function(e){he.call(this,e),de.maybeDistributeParent(this)||de.maybeDistributeAttributeChange(this,e)}};Object.defineProperties(ce,{shadowRoot:{get:function(){return this.shadyRoot}},slot:{get:function(){return this.getAttribute("slot")},set:function(e){this.setAttribute("slot",e)}}});var fe={get:function(){return de.activeElementForNode(this)}},me={};Object.defineProperties(me,{activeElement:fe});var ge={};Object.defineProperties(ge,{_activeElement:fe});var pe={Node:n({__patched:"Node"},ue),Fragment:n({__patched:"Fragment"},ue,_e,me),Element:n({__patched:"Element"},ue,_e,ce,me),Document:n({__patched:"Document"},ue,_e,ce,ge)},ve=function(e){return de.getRootNode(e)},Ne=function(){this._scheduled=!1,this.addedNodes=[],this.removedNodes=[],this.callbacks=new Set};Ne.prototype.schedule=function(){var e=this;this._scheduled||(this._scheduled=!0,x.then(function(){e.flush()}))},Ne.prototype.flush=function(){if(this._scheduled){this._scheduled=!1;var e=this.takeRecords();e.length&&this.callbacks.forEach(function(t){t(e)})}},Ne.prototype.takeRecords=function(){if(this.addedNodes.length||this.removedNodes.length){var e=[{addedNodes:this.addedNodes,removedNodes:this.removedNodes}];return this.addedNodes=[],this.removedNodes=[],e}return[]};var be=function(e,t){M.patchNode(e),e.__dom.observer||(e.__dom.observer=new Ne),e.__dom.observer.callbacks.add(t);var o=e.__dom.observer;return{_callback:t,_observer:o,_node:e,takeRecords:function(){return o.takeRecords()}}},Ce=function(e){var t=e&&e._observer;t&&(t.callbacks.delete(e._callback),t.callbacks.size||(e._node.__dom.observer=null))},Ee=0,ye=!1,Se={canPatchNode:function(e){switch(e){case document.head:case document.documentElement:return!1;default:return!0}},hasPrototypeDescriptors:Boolean(Object.getOwnPropertyDescriptor(window.Node.prototype,"textContent")),patch:function(e){Ee++,ye&&window.console.warn("patch node",e),this.hasPrototypeDescriptors?d(e,this.mixinForObject(e)):(window.console.warn("Patching instance rather than prototype",e),i(e,this.mixinForNode(e)))},mixinForObject:function(e){switch(e.nodeType){case Node.ELEMENT_NODE:return pe.Element;case Node.DOCUMENT_FRAGMENT_NODE:return pe.Fragment;case Node.DOCUMENT_NODE:return pe.Document;case Node.TEXT_NODE:case Node.COMMENT_NODE:return pe.Node}},unpatch:function(e){e.__sourceProto&&(e.__proto__=e.__sourceProto)}};M.patchNode=v,M.isNodePatched=b;var Pe=Element.prototype.addEventListener,Oe=Element.prototype.removeEventListener,De={blur:!0,focus:!0,focusin:!0,focusout:!0,click:!0,dblclick:!0,mousedown:!0,mouseenter:!0,mouseleave:!0,mousemove:!0,mouseout:!0,mouseover:!0,mouseup:!0,wheel:!0,beforeinput:!0,input:!0,keydown:!0,keyup:!0,compositionstart:!0,compositionupdate:!0,compositionend:!0,touchstart:!0,touchend:!0,touchmove:!0,touchcancel:!0,pointerover:!0,pointerenter:!0,pointerdown:!0,pointermove:!0,pointerup:!0,pointercancel:!0,pointerout:!0,pointerleave:!0,gotpointercapture:!0,lostpointercapture:!0,dragstart:!0,drag:!0,dragenter:!0,dragleave:!0,dragover:!0,drop:!0,dragend:!0,DOMActivate:!0,DOMFocusIn:!0,DOMFocusOut:!0,keypress:!0},Te={__patched:"Event",get composed(){return this.isTrusted&&void 0===this.__composed&&(this.__composed=De[this.type]),this.__composed||!1},composedPath:function(){return this.__composedPath||(this.__composedPath=C(this.__target,this.composed)),this.__composedPath},get target(){return E(this.currentTarget,this.composedPath())},get relatedTarget(){return this.__relatedTarget?(this.__relatedTargetComposedPath||(this.__relatedTargetComposedPath=C(this.__relatedTarget,!0)),E(this.currentTarget,this.__relatedTargetComposedPath)):null},stopPropagation:function(){Event.prototype.stopPropagation.call(this),this.__propagationStopped=!0},stopImmediatePropagation:function(){Event.prototype.stopImmediatePropagation.call(this),this.__immediatePropagationStopped=!0,this.__propagationStopped=!0}},we={focus:!0,blur:!0},Le=y(Event),xe=y(CustomEvent),Re=y(MouseEvent);if(L.inUse){window.ShadyDOM={tree:H,getNativeProperty:a,patch:v,isPatched:b,unpatch:N,isShadyRoot:e,enqueue:l,flush:h,inUse:L.inUse,filterMutations:p,observeChildren:be,unobserveChildren:Ce};var $e=function(e){v(e);var t=new J(e);return v(t),t};Element.prototype.attachShadow=function(){return $e(this)},Node.prototype.addEventListener=D,Node.prototype.removeEventListener=T,Event=Le,CustomEvent=xe,MouseEvent=Re,w(),Object.defineProperty(Node.prototype,"isConnected",{get:function(){return document.documentElement.contains(this)},configurable:!0}),Node.prototype.getRootNode=function(e){return ve(this,e)},Object.defineProperty(Element.prototype,"slot",{get:function(){return this.getAttribute("slot")},set:function(e){this.setAttribute("slot",e)},configurable:!0}),Object.defineProperty(Node.prototype,"assignedSlot",{get:function(){return this._assignedSlot||null},configurable:!0})}}();
}

/*
Author: Geraint Luff and others
Year: 2013

This code is released into the "public domain" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.

If you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.
*/
(function (global, factory) {
    // Browser globals
    global.tv4 = factory();
}(this, function () {

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys
if (!Object.keys) {
	Object.keys = (function () {
		var hasOwnProperty = Object.prototype.hasOwnProperty,
			hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
			dontEnums = [
				'toString',
				'toLocaleString',
				'valueOf',
				'hasOwnProperty',
				'isPrototypeOf',
				'propertyIsEnumerable',
				'constructor'
			],
			dontEnumsLength = dontEnums.length;

		return function (obj) {
			if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {
				throw new TypeError('Object.keys called on non-object');
			}

			var result = [];

			for (var prop in obj) {
				if (hasOwnProperty.call(obj, prop)) {
					result.push(prop);
				}
			}

			if (hasDontEnumBug) {
				for (var i=0; i < dontEnumsLength; i++) {
					if (hasOwnProperty.call(obj, dontEnums[i])) {
						result.push(dontEnums[i]);
					}
				}
			}
			return result;
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
if (!Object.create) {
	Object.create = (function(){
		function F(){}

		return function(o){
			if (arguments.length !== 1) {
				throw new Error('Object.create implementation only accepts one parameter.');
			}
			F.prototype = o;
			return new F();
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray
if(!Array.isArray) {
	Array.isArray = function (vArg) {
		return Object.prototype.toString.call(vArg) === "[object Array]";
	};
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
		if (this === null) {
			throw new TypeError();
		}
		var t = Object(this);
		var len = t.length >>> 0;

		if (len === 0) {
			return -1;
		}
		var n = 0;
		if (arguments.length > 1) {
			n = Number(arguments[1]);
			if (n !== n) { // shortcut for verifying if it's NaN
				n = 0;
			} else if (n !== 0 && n !== Infinity && n !== -Infinity) {
				n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}
		}
		if (n >= len) {
			return -1;
		}
		var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
		for (; k < len; k++) {
			if (k in t && t[k] === searchElement) {
				return k;
			}
		}
		return -1;
	};
}

// Grungey Object.isFrozen hack
if (!Object.isFrozen) {
	Object.isFrozen = function (obj) {
		var key = "tv4_test_frozen_key";
		while (obj.hasOwnProperty(key)) {
			key += Math.random();
		}
		try {
			obj[key] = true;
			delete obj[key];
			return false;
		} catch (e) {
			return true;
		}
	};
}
// Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed

var uriTemplateGlobalModifiers = {
	"+": true,
	"#": true,
	".": true,
	"/": true,
	";": true,
	"?": true,
	"&": true
};
var uriTemplateSuffices = {
	"*": true
};

function notReallyPercentEncode(string) {
	return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {
		return "%" + doubleEncoded.substring(3);
	});
}

function uriTemplateSubstitution(spec) {
	var modifier = "";
	if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
		modifier = spec.charAt(0);
		spec = spec.substring(1);
	}
	var separator = "";
	var prefix = "";
	var shouldEscape = true;
	var showVariables = false;
	var trimEmptyString = false;
	if (modifier === '+') {
		shouldEscape = false;
	} else if (modifier === ".") {
		prefix = ".";
		separator = ".";
	} else if (modifier === "/") {
		prefix = "/";
		separator = "/";
	} else if (modifier === '#') {
		prefix = "#";
		shouldEscape = false;
	} else if (modifier === ';') {
		prefix = ";";
		separator = ";";
		showVariables = true;
		trimEmptyString = true;
	} else if (modifier === '?') {
		prefix = "?";
		separator = "&";
		showVariables = true;
	} else if (modifier === '&') {
		prefix = "&";
		separator = "&";
		showVariables = true;
	}

	var varNames = [];
	var varList = spec.split(",");
	var varSpecs = [];
	var varSpecMap = {};
	for (var i = 0; i < varList.length; i++) {
		var varName = varList[i];
		var truncate = null;
		if (varName.indexOf(":") !== -1) {
			var parts = varName.split(":");
			varName = parts[0];
			truncate = parseInt(parts[1], 10);
		}
		var suffices = {};
		while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
			suffices[varName.charAt(varName.length - 1)] = true;
			varName = varName.substring(0, varName.length - 1);
		}
		var varSpec = {
			truncate: truncate,
			name: varName,
			suffices: suffices
		};
		varSpecs.push(varSpec);
		varSpecMap[varName] = varSpec;
		varNames.push(varName);
	}
	var subFunction = function (valueFunction) {
		var result = "";
		var startIndex = 0;
		for (var i = 0; i < varSpecs.length; i++) {
			var varSpec = varSpecs[i];
			var value = valueFunction(varSpec.name);
			if (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {
				startIndex++;
				continue;
			}
			if (i === startIndex) {
				result += prefix;
			} else {
				result += (separator || ",");
			}
			if (Array.isArray(value)) {
				if (showVariables) {
					result += varSpec.name + "=";
				}
				for (var j = 0; j < value.length; j++) {
					if (j > 0) {
						result += varSpec.suffices['*'] ? (separator || ",") : ",";
						if (varSpec.suffices['*'] && showVariables) {
							result += varSpec.name + "=";
						}
					}
					result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
				}
			} else if (typeof value === "object") {
				if (showVariables && !varSpec.suffices['*']) {
					result += varSpec.name + "=";
				}
				var first = true;
				for (var key in value) {
					if (!first) {
						result += varSpec.suffices['*'] ? (separator || ",") : ",";
					}
					first = false;
					result += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);
					result += varSpec.suffices['*'] ? '=' : ",";
					result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);
				}
			} else {
				if (showVariables) {
					result += varSpec.name;
					if (!trimEmptyString || value !== "") {
						result += "=";
					}
				}
				if (varSpec.truncate != null) {
					value = value.substring(0, varSpec.truncate);
				}
				result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21"): notReallyPercentEncode(value);
			}
		}
		return result;
	};
	subFunction.varNames = varNames;
	return {
		prefix: prefix,
		substitution: subFunction
	};
}

function UriTemplate(template) {
	if (!(this instanceof UriTemplate)) {
		return new UriTemplate(template);
	}
	var parts = template.split("{");
	var textParts = [parts.shift()];
	var prefixes = [];
	var substitutions = [];
	var varNames = [];
	while (parts.length > 0) {
		var part = parts.shift();
		var spec = part.split("}")[0];
		var remainder = part.substring(spec.length + 1);
		var funcs = uriTemplateSubstitution(spec);
		substitutions.push(funcs.substitution);
		prefixes.push(funcs.prefix);
		textParts.push(remainder);
		varNames = varNames.concat(funcs.substitution.varNames);
	}
	this.fill = function (valueFunction) {
		var result = textParts[0];
		for (var i = 0; i < substitutions.length; i++) {
			var substitution = substitutions[i];
			result += substitution(valueFunction);
			result += textParts[i + 1];
		}
		return result;
	};
	this.varNames = varNames;
	this.template = template;
}
UriTemplate.prototype = {
	toString: function () {
		return this.template;
	},
	fillFromObject: function (obj) {
		return this.fill(function (varName) {
			return obj[varName];
		});
	}
};
var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorMessages, checkRecursive, trackUnknownProperties) {
	this.missing = [];
	this.missingMap = {};
	this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
	this.schemas = parent ? Object.create(parent.schemas) : {};
	this.collectMultiple = collectMultiple;
	this.errors = [];
	this.handleError = collectMultiple ? this.collectError : this.returnError;
	if (checkRecursive) {
		this.checkRecursive = true;
		this.scanned = [];
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
		this.scannedFrozenValidationErrors = [];
		this.validatedSchemasKey = 'tv4_validation_id';
		this.validationErrorsKey = 'tv4_validation_errors_id';
	}
	if (trackUnknownProperties) {
		this.trackUnknownProperties = true;
		this.knownPropertyPaths = {};
		this.unknownPropertyPaths = {};
	}
	this.errorMessages = errorMessages;
	this.definedKeywords = {};
	if (parent) {
		for (var key in parent.definedKeywords) {
			this.definedKeywords[key] = parent.definedKeywords[key].slice(0);
		}
	}
};
ValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {
	this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
	this.definedKeywords[keyword].push(keywordFunction);
};
ValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors) {
	var messageTemplate = this.errorMessages[code] || ErrorMessagesDefault[code];
	if (typeof messageTemplate !== 'string') {
		return new ValidationError(code, "Unknown error code " + code + ": " + JSON.stringify(messageParams), messageParams, dataPath, schemaPath, subErrors);
	}
	// Adapted from Crockford's supplant()
	var message = messageTemplate.replace(/\{([^{}]*)\}/g, function (whole, varName) {
		var subValue = messageParams[varName];
		return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;
	});
	return new ValidationError(code, message, messageParams, dataPath, schemaPath, subErrors);
};
ValidatorContext.prototype.returnError = function (error) {
	return error;
};
ValidatorContext.prototype.collectError = function (error) {
	if (error) {
		this.errors.push(error);
	}
	return null;
};
ValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {
	for (var i = startIndex; i < this.errors.length; i++) {
		this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
	}
	return this;
};
ValidatorContext.prototype.banUnknownProperties = function () {
	for (var unknownPath in this.unknownPropertyPaths) {
		var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "");
		var result = this.handleError(error);
		if (result) {
			return result;
		}
	}
	return null;
};

ValidatorContext.prototype.addFormat = function (format, validator) {
	if (typeof format === 'object') {
		for (var key in format) {
			this.addFormat(key, format[key]);
		}
		return this;
	}
	this.formatValidators[format] = validator;
};
ValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {
	if (schema['$ref'] !== undefined) {
		urlHistory = urlHistory || {};
		if (urlHistory[schema['$ref']]) {
			return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '');
		}
		urlHistory[schema['$ref']] = true;
		schema = this.getSchema(schema['$ref'], urlHistory);
	}
	return schema;
};
ValidatorContext.prototype.getSchema = function (url, urlHistory) {
	var schema;
	if (this.schemas[url] !== undefined) {
		schema = this.schemas[url];
		return this.resolveRefs(schema, urlHistory);
	}
	var baseUrl = url;
	var fragment = "";
	if (url.indexOf('#') !== -1) {
		fragment = url.substring(url.indexOf("#") + 1);
		baseUrl = url.substring(0, url.indexOf("#"));
	}
	if (typeof this.schemas[baseUrl] === 'object') {
		schema = this.schemas[baseUrl];
		var pointerPath = decodeURIComponent(fragment);
		if (pointerPath === "") {
			return this.resolveRefs(schema, urlHistory);
		} else if (pointerPath.charAt(0) !== "/") {
			return undefined;
		}
		var parts = pointerPath.split("/").slice(1);
		for (var i = 0; i < parts.length; i++) {
			var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
			if (schema[component] === undefined) {
				schema = undefined;
				break;
			}
			schema = schema[component];
		}
		if (schema !== undefined) {
			return this.resolveRefs(schema, urlHistory);
		}
	}
	if (this.missing[baseUrl] === undefined) {
		this.missing.push(baseUrl);
		this.missing[baseUrl] = baseUrl;
		this.missingMap[baseUrl] = baseUrl;
	}
};
ValidatorContext.prototype.searchSchemas = function (schema, url) {
	if (Array.isArray(schema)) {
		for (var i = 0; i < schema.length; i++) {
			this.searchSchemas(schema[i], url);
		}
	} else if (schema && typeof schema === "object") {
		if (typeof schema.id === "string") {
			if (isTrustedUrl(url, schema.id)) {
				if (this.schemas[schema.id] === undefined) {
					this.schemas[schema.id] = schema;
				}
			}
		}
		for (var key in schema) {
			if (key !== "enum") {
				if (typeof schema[key] === "object") {
					this.searchSchemas(schema[key], url);
				} else if (key === "$ref") {
					var uri = getDocumentUri(schema[key]);
					if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
						this.missingMap[uri] = uri;
					}
				}
			}
		}
	}
};
ValidatorContext.prototype.addSchema = function (url, schema) {
	//overload
	if (typeof url !== 'string' || typeof schema === 'undefined') {
		if (typeof url === 'object' && typeof url.id === 'string') {
			schema = url;
			url = schema.id;
		}
		else {
			return;
		}
	}
	if (url === getDocumentUri(url) + "#") {
		// Remove empty fragment
		url = getDocumentUri(url);
	}
	this.schemas[url] = schema;
	delete this.missingMap[url];
	normSchema(schema, url);
	this.searchSchemas(schema, url);
};

ValidatorContext.prototype.getSchemaMap = function () {
	var map = {};
	for (var key in this.schemas) {
		map[key] = this.schemas[key];
	}
	return map;
};

ValidatorContext.prototype.getSchemaUris = function (filterRegExp) {
	var list = [];
	for (var key in this.schemas) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.getMissingUris = function (filterRegExp) {
	var list = [];
	for (var key in this.missingMap) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.dropSchemas = function () {
	this.schemas = {};
	this.reset();
};
ValidatorContext.prototype.reset = function () {
	this.missing = [];
	this.missingMap = {};
	this.errors = [];
};

ValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
	var topLevel;
	schema = this.resolveRefs(schema);
	if (!schema) {
		return null;
	} else if (schema instanceof ValidationError) {
		this.errors.push(schema);
		return schema;
	}

	var startErrorCount = this.errors.length;
	var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
	if (this.checkRecursive && data && typeof data === 'object') {
		topLevel = !this.scanned.length;
		if (data[this.validatedSchemasKey]) {
			var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
			if (schemaIndex !== -1) {
				this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
				return null;
			}
		}
		if (Object.isFrozen(data)) {
			frozenIndex = this.scannedFrozen.indexOf(data);
			if (frozenIndex !== -1) {
				var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
				if (frozenSchemaIndex !== -1) {
					this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
					return null;
				}
			}
		}
		this.scanned.push(data);
		if (Object.isFrozen(data)) {
			if (frozenIndex === -1) {
				frozenIndex = this.scannedFrozen.length;
				this.scannedFrozen.push(data);
				this.scannedFrozenSchemas.push([]);
			}
			scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
			this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
			this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
		} else {
			if (!data[this.validatedSchemasKey]) {
				try {
					Object.defineProperty(data, this.validatedSchemasKey, {
						value: [],
						configurable: true
					});
					Object.defineProperty(data, this.validationErrorsKey, {
						value: [],
						configurable: true
					});
				} catch (e) {
					//IE 7/8 workaround
					data[this.validatedSchemasKey] = [];
					data[this.validationErrorsKey] = [];
				}
			}
			scannedSchemasIndex = data[this.validatedSchemasKey].length;
			data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
			data[this.validationErrorsKey][scannedSchemasIndex] = [];
		}
	}

	var errorCount = this.errors.length;
	var error = this.validateBasic(data, schema, dataPointerPath)
		|| this.validateNumeric(data, schema, dataPointerPath)
		|| this.validateString(data, schema, dataPointerPath)
		|| this.validateArray(data, schema, dataPointerPath)
		|| this.validateObject(data, schema, dataPointerPath)
		|| this.validateCombinations(data, schema, dataPointerPath)
		|| this.validateHypermedia(data, schema, dataPointerPath)
		|| this.validateFormat(data, schema, dataPointerPath)
		|| this.validateDefinedKeywords(data, schema, dataPointerPath)
		|| null;

	if (topLevel) {
		while (this.scanned.length) {
			var item = this.scanned.pop();
			delete item[this.validatedSchemasKey];
		}
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
	}

	if (error || errorCount !== this.errors.length) {
		while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {
			var dataPart = (dataPathParts && dataPathParts.length) ? "" + dataPathParts.pop() : null;
			var schemaPart = (schemaPathParts && schemaPathParts.length) ? "" + schemaPathParts.pop() : null;
			if (error) {
				error = error.prefixWith(dataPart, schemaPart);
			}
			this.prefixErrors(errorCount, dataPart, schemaPart);
		}
	}

	if (scannedFrozenSchemaIndex !== null) {
		this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
	} else if (scannedSchemasIndex !== null) {
		data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
	}

	return this.handleError(error);
};
ValidatorContext.prototype.validateFormat = function (data, schema) {
	if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {
		return null;
	}
	var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
	if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}).prefixWith(null, "format");
	} else if (errorMessage && typeof errorMessage === 'object') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || null, errorMessage.schemaPath || "/format");
	}
	return null;
};
ValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {
	for (var key in this.definedKeywords) {
		if (typeof schema[key] === 'undefined') {
			continue;
		}
		var validationFunctions = this.definedKeywords[key];
		for (var i = 0; i < validationFunctions.length; i++) {
			var func = validationFunctions[i];
			var result = func(data, schema[key], schema, dataPointerPath);
			if (typeof result === 'string' || typeof result === 'number') {
				return this.createError(ErrorCodes.KEYWORD_CUSTOM, {key: key, message: result}).prefixWith(null, "format");
			} else if (result && typeof result === 'object') {
				var code = result.code;
				if (typeof code === 'string') {
					if (!ErrorCodes[code]) {
						throw new Error('Undefined error code (use defineError): ' + code);
					}
					code = ErrorCodes[code];
				} else if (typeof code !== 'number') {
					code = ErrorCodes.KEYWORD_CUSTOM;
				}
				var messageParams = (typeof result.message === 'object') ? result.message : {key: key, message: result.message || "?"};
				var schemaPath = result.schemaPath ||( "/" + key.replace(/~/g, '~0').replace(/\//g, '~1'));
				return this.createError(code, messageParams, result.dataPath || null, schemaPath);
			}
		}
	}
	return null;
};

function recursiveCompare(A, B) {
	if (A === B) {
		return true;
	}
	if (typeof A === "object" && typeof B === "object") {
		if (Array.isArray(A) !== Array.isArray(B)) {
			return false;
		} else if (Array.isArray(A)) {
			if (A.length !== B.length) {
				return false;
			}
			for (var i = 0; i < A.length; i++) {
				if (!recursiveCompare(A[i], B[i])) {
					return false;
				}
			}
		} else {
			var key;
			for (key in A) {
				if (B[key] === undefined && A[key] !== undefined) {
					return false;
				}
			}
			for (key in B) {
				if (A[key] === undefined && B[key] !== undefined) {
					return false;
				}
			}
			for (key in A) {
				if (!recursiveCompare(A[key], B[key])) {
					return false;
				}
			}
		}
		return true;
	}
	return false;
}

ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
	var error;
	if (error = this.validateType(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	if (error = this.validateEnum(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	return null;
};

ValidatorContext.prototype.validateType = function validateType(data, schema) {
	if (schema.type === undefined) {
		return null;
	}
	var dataType = typeof data;
	if (data === null) {
		dataType = "null";
	} else if (Array.isArray(data)) {
		dataType = "array";
	}
	var allowedTypes = schema.type;
	if (typeof allowedTypes !== "object") {
		allowedTypes = [allowedTypes];
	}

	for (var i = 0; i < allowedTypes.length; i++) {
		var type = allowedTypes[i];
		if (type === dataType || (type === "integer" && dataType === "number" && (data % 1 === 0))) {
			return null;
		}
	}
	return this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join("/")});
};

ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
	if (schema["enum"] === undefined) {
		return null;
	}
	for (var i = 0; i < schema["enum"].length; i++) {
		var enumVal = schema["enum"][i];
		if (recursiveCompare(data, enumVal)) {
			return null;
		}
	}
	return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data});
};

ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
	return this.validateMultipleOf(data, schema, dataPointerPath)
		|| this.validateMinMax(data, schema, dataPointerPath)
		|| this.validateNaN(data, schema, dataPointerPath)
		|| null;
};

var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
	var multipleOf = schema.multipleOf || schema.divisibleBy;
	if (multipleOf === undefined) {
		return null;
	}
	if (typeof data === "number") {
		var remainder = (data/multipleOf)%1;
		if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {
			return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf});
		}
	}
	return null;
};

ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
	if (typeof data !== "number") {
		return null;
	}
	if (schema.minimum !== undefined) {
		if (data < schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}).prefixWith(null, "minimum");
		}
		if (schema.exclusiveMinimum && data === schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}).prefixWith(null, "exclusiveMinimum");
		}
	}
	if (schema.maximum !== undefined) {
		if (data > schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}).prefixWith(null, "maximum");
		}
		if (schema.exclusiveMaximum && data === schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}).prefixWith(null, "exclusiveMaximum");
		}
	}
	return null;
};

ValidatorContext.prototype.validateNaN = function validateNaN(data) {
	if (typeof data !== "number") {
		return null;
	}
	if (isNaN(data) === true || data === Infinity || data === -Infinity) {
		return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}).prefixWith(null, "type");
	}
	return null;
};

ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
	return this.validateStringLength(data, schema, dataPointerPath)
		|| this.validateStringPattern(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
	if (typeof data !== "string") {
		return null;
	}
	if (schema.minLength !== undefined) {
		if (data.length < schema.minLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}).prefixWith(null, "minLength");
		}
	}
	if (schema.maxLength !== undefined) {
		if (data.length > schema.maxLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}).prefixWith(null, "maxLength");
		}
	}
	return null;
};

ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
	if (typeof data !== "string" || schema.pattern === undefined) {
		return null;
	}
	var regexp = new RegExp(schema.pattern);
	if (!regexp.test(data)) {
		return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}).prefixWith(null, "pattern");
	}
	return null;
};
ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
	if (!Array.isArray(data)) {
		return null;
	}
	return this.validateArrayLength(data, schema, dataPointerPath)
		|| this.validateArrayUniqueItems(data, schema, dataPointerPath)
		|| this.validateArrayItems(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
	var error;
	if (schema.minItems !== undefined) {
		if (data.length < schema.minItems) {
			error = (this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems})).prefixWith(null, "minItems");
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxItems !== undefined) {
		if (data.length > schema.maxItems) {
			error = (this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems})).prefixWith(null, "maxItems");
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
	if (schema.uniqueItems) {
		for (var i = 0; i < data.length; i++) {
			for (var j = i + 1; j < data.length; j++) {
				if (recursiveCompare(data[i], data[j])) {
					var error = (this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j})).prefixWith(null, "uniqueItems");
					if (this.handleError(error)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
	if (schema.items === undefined) {
		return null;
	}
	var error, i;
	if (Array.isArray(schema.items)) {
		for (i = 0; i < data.length; i++) {
			if (i < schema.items.length) {
				if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
					return error;
				}
			} else if (schema.additionalItems !== undefined) {
				if (typeof schema.additionalItems === "boolean") {
					if (!schema.additionalItems) {
						error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {})).prefixWith("" + i, "additionalItems");
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
					return error;
				}
			}
		}
	} else {
		for (i = 0; i < data.length; i++) {
			if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
	if (typeof data !== "object" || data === null || Array.isArray(data)) {
		return null;
	}
	return this.validateObjectMinMaxProperties(data, schema, dataPointerPath)
		|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)
		|| this.validateObjectProperties(data, schema, dataPointerPath)
		|| this.validateObjectDependencies(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
	var keys = Object.keys(data);
	var error;
	if (schema.minProperties !== undefined) {
		if (keys.length < schema.minProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}).prefixWith(null, "minProperties");
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxProperties !== undefined) {
		if (keys.length > schema.maxProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}).prefixWith(null, "maxProperties");
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
	if (schema.required !== undefined) {
		for (var i = 0; i < schema.required.length; i++) {
			var key = schema.required[i];
			if (data[key] === undefined) {
				var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}).prefixWith(null, "" + i).prefixWith(null, "required");
				if (this.handleError(error)) {
					return error;
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
	var error;
	for (var key in data) {
		var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, '~0').replace(/\//g, '~1');
		var foundMatch = false;
		if (schema.properties !== undefined && schema.properties[key] !== undefined) {
			foundMatch = true;
			if (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {
				return error;
			}
		}
		if (schema.patternProperties !== undefined) {
			for (var patternKey in schema.patternProperties) {
				var regexp = new RegExp(patternKey);
				if (regexp.test(key)) {
					foundMatch = true;
					if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {
						return error;
					}
				}
			}
		}
		if (!foundMatch) {
			if (schema.additionalProperties !== undefined) {
				if (this.trackUnknownProperties) {
					this.knownPropertyPaths[keyPointerPath] = true;
					delete this.unknownPropertyPaths[keyPointerPath];
				}
				if (typeof schema.additionalProperties === "boolean") {
					if (!schema.additionalProperties) {
						error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {}).prefixWith(key, "additionalProperties");
						if (this.handleError(error)) {
							return error;
						}
					}
				} else {
					if (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {
						return error;
					}
				}
			} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
				this.unknownPropertyPaths[keyPointerPath] = true;
			}
		} else if (this.trackUnknownProperties) {
			this.knownPropertyPaths[keyPointerPath] = true;
			delete this.unknownPropertyPaths[keyPointerPath];
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
	var error;
	if (schema.dependencies !== undefined) {
		for (var depKey in schema.dependencies) {
			if (data[depKey] !== undefined) {
				var dep = schema.dependencies[depKey];
				if (typeof dep === "string") {
					if (data[dep] === undefined) {
						error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}).prefixWith(null, depKey).prefixWith(null, "dependencies");
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (Array.isArray(dep)) {
					for (var i = 0; i < dep.length; i++) {
						var requiredKey = dep[i];
						if (data[requiredKey] === undefined) {
							error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}).prefixWith(null, "" + i).prefixWith(null, depKey).prefixWith(null, "dependencies");
							if (this.handleError(error)) {
								return error;
							}
						}
					}
				} else {
					if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
	return this.validateAllOf(data, schema, dataPointerPath)
		|| this.validateAnyOf(data, schema, dataPointerPath)
		|| this.validateOneOf(data, schema, dataPointerPath)
		|| this.validateNot(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
	if (schema.allOf === undefined) {
		return null;
	}
	var error;
	for (var i = 0; i < schema.allOf.length; i++) {
		var subSchema = schema.allOf[i];
		if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
			return error;
		}
	}
	return null;
};

ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
	if (schema.anyOf === undefined) {
		return null;
	}
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	var errorAtEnd = true;
	for (var i = 0; i < schema.anyOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.anyOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			this.errors = this.errors.slice(0, startErrorCount);

			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
				// We need to continue looping so we catch all the property definitions, but we don't want to return an error
				errorAtEnd = false;
				continue;
			}

			return null;
		}
		if (error) {
			errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (errorAtEnd) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors);
	}
};

ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
	if (schema.oneOf === undefined) {
		return null;
	}
	var validIndex = null;
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	for (var i = 0; i < schema.oneOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.oneOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			if (validIndex === null) {
				validIndex = i;
			} else {
				this.errors = this.errors.slice(0, startErrorCount);
				return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, "", "/oneOf");
			}
			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
			}
		} else if (error) {
			errors.push(error);
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (validIndex === null) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors);
	} else {
		this.errors = this.errors.slice(0, startErrorCount);
	}
	return null;
};

ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
	if (schema.not === undefined) {
		return null;
	}
	var oldErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
		this.unknownPropertyPaths = {};
		this.knownPropertyPaths = {};
	}
	var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
	var notErrors = this.errors.slice(oldErrorCount);
	this.errors = this.errors.slice(0, oldErrorCount);
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (error === null && notErrors.length === 0) {
		return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not");
	}
	return null;
};

ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
	if (!schema.links) {
		return null;
	}
	var error;
	for (var i = 0; i < schema.links.length; i++) {
		var ldo = schema.links[i];
		if (ldo.rel === "describedby") {
			var template = new UriTemplate(ldo.href);
			var allPresent = true;
			for (var j = 0; j < template.varNames.length; j++) {
				if (!(template.varNames[j] in data)) {
					allPresent = false;
					break;
				}
			}
			if (allPresent) {
				var schemaUrl = template.fillFromObject(data);
				var subSchema = {"$ref": schemaUrl};
				if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
					return error;
				}
			}
		}
	}
};

// parseURI() and resolveUrl() are from https://gist.github.com/1088850
//   -  released as public domain by author ("Yaffle") - see comments on gist

function parseURI(url) {
	var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
	// authority = '//' + user + ':' + pass '@' + hostname + ':' port
	return (m ? {
		href     : m[0] || '',
		protocol : m[1] || '',
		authority: m[2] || '',
		host     : m[3] || '',
		hostname : m[4] || '',
		port     : m[5] || '',
		pathname : m[6] || '',
		search   : m[7] || '',
		hash     : m[8] || ''
	} : null);
}

function resolveUrl(base, href) {// RFC 3986

	function removeDotSegments(input) {
		var output = [];
		input.replace(/^(\.\.?(\/|$))+/, '')
			.replace(/\/(\.(\/|$))+/g, '/')
			.replace(/\/\.\.$/, '/../')
			.replace(/\/?[^\/]*/g, function (p) {
				if (p === '/..') {
					output.pop();
				} else {
					output.push(p);
				}
		});
		return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
	}

	href = parseURI(href || '');
	base = parseURI(base || '');

	return !href || !base ? null : (href.protocol || base.protocol) +
		(href.protocol || href.authority ? href.authority : base.authority) +
		removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
		(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
		href.hash;
}

function getDocumentUri(uri) {
	return uri.split('#')[0];
}
function normSchema(schema, baseUri) {
	if (schema && typeof schema === "object") {
		if (baseUri === undefined) {
			baseUri = schema.id;
		} else if (typeof schema.id === "string") {
			baseUri = resolveUrl(baseUri, schema.id);
			schema.id = baseUri;
		}
		if (Array.isArray(schema)) {
			for (var i = 0; i < schema.length; i++) {
				normSchema(schema[i], baseUri);
			}
		} else {
			if (typeof schema['$ref'] === "string") {
				schema['$ref'] = resolveUrl(baseUri, schema['$ref']);
			}
			for (var key in schema) {
				if (key !== "enum") {
					normSchema(schema[key], baseUri);
				}
			}
		}
	}
}

var ErrorCodes = {
	INVALID_TYPE: 0,
	ENUM_MISMATCH: 1,
	ANY_OF_MISSING: 10,
	ONE_OF_MISSING: 11,
	ONE_OF_MULTIPLE: 12,
	NOT_PASSED: 13,
	// Numeric errors
	NUMBER_MULTIPLE_OF: 100,
	NUMBER_MINIMUM: 101,
	NUMBER_MINIMUM_EXCLUSIVE: 102,
	NUMBER_MAXIMUM: 103,
	NUMBER_MAXIMUM_EXCLUSIVE: 104,
	NUMBER_NOT_A_NUMBER: 105,
	// String errors
	STRING_LENGTH_SHORT: 200,
	STRING_LENGTH_LONG: 201,
	STRING_PATTERN: 202,
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: 300,
	OBJECT_PROPERTIES_MAXIMUM: 301,
	OBJECT_REQUIRED: 302,
	OBJECT_ADDITIONAL_PROPERTIES: 303,
	OBJECT_DEPENDENCY_KEY: 304,
	// Array errors
	ARRAY_LENGTH_SHORT: 400,
	ARRAY_LENGTH_LONG: 401,
	ARRAY_UNIQUE: 402,
	ARRAY_ADDITIONAL_ITEMS: 403,
	// Custom/user-defined errors
	FORMAT_CUSTOM: 500,
	KEYWORD_CUSTOM: 501,
	// Schema structure
	CIRCULAR_REFERENCE: 600,
	// Non-standard validation options
	UNKNOWN_PROPERTY: 1000
};
var ErrorCodeLookup = {};
for (var key in ErrorCodes) {
	ErrorCodeLookup[ErrorCodes[key]] = key;
}
var ErrorMessagesDefault = {
	INVALID_TYPE: "Invalid type: {type} (expected {expected})",
	ENUM_MISMATCH: "No enum match for: {value}",
	ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
	ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
	ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
	NOT_PASSED: "Data matches schema from \"not\"",
	// Numeric errors
	NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
	NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
	NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
	NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
	NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
	NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
	// String errors
	STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
	STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
	STRING_PATTERN: "String does not match pattern: {pattern}",
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
	OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
	OBJECT_REQUIRED: "Missing required property: {key}",
	OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
	OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
	// Array errors
	ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
	ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
	ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
	ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
	// Format errors
	FORMAT_CUSTOM: "Format validation failed ({message})",
	KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
	// Schema structure
	CIRCULAR_REFERENCE: "Circular $refs: {urls}",
	// Non-standard validation options
	UNKNOWN_PROPERTY: "Unknown property (not in schema)"
};

function ValidationError(code, message, params, dataPath, schemaPath, subErrors) {
	Error.call(this);
	if (code === undefined) {
		throw new Error ("No code supplied for error: "+ message);
	}
	this.message = message;
	this.params = params;
	this.code = code;
	this.dataPath = dataPath || "";
	this.schemaPath = schemaPath || "";
	this.subErrors = subErrors || null;

	var err = new Error(this.message);
	this.stack = err.stack || err.stacktrace;
	if (!this.stack) {
		try {
			throw err;
		}
		catch(err) {
			this.stack = err.stack || err.stacktrace;
		}
	}
}
ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;
ValidationError.prototype.name = 'ValidationError';

ValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {
	if (dataPrefix !== null) {
		dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.dataPath = "/" + dataPrefix + this.dataPath;
	}
	if (schemaPrefix !== null) {
		schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.schemaPath = "/" + schemaPrefix + this.schemaPath;
	}
	if (this.subErrors !== null) {
		for (var i = 0; i < this.subErrors.length; i++) {
			this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
		}
	}
	return this;
};

function isTrustedUrl(baseUrl, testUrl) {
	if(testUrl.substring(0, baseUrl.length) === baseUrl){
		var remainder = testUrl.substring(baseUrl.length);
		if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/")
			|| remainder.charAt(0) === "#"
			|| remainder.charAt(0) === "?") {
			return true;
		}
	}
	return false;
}

var languages = {};
function createApi(language) {
	var globalContext = new ValidatorContext();
	var currentLanguage = language || 'en';
	var api = {
		addFormat: function () {
			globalContext.addFormat.apply(globalContext, arguments);
		},
		language: function (code) {
			if (!code) {
				return currentLanguage;
			}
			if (!languages[code]) {
				code = code.split('-')[0]; // fall back to base language
			}
			if (languages[code]) {
				currentLanguage = code;
				return code; // so you can tell if fall-back has happened
			}
			return false;
		},
		addLanguage: function (code, messageMap) {
			var key;
			for (key in ErrorCodes) {
				if (messageMap[key] && !messageMap[ErrorCodes[key]]) {
					messageMap[ErrorCodes[key]] = messageMap[key];
				}
			}
			var rootCode = code.split('-')[0];
			if (!languages[rootCode]) { // use for base language if not yet defined
				languages[code] = messageMap;
				languages[rootCode] = messageMap;
			} else {
				languages[code] = Object.create(languages[rootCode]);
				for (key in messageMap) {
					if (typeof languages[rootCode][key] === 'undefined') {
						languages[rootCode][key] = messageMap[key];
					}
					languages[code][key] = messageMap[key];
				}
			}
			return this;
		},
		freshApi: function (language) {
			var result = createApi();
			if (language) {
				result.language(language);
			}
			return result;
		},
		validate: function (data, schema, checkRecursive, banUnknownProperties) {
			var context = new ValidatorContext(globalContext, false, languages[currentLanguage], checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			var error = context.validateAll(data, schema, null, null, "");
			if (!error && banUnknownProperties) {
				error = context.banUnknownProperties();
			}
			this.error = error;
			this.missing = context.missing;
			this.valid = (error === null);
			return this.valid;
		},
		validateResult: function () {
			var result = {};
			this.validate.apply(result, arguments);
			return result;
		},
		validateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {
			var context = new ValidatorContext(globalContext, true, languages[currentLanguage], checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			context.validateAll(data, schema, null, null, "");
			if (banUnknownProperties) {
				context.banUnknownProperties();
			}
			var result = {};
			result.errors = context.errors;
			result.missing = context.missing;
			result.valid = (result.errors.length === 0);
			return result;
		},
		addSchema: function () {
			return globalContext.addSchema.apply(globalContext, arguments);
		},
		getSchema: function () {
			return globalContext.getSchema.apply(globalContext, arguments);
		},
		getSchemaMap: function () {
			return globalContext.getSchemaMap.apply(globalContext, arguments);
		},
		getSchemaUris: function () {
			return globalContext.getSchemaUris.apply(globalContext, arguments);
		},
		getMissingUris: function () {
			return globalContext.getMissingUris.apply(globalContext, arguments);
		},
		dropSchemas: function () {
			globalContext.dropSchemas.apply(globalContext, arguments);
		},
		defineKeyword: function () {
			globalContext.defineKeyword.apply(globalContext, arguments);
		},
		defineError: function (codeName, codeNumber, defaultMessage) {
			if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
				throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');
			}
			if (typeof codeNumber !== 'number' || codeNumber%1 !== 0 || codeNumber < 10000) {
				throw new Error('Code number must be an integer > 10000');
			}
			if (typeof ErrorCodes[codeName] !== 'undefined') {
				throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);
			}
			if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {
				throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);
			}
			ErrorCodes[codeName] = codeNumber;
			ErrorCodeLookup[codeNumber] = codeName;
			ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
			for (var langCode in languages) {
				var language = languages[langCode];
				if (language[codeName]) {
					language[codeNumber] = language[codeNumber] || language[codeName];
				}
			}
		},
		reset: function () {
			globalContext.reset();
			this.error = null;
			this.missing = [];
			this.valid = true;
		},
		missing: [],
		error: null,
		valid: true,
		normSchema: normSchema,
		resolveUrl: resolveUrl,
		getDocumentUri: getDocumentUri,
		errorCodes: ErrorCodes
	};
	return api;
}

var tv4 = createApi();
tv4.addLanguage('en-gb', ErrorMessagesDefault);

//legacy property
tv4.tv4 = tv4;

return tv4; // used by _header.js to globalise.

}));
/*
 * Defiant.js v1.2.5
 * Serch JSON structures plus smart templating with XSLT and XPath.
 * http://defiantjs.com
 *
 * Copyright (c) 2013-2015, Hakan Bilgin <hbi@longscript.com>
 * Licensed under the MIT License
 *
 * CommonTime: updated ie check to be /msie|trident/i (was /msie/i)
 */
if("undefined"==typeof module)var module={exports:void 0};if(module.exports=Defiant=function(){"use strict";var a={is_ie:/msie|trident/i.test(navigator.userAgent),is_safari:/safari/i.test(navigator.userAgent),env:"production",xml_decl:'<?xml version="1.0" encoding="utf-8"?>',namespace:'xmlns:d="defiant-namespace"',tabsize:4,render:function(a,b){var c,d,e,f,g=new XSLTProcessor,h=document.createElement("span"),i={match:"/"};switch(typeof a){case"object":this.extend(i,a),i.data||(i.data=b);break;case"string":i.template=a,i.data=b;break;default:throw"error"}if(i.data=JSON.toXML(i.data),c='//xsl:template[@name="'+i.template+'"]',this.xsl_template||this.gatherTemplates(),i.sorter&&(f=this.node.selectSingleNode(this.xsl_template,c+"//xsl:for-each//xsl:sort"),f&&(i.sorter.order&&f.setAttribute("order",i.sorter.order),i.sorter.select&&f.setAttribute("select",i.sorter.select),f.setAttribute("data-type",i.sorter.type||"text"))),e=this.node.selectSingleNode(this.xsl_template,c),e.setAttribute("match",i.match),g.importStylesheet(this.xsl_template),h.appendChild(g.transformToFragment(i.data,document)),e.removeAttribute("match"),this.is_safari){d=h.getElementsByTagName("script");for(var j=0,k=d.length;k>j;j++)d[j].defer=!0}return h.innerHTML},gatherTemplates:function(){for(var a=document.getElementsByTagName("script"),b="",c=0,d=a.length;d>c;c++)"defiant/xsl-template"===a[c].type&&(b+=a[c].innerHTML);this.xsl_template=this.xmlFromString('<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" '+this.namespace+">"+b.replace(/defiant:(\w+)/g,"$1")+"</xsl:stylesheet>")},getSnapshot:function(a){return JSON.toXML(a,!0)},xmlFromString:function(a){var b,c;return a=a.replace(/>\s{1,}</g,"><"),null===a.trim().match(/<\?xml/)&&(a=this.xml_decl+a),this.is_ie?(c=new ActiveXObject("Msxml2.DOMDocument"),c.loadXML(a),-1===a.indexOf("xsl:stylesheet")&&c.setProperty("SelectionLanguage","XPath")):(b=new DOMParser,c=b.parseFromString(a,"text/xml")),c},extend:function(a,b){for(var c in b)a[c]&&"object"==typeof b[c]?this.extend(a[c],b[c]):a[c]=b[c];return a},node:{}};return a}(this),"undefined"==typeof XSLTProcessor){var XSLTProcessor=function(){};XSLTProcessor.prototype={importStylesheet:function(a){this.xsldoc=a},transformToFragment:function(a){var b=a.transformNode(this.xsldoc),c=document.createElement("span");return c.innerHTML=b,c}}}String.prototype.fill||(String.prototype.fill=function(a,b){var c=this;for(b=b||" ";c.length<a;c+=b);return c}),String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^\s+|\s+$/gm,"")}),String.prototype.xTransform||(String.prototype.xTransform=function(){var a=this;return-1===this.indexOf("translate(")&&(a=this.replace(/contains\(([^,]+),([^\\)]+)\)/,function(a,b,c){var d="abcdefghijklmnopqrstuvwxyz",e=c.trim().slice(-1);return"contains(translate("+b+", "+e+d.toUpperCase()+e+", "+e+d+e+"),"+c.toLowerCase()+")"})),a.toString()}),"undefined"==typeof JSON&&(window.JSON={parse:function(sJSON){return eval("("+sJSON+")")},stringify:function(a){if(a instanceof Object){var b="";if(a.constructor===Array){for(var c=0;c<a.length;b+=this.stringify(a[c])+",",c++);return"["+b.substr(0,b.length-1)+"]"}if(a.toString!==Object.prototype.toString)return'"'+a.toString().replace(/"/g,"\\$&")+'"';for(var d in a)b+='"'+d.replace(/"/g,"\\$&")+'":'+this.stringify(a[d])+",";return"{"+b.substr(0,b.length-1)+"}"}return"string"==typeof a?'"'+a.replace(/"/g,"\\$&")+'"':String(a)}}),JSON.toXML||(JSON.toXML=function(a,b){"use strict";var c={map:[],rx_validate_name:/^(?!xml)[a-z_][\w\d.:]*$/i,rx_node:/<(.+?)( .*?)>/,rx_constructor:/<(.+?)( d:contr=".*?")>/,rx_namespace:/ xmlns\:d="defiant\-namespace"/,rx_data:/(<.+?>)(.*?)(<\/d:data>)/i,rx_function:/function (\w+)/i,to_xml:function(a){var b=this.hash_to_xml(null,a);return Defiant.xmlFromString(b)},hash_to_xml:function(a,b,c){var d,e,f,g,h,i,j,k,l=b.constructor===Array,m=[],n=[];for(d in b)if(e=b[d],(null===e||void 0===e||"NaN"===e.toString())&&(e=null),g="@"===d.slice(0,1),h=c?a:d,h==+h&&b.constructor!==Object&&(h="d:item"),null===e?(i=null,j=!1):(i=e.constructor,j=i.toString().match(this.rx_function)[1]),g)n.push(h.slice(1)+'="'+this.escape_xml(e)+'"'),"String"!==j&&n.push("d:"+h.slice(1)+'="'+j+'"');else if(null===e)m.push(this.scalar_to_xml(h,e));else switch(i){case Function:break;case Object:m.push(this.hash_to_xml(h,e));break;case Array:if(d===h){if(f=e.constructor===Array)for(k=e.length;k--;)e[k].constructor===Array&&(f=!0),f||e[k].constructor!==Object||(f=!0);m.push(this.scalar_to_xml(h,e,f));break}case String:if("string"==typeof e&&(e=e.toString().replace(/\&/g,"&amp;").replace(/\r|\n/g,"&#13;")),"#text"===h){this.map.push(b),n.push('d:mi="'+this.map.length+'"'),n.push('d:constr="'+j+'"'),m.push(this.escape_xml(e));break}case Number:case Boolean:if("#text"===h&&"String"!==j){this.map.push(b),n.push('d:mi="'+this.map.length+'"'),n.push('d:constr="'+j+'"'),m.push(this.escape_xml(e));break}m.push(this.scalar_to_xml(h,e))}return a||(a="d:data",n.push(Defiant.namespace),l&&n.push('d:constr="Array"')),null===a.match(this.rx_validate_name)&&(n.push('d:name="'+a+'"'),a="d:name"),c?m.join(""):(this.map.push(b),n.push('d:mi="'+this.map.length+'"'),"<"+a+(n.length?" "+n.join(" "):"")+(m.length?">"+m.join("")+"</"+a+">":"/>"))},scalar_to_xml:function(a,b,c){var d,e,f,g="";if(null===a.match(this.rx_validate_name)&&(g+=' d:name="'+a+'"',a="d:name",c=!1),(null===b||"NaN"===b.toString())&&(b=null),null===b)return"<"+a+' d:constr="null"/>';if(1===b.length&&b[0].constructor===Object){d=this.hash_to_xml(!1,b[0]);var h=d.match(this.rx_node),i=d.match(this.rx_constructor);return h=null!==h?h[2].replace(this.rx_namespace,"").replace(/>/,"").replace(/"\/$/,'"'):"",i=null!==i?i[2]:"",d=d.match(this.rx_data),d=null!==d?d[2]:"","<"+a+h+" "+i+' d:type="ArrayItem">'+d+"</"+a+">"}return 0===b.length&&b.constructor===Array?"<"+a+' d:constr="Array"/>':c?this.hash_to_xml(a,b,!0):(e=b.constructor,f=e.toString().match(this.rx_function)[1],d=e===Array?this.hash_to_xml("d:item",b,!0):this.escape_xml(b),g+=' d:constr="'+f+'"',this.map.push(b),g+=' d:mi="'+this.map.length+'"',"#text"===a?this.escape_xml(b):"<"+a+g+">"+d+"</"+a+">")},escape_xml:function(a){return String(a).replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/&nbsp;/g,"&#160;")}},d=c.to_xml.call(c,a);return b?{doc:d,src:a,map:c.map}:(this.search.map=c.map,d)}),JSON.search||(JSON.search=function(a,b,c){"use strict";var d,e,f=a.doc&&a.doc.nodeType,g=f?a.doc:JSON.toXML(a),h=f?a.map:this.search.map,i=f?a.src:a,j=Defiant.node[c?"selectSingleNode":"selectNodes"](g,b.xTransform()),k=[];for(c&&(j=[j]),e=j.length;e--;)switch(j[e].nodeType){case 2:case 3:k.unshift(j[e].nodeValue);break;default:d=+j[e].getAttribute("d:mi"),h[d-1]&&k.unshift(h[d-1])}return"development"===Defiant.env&&(this.trace=JSON.mtrace(i,k,j)),k}),JSON.mtrace||(JSON.mtrace=function(a,b,c){"use strict";for(var d,e,f,g,h,i=window,j=JSON.stringify,k=j(a,null,"	").replace(/\t/g,""),l=[],m=0,n=c.length,o=n?c[m].ownerDocument.documentElement:!1,p=(this.search.map,0);n>m;m++){switch(c[m].nodeType){case 2:e=c[m].ownerElement?c[m].ownerElement.getAttribute("d:"+c[m].nodeName):"String",d='"@'+c[m].nodeName+'": '+i[e](b[m]),f=k.indexOf(d),h=0;break;case 3:e=c[m].parentNode.getAttribute("d:constr"),d=i[e](b[m]),d='"'+c[m].parentNode.nodeName+'": '+("Number"===d?d:'"'+d+'"'),f=k.indexOf(d),h=0;break;default:if(c[m]===o)continue;"String"===c[m].getAttribute("d:constr")?(e=c[m].getAttribute("d:constr"),d=i[e](b[m]),d='"'+c[m].nodeName+'": '+("Number"===d?d:'"'+d+'"'),f=k.indexOf(d,p),h=0,p=f+1):(d=j(b[m],null,"	").replace(/\t/g,""),f=k.indexOf(d),h=d.match(/\n/g).length)}g=k.substring(0,f).match(/\n/g).length+1,l.push([g,h])}return l}),Defiant.node.selectNodes=function(a,b){if(a.evaluate){for(var c=a.createNSResolver(a.documentElement),d=a.evaluate(b,a,c,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null),e=[],f=0,g=d.snapshotLength;g>f;f++)e.push(d.snapshotItem(f));return e}return a.selectNodes(b)},Defiant.node.selectSingleNode=function(a,b){if(a.evaluate){var c=this.selectNodes(a,b);return c.length>0?c[0]:null}return a.selectSingleNode(b)},Defiant.node.prettyPrint=function(a){var b,c,d=Defiant,e=d.tabsize,f=d.xml_decl.toLowerCase();d.is_ie?c=a.xml:(b=new XMLSerializer,c=b.serializeToString(a)),"development"!==d.env&&(c=c.replace(/ \w+\:d=".*?"| d\:\w+=".*?"/g,""));for(var g,h,i=c.trim().replace(/(>)\s*(<)(\/*)/g,"$1\n$2$3"),j=i.split("\n"),k=-1,l=0,m=j.length;m>l;l++)(0!==l||j[l].toLowerCase()!==f)&&(g=null!==j[l].match(/<[A-Za-z_\:]+.*?>/g),h=null!==j[l].match(/<\/[\w\:]+>/g),null!==j[l].match(/<.*?\/>/g)&&(g=h=!0),g&&k++,j[l]=String().fill(k,"	")+j[l],g&&h&&k--,!g&&h&&k--);return j.join("\n").replace(/\t/g,String().fill(e," "))},Defiant.node.toJSON=function(a,b){"use strict";var c=function(a){var b,d,e,f,g,h,i,j,k,l,m={},n=window;switch(a.nodeType){case 1:for(g=a.getAttribute("d:constr"),"Array"===g?m=[]:"String"===g&&""===a.textContent&&(m=""),b=a.attributes,j=0,k=b.length;k>j;j++)l=b.item(j),null===l.nodeName.match(/\:d|d\:/g)&&(g=a.getAttribute("d:"+l.nodeName),h=g&&"undefined"!==g?"null"===l.nodeValue?null:n[g]("false"===l.nodeValue?"":l.nodeValue):l.nodeValue,m["@"+l.nodeName]=h);break;case 3:d=a.parentNode.getAttribute("d:type"),h=d?n[d]("false"===a.nodeValue?"":a.nodeValue):a.nodeValue,m=h}if(a.hasChildNodes())for(j=0,k=a.childNodes.length;k>j;j++)if(e=a.childNodes.item(j),f=e.nodeName,b=a.attributes,"d:name"===f&&(f=e.getAttribute("d:name")),"#text"===f)g=a.getAttribute("d:constr"),"undefined"===g&&(g=void 0),i=e.textContent||e.text,h="Boolean"===g&&"false"===i?"":i,g||b.length?g&&1===k?m=n[g](h):a.hasChildNodes()&&b.length<3?m=g?n[g](h):h:m[f]=g?n[g](h):h:m=h;else{if(m[f]){m[f].push?m[f].push(c(e)):m[f]=[m[f],c(e)];continue}switch(g=e.getAttribute("d:constr")){case"null":m.push?m.push(null):m[f]=null;break;case"Array":e.parentNode.firstChild===e&&"Array"===g&&"d:item"!==f?"d:item"===f||"Array"===g?(h=c(e),m[f]=h.length?[h]:h):m[f]=c(e):m.push?m.push(c(e)):m[f]=c(e);break;case"String":case"Number":case"Boolean":i=e.textContent||e.text,h="Boolean"===g&&"false"===i?"":i,m.push?m.push(n[g](h)):m[f]=c(e);break;default:m.push?m.push(c(e)):m[f]=c(e)}}return 1===a.nodeType&&"ArrayItem"===a.getAttribute("d:type")&&(m=[m]),m},d=9===a.nodeType?a.documentElement:a,e=c(d),f=e[d.nodeName];return d===d.ownerDocument.documentElement&&f&&f.constructor===Array&&(e=f),b&&"true"===b.toString()&&(b="	"),b?JSON.stringify(e,null,b):e},"undefined"!=typeof jQuery&&!function(a){"use strict";a.fn.defiant=function(a,b){return this.html(Defiant.render(a,b)),this}}(jQuery);

// odd, but need to do this as something (don't know what) reassigns the value of JSON
window.JSON2 = JSON;
/*
 AngularJS v1.4.7
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(Q,X,w){'use strict';function I(b){return function(){var a=arguments[0],c;c="["+(b?b+":":"")+a+"] http://errors.angularjs.org/1.4.7/"+(b?b+"/":"")+a;for(a=1;a<arguments.length;a++){c=c+(1==a?"?":"&")+"p"+(a-1)+"=";var d=encodeURIComponent,e;e=arguments[a];e="function"==typeof e?e.toString().replace(/ \{[\s\S]*$/,""):"undefined"==typeof e?"undefined":"string"!=typeof e?JSON.stringify(e):e;c+=d(e)}return Error(c)}}function Da(b){if(null==b||Za(b))return!1;var a="length"in Object(b)&&b.length;
return b.nodeType===pa&&a?!0:G(b)||J(b)||0===a||"number"===typeof a&&0<a&&a-1 in b}function m(b,a,c){var d,e;if(b)if(x(b))for(d in b)"prototype"==d||"length"==d||"name"==d||b.hasOwnProperty&&!b.hasOwnProperty(d)||a.call(c,b[d],d,b);else if(J(b)||Da(b)){var f="object"!==typeof b;d=0;for(e=b.length;d<e;d++)(f||d in b)&&a.call(c,b[d],d,b)}else if(b.forEach&&b.forEach!==m)b.forEach(a,c,b);else if(mc(b))for(d in b)a.call(c,b[d],d,b);else if("function"===typeof b.hasOwnProperty)for(d in b)b.hasOwnProperty(d)&&
a.call(c,b[d],d,b);else for(d in b)ta.call(b,d)&&a.call(c,b[d],d,b);return b}function nc(b,a,c){for(var d=Object.keys(b).sort(),e=0;e<d.length;e++)a.call(c,b[d[e]],d[e]);return d}function oc(b){return function(a,c){b(c,a)}}function Ud(){return++nb}function pc(b,a){a?b.$$hashKey=a:delete b.$$hashKey}function Mb(b,a,c){for(var d=b.$$hashKey,e=0,f=a.length;e<f;++e){var h=a[e];if(C(h)||x(h))for(var g=Object.keys(h),l=0,k=g.length;l<k;l++){var n=g[l],p=h[n];c&&C(p)?ea(p)?b[n]=new Date(p.valueOf()):Oa(p)?
b[n]=new RegExp(p):(C(b[n])||(b[n]=J(p)?[]:{}),Mb(b[n],[p],!0)):b[n]=p}}pc(b,d);return b}function P(b){return Mb(b,ua.call(arguments,1),!1)}function Vd(b){return Mb(b,ua.call(arguments,1),!0)}function Y(b){return parseInt(b,10)}function Nb(b,a){return P(Object.create(b),a)}function y(){}function $a(b){return b}function qa(b){return function(){return b}}function qc(b){return x(b.toString)&&b.toString!==Object.prototype.toString}function v(b){return"undefined"===typeof b}function A(b){return"undefined"!==
typeof b}function C(b){return null!==b&&"object"===typeof b}function mc(b){return null!==b&&"object"===typeof b&&!rc(b)}function G(b){return"string"===typeof b}function V(b){return"number"===typeof b}function ea(b){return"[object Date]"===va.call(b)}function x(b){return"function"===typeof b}function Oa(b){return"[object RegExp]"===va.call(b)}function Za(b){return b&&b.window===b}function ab(b){return b&&b.$evalAsync&&b.$watch}function bb(b){return"boolean"===typeof b}function sc(b){return!(!b||!(b.nodeName||
b.prop&&b.attr&&b.find))}function Wd(b){var a={};b=b.split(",");var c;for(c=0;c<b.length;c++)a[b[c]]=!0;return a}function wa(b){return F(b.nodeName||b[0]&&b[0].nodeName)}function cb(b,a){var c=b.indexOf(a);0<=c&&b.splice(c,1);return c}function ha(b,a,c,d){if(Za(b)||ab(b))throw Ea("cpws");if(tc.test(va.call(a)))throw Ea("cpta");if(a){if(b===a)throw Ea("cpi");c=c||[];d=d||[];C(b)&&(c.push(b),d.push(a));var e;if(J(b))for(e=a.length=0;e<b.length;e++)a.push(ha(b[e],null,c,d));else{var f=a.$$hashKey;J(a)?
a.length=0:m(a,function(b,c){delete a[c]});if(mc(b))for(e in b)a[e]=ha(b[e],null,c,d);else if(b&&"function"===typeof b.hasOwnProperty)for(e in b)b.hasOwnProperty(e)&&(a[e]=ha(b[e],null,c,d));else for(e in b)ta.call(b,e)&&(a[e]=ha(b[e],null,c,d));pc(a,f)}}else if(a=b,C(b)){if(c&&-1!==(f=c.indexOf(b)))return d[f];if(J(b))return ha(b,[],c,d);if(tc.test(va.call(b)))a=new b.constructor(b);else if(ea(b))a=new Date(b.getTime());else if(Oa(b))a=new RegExp(b.source,b.toString().match(/[^\/]*$/)[0]),a.lastIndex=
b.lastIndex;else if(x(b.cloneNode))a=b.cloneNode(!0);else return e=Object.create(rc(b)),ha(b,e,c,d);d&&(c.push(b),d.push(a))}return a}function ja(b,a){if(J(b)){a=a||[];for(var c=0,d=b.length;c<d;c++)a[c]=b[c]}else if(C(b))for(c in a=a||{},b)if("$"!==c.charAt(0)||"$"!==c.charAt(1))a[c]=b[c];return a||b}function ka(b,a){if(b===a)return!0;if(null===b||null===a)return!1;if(b!==b&&a!==a)return!0;var c=typeof b,d;if(c==typeof a&&"object"==c)if(J(b)){if(!J(a))return!1;if((c=b.length)==a.length){for(d=0;d<
c;d++)if(!ka(b[d],a[d]))return!1;return!0}}else{if(ea(b))return ea(a)?ka(b.getTime(),a.getTime()):!1;if(Oa(b))return Oa(a)?b.toString()==a.toString():!1;if(ab(b)||ab(a)||Za(b)||Za(a)||J(a)||ea(a)||Oa(a))return!1;c=fa();for(d in b)if("$"!==d.charAt(0)&&!x(b[d])){if(!ka(b[d],a[d]))return!1;c[d]=!0}for(d in a)if(!(d in c)&&"$"!==d.charAt(0)&&A(a[d])&&!x(a[d]))return!1;return!0}return!1}function db(b,a,c){return b.concat(ua.call(a,c))}function uc(b,a){var c=2<arguments.length?ua.call(arguments,2):[];
return!x(a)||a instanceof RegExp?a:c.length?function(){return arguments.length?a.apply(b,db(c,arguments,0)):a.apply(b,c)}:function(){return arguments.length?a.apply(b,arguments):a.call(b)}}function Xd(b,a){var c=a;"string"===typeof b&&"$"===b.charAt(0)&&"$"===b.charAt(1)?c=w:Za(a)?c="$WINDOW":a&&X===a?c="$DOCUMENT":ab(a)&&(c="$SCOPE");return c}function eb(b,a){if("undefined"===typeof b)return w;V(a)||(a=a?2:null);return JSON.stringify(b,Xd,a)}function vc(b){return G(b)?JSON.parse(b):b}function wc(b,
a){var c=Date.parse("Jan 01, 1970 00:00:00 "+b)/6E4;return isNaN(c)?a:c}function Ob(b,a,c){c=c?-1:1;var d=wc(a,b.getTimezoneOffset());a=b;b=c*(d-b.getTimezoneOffset());a=new Date(a.getTime());a.setMinutes(a.getMinutes()+b);return a}function xa(b){b=B(b).clone();try{b.empty()}catch(a){}var c=B("<div>").append(b).html();try{return b[0].nodeType===Pa?F(c):c.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/,function(a,b){return"<"+F(b)})}catch(d){return F(c)}}function xc(b){try{return decodeURIComponent(b)}catch(a){}}
function yc(b){var a={};m((b||"").split("&"),function(b){var d,e,f;b&&(e=b=b.replace(/\+/g,"%20"),d=b.indexOf("="),-1!==d&&(e=b.substring(0,d),f=b.substring(d+1)),e=xc(e),A(e)&&(f=A(f)?xc(f):!0,ta.call(a,e)?J(a[e])?a[e].push(f):a[e]=[a[e],f]:a[e]=f))});return a}function Pb(b){var a=[];m(b,function(b,d){J(b)?m(b,function(b){a.push(la(d,!0)+(!0===b?"":"="+la(b,!0)))}):a.push(la(d,!0)+(!0===b?"":"="+la(b,!0)))});return a.length?a.join("&"):""}function ob(b){return la(b,!0).replace(/%26/gi,"&").replace(/%3D/gi,
"=").replace(/%2B/gi,"+")}function la(b,a){return encodeURIComponent(b).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%20/g,a?"%20":"+")}function Yd(b,a){var c,d,e=Qa.length;for(d=0;d<e;++d)if(c=Qa[d]+a,G(c=b.getAttribute(c)))return c;return null}function Zd(b,a){var c,d,e={};m(Qa,function(a){a+="app";!c&&b.hasAttribute&&b.hasAttribute(a)&&(c=b,d=b.getAttribute(a))});m(Qa,function(a){a+="app";var e;!c&&(e=b.querySelector("["+a.replace(":",
"\\:")+"]"))&&(c=e,d=e.getAttribute(a))});c&&(e.strictDi=null!==Yd(c,"strict-di"),a(c,d?[d]:[],e))}function zc(b,a,c){C(c)||(c={});c=P({strictDi:!1},c);var d=function(){b=B(b);if(b.injector()){var d=b[0]===X?"document":xa(b);throw Ea("btstrpd",d.replace(/</,"&lt;").replace(/>/,"&gt;"));}a=a||[];a.unshift(["$provide",function(a){a.value("$rootElement",b)}]);c.debugInfoEnabled&&a.push(["$compileProvider",function(a){a.debugInfoEnabled(!0)}]);a.unshift("ng");d=fb(a,c.strictDi);d.invoke(["$rootScope",
"$rootElement","$compile","$injector",function(a,b,c,d){a.$apply(function(){b.data("$injector",d);c(b)(a)})}]);return d},e=/^NG_ENABLE_DEBUG_INFO!/,f=/^NG_DEFER_BOOTSTRAP!/;Q&&e.test(Q.name)&&(c.debugInfoEnabled=!0,Q.name=Q.name.replace(e,""));if(Q&&!f.test(Q.name))return d();Q.name=Q.name.replace(f,"");da.resumeBootstrap=function(b){m(b,function(b){a.push(b)});return d()};x(da.resumeDeferredBootstrap)&&da.resumeDeferredBootstrap()}function $d(){Q.name="NG_ENABLE_DEBUG_INFO!"+Q.name;Q.location.reload()}
function ae(b){b=da.element(b).injector();if(!b)throw Ea("test");return b.get("$$testability")}function Ac(b,a){a=a||"_";return b.replace(be,function(b,d){return(d?a:"")+b.toLowerCase()})}function ce(){var b;if(!Bc){var a=pb();(ra=v(a)?Q.jQuery:a?Q[a]:w)&&ra.fn.on?(B=ra,P(ra.fn,{scope:Ra.scope,isolateScope:Ra.isolateScope,controller:Ra.controller,injector:Ra.injector,inheritedData:Ra.inheritedData}),b=ra.cleanData,ra.cleanData=function(a){var d;if(Qb)Qb=!1;else for(var e=0,f;null!=(f=a[e]);e++)(d=
ra._data(f,"events"))&&d.$destroy&&ra(f).triggerHandler("$destroy");b(a)}):B=R;da.element=B;Bc=!0}}function qb(b,a,c){if(!b)throw Ea("areq",a||"?",c||"required");return b}function Sa(b,a,c){c&&J(b)&&(b=b[b.length-1]);qb(x(b),a,"not a function, got "+(b&&"object"===typeof b?b.constructor.name||"Object":typeof b));return b}function Ta(b,a){if("hasOwnProperty"===b)throw Ea("badname",a);}function Cc(b,a,c){if(!a)return b;a=a.split(".");for(var d,e=b,f=a.length,h=0;h<f;h++)d=a[h],b&&(b=(e=b)[d]);return!c&&
x(b)?uc(e,b):b}function rb(b){for(var a=b[0],c=b[b.length-1],d,e=1;a!==c&&(a=a.nextSibling);e++)if(d||b[e]!==a)d||(d=B(ua.call(b,0,e))),d.push(a);return d||b}function fa(){return Object.create(null)}function de(b){function a(a,b,c){return a[b]||(a[b]=c())}var c=I("$injector"),d=I("ng");b=a(b,"angular",Object);b.$$minErr=b.$$minErr||I;return a(b,"module",function(){var b={};return function(f,h,g){if("hasOwnProperty"===f)throw d("badname","module");h&&b.hasOwnProperty(f)&&(b[f]=null);return a(b,f,function(){function a(b,
c,e,f){f||(f=d);return function(){f[e||"push"]([b,c,arguments]);return E}}function b(a,c){return function(b,e){e&&x(e)&&(e.$$moduleName=f);d.push([a,c,arguments]);return E}}if(!h)throw c("nomod",f);var d=[],e=[],r=[],t=a("$injector","invoke","push",e),E={_invokeQueue:d,_configBlocks:e,_runBlocks:r,requires:h,name:f,provider:b("$provide","provider"),factory:b("$provide","factory"),service:b("$provide","service"),value:a("$provide","value"),constant:a("$provide","constant","unshift"),decorator:b("$provide",
"decorator"),animation:b("$animateProvider","register"),filter:b("$filterProvider","register"),controller:b("$controllerProvider","register"),directive:b("$compileProvider","directive"),config:t,run:function(a){r.push(a);return this}};g&&t(g);return E})}})}function ee(b){P(b,{bootstrap:zc,copy:ha,extend:P,merge:Vd,equals:ka,element:B,forEach:m,injector:fb,noop:y,bind:uc,toJson:eb,fromJson:vc,identity:$a,isUndefined:v,isDefined:A,isString:G,isFunction:x,isObject:C,isNumber:V,isElement:sc,isArray:J,
version:fe,isDate:ea,lowercase:F,uppercase:sb,callbacks:{counter:0},getTestability:ae,$$minErr:I,$$csp:Fa,reloadWithDebugInfo:$d});Rb=de(Q);Rb("ng",["ngLocale"],["$provide",function(a){a.provider({$$sanitizeUri:ge});a.provider("$compile",Dc).directive({a:he,input:Ec,textarea:Ec,form:ie,script:je,select:ke,style:le,option:me,ngBind:ne,ngBindHtml:oe,ngBindTemplate:pe,ngClass:qe,ngClassEven:re,ngClassOdd:se,ngCloak:te,ngController:ue,ngForm:ve,ngHide:we,ngIf:xe,ngInclude:ye,ngInit:ze,ngNonBindable:Ae,
ngPluralize:Be,ngRepeat:Ce,ngShow:De,ngStyle:Ee,ngSwitch:Fe,ngSwitchWhen:Ge,ngSwitchDefault:He,ngOptions:Ie,ngTransclude:Je,ngModel:Ke,ngList:Le,ngChange:Me,pattern:Fc,ngPattern:Fc,required:Gc,ngRequired:Gc,minlength:Hc,ngMinlength:Hc,maxlength:Ic,ngMaxlength:Ic,ngValue:Ne,ngModelOptions:Oe}).directive({ngInclude:Pe}).directive(tb).directive(Jc);a.provider({$anchorScroll:Qe,$animate:Re,$animateCss:Se,$$animateQueue:Te,$$AnimateRunner:Ue,$browser:Ve,$cacheFactory:We,$controller:Xe,$document:Ye,$exceptionHandler:Ze,
$filter:Kc,$$forceReflow:$e,$interpolate:af,$interval:bf,$http:cf,$httpParamSerializer:df,$httpParamSerializerJQLike:ef,$httpBackend:ff,$xhrFactory:gf,$location:hf,$log:jf,$parse:kf,$rootScope:lf,$q:mf,$$q:nf,$sce:of,$sceDelegate:pf,$sniffer:qf,$templateCache:rf,$templateRequest:sf,$$testability:tf,$timeout:uf,$window:vf,$$rAF:wf,$$jqLite:xf,$$HashMap:yf,$$cookieReader:zf})}])}function gb(b){return b.replace(Af,function(a,b,d,e){return e?d.toUpperCase():d}).replace(Bf,"Moz$1")}function Lc(b){b=b.nodeType;
return b===pa||!b||9===b}function Mc(b,a){var c,d,e=a.createDocumentFragment(),f=[];if(Sb.test(b)){c=c||e.appendChild(a.createElement("div"));d=(Cf.exec(b)||["",""])[1].toLowerCase();d=ma[d]||ma._default;c.innerHTML=d[1]+b.replace(Df,"<$1></$2>")+d[2];for(d=d[0];d--;)c=c.lastChild;f=db(f,c.childNodes);c=e.firstChild;c.textContent=""}else f.push(a.createTextNode(b));e.textContent="";e.innerHTML="";m(f,function(a){e.appendChild(a)});return e}function R(b){if(b instanceof R)return b;var a;G(b)&&(b=T(b),
a=!0);if(!(this instanceof R)){if(a&&"<"!=b.charAt(0))throw Tb("nosel");return new R(b)}if(a){a=X;var c;b=(c=Ef.exec(b))?[a.createElement(c[1])]:(c=Mc(b,a))?c.childNodes:[]}Nc(this,b)}function Ub(b){return b.cloneNode(!0)}function ub(b,a){a||vb(b);if(b.querySelectorAll)for(var c=b.querySelectorAll("*"),d=0,e=c.length;d<e;d++)vb(c[d])}function Oc(b,a,c,d){if(A(d))throw Tb("offargs");var e=(d=wb(b))&&d.events,f=d&&d.handle;if(f)if(a)m(a.split(" "),function(a){if(A(c)){var d=e[a];cb(d||[],c);if(d&&0<
d.length)return}b.removeEventListener(a,f,!1);delete e[a]});else for(a in e)"$destroy"!==a&&b.removeEventListener(a,f,!1),delete e[a]}function vb(b,a){var c=b.ng339,d=c&&hb[c];d&&(a?delete d.data[a]:(d.handle&&(d.events.$destroy&&d.handle({},"$destroy"),Oc(b)),delete hb[c],b.ng339=w))}function wb(b,a){var c=b.ng339,c=c&&hb[c];a&&!c&&(b.ng339=c=++Ff,c=hb[c]={events:{},data:{},handle:w});return c}function Vb(b,a,c){if(Lc(b)){var d=A(c),e=!d&&a&&!C(a),f=!a;b=(b=wb(b,!e))&&b.data;if(d)b[a]=c;else{if(f)return b;
if(e)return b&&b[a];P(b,a)}}}function xb(b,a){return b.getAttribute?-1<(" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").indexOf(" "+a+" "):!1}function yb(b,a){a&&b.setAttribute&&m(a.split(" "),function(a){b.setAttribute("class",T((" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").replace(" "+T(a)+" "," ")))})}function zb(b,a){if(a&&b.setAttribute){var c=(" "+(b.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ");m(a.split(" "),function(a){a=T(a);-1===c.indexOf(" "+a+" ")&&
(c+=a+" ")});b.setAttribute("class",T(c))}}function Nc(b,a){if(a)if(a.nodeType)b[b.length++]=a;else{var c=a.length;if("number"===typeof c&&a.window!==a){if(c)for(var d=0;d<c;d++)b[b.length++]=a[d]}else b[b.length++]=a}}function Pc(b,a){return Ab(b,"$"+(a||"ngController")+"Controller")}function Ab(b,a,c){9==b.nodeType&&(b=b.documentElement);for(a=J(a)?a:[a];b;){for(var d=0,e=a.length;d<e;d++)if(A(c=B.data(b,a[d])))return c;b=b.parentNode||11===b.nodeType&&b.host}}function Qc(b){for(ub(b,!0);b.firstChild;)b.removeChild(b.firstChild)}
function Wb(b,a){a||ub(b);var c=b.parentNode;c&&c.removeChild(b)}function Gf(b,a){a=a||Q;if("complete"===a.document.readyState)a.setTimeout(b);else B(a).on("load",b)}function Rc(b,a){var c=Bb[a.toLowerCase()];return c&&Sc[wa(b)]&&c}function Hf(b,a){var c=function(c,e){c.isDefaultPrevented=function(){return c.defaultPrevented};var f=a[e||c.type],h=f?f.length:0;if(h){if(v(c.immediatePropagationStopped)){var g=c.stopImmediatePropagation;c.stopImmediatePropagation=function(){c.immediatePropagationStopped=
!0;c.stopPropagation&&c.stopPropagation();g&&g.call(c)}}c.isImmediatePropagationStopped=function(){return!0===c.immediatePropagationStopped};1<h&&(f=ja(f));for(var l=0;l<h;l++)c.isImmediatePropagationStopped()||f[l].call(b,c)}};c.elem=b;return c}function xf(){this.$get=function(){return P(R,{hasClass:function(b,a){b.attr&&(b=b[0]);return xb(b,a)},addClass:function(b,a){b.attr&&(b=b[0]);return zb(b,a)},removeClass:function(b,a){b.attr&&(b=b[0]);return yb(b,a)}})}}function Ga(b,a){var c=b&&b.$$hashKey;
if(c)return"function"===typeof c&&(c=b.$$hashKey()),c;c=typeof b;return c="function"==c||"object"==c&&null!==b?b.$$hashKey=c+":"+(a||Ud)():c+":"+b}function Ua(b,a){if(a){var c=0;this.nextUid=function(){return++c}}m(b,this.put,this)}function If(b){return(b=b.toString().replace(Tc,"").match(Uc))?"function("+(b[1]||"").replace(/[\s\r\n]+/," ")+")":"fn"}function fb(b,a){function c(a){return function(b,c){if(C(b))m(b,oc(a));else return a(b,c)}}function d(a,b){Ta(a,"service");if(x(b)||J(b))b=r.instantiate(b);
if(!b.$get)throw Ha("pget",a);return p[a+"Provider"]=b}function e(a,b){return function(){var c=E.invoke(b,this);if(v(c))throw Ha("undef",a);return c}}function f(a,b,c){return d(a,{$get:!1!==c?e(a,b):b})}function h(a){qb(v(a)||J(a),"modulesToLoad","not an array");var b=[],c;m(a,function(a){function d(a){var b,c;b=0;for(c=a.length;b<c;b++){var e=a[b],f=r.get(e[0]);f[e[1]].apply(f,e[2])}}if(!n.get(a)){n.put(a,!0);try{G(a)?(c=Rb(a),b=b.concat(h(c.requires)).concat(c._runBlocks),d(c._invokeQueue),d(c._configBlocks)):
x(a)?b.push(r.invoke(a)):J(a)?b.push(r.invoke(a)):Sa(a,"module")}catch(e){throw J(a)&&(a=a[a.length-1]),e.message&&e.stack&&-1==e.stack.indexOf(e.message)&&(e=e.message+"\n"+e.stack),Ha("modulerr",a,e.stack||e.message||e);}}});return b}function g(b,c){function d(a,e){if(b.hasOwnProperty(a)){if(b[a]===l)throw Ha("cdep",a+" <- "+k.join(" <- "));return b[a]}try{return k.unshift(a),b[a]=l,b[a]=c(a,e)}catch(f){throw b[a]===l&&delete b[a],f;}finally{k.shift()}}function e(b,c,f,g){"string"===typeof f&&(g=
f,f=null);var h=[],k=fb.$$annotate(b,a,g),l,r,p;r=0;for(l=k.length;r<l;r++){p=k[r];if("string"!==typeof p)throw Ha("itkn",p);h.push(f&&f.hasOwnProperty(p)?f[p]:d(p,g))}J(b)&&(b=b[l]);return b.apply(c,h)}return{invoke:e,instantiate:function(a,b,c){var d=Object.create((J(a)?a[a.length-1]:a).prototype||null);a=e(a,d,b,c);return C(a)||x(a)?a:d},get:d,annotate:fb.$$annotate,has:function(a){return p.hasOwnProperty(a+"Provider")||b.hasOwnProperty(a)}}}a=!0===a;var l={},k=[],n=new Ua([],!0),p={$provide:{provider:c(d),
factory:c(f),service:c(function(a,b){return f(a,["$injector",function(a){return a.instantiate(b)}])}),value:c(function(a,b){return f(a,qa(b),!1)}),constant:c(function(a,b){Ta(a,"constant");p[a]=b;t[a]=b}),decorator:function(a,b){var c=r.get(a+"Provider"),d=c.$get;c.$get=function(){var a=E.invoke(d,c);return E.invoke(b,null,{$delegate:a})}}}},r=p.$injector=g(p,function(a,b){da.isString(b)&&k.push(b);throw Ha("unpr",k.join(" <- "));}),t={},E=t.$injector=g(t,function(a,b){var c=r.get(a+"Provider",b);
return E.invoke(c.$get,c,w,a)});m(h(b),function(a){a&&E.invoke(a)});return E}function Qe(){var b=!0;this.disableAutoScrolling=function(){b=!1};this.$get=["$window","$location","$rootScope",function(a,c,d){function e(a){var b=null;Array.prototype.some.call(a,function(a){if("a"===wa(a))return b=a,!0});return b}function f(b){if(b){b.scrollIntoView();var c;c=h.yOffset;x(c)?c=c():sc(c)?(c=c[0],c="fixed"!==a.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):V(c)||(c=0);c&&(b=b.getBoundingClientRect().top,
a.scrollBy(0,b-c))}else a.scrollTo(0,0)}function h(a){a=G(a)?a:c.hash();var b;a?(b=g.getElementById(a))?f(b):(b=e(g.getElementsByName(a)))?f(b):"top"===a&&f(null):f(null)}var g=a.document;b&&d.$watch(function(){return c.hash()},function(a,b){a===b&&""===a||Gf(function(){d.$evalAsync(h)})});return h}]}function ib(b,a){if(!b&&!a)return"";if(!b)return a;if(!a)return b;J(b)&&(b=b.join(" "));J(a)&&(a=a.join(" "));return b+" "+a}function Jf(b){G(b)&&(b=b.split(" "));var a=fa();m(b,function(b){b.length&&
(a[b]=!0)});return a}function Ia(b){return C(b)?b:{}}function Kf(b,a,c,d){function e(a){try{a.apply(null,ua.call(arguments,1))}finally{if(E--,0===E)for(;K.length;)try{K.pop()()}catch(b){c.error(b)}}}function f(){ia=null;h();g()}function h(){a:{try{u=n.state;break a}catch(a){}u=void 0}u=v(u)?null:u;ka(u,L)&&(u=L);L=u}function g(){if(z!==l.url()||q!==u)z=l.url(),q=u,m(O,function(a){a(l.url(),u)})}var l=this,k=b.location,n=b.history,p=b.setTimeout,r=b.clearTimeout,t={};l.isMock=!1;var E=0,K=[];l.$$completeOutstandingRequest=
e;l.$$incOutstandingRequestCount=function(){E++};l.notifyWhenNoOutstandingRequests=function(a){0===E?a():K.push(a)};var u,q,z=k.href,N=a.find("base"),ia=null;h();q=u;l.url=function(a,c,e){v(e)&&(e=null);k!==b.location&&(k=b.location);n!==b.history&&(n=b.history);if(a){var f=q===e;if(z===a&&(!d.history||f))return l;var g=z&&Ja(z)===Ja(a);z=a;q=e;if(!d.history||g&&f){if(!g||ia)ia=a;c?k.replace(a):g?(c=k,e=a.indexOf("#"),e=-1===e?"":a.substr(e),c.hash=e):k.href=a;k.href!==a&&(ia=a)}else n[c?"replaceState":
"pushState"](e,"",a),h(),q=u;return l}return ia||k.href.replace(/%27/g,"'")};l.state=function(){return u};var O=[],H=!1,L=null;l.onUrlChange=function(a){if(!H){if(d.history)B(b).on("popstate",f);B(b).on("hashchange",f);H=!0}O.push(a);return a};l.$$applicationDestroyed=function(){B(b).off("hashchange popstate",f)};l.$$checkUrlChange=g;l.baseHref=function(){var a=N.attr("href");return a?a.replace(/^(https?\:)?\/\/[^\/]*/,""):""};l.defer=function(a,b){var c;E++;c=p(function(){delete t[c];e(a)},b||0);
t[c]=!0;return c};l.defer.cancel=function(a){return t[a]?(delete t[a],r(a),e(y),!0):!1}}function Ve(){this.$get=["$window","$log","$sniffer","$document",function(b,a,c,d){return new Kf(b,d,a,c)}]}function We(){this.$get=function(){function b(b,d){function e(a){a!=p&&(r?r==a&&(r=a.n):r=a,f(a.n,a.p),f(a,p),p=a,p.n=null)}function f(a,b){a!=b&&(a&&(a.p=b),b&&(b.n=a))}if(b in a)throw I("$cacheFactory")("iid",b);var h=0,g=P({},d,{id:b}),l={},k=d&&d.capacity||Number.MAX_VALUE,n={},p=null,r=null;return a[b]=
{put:function(a,b){if(!v(b)){if(k<Number.MAX_VALUE){var c=n[a]||(n[a]={key:a});e(c)}a in l||h++;l[a]=b;h>k&&this.remove(r.key);return b}},get:function(a){if(k<Number.MAX_VALUE){var b=n[a];if(!b)return;e(b)}return l[a]},remove:function(a){if(k<Number.MAX_VALUE){var b=n[a];if(!b)return;b==p&&(p=b.p);b==r&&(r=b.n);f(b.n,b.p);delete n[a]}delete l[a];h--},removeAll:function(){l={};h=0;n={};p=r=null},destroy:function(){n=g=l=null;delete a[b]},info:function(){return P({},g,{size:h})}}}var a={};b.info=function(){var b=
{};m(a,function(a,e){b[e]=a.info()});return b};b.get=function(b){return a[b]};return b}}function rf(){this.$get=["$cacheFactory",function(b){return b("templates")}]}function Dc(b,a){function c(a,b,c){var d=/^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/,e={};m(a,function(a,f){var g=a.match(d);if(!g)throw ga("iscp",b,f,a,c?"controller bindings definition":"isolate scope definition");e[f]={mode:g[1][0],collection:"*"===g[2],optional:"?"===g[3],attrName:g[4]||f}});return e}function d(a){var b=a.charAt(0);if(!b||
b!==F(b))throw ga("baddir",a);if(a!==a.trim())throw ga("baddir",a);}var e={},f=/^\s*directive\:\s*([\w\-]+)\s+(.*)$/,h=/(([\w\-]+)(?:\:([^;]+))?;?)/,g=Wd("ngSrc,ngSrcset,src,srcset"),l=/^(?:(\^\^?)?(\?)?(\^\^?)?)?/,k=/^(on[a-z]+|formaction)$/;this.directive=function r(a,f){Ta(a,"directive");G(a)?(d(a),qb(f,"directiveFactory"),e.hasOwnProperty(a)||(e[a]=[],b.factory(a+"Directive",["$injector","$exceptionHandler",function(b,d){var f=[];m(e[a],function(e,g){try{var h=b.invoke(e);x(h)?h={compile:qa(h)}:
!h.compile&&h.link&&(h.compile=qa(h.link));h.priority=h.priority||0;h.index=g;h.name=h.name||a;h.require=h.require||h.controller&&h.name;h.restrict=h.restrict||"EA";var k=h,l=h,r=h.name,n={isolateScope:null,bindToController:null};C(l.scope)&&(!0===l.bindToController?(n.bindToController=c(l.scope,r,!0),n.isolateScope={}):n.isolateScope=c(l.scope,r,!1));C(l.bindToController)&&(n.bindToController=c(l.bindToController,r,!0));if(C(n.bindToController)){var S=l.controller,E=l.controllerAs;if(!S)throw ga("noctrl",
r);var ca;a:if(E&&G(E))ca=E;else{if(G(S)){var m=Vc.exec(S);if(m){ca=m[3];break a}}ca=void 0}if(!ca)throw ga("noident",r);}var s=k.$$bindings=n;C(s.isolateScope)&&(h.$$isolateBindings=s.isolateScope);h.$$moduleName=e.$$moduleName;f.push(h)}catch(w){d(w)}});return f}])),e[a].push(f)):m(a,oc(r));return this};this.aHrefSanitizationWhitelist=function(b){return A(b)?(a.aHrefSanitizationWhitelist(b),this):a.aHrefSanitizationWhitelist()};this.imgSrcSanitizationWhitelist=function(b){return A(b)?(a.imgSrcSanitizationWhitelist(b),
this):a.imgSrcSanitizationWhitelist()};var n=!0;this.debugInfoEnabled=function(a){return A(a)?(n=a,this):n};this.$get=["$injector","$interpolate","$exceptionHandler","$templateRequest","$parse","$controller","$rootScope","$document","$sce","$animate","$$sanitizeUri",function(a,b,c,d,u,q,z,N,ia,O,H){function L(a,b){try{a.addClass(b)}catch(c){}}function W(a,b,c,d,e){a instanceof B||(a=B(a));m(a,function(b,c){b.nodeType==Pa&&b.nodeValue.match(/\S+/)&&(a[c]=B(b).wrap("<span></span>").parent()[0])});var f=
S(a,b,a,c,d,e);W.$$addScopeClass(a);var g=null;return function(b,c,d){qb(b,"scope");d=d||{};var e=d.parentBoundTranscludeFn,h=d.transcludeControllers;d=d.futureParentElement;e&&e.$$boundTransclude&&(e=e.$$boundTransclude);g||(g=(d=d&&d[0])?"foreignobject"!==wa(d)&&d.toString().match(/SVG/)?"svg":"html":"html");d="html"!==g?B(Xb(g,B("<div>").append(a).html())):c?Ra.clone.call(a):a;if(h)for(var k in h)d.data("$"+k+"Controller",h[k].instance);W.$$addScopeInfo(d,b);c&&c(d,b);f&&f(b,d,d,e);return d}}function S(a,
b,c,d,e,f){function g(a,c,d,e){var f,k,l,r,n,t,O;if(q)for(O=Array(c.length),r=0;r<h.length;r+=3)f=h[r],O[f]=c[f];else O=c;r=0;for(n=h.length;r<n;)if(k=O[h[r++]],c=h[r++],f=h[r++],c){if(c.scope){if(l=a.$new(),W.$$addScopeInfo(B(k),l),t=c.$$destroyBindings)c.$$destroyBindings=null,l.$on("$destroyed",t)}else l=a;t=c.transcludeOnThisElement?ba(a,c.transclude,e):!c.templateOnThisElement&&e?e:!e&&b?ba(a,b):null;c(f,l,k,d,t,c)}else f&&f(a,k.childNodes,w,e)}for(var h=[],k,l,r,n,q,t=0;t<a.length;t++){k=new Z;
l=ca(a[t],[],k,0===t?d:w,e);(f=l.length?D(l,a[t],k,b,c,null,[],[],f):null)&&f.scope&&W.$$addScopeClass(k.$$element);k=f&&f.terminal||!(r=a[t].childNodes)||!r.length?null:S(r,f?(f.transcludeOnThisElement||!f.templateOnThisElement)&&f.transclude:b);if(f||k)h.push(t,f,k),n=!0,q=q||f;f=null}return n?g:null}function ba(a,b,c){return function(d,e,f,g,h){d||(d=a.$new(!1,h),d.$$transcluded=!0);return b(d,e,{parentBoundTranscludeFn:c,transcludeControllers:f,futureParentElement:g})}}function ca(a,b,c,d,e){var g=
c.$attr,k;switch(a.nodeType){case pa:na(b,ya(wa(a)),"E",d,e);for(var l,r,n,q=a.attributes,t=0,O=q&&q.length;t<O;t++){var K=!1,H=!1;l=q[t];k=l.name;r=T(l.value);l=ya(k);if(n=ja.test(l))k=k.replace(Wc,"").substr(8).replace(/_(.)/g,function(a,b){return b.toUpperCase()});var S=l.replace(/(Start|End)$/,"");I(S)&&l===S+"Start"&&(K=k,H=k.substr(0,k.length-5)+"end",k=k.substr(0,k.length-6));l=ya(k.toLowerCase());g[l]=k;if(n||!c.hasOwnProperty(l))c[l]=r,Rc(a,l)&&(c[l]=!0);V(a,b,r,l,n);na(b,l,"A",d,e,K,H)}a=
a.className;C(a)&&(a=a.animVal);if(G(a)&&""!==a)for(;k=h.exec(a);)l=ya(k[2]),na(b,l,"C",d,e)&&(c[l]=T(k[3])),a=a.substr(k.index+k[0].length);break;case Pa:if(11===Wa)for(;a.parentNode&&a.nextSibling&&a.nextSibling.nodeType===Pa;)a.nodeValue+=a.nextSibling.nodeValue,a.parentNode.removeChild(a.nextSibling);Ka(b,a.nodeValue);break;case 8:try{if(k=f.exec(a.nodeValue))l=ya(k[1]),na(b,l,"M",d,e)&&(c[l]=T(k[2]))}catch(E){}}b.sort(M);return b}function za(a,b,c){var d=[],e=0;if(b&&a.hasAttribute&&a.hasAttribute(b)){do{if(!a)throw ga("uterdir",
b,c);a.nodeType==pa&&(a.hasAttribute(b)&&e++,a.hasAttribute(c)&&e--);d.push(a);a=a.nextSibling}while(0<e)}else d.push(a);return B(d)}function s(a,b,c){return function(d,e,f,g,h){e=za(e[0],b,c);return a(d,e,f,g,h)}}function D(a,b,d,e,f,g,h,k,r){function n(a,b,c,d){if(a){c&&(a=s(a,c,d));a.require=D.require;a.directiveName=y;if(u===D||D.$$isolateScope)a=$(a,{isolateScope:!0});h.push(a)}if(b){c&&(b=s(b,c,d));b.require=D.require;b.directiveName=y;if(u===D||D.$$isolateScope)b=$(b,{isolateScope:!0});k.push(b)}}
function t(a,b,c,d){var e;if(G(b)){var f=b.match(l);b=b.substring(f[0].length);var g=f[1]||f[3],f="?"===f[2];"^^"===g?c=c.parent():e=(e=d&&d[b])&&e.instance;e||(d="$"+b+"Controller",e=g?c.inheritedData(d):c.data(d));if(!e&&!f)throw ga("ctreq",b,a);}else if(J(b))for(e=[],g=0,f=b.length;g<f;g++)e[g]=t(a,b[g],c,d);return e||null}function O(a,b,c,d,e,f){var g=fa(),h;for(h in d){var k=d[h],l={$scope:k===u||k.$$isolateScope?e:f,$element:a,$attrs:b,$transclude:c},r=k.controller;"@"==r&&(r=b[k.name]);l=q(r,
l,!0,k.controllerAs);g[k.name]=l;ia||a.data("$"+k.name+"Controller",l.instance)}return g}function K(a,c,e,f,g,l){function r(a,b,c){var d;ab(a)||(c=b,b=a,a=w);ia&&(d=ca);c||(c=ia?N.parent():N);return g(a,b,d,c,za)}var n,q,H,E,ca,z,N;b===e?(f=d,N=d.$$element):(N=B(e),f=new Z(N,d));u&&(E=c.$new(!0));g&&(z=r,z.$$boundTransclude=g);ba&&(ca=O(N,f,z,ba,E,c));u&&(W.$$addScopeInfo(N,E,!0,!(L&&(L===u||L===u.$$originalDirective))),W.$$addScopeClass(N,!0),E.$$isolateBindings=u.$$isolateBindings,Y(c,f,E,E.$$isolateBindings,
u,E));if(ca){var Va=u||S,m;Va&&ca[Va.name]&&(q=Va.$$bindings.bindToController,(H=ca[Va.name])&&H.identifier&&q&&(m=H,l.$$destroyBindings=Y(c,f,H.instance,q,Va)));for(n in ca){H=ca[n];var D=H();D!==H.instance&&(H.instance=D,N.data("$"+n+"Controller",D),H===m&&(l.$$destroyBindings(),l.$$destroyBindings=Y(c,f,D,q,Va)))}}n=0;for(l=h.length;n<l;n++)q=h[n],aa(q,q.isolateScope?E:c,N,f,q.require&&t(q.directiveName,q.require,N,ca),z);var za=c;u&&(u.template||null===u.templateUrl)&&(za=E);a&&a(za,e.childNodes,
w,g);for(n=k.length-1;0<=n;n--)q=k[n],aa(q,q.isolateScope?E:c,N,f,q.require&&t(q.directiveName,q.require,N,ca),z)}r=r||{};for(var H=-Number.MAX_VALUE,S=r.newScopeDirective,ba=r.controllerDirectives,u=r.newIsolateScopeDirective,L=r.templateDirective,z=r.nonTlbTranscludeDirective,N=!1,m=!1,ia=r.hasElementTranscludeDirective,v=d.$$element=B(b),D,y,M,Ka=e,na,I=0,F=a.length;I<F;I++){D=a[I];var P=D.$$start,R=D.$$end;P&&(v=za(b,P,R));M=w;if(H>D.priority)break;if(M=D.scope)D.templateUrl||(C(M)?(Q("new/isolated scope",
u||S,D,v),u=D):Q("new/isolated scope",u,D,v)),S=S||D;y=D.name;!D.templateUrl&&D.controller&&(M=D.controller,ba=ba||fa(),Q("'"+y+"' controller",ba[y],D,v),ba[y]=D);if(M=D.transclude)N=!0,D.$$tlb||(Q("transclusion",z,D,v),z=D),"element"==M?(ia=!0,H=D.priority,M=v,v=d.$$element=B(X.createComment(" "+y+": "+d[y]+" ")),b=v[0],U(f,ua.call(M,0),b),Ka=W(M,e,H,g&&g.name,{nonTlbTranscludeDirective:z})):(M=B(Ub(b)).contents(),v.empty(),Ka=W(M,e));if(D.template)if(m=!0,Q("template",L,D,v),L=D,M=x(D.template)?
D.template(v,d):D.template,M=ha(M),D.replace){g=D;M=Sb.test(M)?Xc(Xb(D.templateNamespace,T(M))):[];b=M[0];if(1!=M.length||b.nodeType!==pa)throw ga("tplrt",y,"");U(f,v,b);F={$attr:{}};M=ca(b,[],F);var Lf=a.splice(I+1,a.length-(I+1));u&&A(M);a=a.concat(M).concat(Lf);Yc(d,F);F=a.length}else v.html(M);if(D.templateUrl)m=!0,Q("template",L,D,v),L=D,D.replace&&(g=D),K=Mf(a.splice(I,a.length-I),v,d,f,N&&Ka,h,k,{controllerDirectives:ba,newScopeDirective:S!==D&&S,newIsolateScopeDirective:u,templateDirective:L,
nonTlbTranscludeDirective:z}),F=a.length;else if(D.compile)try{na=D.compile(v,d,Ka),x(na)?n(null,na,P,R):na&&n(na.pre,na.post,P,R)}catch(V){c(V,xa(v))}D.terminal&&(K.terminal=!0,H=Math.max(H,D.priority))}K.scope=S&&!0===S.scope;K.transcludeOnThisElement=N;K.templateOnThisElement=m;K.transclude=Ka;r.hasElementTranscludeDirective=ia;return K}function A(a){for(var b=0,c=a.length;b<c;b++)a[b]=Nb(a[b],{$$isolateScope:!0})}function na(b,d,f,g,h,k,l){if(d===h)return null;h=null;if(e.hasOwnProperty(d)){var n;
d=a.get(d+"Directive");for(var q=0,t=d.length;q<t;q++)try{n=d[q],(v(g)||g>n.priority)&&-1!=n.restrict.indexOf(f)&&(k&&(n=Nb(n,{$$start:k,$$end:l})),b.push(n),h=n)}catch(H){c(H)}}return h}function I(b){if(e.hasOwnProperty(b))for(var c=a.get(b+"Directive"),d=0,f=c.length;d<f;d++)if(b=c[d],b.multiElement)return!0;return!1}function Yc(a,b){var c=b.$attr,d=a.$attr,e=a.$$element;m(a,function(d,e){"$"!=e.charAt(0)&&(b[e]&&b[e]!==d&&(d+=("style"===e?";":" ")+b[e]),a.$set(e,d,!0,c[e]))});m(b,function(b,f){"class"==
f?(L(e,b),a["class"]=(a["class"]?a["class"]+" ":"")+b):"style"==f?(e.attr("style",e.attr("style")+";"+b),a.style=(a.style?a.style+";":"")+b):"$"==f.charAt(0)||a.hasOwnProperty(f)||(a[f]=b,d[f]=c[f])})}function Mf(a,b,c,e,f,g,h,k){var l=[],r,n,q=b[0],t=a.shift(),H=Nb(t,{templateUrl:null,transclude:null,replace:null,$$originalDirective:t}),O=x(t.templateUrl)?t.templateUrl(b,c):t.templateUrl,E=t.templateNamespace;b.empty();d(O).then(function(d){var K,u;d=ha(d);if(t.replace){d=Sb.test(d)?Xc(Xb(E,T(d))):
[];K=d[0];if(1!=d.length||K.nodeType!==pa)throw ga("tplrt",t.name,O);d={$attr:{}};U(e,b,K);var z=ca(K,[],d);C(t.scope)&&A(z);a=z.concat(a);Yc(c,d)}else K=q,b.html(d);a.unshift(H);r=D(a,K,c,f,b,t,g,h,k);m(e,function(a,c){a==K&&(e[c]=b[0])});for(n=S(b[0].childNodes,f);l.length;){d=l.shift();u=l.shift();var N=l.shift(),W=l.shift(),z=b[0];if(!d.$$destroyed){if(u!==q){var za=u.className;k.hasElementTranscludeDirective&&t.replace||(z=Ub(K));U(N,B(u),z);L(B(z),za)}u=r.transcludeOnThisElement?ba(d,r.transclude,
W):W;r(n,d,z,e,u,r)}}l=null});return function(a,b,c,d,e){a=e;b.$$destroyed||(l?l.push(b,c,d,a):(r.transcludeOnThisElement&&(a=ba(b,r.transclude,e)),r(n,b,c,d,a,r)))}}function M(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function Q(a,b,c,d){function e(a){return a?" (module: "+a+")":""}if(b)throw ga("multidir",b.name,e(b.$$moduleName),c.name,e(c.$$moduleName),a,xa(d));}function Ka(a,c){var d=b(c,!0);d&&a.push({priority:0,compile:function(a){a=
a.parent();var b=!!a.length;b&&W.$$addBindingClass(a);return function(a,c){var e=c.parent();b||W.$$addBindingClass(e);W.$$addBindingInfo(e,d.expressions);a.$watch(d,function(a){c[0].nodeValue=a})}}})}function Xb(a,b){a=F(a||"html");switch(a){case "svg":case "math":var c=X.createElement("div");c.innerHTML="<"+a+">"+b+"</"+a+">";return c.childNodes[0].childNodes;default:return b}}function R(a,b){if("srcdoc"==b)return ia.HTML;var c=wa(a);if("xlinkHref"==b||"form"==c&&"action"==b||"img"!=c&&("src"==b||
"ngSrc"==b))return ia.RESOURCE_URL}function V(a,c,d,e,f){var h=R(a,e);f=g[e]||f;var l=b(d,!0,h,f);if(l){if("multiple"===e&&"select"===wa(a))throw ga("selmulti",xa(a));c.push({priority:100,compile:function(){return{pre:function(a,c,g){c=g.$$observers||(g.$$observers=fa());if(k.test(e))throw ga("nodomevents");var r=g[e];r!==d&&(l=r&&b(r,!0,h,f),d=r);l&&(g[e]=l(a),(c[e]||(c[e]=[])).$$inter=!0,(g.$$observers&&g.$$observers[e].$$scope||a).$watch(l,function(a,b){"class"===e&&a!=b?g.$updateClass(a,b):g.$set(e,
a)}))}}}})}}function U(a,b,c){var d=b[0],e=b.length,f=d.parentNode,g,h;if(a)for(g=0,h=a.length;g<h;g++)if(a[g]==d){a[g++]=c;h=g+e-1;for(var k=a.length;g<k;g++,h++)h<k?a[g]=a[h]:delete a[g];a.length-=e-1;a.context===d&&(a.context=c);break}f&&f.replaceChild(c,d);a=X.createDocumentFragment();a.appendChild(d);B.hasData(d)&&(B(c).data(B(d).data()),ra?(Qb=!0,ra.cleanData([d])):delete B.cache[d[B.expando]]);d=1;for(e=b.length;d<e;d++)f=b[d],B(f).remove(),a.appendChild(f),delete b[d];b[0]=c;b.length=1}function $(a,
b){return P(function(){return a.apply(null,arguments)},a,b)}function aa(a,b,d,e,f,g){try{a(b,d,e,f,g)}catch(h){c(h,xa(d))}}function Y(a,c,d,e,f,g){var h;m(e,function(e,g){var k=e.attrName,l=e.optional,r,n,q,K;switch(e.mode){case "@":l||ta.call(c,k)||(d[g]=c[k]=void 0);c.$observe(k,function(a){G(a)&&(d[g]=a)});c.$$observers[k].$$scope=a;G(c[k])&&(d[g]=b(c[k])(a));break;case "=":if(!ta.call(c,k)){if(l)break;c[k]=void 0}if(l&&!c[k])break;n=u(c[k]);K=n.literal?ka:function(a,b){return a===b||a!==a&&b!==
b};q=n.assign||function(){r=d[g]=n(a);throw ga("nonassign",c[k],f.name);};r=d[g]=n(a);l=function(b){K(b,d[g])||(K(b,r)?q(a,b=d[g]):d[g]=b);return r=b};l.$stateful=!0;l=e.collection?a.$watchCollection(c[k],l):a.$watch(u(c[k],l),null,n.literal);h=h||[];h.push(l);break;case "&":n=c.hasOwnProperty(k)?u(c[k]):y;if(n===y&&l)break;d[g]=function(b){return n(a,b)}}});e=h?function(){for(var a=0,b=h.length;a<b;++a)h[a]()}:y;return g&&e!==y?(g.$on("$destroy",e),y):e}var Z=function(a,b){if(b){var c=Object.keys(b),
d,e,f;d=0;for(e=c.length;d<e;d++)f=c[d],this[f]=b[f]}else this.$attr={};this.$$element=a};Z.prototype={$normalize:ya,$addClass:function(a){a&&0<a.length&&O.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&O.removeClass(this.$$element,a)},$updateClass:function(a,b){var c=Zc(a,b);c&&c.length&&O.addClass(this.$$element,c);(c=Zc(b,a))&&c.length&&O.removeClass(this.$$element,c)},$set:function(a,b,d,e){var f=Rc(this.$$element[0],a),g=$c[a],h=a;f?(this.$$element.prop(a,b),e=f):g&&(this[g]=
b,h=g);this[a]=b;e?this.$attr[a]=e:(e=this.$attr[a])||(this.$attr[a]=e=Ac(a,"-"));f=wa(this.$$element);if("a"===f&&"href"===a||"img"===f&&"src"===a)this[a]=b=H(b,"src"===a);else if("img"===f&&"srcset"===a){for(var f="",g=T(b),k=/(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/,k=/\s/.test(g)?k:/(,)/,g=g.split(k),k=Math.floor(g.length/2),l=0;l<k;l++)var r=2*l,f=f+H(T(g[r]),!0),f=f+(" "+T(g[r+1]));g=T(g[2*l]).split(/\s/);f+=H(T(g[0]),!0);2===g.length&&(f+=" "+T(g[1]));this[a]=b=f}!1!==d&&(null===b||v(b)?this.$$element.removeAttr(e):
this.$$element.attr(e,b));(a=this.$$observers)&&m(a[h],function(a){try{a(b)}catch(d){c(d)}})},$observe:function(a,b){var c=this,d=c.$$observers||(c.$$observers=fa()),e=d[a]||(d[a]=[]);e.push(b);z.$evalAsync(function(){e.$$inter||!c.hasOwnProperty(a)||v(c[a])||b(c[a])});return function(){cb(e,b)}}};var da=b.startSymbol(),ea=b.endSymbol(),ha="{{"==da||"}}"==ea?$a:function(a){return a.replace(/\{\{/g,da).replace(/}}/g,ea)},ja=/^ngAttr[A-Z]/;W.$$addBindingInfo=n?function(a,b){var c=a.data("$binding")||
[];J(b)?c=c.concat(b):c.push(b);a.data("$binding",c)}:y;W.$$addBindingClass=n?function(a){L(a,"ng-binding")}:y;W.$$addScopeInfo=n?function(a,b,c,d){a.data(c?d?"$isolateScopeNoTemplate":"$isolateScope":"$scope",b)}:y;W.$$addScopeClass=n?function(a,b){L(a,b?"ng-isolate-scope":"ng-scope")}:y;return W}]}function ya(b){return gb(b.replace(Wc,""))}function Zc(b,a){var c="",d=b.split(/\s+/),e=a.split(/\s+/),f=0;a:for(;f<d.length;f++){for(var h=d[f],g=0;g<e.length;g++)if(h==e[g])continue a;c+=(0<c.length?
" ":"")+h}return c}function Xc(b){b=B(b);var a=b.length;if(1>=a)return b;for(;a--;)8===b[a].nodeType&&Nf.call(b,a,1);return b}function Xe(){var b={},a=!1;this.register=function(a,d){Ta(a,"controller");C(a)?P(b,a):b[a]=d};this.allowGlobals=function(){a=!0};this.$get=["$injector","$window",function(c,d){function e(a,b,c,d){if(!a||!C(a.$scope))throw I("$controller")("noscp",d,b);a.$scope[b]=c}return function(f,h,g,l){var k,n,p;g=!0===g;l&&G(l)&&(p=l);if(G(f)){l=f.match(Vc);if(!l)throw Of("ctrlfmt",f);
n=l[1];p=p||l[3];f=b.hasOwnProperty(n)?b[n]:Cc(h.$scope,n,!0)||(a?Cc(d,n,!0):w);Sa(f,n,!0)}if(g)return g=(J(f)?f[f.length-1]:f).prototype,k=Object.create(g||null),p&&e(h,p,k,n||f.name),P(function(){var a=c.invoke(f,k,h,n);a!==k&&(C(a)||x(a))&&(k=a,p&&e(h,p,k,n||f.name));return k},{instance:k,identifier:p});k=c.instantiate(f,h,n);p&&e(h,p,k,n||f.name);return k}}]}function Ye(){this.$get=["$window",function(b){return B(b.document)}]}function Ze(){this.$get=["$log",function(b){return function(a,c){b.error.apply(b,
arguments)}}]}function Yb(b){return C(b)?ea(b)?b.toISOString():eb(b):b}function df(){this.$get=function(){return function(b){if(!b)return"";var a=[];nc(b,function(b,d){null===b||v(b)||(J(b)?m(b,function(b,c){a.push(la(d)+"="+la(Yb(b)))}):a.push(la(d)+"="+la(Yb(b))))});return a.join("&")}}}function ef(){this.$get=function(){return function(b){function a(b,e,f){null===b||v(b)||(J(b)?m(b,function(b,c){a(b,e+"["+(C(b)?c:"")+"]")}):C(b)&&!ea(b)?nc(b,function(b,c){a(b,e+(f?"":"[")+c+(f?"":"]"))}):c.push(la(e)+
"="+la(Yb(b))))}if(!b)return"";var c=[];a(b,"",!0);return c.join("&")}}}function Zb(b,a){if(G(b)){var c=b.replace(Pf,"").trim();if(c){var d=a("Content-Type");(d=d&&0===d.indexOf(ad))||(d=(d=c.match(Qf))&&Rf[d[0]].test(c));d&&(b=vc(c))}}return b}function bd(b){var a=fa(),c;G(b)?m(b.split("\n"),function(b){c=b.indexOf(":");var e=F(T(b.substr(0,c)));b=T(b.substr(c+1));e&&(a[e]=a[e]?a[e]+", "+b:b)}):C(b)&&m(b,function(b,c){var f=F(c),h=T(b);f&&(a[f]=a[f]?a[f]+", "+h:h)});return a}function cd(b){var a;
return function(c){a||(a=bd(b));return c?(c=a[F(c)],void 0===c&&(c=null),c):a}}function dd(b,a,c,d){if(x(d))return d(b,a,c);m(d,function(d){b=d(b,a,c)});return b}function cf(){var b=this.defaults={transformResponse:[Zb],transformRequest:[function(a){return C(a)&&"[object File]"!==va.call(a)&&"[object Blob]"!==va.call(a)&&"[object FormData]"!==va.call(a)?eb(a):a}],headers:{common:{Accept:"application/json, text/plain, */*"},post:ja($b),put:ja($b),patch:ja($b)},xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",
paramSerializer:"$httpParamSerializer"},a=!1;this.useApplyAsync=function(b){return A(b)?(a=!!b,this):a};var c=!0;this.useLegacyPromiseExtensions=function(a){return A(a)?(c=!!a,this):c};var d=this.interceptors=[];this.$get=["$httpBackend","$$cookieReader","$cacheFactory","$rootScope","$q","$injector",function(e,f,h,g,l,k){function n(a){function d(a){var b=P({},a);b.data=a.data?dd(a.data,a.headers,a.status,f.transformResponse):a.data;a=a.status;return 200<=a&&300>a?b:l.reject(b)}function e(a,b){var c,
d={};m(a,function(a,e){x(a)?(c=a(b),null!=c&&(d[e]=c)):d[e]=a});return d}if(!da.isObject(a))throw I("$http")("badreq",a);var f=P({method:"get",transformRequest:b.transformRequest,transformResponse:b.transformResponse,paramSerializer:b.paramSerializer},a);f.headers=function(a){var c=b.headers,d=P({},a.headers),f,g,h,c=P({},c.common,c[F(a.method)]);a:for(f in c){g=F(f);for(h in d)if(F(h)===g)continue a;d[f]=c[f]}return e(d,ja(a))}(a);f.method=sb(f.method);f.paramSerializer=G(f.paramSerializer)?k.get(f.paramSerializer):
f.paramSerializer;var g=[function(a){var c=a.headers,e=dd(a.data,cd(c),w,a.transformRequest);v(e)&&m(c,function(a,b){"content-type"===F(b)&&delete c[b]});v(a.withCredentials)&&!v(b.withCredentials)&&(a.withCredentials=b.withCredentials);return p(a,e).then(d,d)},w],h=l.when(f);for(m(E,function(a){(a.request||a.requestError)&&g.unshift(a.request,a.requestError);(a.response||a.responseError)&&g.push(a.response,a.responseError)});g.length;){a=g.shift();var r=g.shift(),h=h.then(a,r)}c?(h.success=function(a){Sa(a,
"fn");h.then(function(b){a(b.data,b.status,b.headers,f)});return h},h.error=function(a){Sa(a,"fn");h.then(null,function(b){a(b.data,b.status,b.headers,f)});return h}):(h.success=ed("success"),h.error=ed("error"));return h}function p(c,d){function h(b,c,d,e){function f(){k(c,b,d,e)}L&&(200<=b&&300>b?L.put(ba,[b,c,bd(d),e]):L.remove(ba));a?g.$applyAsync(f):(f(),g.$$phase||g.$apply())}function k(a,b,d,e){b=-1<=b?b:0;(200<=b&&300>b?O.resolve:O.reject)({data:a,status:b,headers:cd(d),config:c,statusText:e})}
function p(a){k(a.data,a.status,ja(a.headers()),a.statusText)}function E(){var a=n.pendingRequests.indexOf(c);-1!==a&&n.pendingRequests.splice(a,1)}var O=l.defer(),H=O.promise,L,m,S=c.headers,ba=r(c.url,c.paramSerializer(c.params));n.pendingRequests.push(c);H.then(E,E);!c.cache&&!b.cache||!1===c.cache||"GET"!==c.method&&"JSONP"!==c.method||(L=C(c.cache)?c.cache:C(b.cache)?b.cache:t);L&&(m=L.get(ba),A(m)?m&&x(m.then)?m.then(p,p):J(m)?k(m[1],m[0],ja(m[2]),m[3]):k(m,200,{},"OK"):L.put(ba,H));v(m)&&((m=
fd(c.url)?f()[c.xsrfCookieName||b.xsrfCookieName]:w)&&(S[c.xsrfHeaderName||b.xsrfHeaderName]=m),e(c.method,ba,d,h,S,c.timeout,c.withCredentials,c.responseType));return H}function r(a,b){0<b.length&&(a+=(-1==a.indexOf("?")?"?":"&")+b);return a}var t=h("$http");b.paramSerializer=G(b.paramSerializer)?k.get(b.paramSerializer):b.paramSerializer;var E=[];m(d,function(a){E.unshift(G(a)?k.get(a):k.invoke(a))});n.pendingRequests=[];(function(a){m(arguments,function(a){n[a]=function(b,c){return n(P({},c||{},
{method:a,url:b}))}})})("get","delete","head","jsonp");(function(a){m(arguments,function(a){n[a]=function(b,c,d){return n(P({},d||{},{method:a,url:b,data:c}))}})})("post","put","patch");n.defaults=b;return n}]}function gf(){this.$get=function(){return function(){return new Q.XMLHttpRequest}}}function ff(){this.$get=["$browser","$window","$document","$xhrFactory",function(b,a,c,d){return Sf(b,d,b.defer,a.angular.callbacks,c[0])}]}function Sf(b,a,c,d,e){function f(a,b,c){var f=e.createElement("script"),
n=null;f.type="text/javascript";f.src=a;f.async=!0;n=function(a){f.removeEventListener("load",n,!1);f.removeEventListener("error",n,!1);e.body.removeChild(f);f=null;var h=-1,t="unknown";a&&("load"!==a.type||d[b].called||(a={type:"error"}),t=a.type,h="error"===a.type?404:200);c&&c(h,t)};f.addEventListener("load",n,!1);f.addEventListener("error",n,!1);e.body.appendChild(f);return n}return function(e,g,l,k,n,p,r,t){function E(){q&&q();z&&z.abort()}function K(a,d,e,f,g){A(s)&&c.cancel(s);q=z=null;a(d,
e,f,g);b.$$completeOutstandingRequest(y)}b.$$incOutstandingRequestCount();g=g||b.url();if("jsonp"==F(e)){var u="_"+(d.counter++).toString(36);d[u]=function(a){d[u].data=a;d[u].called=!0};var q=f(g.replace("JSON_CALLBACK","angular.callbacks."+u),u,function(a,b){K(k,a,d[u].data,"",b);d[u]=y})}else{var z=a(e,g);z.open(e,g,!0);m(n,function(a,b){A(a)&&z.setRequestHeader(b,a)});z.onload=function(){var a=z.statusText||"",b="response"in z?z.response:z.responseText,c=1223===z.status?204:z.status;0===c&&(c=
b?200:"file"==Aa(g).protocol?404:0);K(k,c,b,z.getAllResponseHeaders(),a)};e=function(){K(k,-1,null,null,"")};z.onerror=e;z.onabort=e;r&&(z.withCredentials=!0);if(t)try{z.responseType=t}catch(N){if("json"!==t)throw N;}z.send(v(l)?null:l)}if(0<p)var s=c(E,p);else p&&x(p.then)&&p.then(E)}}function af(){var b="{{",a="}}";this.startSymbol=function(a){return a?(b=a,this):b};this.endSymbol=function(b){return b?(a=b,this):a};this.$get=["$parse","$exceptionHandler","$sce",function(c,d,e){function f(a){return"\\\\\\"+
a}function h(c){return c.replace(n,b).replace(p,a)}function g(f,g,n,p){function u(a){try{var b=a;a=n?e.getTrusted(n,b):e.valueOf(b);var c;if(p&&!A(a))c=a;else if(null==a)c="";else{switch(typeof a){case "string":break;case "number":a=""+a;break;default:a=eb(a)}c=a}return c}catch(g){d(La.interr(f,g))}}p=!!p;for(var q,m,N=0,s=[],O=[],H=f.length,L=[],W=[];N<H;)if(-1!=(q=f.indexOf(b,N))&&-1!=(m=f.indexOf(a,q+l)))N!==q&&L.push(h(f.substring(N,q))),N=f.substring(q+l,m),s.push(N),O.push(c(N,u)),N=m+k,W.push(L.length),
L.push("");else{N!==H&&L.push(h(f.substring(N)));break}n&&1<L.length&&La.throwNoconcat(f);if(!g||s.length){var S=function(a){for(var b=0,c=s.length;b<c;b++){if(p&&v(a[b]))return;L[W[b]]=a[b]}return L.join("")};return P(function(a){var b=0,c=s.length,e=Array(c);try{for(;b<c;b++)e[b]=O[b](a);return S(e)}catch(g){d(La.interr(f,g))}},{exp:f,expressions:s,$$watchDelegate:function(a,b){var c;return a.$watchGroup(O,function(d,e){var f=S(d);x(b)&&b.call(this,f,d!==e?c:f,a);c=f})}})}}var l=b.length,k=a.length,
n=new RegExp(b.replace(/./g,f),"g"),p=new RegExp(a.replace(/./g,f),"g");g.startSymbol=function(){return b};g.endSymbol=function(){return a};return g}]}function bf(){this.$get=["$rootScope","$window","$q","$$q",function(b,a,c,d){function e(e,g,l,k){var n=4<arguments.length,p=n?ua.call(arguments,4):[],r=a.setInterval,t=a.clearInterval,E=0,K=A(k)&&!k,u=(K?d:c).defer(),q=u.promise;l=A(l)?l:0;q.then(null,null,n?function(){e.apply(null,p)}:e);q.$$intervalId=r(function(){u.notify(E++);0<l&&E>=l&&(u.resolve(E),
t(q.$$intervalId),delete f[q.$$intervalId]);K||b.$apply()},g);f[q.$$intervalId]=u;return q}var f={};e.cancel=function(b){return b&&b.$$intervalId in f?(f[b.$$intervalId].reject("canceled"),a.clearInterval(b.$$intervalId),delete f[b.$$intervalId],!0):!1};return e}]}function ac(b){b=b.split("/");for(var a=b.length;a--;)b[a]=ob(b[a]);return b.join("/")}function gd(b,a){var c=Aa(b);a.$$protocol=c.protocol;a.$$host=c.hostname;a.$$port=Y(c.port)||Tf[c.protocol]||null}function hd(b,a){var c="/"!==b.charAt(0);
c&&(b="/"+b);var d=Aa(b);a.$$path=decodeURIComponent(c&&"/"===d.pathname.charAt(0)?d.pathname.substring(1):d.pathname);a.$$search=yc(d.search);a.$$hash=decodeURIComponent(d.hash);a.$$path&&"/"!=a.$$path.charAt(0)&&(a.$$path="/"+a.$$path)}function sa(b,a){if(0===a.indexOf(b))return a.substr(b.length)}function Ja(b){var a=b.indexOf("#");return-1==a?b:b.substr(0,a)}function Cb(b){return b.replace(/(#.+)|#$/,"$1")}function bc(b,a,c){this.$$html5=!0;c=c||"";gd(b,this);this.$$parse=function(b){var c=sa(a,
b);if(!G(c))throw Db("ipthprfx",b,a);hd(c,this);this.$$path||(this.$$path="/");this.$$compose()};this.$$compose=function(){var b=Pb(this.$$search),c=this.$$hash?"#"+ob(this.$$hash):"";this.$$url=ac(this.$$path)+(b?"?"+b:"")+c;this.$$absUrl=a+this.$$url.substr(1)};this.$$parseLinkUrl=function(d,e){if(e&&"#"===e[0])return this.hash(e.slice(1)),!0;var f,h;A(f=sa(b,d))?(h=f,h=A(f=sa(c,f))?a+(sa("/",f)||f):b+h):A(f=sa(a,d))?h=a+f:a==d+"/"&&(h=a);h&&this.$$parse(h);return!!h}}function cc(b,a,c){gd(b,this);
this.$$parse=function(d){var e=sa(b,d)||sa(a,d),f;v(e)||"#"!==e.charAt(0)?this.$$html5?f=e:(f="",v(e)&&(b=d,this.replace())):(f=sa(c,e),v(f)&&(f=e));hd(f,this);d=this.$$path;var e=b,h=/^\/[A-Z]:(\/.*)/;0===f.indexOf(e)&&(f=f.replace(e,""));h.exec(f)||(d=(f=h.exec(d))?f[1]:d);this.$$path=d;this.$$compose()};this.$$compose=function(){var a=Pb(this.$$search),e=this.$$hash?"#"+ob(this.$$hash):"";this.$$url=ac(this.$$path)+(a?"?"+a:"")+e;this.$$absUrl=b+(this.$$url?c+this.$$url:"")};this.$$parseLinkUrl=
function(a,c){return Ja(b)==Ja(a)?(this.$$parse(a),!0):!1}}function id(b,a,c){this.$$html5=!0;cc.apply(this,arguments);this.$$parseLinkUrl=function(d,e){if(e&&"#"===e[0])return this.hash(e.slice(1)),!0;var f,h;b==Ja(d)?f=d:(h=sa(a,d))?f=b+c+h:a===d+"/"&&(f=a);f&&this.$$parse(f);return!!f};this.$$compose=function(){var a=Pb(this.$$search),e=this.$$hash?"#"+ob(this.$$hash):"";this.$$url=ac(this.$$path)+(a?"?"+a:"")+e;this.$$absUrl=b+c+this.$$url}}function Eb(b){return function(){return this[b]}}function jd(b,
a){return function(c){if(v(c))return this[b];this[b]=a(c);this.$$compose();return this}}function hf(){var b="",a={enabled:!1,requireBase:!0,rewriteLinks:!0};this.hashPrefix=function(a){return A(a)?(b=a,this):b};this.html5Mode=function(b){return bb(b)?(a.enabled=b,this):C(b)?(bb(b.enabled)&&(a.enabled=b.enabled),bb(b.requireBase)&&(a.requireBase=b.requireBase),bb(b.rewriteLinks)&&(a.rewriteLinks=b.rewriteLinks),this):a};this.$get=["$rootScope","$browser","$sniffer","$rootElement","$window",function(c,
d,e,f,h){function g(a,b,c){var e=k.url(),f=k.$$state;try{d.url(a,b,c),k.$$state=d.state()}catch(g){throw k.url(e),k.$$state=f,g;}}function l(a,b){c.$broadcast("$locationChangeSuccess",k.absUrl(),a,k.$$state,b)}var k,n;n=d.baseHref();var p=d.url(),r;if(a.enabled){if(!n&&a.requireBase)throw Db("nobase");r=p.substring(0,p.indexOf("/",p.indexOf("//")+2))+(n||"/");n=e.history?bc:id}else r=Ja(p),n=cc;var t=r.substr(0,Ja(r).lastIndexOf("/")+1);k=new n(r,t,"#"+b);k.$$parseLinkUrl(p,p);k.$$state=d.state();
var E=/^\s*(javascript|mailto):/i;f.on("click",function(b){if(a.rewriteLinks&&!b.ctrlKey&&!b.metaKey&&!b.shiftKey&&2!=b.which&&2!=b.button){for(var e=B(b.target);"a"!==wa(e[0]);)if(e[0]===f[0]||!(e=e.parent())[0])return;var g=e.prop("href"),l=e.attr("href")||e.attr("xlink:href");C(g)&&"[object SVGAnimatedString]"===g.toString()&&(g=Aa(g.animVal).href);E.test(g)||!g||e.attr("target")||b.isDefaultPrevented()||!k.$$parseLinkUrl(g,l)||(b.preventDefault(),k.absUrl()!=d.url()&&(c.$apply(),h.angular["ff-684208-preventDefault"]=
!0))}});Cb(k.absUrl())!=Cb(p)&&d.url(k.absUrl(),!0);var K=!0;d.onUrlChange(function(a,b){v(sa(t,a))?h.location.href=a:(c.$evalAsync(function(){var d=k.absUrl(),e=k.$$state,f;k.$$parse(a);k.$$state=b;f=c.$broadcast("$locationChangeStart",a,d,b,e).defaultPrevented;k.absUrl()===a&&(f?(k.$$parse(d),k.$$state=e,g(d,!1,e)):(K=!1,l(d,e)))}),c.$$phase||c.$digest())});c.$watch(function(){var a=Cb(d.url()),b=Cb(k.absUrl()),f=d.state(),h=k.$$replace,r=a!==b||k.$$html5&&e.history&&f!==k.$$state;if(K||r)K=!1,
c.$evalAsync(function(){var b=k.absUrl(),d=c.$broadcast("$locationChangeStart",b,a,k.$$state,f).defaultPrevented;k.absUrl()===b&&(d?(k.$$parse(a),k.$$state=f):(r&&g(b,h,f===k.$$state?null:k.$$state),l(a,f)))});k.$$replace=!1});return k}]}function jf(){var b=!0,a=this;this.debugEnabled=function(a){return A(a)?(b=a,this):b};this.$get=["$window",function(c){function d(a){a instanceof Error&&(a.stack?a=a.message&&-1===a.stack.indexOf(a.message)?"Error: "+a.message+"\n"+a.stack:a.stack:a.sourceURL&&(a=
a.message+"\n"+a.sourceURL+":"+a.line));return a}function e(a){var b=c.console||{},e=b[a]||b.log||y;a=!1;try{a=!!e.apply}catch(l){}return a?function(){var a=[];m(arguments,function(b){a.push(d(b))});return e.apply(b,a)}:function(a,b){e(a,null==b?"":b)}}return{log:e("log"),info:e("info"),warn:e("warn"),error:e("error"),debug:function(){var c=e("debug");return function(){b&&c.apply(a,arguments)}}()}}]}function Xa(b,a){if("__defineGetter__"===b||"__defineSetter__"===b||"__lookupGetter__"===b||"__lookupSetter__"===
b||"__proto__"===b)throw Z("isecfld",a);return b}function kd(b,a){b+="";if(!G(b))throw Z("iseccst",a);return b}function Ba(b,a){if(b){if(b.constructor===b)throw Z("isecfn",a);if(b.window===b)throw Z("isecwindow",a);if(b.children&&(b.nodeName||b.prop&&b.attr&&b.find))throw Z("isecdom",a);if(b===Object)throw Z("isecobj",a);}return b}function ld(b,a){if(b){if(b.constructor===b)throw Z("isecfn",a);if(b===Uf||b===Vf||b===Wf)throw Z("isecff",a);}}function md(b,a){if(b&&(b===(0).constructor||b===(!1).constructor||
b==="".constructor||b==={}.constructor||b===[].constructor||b===Function.constructor))throw Z("isecaf",a);}function Xf(b,a){return"undefined"!==typeof b?b:a}function nd(b,a){return"undefined"===typeof b?a:"undefined"===typeof a?b:b+a}function U(b,a){var c,d;switch(b.type){case s.Program:c=!0;m(b.body,function(b){U(b.expression,a);c=c&&b.expression.constant});b.constant=c;break;case s.Literal:b.constant=!0;b.toWatch=[];break;case s.UnaryExpression:U(b.argument,a);b.constant=b.argument.constant;b.toWatch=
b.argument.toWatch;break;case s.BinaryExpression:U(b.left,a);U(b.right,a);b.constant=b.left.constant&&b.right.constant;b.toWatch=b.left.toWatch.concat(b.right.toWatch);break;case s.LogicalExpression:U(b.left,a);U(b.right,a);b.constant=b.left.constant&&b.right.constant;b.toWatch=b.constant?[]:[b];break;case s.ConditionalExpression:U(b.test,a);U(b.alternate,a);U(b.consequent,a);b.constant=b.test.constant&&b.alternate.constant&&b.consequent.constant;b.toWatch=b.constant?[]:[b];break;case s.Identifier:b.constant=
!1;b.toWatch=[b];break;case s.MemberExpression:U(b.object,a);b.computed&&U(b.property,a);b.constant=b.object.constant&&(!b.computed||b.property.constant);b.toWatch=[b];break;case s.CallExpression:c=b.filter?!a(b.callee.name).$stateful:!1;d=[];m(b.arguments,function(b){U(b,a);c=c&&b.constant;b.constant||d.push.apply(d,b.toWatch)});b.constant=c;b.toWatch=b.filter&&!a(b.callee.name).$stateful?d:[b];break;case s.AssignmentExpression:U(b.left,a);U(b.right,a);b.constant=b.left.constant&&b.right.constant;
b.toWatch=[b];break;case s.ArrayExpression:c=!0;d=[];m(b.elements,function(b){U(b,a);c=c&&b.constant;b.constant||d.push.apply(d,b.toWatch)});b.constant=c;b.toWatch=d;break;case s.ObjectExpression:c=!0;d=[];m(b.properties,function(b){U(b.value,a);c=c&&b.value.constant;b.value.constant||d.push.apply(d,b.value.toWatch)});b.constant=c;b.toWatch=d;break;case s.ThisExpression:b.constant=!1,b.toWatch=[]}}function od(b){if(1==b.length){b=b[0].expression;var a=b.toWatch;return 1!==a.length?a:a[0]!==b?a:w}}
function pd(b){return b.type===s.Identifier||b.type===s.MemberExpression}function qd(b){if(1===b.body.length&&pd(b.body[0].expression))return{type:s.AssignmentExpression,left:b.body[0].expression,right:{type:s.NGValueParameter},operator:"="}}function rd(b){return 0===b.body.length||1===b.body.length&&(b.body[0].expression.type===s.Literal||b.body[0].expression.type===s.ArrayExpression||b.body[0].expression.type===s.ObjectExpression)}function sd(b,a){this.astBuilder=b;this.$filter=a}function td(b,
a){this.astBuilder=b;this.$filter=a}function Fb(b){return"constructor"==b}function dc(b){return x(b.valueOf)?b.valueOf():Yf.call(b)}function kf(){var b=fa(),a=fa();this.$get=["$filter",function(c){function d(a,b){return null==a||null==b?a===b:"object"===typeof a&&(a=dc(a),"object"===typeof a)?!1:a===b||a!==a&&b!==b}function e(a,b,c,e,f){var g=e.inputs,h;if(1===g.length){var k=d,g=g[0];return a.$watch(function(a){var b=g(a);d(b,k)||(h=e(a,w,w,[b]),k=b&&dc(b));return h},b,c,f)}for(var l=[],n=[],p=0,
m=g.length;p<m;p++)l[p]=d,n[p]=null;return a.$watch(function(a){for(var b=!1,c=0,f=g.length;c<f;c++){var k=g[c](a);if(b||(b=!d(k,l[c])))n[c]=k,l[c]=k&&dc(k)}b&&(h=e(a,w,w,n));return h},b,c,f)}function f(a,b,c,d){var e,f;return e=a.$watch(function(a){return d(a)},function(a,c,d){f=a;x(b)&&b.apply(this,arguments);A(a)&&d.$$postDigest(function(){A(f)&&e()})},c)}function h(a,b,c,d){function e(a){var b=!0;m(a,function(a){A(a)||(b=!1)});return b}var f,g;return f=a.$watch(function(a){return d(a)},function(a,
c,d){g=a;x(b)&&b.call(this,a,c,d);e(a)&&d.$$postDigest(function(){e(g)&&f()})},c)}function g(a,b,c,d){var e;return e=a.$watch(function(a){return d(a)},function(a,c,d){x(b)&&b.apply(this,arguments);e()},c)}function l(a,b){if(!b)return a;var c=a.$$watchDelegate,c=c!==h&&c!==f?function(c,d,e,f){e=a(c,d,e,f);return b(e,c,d)}:function(c,d,e,f){e=a(c,d,e,f);c=b(e,c,d);return A(e)?c:e};a.$$watchDelegate&&a.$$watchDelegate!==e?c.$$watchDelegate=a.$$watchDelegate:b.$stateful||(c.$$watchDelegate=e,c.inputs=
a.inputs?a.inputs:[a]);return c}var k=Fa().noUnsafeEval,n={csp:k,expensiveChecks:!1},p={csp:k,expensiveChecks:!0};return function(d,k,E){var m,u,q;switch(typeof d){case "string":q=d=d.trim();var s=E?a:b;m=s[q];m||(":"===d.charAt(0)&&":"===d.charAt(1)&&(u=!0,d=d.substring(2)),E=E?p:n,m=new ec(E),m=(new fc(m,c,E)).parse(d),m.constant?m.$$watchDelegate=g:u?m.$$watchDelegate=m.literal?h:f:m.inputs&&(m.$$watchDelegate=e),s[q]=m);return l(m,k);case "function":return l(d,k);default:return y}}}]}function mf(){this.$get=
["$rootScope","$exceptionHandler",function(b,a){return ud(function(a){b.$evalAsync(a)},a)}]}function nf(){this.$get=["$browser","$exceptionHandler",function(b,a){return ud(function(a){b.defer(a)},a)}]}function ud(b,a){function c(a,b,c){function d(b){return function(c){e||(e=!0,b.call(a,c))}}var e=!1;return[d(b),d(c)]}function d(){this.$$state={status:0}}function e(a,b){return function(c){b.call(a,c)}}function f(c){!c.processScheduled&&c.pending&&(c.processScheduled=!0,b(function(){var b,d,e;e=c.pending;
c.processScheduled=!1;c.pending=w;for(var f=0,g=e.length;f<g;++f){d=e[f][0];b=e[f][c.status];try{x(b)?d.resolve(b(c.value)):1===c.status?d.resolve(c.value):d.reject(c.value)}catch(h){d.reject(h),a(h)}}}))}function h(){this.promise=new d;this.resolve=e(this,this.resolve);this.reject=e(this,this.reject);this.notify=e(this,this.notify)}var g=I("$q",TypeError);P(d.prototype,{then:function(a,b,c){if(v(a)&&v(b)&&v(c))return this;var d=new h;this.$$state.pending=this.$$state.pending||[];this.$$state.pending.push([d,
a,b,c]);0<this.$$state.status&&f(this.$$state);return d.promise},"catch":function(a){return this.then(null,a)},"finally":function(a,b){return this.then(function(b){return k(b,!0,a)},function(b){return k(b,!1,a)},b)}});P(h.prototype,{resolve:function(a){this.promise.$$state.status||(a===this.promise?this.$$reject(g("qcycle",a)):this.$$resolve(a))},$$resolve:function(b){var d,e;e=c(this,this.$$resolve,this.$$reject);try{if(C(b)||x(b))d=b&&b.then;x(d)?(this.promise.$$state.status=-1,d.call(b,e[0],e[1],
this.notify)):(this.promise.$$state.value=b,this.promise.$$state.status=1,f(this.promise.$$state))}catch(g){e[1](g),a(g)}},reject:function(a){this.promise.$$state.status||this.$$reject(a)},$$reject:function(a){this.promise.$$state.value=a;this.promise.$$state.status=2;f(this.promise.$$state)},notify:function(c){var d=this.promise.$$state.pending;0>=this.promise.$$state.status&&d&&d.length&&b(function(){for(var b,e,f=0,g=d.length;f<g;f++){e=d[f][0];b=d[f][3];try{e.notify(x(b)?b(c):c)}catch(h){a(h)}}})}});
var l=function(a,b){var c=new h;b?c.resolve(a):c.reject(a);return c.promise},k=function(a,b,c){var d=null;try{x(c)&&(d=c())}catch(e){return l(e,!1)}return d&&x(d.then)?d.then(function(){return l(a,b)},function(a){return l(a,!1)}):l(a,b)},n=function(a,b,c,d){var e=new h;e.resolve(a);return e.promise.then(b,c,d)},p=function t(a){if(!x(a))throw g("norslvr",a);if(!(this instanceof t))return new t(a);var b=new h;a(function(a){b.resolve(a)},function(a){b.reject(a)});return b.promise};p.defer=function(){return new h};
p.reject=function(a){var b=new h;b.reject(a);return b.promise};p.when=n;p.resolve=n;p.all=function(a){var b=new h,c=0,d=J(a)?[]:{};m(a,function(a,e){c++;n(a).then(function(a){d.hasOwnProperty(e)||(d[e]=a,--c||b.resolve(d))},function(a){d.hasOwnProperty(e)||b.reject(a)})});0===c&&b.resolve(d);return b.promise};return p}function wf(){this.$get=["$window","$timeout",function(b,a){var c=b.requestAnimationFrame||b.webkitRequestAnimationFrame,d=b.cancelAnimationFrame||b.webkitCancelAnimationFrame||b.webkitCancelRequestAnimationFrame,
e=!!c,f=e?function(a){var b=c(a);return function(){d(b)}}:function(b){var c=a(b,16.66,!1);return function(){a.cancel(c)}};f.supported=e;return f}]}function lf(){function b(a){function b(){this.$$watchers=this.$$nextSibling=this.$$childHead=this.$$childTail=null;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$id=++nb;this.$$ChildScope=null}b.prototype=a;return b}var a=10,c=I("$rootScope"),d=null,e=null;this.digestTtl=function(b){arguments.length&&(a=b);return a};this.$get=
["$injector","$exceptionHandler","$parse","$browser",function(f,h,g,l){function k(a){a.currentScope.$$destroyed=!0}function n(){this.$id=++nb;this.$$phase=this.$parent=this.$$watchers=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null;this.$root=this;this.$$destroyed=!1;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$$isolateBindings=null}function p(a){if(q.$$phase)throw c("inprog",q.$$phase);q.$$phase=a}function r(a,b){do a.$$watchersCount+=b;while(a=
a.$parent)}function t(a,b,c){do a.$$listenerCount[c]-=b,0===a.$$listenerCount[c]&&delete a.$$listenerCount[c];while(a=a.$parent)}function E(){}function s(){for(;w.length;)try{w.shift()()}catch(a){h(a)}e=null}function u(){null===e&&(e=l.defer(function(){q.$apply(s)}))}n.prototype={constructor:n,$new:function(a,c){var d;c=c||this;a?(d=new n,d.$root=this.$root):(this.$$ChildScope||(this.$$ChildScope=b(this)),d=new this.$$ChildScope);d.$parent=c;d.$$prevSibling=c.$$childTail;c.$$childHead?(c.$$childTail.$$nextSibling=
d,c.$$childTail=d):c.$$childHead=c.$$childTail=d;(a||c!=this)&&d.$on("$destroy",k);return d},$watch:function(a,b,c,e){var f=g(a);if(f.$$watchDelegate)return f.$$watchDelegate(this,b,c,f,a);var h=this,k=h.$$watchers,l={fn:b,last:E,get:f,exp:e||a,eq:!!c};d=null;x(b)||(l.fn=y);k||(k=h.$$watchers=[]);k.unshift(l);r(this,1);return function(){0<=cb(k,l)&&r(h,-1);d=null}},$watchGroup:function(a,b){function c(){h=!1;k?(k=!1,b(e,e,g)):b(e,d,g)}var d=Array(a.length),e=Array(a.length),f=[],g=this,h=!1,k=!0;
if(!a.length){var l=!0;g.$evalAsync(function(){l&&b(e,e,g)});return function(){l=!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});m(a,function(a,b){var k=g.$watch(a,function(a,f){e[b]=a;d[b]=f;h||(h=!0,g.$evalAsync(c))});f.push(k)});return function(){for(;f.length;)f.shift()()}},$watchCollection:function(a,b){function c(a){e=a;var b,d,g,h;if(!v(e)){if(C(e))if(Da(e))for(f!==p&&(f=p,t=f.length=0,l++),a=e.length,t!==a&&(l++,f.length=t=a),b=0;b<a;b++)h=f[b],
g=e[b],d=h!==h&&g!==g,d||h===g||(l++,f[b]=g);else{f!==r&&(f=r={},t=0,l++);a=0;for(b in e)ta.call(e,b)&&(a++,g=e[b],h=f[b],b in f?(d=h!==h&&g!==g,d||h===g||(l++,f[b]=g)):(t++,f[b]=g,l++));if(t>a)for(b in l++,f)ta.call(e,b)||(t--,delete f[b])}else f!==e&&(f=e,l++);return l}}c.$stateful=!0;var d=this,e,f,h,k=1<b.length,l=0,n=g(a,c),p=[],r={},q=!0,t=0;return this.$watch(n,function(){q?(q=!1,b(e,e,d)):b(e,h,d);if(k)if(C(e))if(Da(e)){h=Array(e.length);for(var a=0;a<e.length;a++)h[a]=e[a]}else for(a in h=
{},e)ta.call(e,a)&&(h[a]=e[a]);else h=e})},$digest:function(){var b,f,g,k,n,r,t=a,m,u=[],D,v;p("$digest");l.$$checkUrlChange();this===q&&null!==e&&(l.defer.cancel(e),s());d=null;do{r=!1;for(m=this;z.length;){try{v=z.shift(),v.scope.$eval(v.expression,v.locals)}catch(w){h(w)}d=null}a:do{if(k=m.$$watchers)for(n=k.length;n--;)try{if(b=k[n])if((f=b.get(m))!==(g=b.last)&&!(b.eq?ka(f,g):"number"===typeof f&&"number"===typeof g&&isNaN(f)&&isNaN(g)))r=!0,d=b,b.last=b.eq?ha(f,null):f,b.fn(f,g===E?f:g,m),5>
t&&(D=4-t,u[D]||(u[D]=[]),u[D].push({msg:x(b.exp)?"fn: "+(b.exp.name||b.exp.toString()):b.exp,newVal:f,oldVal:g}));else if(b===d){r=!1;break a}}catch(y){h(y)}if(!(k=m.$$watchersCount&&m.$$childHead||m!==this&&m.$$nextSibling))for(;m!==this&&!(k=m.$$nextSibling);)m=m.$parent}while(m=k);if((r||z.length)&&!t--)throw q.$$phase=null,c("infdig",a,u);}while(r||z.length);for(q.$$phase=null;N.length;)try{N.shift()()}catch(A){h(A)}},$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast("$destroy");
this.$$destroyed=!0;this===q&&l.$$applicationDestroyed();r(this,-this.$$watchersCount);for(var b in this.$$listenerCount)t(this,this.$$listenerCount[b],b);a&&a.$$childHead==this&&(a.$$childHead=this.$$nextSibling);a&&a.$$childTail==this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=this.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=this.$$prevSibling);this.$destroy=this.$digest=this.$apply=this.$evalAsync=this.$applyAsync=y;this.$on=
this.$watch=this.$watchGroup=function(){return y};this.$$listeners={};this.$parent=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=this.$root=this.$$watchers=null}},$eval:function(a,b){return g(a)(this,b)},$evalAsync:function(a,b){q.$$phase||z.length||l.defer(function(){z.length&&q.$digest()});z.push({scope:this,expression:a,locals:b})},$$postDigest:function(a){N.push(a)},$apply:function(a){try{p("$apply");try{return this.$eval(a)}finally{q.$$phase=null}}catch(b){h(b)}finally{try{q.$digest()}catch(c){throw h(c),
c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&w.push(b);u()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||(d.$$listenerCount[a]=0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(c[d]=null,t(e,1,a))}},$emit:function(a,b){var c=[],d,e=this,f=!1,g={name:a,targetScope:e,stopPropagation:function(){f=!0},preventDefault:function(){g.defaultPrevented=!0},defaultPrevented:!1},
k=db([g],arguments,1),l,n;do{d=e.$$listeners[a]||c;g.currentScope=e;l=0;for(n=d.length;l<n;l++)if(d[l])try{d[l].apply(null,k)}catch(p){h(p)}else d.splice(l,1),l--,n--;if(f)return g.currentScope=null,g;e=e.$parent}while(e);g.currentScope=null;return g},$broadcast:function(a,b){var c=this,d=this,e={name:a,targetScope:this,preventDefault:function(){e.defaultPrevented=!0},defaultPrevented:!1};if(!this.$$listenerCount[a])return e;for(var f=db([e],arguments,1),g,k;c=d;){e.currentScope=c;d=c.$$listeners[a]||
[];g=0;for(k=d.length;g<k;g++)if(d[g])try{d[g].apply(null,f)}catch(l){h(l)}else d.splice(g,1),g--,k--;if(!(d=c.$$listenerCount[a]&&c.$$childHead||c!==this&&c.$$nextSibling))for(;c!==this&&!(d=c.$$nextSibling);)c=c.$parent}e.currentScope=null;return e}};var q=new n,z=q.$$asyncQueue=[],N=q.$$postDigestQueue=[],w=q.$$applyAsyncQueue=[];return q}]}function ge(){var b=/^\s*(https?|ftp|mailto|tel|file):/,a=/^\s*((https?|ftp|file|blob):|data:image\/)/;this.aHrefSanitizationWhitelist=function(a){return A(a)?
(b=a,this):b};this.imgSrcSanitizationWhitelist=function(b){return A(b)?(a=b,this):a};this.$get=function(){return function(c,d){var e=d?a:b,f;f=Aa(c).href;return""===f||f.match(e)?c:"unsafe:"+f}}}function Zf(b){if("self"===b)return b;if(G(b)){if(-1<b.indexOf("***"))throw Ca("iwcard",b);b=vd(b).replace("\\*\\*",".*").replace("\\*","[^:/.?&;]*");return new RegExp("^"+b+"$")}if(Oa(b))return new RegExp("^"+b.source+"$");throw Ca("imatcher");}function wd(b){var a=[];A(b)&&m(b,function(b){a.push(Zf(b))});
return a}function pf(){this.SCE_CONTEXTS=oa;var b=["self"],a=[];this.resourceUrlWhitelist=function(a){arguments.length&&(b=wd(a));return b};this.resourceUrlBlacklist=function(b){arguments.length&&(a=wd(b));return a};this.$get=["$injector",function(c){function d(a,b){return"self"===a?fd(b):!!a.exec(b.href)}function e(a){var b=function(a){this.$$unwrapTrustedValue=function(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};
return b}var f=function(a){throw Ca("unsafe");};c.has("$sanitize")&&(f=c.get("$sanitize"));var h=e(),g={};g[oa.HTML]=e(h);g[oa.CSS]=e(h);g[oa.URL]=e(h);g[oa.JS]=e(h);g[oa.RESOURCE_URL]=e(g[oa.URL]);return{trustAs:function(a,b){var c=g.hasOwnProperty(a)?g[a]:null;if(!c)throw Ca("icontext",a,b);if(null===b||v(b)||""===b)return b;if("string"!==typeof b)throw Ca("itype",a);return new c(b)},getTrusted:function(c,e){if(null===e||v(e)||""===e)return e;var h=g.hasOwnProperty(c)?g[c]:null;if(h&&e instanceof
h)return e.$$unwrapTrustedValue();if(c===oa.RESOURCE_URL){var h=Aa(e.toString()),p,r,t=!1;p=0;for(r=b.length;p<r;p++)if(d(b[p],h)){t=!0;break}if(t)for(p=0,r=a.length;p<r;p++)if(d(a[p],h)){t=!1;break}if(t)return e;throw Ca("insecurl",e.toString());}if(c===oa.HTML)return f(e);throw Ca("unsafe");},valueOf:function(a){return a instanceof h?a.$$unwrapTrustedValue():a}}}]}function of(){var b=!0;this.enabled=function(a){arguments.length&&(b=!!a);return b};this.$get=["$parse","$sceDelegate",function(a,c){if(b&&
8>Wa)throw Ca("iequirks");var d=ja(oa);d.isEnabled=function(){return b};d.trustAs=c.trustAs;d.getTrusted=c.getTrusted;d.valueOf=c.valueOf;b||(d.trustAs=d.getTrusted=function(a,b){return b},d.valueOf=$a);d.parseAs=function(b,c){var e=a(c);return e.literal&&e.constant?e:a(c,function(a){return d.getTrusted(b,a)})};var e=d.parseAs,f=d.getTrusted,h=d.trustAs;m(oa,function(a,b){var c=F(b);d[gb("parse_as_"+c)]=function(b){return e(a,b)};d[gb("get_trusted_"+c)]=function(b){return f(a,b)};d[gb("trust_as_"+
c)]=function(b){return h(a,b)}});return d}]}function qf(){this.$get=["$window","$document",function(b,a){var c={},d=Y((/android (\d+)/.exec(F((b.navigator||{}).userAgent))||[])[1]),e=/Boxee/i.test((b.navigator||{}).userAgent),f=a[0]||{},h,g=/^(Moz|webkit|ms)(?=[A-Z])/,l=f.body&&f.body.style,k=!1,n=!1;if(l){for(var p in l)if(k=g.exec(p)){h=k[0];h=h.substr(0,1).toUpperCase()+h.substr(1);break}h||(h="WebkitOpacity"in l&&"webkit");k=!!("transition"in l||h+"Transition"in l);n=!!("animation"in l||h+"Animation"in
l);!d||k&&n||(k=G(l.webkitTransition),n=G(l.webkitAnimation))}return{history:!(!b.history||!b.history.pushState||4>d||e),hasEvent:function(a){if("input"===a&&11>=Wa)return!1;if(v(c[a])){var b=f.createElement("div");c[a]="on"+a in b}return c[a]},csp:Fa(),vendorPrefix:h,transitions:k,animations:n,android:d}}]}function sf(){this.$get=["$templateCache","$http","$q","$sce",function(b,a,c,d){function e(f,h){e.totalPendingRequests++;G(f)&&b.get(f)||(f=d.getTrustedResourceUrl(f));var g=a.defaults&&a.defaults.transformResponse;
J(g)?g=g.filter(function(a){return a!==Zb}):g===Zb&&(g=null);return a.get(f,{cache:b,transformResponse:g})["finally"](function(){e.totalPendingRequests--}).then(function(a){b.put(f,a.data);return a.data},function(a){if(!h)throw ga("tpload",f,a.status,a.statusText);return c.reject(a)})}e.totalPendingRequests=0;return e}]}function tf(){this.$get=["$rootScope","$browser","$location",function(b,a,c){return{findBindings:function(a,b,c){a=a.getElementsByClassName("ng-binding");var h=[];m(a,function(a){var d=
da.element(a).data("$binding");d&&m(d,function(d){c?(new RegExp("(^|\\s)"+vd(b)+"(\\s|\\||$)")).test(d)&&h.push(a):-1!=d.indexOf(b)&&h.push(a)})});return h},findModels:function(a,b,c){for(var h=["ng-","data-ng-","ng\\:"],g=0;g<h.length;++g){var l=a.querySelectorAll("["+h[g]+"model"+(c?"=":"*=")+'"'+b+'"]');if(l.length)return l}},getLocation:function(){return c.url()},setLocation:function(a){a!==c.url()&&(c.url(a),b.$digest())},whenStable:function(b){a.notifyWhenNoOutstandingRequests(b)}}}]}function uf(){this.$get=
["$rootScope","$browser","$q","$$q","$exceptionHandler",function(b,a,c,d,e){function f(f,l,k){x(f)||(k=l,l=f,f=y);var n=ua.call(arguments,3),p=A(k)&&!k,r=(p?d:c).defer(),t=r.promise,m;m=a.defer(function(){try{r.resolve(f.apply(null,n))}catch(a){r.reject(a),e(a)}finally{delete h[t.$$timeoutId]}p||b.$apply()},l);t.$$timeoutId=m;h[m]=r;return t}var h={};f.cancel=function(b){return b&&b.$$timeoutId in h?(h[b.$$timeoutId].reject("canceled"),delete h[b.$$timeoutId],a.defer.cancel(b.$$timeoutId)):!1};return f}]}
function Aa(b){Wa&&($.setAttribute("href",b),b=$.href);$.setAttribute("href",b);return{href:$.href,protocol:$.protocol?$.protocol.replace(/:$/,""):"",host:$.host,search:$.search?$.search.replace(/^\?/,""):"",hash:$.hash?$.hash.replace(/^#/,""):"",hostname:$.hostname,port:$.port,pathname:"/"===$.pathname.charAt(0)?$.pathname:"/"+$.pathname}}function fd(b){b=G(b)?Aa(b):b;return b.protocol===xd.protocol&&b.host===xd.host}function vf(){this.$get=qa(Q)}function yd(b){function a(a){try{return decodeURIComponent(a)}catch(b){return a}}
var c=b[0]||{},d={},e="";return function(){var b,h,g,l,k;b=c.cookie||"";if(b!==e)for(e=b,b=e.split("; "),d={},g=0;g<b.length;g++)h=b[g],l=h.indexOf("="),0<l&&(k=a(h.substring(0,l)),v(d[k])&&(d[k]=a(h.substring(l+1))));return d}}function zf(){this.$get=yd}function Kc(b){function a(c,d){if(C(c)){var e={};m(c,function(b,c){e[c]=a(c,b)});return e}return b.factory(c+"Filter",d)}this.register=a;this.$get=["$injector",function(a){return function(b){return a.get(b+"Filter")}}];a("currency",zd);a("date",Ad);
a("filter",$f);a("json",ag);a("limitTo",bg);a("lowercase",cg);a("number",Bd);a("orderBy",Cd);a("uppercase",dg)}function $f(){return function(b,a,c){if(!Da(b)){if(null==b)return b;throw I("filter")("notarray",b);}var d;switch(gc(a)){case "function":break;case "boolean":case "null":case "number":case "string":d=!0;case "object":a=eg(a,c,d);break;default:return b}return Array.prototype.filter.call(b,a)}}function eg(b,a,c){var d=C(b)&&"$"in b;!0===a?a=ka:x(a)||(a=function(a,b){if(v(a))return!1;if(null===
a||null===b)return a===b;if(C(b)||C(a)&&!qc(a))return!1;a=F(""+a);b=F(""+b);return-1!==a.indexOf(b)});return function(e){return d&&!C(e)?Ma(e,b.$,a,!1):Ma(e,b,a,c)}}function Ma(b,a,c,d,e){var f=gc(b),h=gc(a);if("string"===h&&"!"===a.charAt(0))return!Ma(b,a.substring(1),c,d);if(J(b))return b.some(function(b){return Ma(b,a,c,d)});switch(f){case "object":var g;if(d){for(g in b)if("$"!==g.charAt(0)&&Ma(b[g],a,c,!0))return!0;return e?!1:Ma(b,a,c,!1)}if("object"===h){for(g in a)if(e=a[g],!x(e)&&!v(e)&&
(f="$"===g,!Ma(f?b:b[g],e,c,f,f)))return!1;return!0}return c(b,a);case "function":return!1;default:return c(b,a)}}function gc(b){return null===b?"null":typeof b}function zd(b){var a=b.NUMBER_FORMATS;return function(b,d,e){v(d)&&(d=a.CURRENCY_SYM);v(e)&&(e=a.PATTERNS[1].maxFrac);return null==b?b:Dd(b,a.PATTERNS[1],a.GROUP_SEP,a.DECIMAL_SEP,e).replace(/\u00A4/g,d)}}function Bd(b){var a=b.NUMBER_FORMATS;return function(b,d){return null==b?b:Dd(b,a.PATTERNS[0],a.GROUP_SEP,a.DECIMAL_SEP,d)}}function Dd(b,
a,c,d,e){if(C(b))return"";var f=0>b;b=Math.abs(b);var h=Infinity===b;if(!h&&!isFinite(b))return"";var g=b+"",l="",k=!1,n=[];h&&(l="\u221e");if(!h&&-1!==g.indexOf("e")){var p=g.match(/([\d\.]+)e(-?)(\d+)/);p&&"-"==p[2]&&p[3]>e+1?b=0:(l=g,k=!0)}if(h||k)0<e&&1>b&&(l=b.toFixed(e),b=parseFloat(l),l=l.replace(hc,d));else{h=(g.split(hc)[1]||"").length;v(e)&&(e=Math.min(Math.max(a.minFrac,h),a.maxFrac));b=+(Math.round(+(b.toString()+"e"+e)).toString()+"e"+-e);var h=(""+b).split(hc),g=h[0],h=h[1]||"",p=0,
r=a.lgSize,t=a.gSize;if(g.length>=r+t)for(p=g.length-r,k=0;k<p;k++)0===(p-k)%t&&0!==k&&(l+=c),l+=g.charAt(k);for(k=p;k<g.length;k++)0===(g.length-k)%r&&0!==k&&(l+=c),l+=g.charAt(k);for(;h.length<e;)h+="0";e&&"0"!==e&&(l+=d+h.substr(0,e))}0===b&&(f=!1);n.push(f?a.negPre:a.posPre,l,f?a.negSuf:a.posSuf);return n.join("")}function Gb(b,a,c){var d="";0>b&&(d="-",b=-b);for(b=""+b;b.length<a;)b="0"+b;c&&(b=b.substr(b.length-a));return d+b}function aa(b,a,c,d){c=c||0;return function(e){e=e["get"+b]();if(0<
c||e>-c)e+=c;0===e&&-12==c&&(e=12);return Gb(e,a,d)}}function Hb(b,a){return function(c,d){var e=c["get"+b](),f=sb(a?"SHORT"+b:b);return d[f][e]}}function Ed(b){var a=(new Date(b,0,1)).getDay();return new Date(b,0,(4>=a?5:12)-a)}function Fd(b){return function(a){var c=Ed(a.getFullYear());a=+new Date(a.getFullYear(),a.getMonth(),a.getDate()+(4-a.getDay()))-+c;a=1+Math.round(a/6048E5);return Gb(a,b)}}function ic(b,a){return 0>=b.getFullYear()?a.ERAS[0]:a.ERAS[1]}function Ad(b){function a(a){var b;if(b=
a.match(c)){a=new Date(0);var f=0,h=0,g=b[8]?a.setUTCFullYear:a.setFullYear,l=b[8]?a.setUTCHours:a.setHours;b[9]&&(f=Y(b[9]+b[10]),h=Y(b[9]+b[11]));g.call(a,Y(b[1]),Y(b[2])-1,Y(b[3]));f=Y(b[4]||0)-f;h=Y(b[5]||0)-h;g=Y(b[6]||0);b=Math.round(1E3*parseFloat("0."+(b[7]||0)));l.call(a,f,h,g,b)}return a}var c=/^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;return function(c,e,f){var h="",g=[],l,k;e=e||"mediumDate";e=b.DATETIME_FORMATS[e]||e;G(c)&&(c=
fg.test(c)?Y(c):a(c));V(c)&&(c=new Date(c));if(!ea(c)||!isFinite(c.getTime()))return c;for(;e;)(k=gg.exec(e))?(g=db(g,k,1),e=g.pop()):(g.push(e),e=null);var n=c.getTimezoneOffset();f&&(n=wc(f,c.getTimezoneOffset()),c=Ob(c,f,!0));m(g,function(a){l=hg[a];h+=l?l(c,b.DATETIME_FORMATS,n):a.replace(/(^'|'$)/g,"").replace(/''/g,"'")});return h}}function ag(){return function(b,a){v(a)&&(a=2);return eb(b,a)}}function bg(){return function(b,a,c){a=Infinity===Math.abs(Number(a))?Number(a):Y(a);if(isNaN(a))return b;
V(b)&&(b=b.toString());if(!J(b)&&!G(b))return b;c=!c||isNaN(c)?0:Y(c);c=0>c&&c>=-b.length?b.length+c:c;return 0<=a?b.slice(c,c+a):0===c?b.slice(a,b.length):b.slice(Math.max(0,c+a),c)}}function Cd(b){function a(a,c){c=c?-1:1;return a.map(function(a){var d=1,g=$a;if(x(a))g=a;else if(G(a)){if("+"==a.charAt(0)||"-"==a.charAt(0))d="-"==a.charAt(0)?-1:1,a=a.substring(1);if(""!==a&&(g=b(a),g.constant))var l=g(),g=function(a){return a[l]}}return{get:g,descending:d*c}})}function c(a){switch(typeof a){case "number":case "boolean":case "string":return!0;
default:return!1}}return function(b,e,f){if(!Da(b))return b;J(e)||(e=[e]);0===e.length&&(e=["+"]);var h=a(e,f);h.push({get:function(){return{}},descending:f?-1:1});b=Array.prototype.map.call(b,function(a,b){return{value:a,predicateValues:h.map(function(d){var e=d.get(a);d=typeof e;if(null===e)d="string",e="null";else if("string"===d)e=e.toLowerCase();else if("object"===d)a:{if("function"===typeof e.valueOf&&(e=e.valueOf(),c(e)))break a;if(qc(e)&&(e=e.toString(),c(e)))break a;e=b}return{value:e,type:d}})}});
b.sort(function(a,b){for(var c=0,d=0,e=h.length;d<e;++d){var c=a.predicateValues[d],f=b.predicateValues[d],t=0;c.type===f.type?c.value!==f.value&&(t=c.value<f.value?-1:1):t=c.type<f.type?-1:1;if(c=t*h[d].descending)break}return c});return b=b.map(function(a){return a.value})}}function Na(b){x(b)&&(b={link:b});b.restrict=b.restrict||"AC";return qa(b)}function Gd(b,a,c,d,e){var f=this,h=[];f.$error={};f.$$success={};f.$pending=w;f.$name=e(a.name||a.ngForm||"")(c);f.$dirty=!1;f.$pristine=!0;f.$valid=
!0;f.$invalid=!1;f.$submitted=!1;f.$$parentForm=Ib;f.$rollbackViewValue=function(){m(h,function(a){a.$rollbackViewValue()})};f.$commitViewValue=function(){m(h,function(a){a.$commitViewValue()})};f.$addControl=function(a){Ta(a.$name,"input");h.push(a);a.$name&&(f[a.$name]=a);a.$$parentForm=f};f.$$renameControl=function(a,b){var c=a.$name;f[c]===a&&delete f[c];f[b]=a;a.$name=b};f.$removeControl=function(a){a.$name&&f[a.$name]===a&&delete f[a.$name];m(f.$pending,function(b,c){f.$setValidity(c,null,a)});
m(f.$error,function(b,c){f.$setValidity(c,null,a)});m(f.$$success,function(b,c){f.$setValidity(c,null,a)});cb(h,a);a.$$parentForm=Ib};Hd({ctrl:this,$element:b,set:function(a,b,c){var d=a[b];d?-1===d.indexOf(c)&&d.push(c):a[b]=[c]},unset:function(a,b,c){var d=a[b];d&&(cb(d,c),0===d.length&&delete a[b])},$animate:d});f.$setDirty=function(){d.removeClass(b,Ya);d.addClass(b,Jb);f.$dirty=!0;f.$pristine=!1;f.$$parentForm.$setDirty()};f.$setPristine=function(){d.setClass(b,Ya,Jb+" ng-submitted");f.$dirty=
!1;f.$pristine=!0;f.$submitted=!1;m(h,function(a){a.$setPristine()})};f.$setUntouched=function(){m(h,function(a){a.$setUntouched()})};f.$setSubmitted=function(){d.addClass(b,"ng-submitted");f.$submitted=!0;f.$$parentForm.$setSubmitted()}}function jc(b){b.$formatters.push(function(a){return b.$isEmpty(a)?a:a.toString()})}function jb(b,a,c,d,e,f){var h=F(a[0].type);if(!e.android){var g=!1;a.on("compositionstart",function(a){g=!0});a.on("compositionend",function(){g=!1;l()})}var l=function(b){k&&(f.defer.cancel(k),
k=null);if(!g){var e=a.val();b=b&&b.type;"password"===h||c.ngTrim&&"false"===c.ngTrim||(e=T(e));(d.$viewValue!==e||""===e&&d.$$hasNativeValidators)&&d.$setViewValue(e,b)}};if(e.hasEvent("input"))a.on("input",l);else{var k,n=function(a,b,c){k||(k=f.defer(function(){k=null;b&&b.value===c||l(a)}))};a.on("keydown",function(a){var b=a.keyCode;91===b||15<b&&19>b||37<=b&&40>=b||n(a,this,this.value)});if(e.hasEvent("paste"))a.on("paste cut",n)}a.on("change",l);d.$render=function(){var b=d.$isEmpty(d.$viewValue)?
"":d.$viewValue;a.val()!==b&&a.val(b)}}function Kb(b,a){return function(c,d){var e,f;if(ea(c))return c;if(G(c)){'"'==c.charAt(0)&&'"'==c.charAt(c.length-1)&&(c=c.substring(1,c.length-1));if(ig.test(c))return new Date(c);b.lastIndex=0;if(e=b.exec(c))return e.shift(),f=d?{yyyy:d.getFullYear(),MM:d.getMonth()+1,dd:d.getDate(),HH:d.getHours(),mm:d.getMinutes(),ss:d.getSeconds(),sss:d.getMilliseconds()/1E3}:{yyyy:1970,MM:1,dd:1,HH:0,mm:0,ss:0,sss:0},m(e,function(b,c){c<a.length&&(f[a[c]]=+b)}),new Date(f.yyyy,
f.MM-1,f.dd,f.HH,f.mm,f.ss||0,1E3*f.sss||0)}return NaN}}function kb(b,a,c,d){return function(e,f,h,g,l,k,n){function p(a){return a&&!(a.getTime&&a.getTime()!==a.getTime())}function r(a){return A(a)&&!ea(a)?c(a)||w:a}Id(e,f,h,g);jb(e,f,h,g,l,k);var t=g&&g.$options&&g.$options.timezone,m;g.$$parserName=b;g.$parsers.push(function(b){return g.$isEmpty(b)?null:a.test(b)?(b=c(b,m),t&&(b=Ob(b,t)),b):w});g.$formatters.push(function(a){if(a&&!ea(a))throw lb("datefmt",a);if(p(a))return(m=a)&&t&&(m=Ob(m,t,!0)),
n("date")(a,d,t);m=null;return""});if(A(h.min)||h.ngMin){var s;g.$validators.min=function(a){return!p(a)||v(s)||c(a)>=s};h.$observe("min",function(a){s=r(a);g.$validate()})}if(A(h.max)||h.ngMax){var u;g.$validators.max=function(a){return!p(a)||v(u)||c(a)<=u};h.$observe("max",function(a){u=r(a);g.$validate()})}}}function Id(b,a,c,d){(d.$$hasNativeValidators=C(a[0].validity))&&d.$parsers.push(function(b){var c=a.prop("validity")||{};return c.badInput&&!c.typeMismatch?w:b})}function Jd(b,a,c,d,e){if(A(d)){b=
b(d);if(!b.constant)throw lb("constexpr",c,d);return b(a)}return e}function kc(b,a){b="ngClass"+b;return["$animate",function(c){function d(a,b){var c=[],d=0;a:for(;d<a.length;d++){for(var e=a[d],n=0;n<b.length;n++)if(e==b[n])continue a;c.push(e)}return c}function e(a){var b=[];return J(a)?(m(a,function(a){b=b.concat(e(a))}),b):G(a)?a.split(" "):C(a)?(m(a,function(a,c){a&&(b=b.concat(c.split(" ")))}),b):a}return{restrict:"AC",link:function(f,h,g){function l(a,b){var c=h.data("$classCounts")||fa(),
d=[];m(a,function(a){if(0<b||c[a])c[a]=(c[a]||0)+b,c[a]===+(0<b)&&d.push(a)});h.data("$classCounts",c);return d.join(" ")}function k(b){if(!0===a||f.$index%2===a){var k=e(b||[]);if(!n){var m=l(k,1);g.$addClass(m)}else if(!ka(b,n)){var s=e(n),m=d(k,s),k=d(s,k),m=l(m,1),k=l(k,-1);m&&m.length&&c.addClass(h,m);k&&k.length&&c.removeClass(h,k)}}n=ja(b)}var n;f.$watch(g[b],k,!0);g.$observe("class",function(a){k(f.$eval(g[b]))});"ngClass"!==b&&f.$watch("$index",function(c,d){var h=c&1;if(h!==(d&1)){var k=
e(f.$eval(g[b]));h===a?(h=l(k,1),g.$addClass(h)):(h=l(k,-1),g.$removeClass(h))}})}}}]}function Hd(b){function a(a,b){b&&!f[a]?(l.addClass(e,a),f[a]=!0):!b&&f[a]&&(l.removeClass(e,a),f[a]=!1)}function c(b,c){b=b?"-"+Ac(b,"-"):"";a(mb+b,!0===c);a(Kd+b,!1===c)}var d=b.ctrl,e=b.$element,f={},h=b.set,g=b.unset,l=b.$animate;f[Kd]=!(f[mb]=e.hasClass(mb));d.$setValidity=function(b,e,f){v(e)?(d.$pending||(d.$pending={}),h(d.$pending,b,f)):(d.$pending&&g(d.$pending,b,f),Ld(d.$pending)&&(d.$pending=w));bb(e)?
e?(g(d.$error,b,f),h(d.$$success,b,f)):(h(d.$error,b,f),g(d.$$success,b,f)):(g(d.$error,b,f),g(d.$$success,b,f));d.$pending?(a(Md,!0),d.$valid=d.$invalid=w,c("",null)):(a(Md,!1),d.$valid=Ld(d.$error),d.$invalid=!d.$valid,c("",d.$valid));e=d.$pending&&d.$pending[b]?w:d.$error[b]?!1:d.$$success[b]?!0:null;c(b,e);d.$$parentForm.$setValidity(b,e,d)}}function Ld(b){if(b)for(var a in b)if(b.hasOwnProperty(a))return!1;return!0}var jg=/^\/(.+)\/([a-z]*)$/,F=function(b){return G(b)?b.toLowerCase():b},ta=Object.prototype.hasOwnProperty,
sb=function(b){return G(b)?b.toUpperCase():b},Wa,B,ra,ua=[].slice,Nf=[].splice,kg=[].push,va=Object.prototype.toString,rc=Object.getPrototypeOf,Ea=I("ng"),da=Q.angular||(Q.angular={}),Rb,nb=0;Wa=X.documentMode;y.$inject=[];$a.$inject=[];var J=Array.isArray,tc=/^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/,T=function(b){return G(b)?b.trim():b},vd=function(b){return b.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")},Fa=function(){if(!A(Fa.rules)){var b=
X.querySelector("[ng-csp]")||X.querySelector("[data-ng-csp]");if(b){var a=b.getAttribute("ng-csp")||b.getAttribute("data-ng-csp");Fa.rules={noUnsafeEval:!a||-1!==a.indexOf("no-unsafe-eval"),noInlineStyle:!a||-1!==a.indexOf("no-inline-style")}}else{b=Fa;try{new Function(""),a=!1}catch(c){a=!0}b.rules={noUnsafeEval:a,noInlineStyle:!1}}}return Fa.rules},pb=function(){if(A(pb.name_))return pb.name_;var b,a,c=Qa.length,d,e;for(a=0;a<c;++a)if(d=Qa[a],b=X.querySelector("["+d.replace(":","\\:")+"jq]")){e=
b.getAttribute(d+"jq");break}return pb.name_=e},Qa=["ng-","data-ng-","ng:","x-ng-"],be=/[A-Z]/g,Bc=!1,Qb,pa=1,Pa=3,fe={full:"1.4.7",major:1,minor:4,dot:7,codeName:"dark-luminescence"};R.expando="ng339";var hb=R.cache={},Ff=1;R._data=function(b){return this.cache[b[this.expando]]||{}};var Af=/([\:\-\_]+(.))/g,Bf=/^moz([A-Z])/,lg={mouseleave:"mouseout",mouseenter:"mouseover"},Tb=I("jqLite"),Ef=/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,Sb=/<|&#?\w+;/,Cf=/<([\w:-]+)/,Df=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
ma={option:[1,'<select multiple="multiple">',"</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ma.optgroup=ma.option;ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead;ma.th=ma.td;var Ra=R.prototype={ready:function(b){function a(){c||(c=!0,b())}var c=!1;"complete"===X.readyState?setTimeout(a):(this.on("DOMContentLoaded",a),R(Q).on("load",a))},
toString:function(){var b=[];m(this,function(a){b.push(""+a)});return"["+b.join(", ")+"]"},eq:function(b){return 0<=b?B(this[b]):B(this[this.length+b])},length:0,push:kg,sort:[].sort,splice:[].splice},Bb={};m("multiple selected checked disabled readOnly required open".split(" "),function(b){Bb[F(b)]=b});var Sc={};m("input select option textarea button form details".split(" "),function(b){Sc[b]=!0});var $c={ngMinlength:"minlength",ngMaxlength:"maxlength",ngMin:"min",ngMax:"max",ngPattern:"pattern"};
m({data:Vb,removeData:vb,hasData:function(b){for(var a in hb[b.ng339])return!0;return!1}},function(b,a){R[a]=b});m({data:Vb,inheritedData:Ab,scope:function(b){return B.data(b,"$scope")||Ab(b.parentNode||b,["$isolateScope","$scope"])},isolateScope:function(b){return B.data(b,"$isolateScope")||B.data(b,"$isolateScopeNoTemplate")},controller:Pc,injector:function(b){return Ab(b,"$injector")},removeAttr:function(b,a){b.removeAttribute(a)},hasClass:xb,css:function(b,a,c){a=gb(a);if(A(c))b.style[a]=c;else return b.style[a]},
attr:function(b,a,c){var d=b.nodeType;if(d!==Pa&&2!==d&&8!==d)if(d=F(a),Bb[d])if(A(c))c?(b[a]=!0,b.setAttribute(a,d)):(b[a]=!1,b.removeAttribute(d));else return b[a]||(b.attributes.getNamedItem(a)||y).specified?d:w;else if(A(c))b.setAttribute(a,c);else if(b.getAttribute)return b=b.getAttribute(a,2),null===b?w:b},prop:function(b,a,c){if(A(c))b[a]=c;else return b[a]},text:function(){function b(a,b){if(v(b)){var d=a.nodeType;return d===pa||d===Pa?a.textContent:""}a.textContent=b}b.$dv="";return b}(),
val:function(b,a){if(v(a)){if(b.multiple&&"select"===wa(b)){var c=[];m(b.options,function(a){a.selected&&c.push(a.value||a.text)});return 0===c.length?null:c}return b.value}b.value=a},html:function(b,a){if(v(a))return b.innerHTML;ub(b,!0);b.innerHTML=a},empty:Qc},function(b,a){R.prototype[a]=function(a,d){var e,f,h=this.length;if(b!==Qc&&v(2==b.length&&b!==xb&&b!==Pc?a:d)){if(C(a)){for(e=0;e<h;e++)if(b===Vb)b(this[e],a);else for(f in a)b(this[e],f,a[f]);return this}e=b.$dv;h=v(e)?Math.min(h,1):h;
for(f=0;f<h;f++){var g=b(this[f],a,d);e=e?e+g:g}return e}for(e=0;e<h;e++)b(this[e],a,d);return this}});m({removeData:vb,on:function a(c,d,e,f){if(A(f))throw Tb("onargs");if(Lc(c)){var h=wb(c,!0);f=h.events;var g=h.handle;g||(g=h.handle=Hf(c,f));for(var h=0<=d.indexOf(" ")?d.split(" "):[d],l=h.length;l--;){d=h[l];var k=f[d];k||(f[d]=[],"mouseenter"===d||"mouseleave"===d?a(c,lg[d],function(a){var c=a.relatedTarget;c&&(c===this||this.contains(c))||g(a,d)}):"$destroy"!==d&&c.addEventListener(d,g,!1),
k=f[d]);k.push(e)}}},off:Oc,one:function(a,c,d){a=B(a);a.on(c,function f(){a.off(c,d);a.off(c,f)});a.on(c,d)},replaceWith:function(a,c){var d,e=a.parentNode;ub(a);m(new R(c),function(c){d?e.insertBefore(c,d.nextSibling):e.replaceChild(c,a);d=c})},children:function(a){var c=[];m(a.childNodes,function(a){a.nodeType===pa&&c.push(a)});return c},contents:function(a){return a.contentDocument||a.childNodes||[]},append:function(a,c){var d=a.nodeType;if(d===pa||11===d){c=new R(c);for(var d=0,e=c.length;d<
e;d++)a.appendChild(c[d])}},prepend:function(a,c){if(a.nodeType===pa){var d=a.firstChild;m(new R(c),function(c){a.insertBefore(c,d)})}},wrap:function(a,c){c=B(c).eq(0).clone()[0];var d=a.parentNode;d&&d.replaceChild(c,a);c.appendChild(a)},remove:Wb,detach:function(a){Wb(a,!0)},after:function(a,c){var d=a,e=a.parentNode;c=new R(c);for(var f=0,h=c.length;f<h;f++){var g=c[f];e.insertBefore(g,d.nextSibling);d=g}},addClass:zb,removeClass:yb,toggleClass:function(a,c,d){c&&m(c.split(" "),function(c){var f=
d;v(f)&&(f=!xb(a,c));(f?zb:yb)(a,c)})},parent:function(a){return(a=a.parentNode)&&11!==a.nodeType?a:null},next:function(a){return a.nextElementSibling},find:function(a,c){return a.getElementsByTagName?a.getElementsByTagName(c):[]},clone:Ub,triggerHandler:function(a,c,d){var e,f,h=c.type||c,g=wb(a);if(g=(g=g&&g.events)&&g[h])e={preventDefault:function(){this.defaultPrevented=!0},isDefaultPrevented:function(){return!0===this.defaultPrevented},stopImmediatePropagation:function(){this.immediatePropagationStopped=
!0},isImmediatePropagationStopped:function(){return!0===this.immediatePropagationStopped},stopPropagation:y,type:h,target:a},c.type&&(e=P(e,c)),c=ja(g),f=d?[e].concat(d):[e],m(c,function(c){e.isImmediatePropagationStopped()||c.apply(a,f)})}},function(a,c){R.prototype[c]=function(c,e,f){for(var h,g=0,l=this.length;g<l;g++)v(h)?(h=a(this[g],c,e,f),A(h)&&(h=B(h))):Nc(h,a(this[g],c,e,f));return A(h)?h:this};R.prototype.bind=R.prototype.on;R.prototype.unbind=R.prototype.off});Ua.prototype={put:function(a,
c){this[Ga(a,this.nextUid)]=c},get:function(a){return this[Ga(a,this.nextUid)]},remove:function(a){var c=this[a=Ga(a,this.nextUid)];delete this[a];return c}};var yf=[function(){this.$get=[function(){return Ua}]}],Uc=/^[^\(]*\(\s*([^\)]*)\)/m,mg=/,/,ng=/^\s*(_?)(\S+?)\1\s*$/,Tc=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,Ha=I("$injector");fb.$$annotate=function(a,c,d){var e;if("function"===typeof a){if(!(e=a.$inject)){e=[];if(a.length){if(c)throw G(d)&&d||(d=a.name||If(a)),Ha("strictdi",d);c=a.toString().replace(Tc,
"");c=c.match(Uc);m(c[1].split(mg),function(a){a.replace(ng,function(a,c,d){e.push(d)})})}a.$inject=e}}else J(a)?(c=a.length-1,Sa(a[c],"fn"),e=a.slice(0,c)):Sa(a,"fn",!0);return e};var Nd=I("$animate"),Ue=function(){this.$get=["$q","$$rAF",function(a,c){function d(){}d.all=y;d.chain=y;d.prototype={end:y,cancel:y,resume:y,pause:y,complete:y,then:function(d,f){return a(function(a){c(function(){a()})}).then(d,f)}};return d}]},Te=function(){var a=new Ua,c=[];this.$get=["$$AnimateRunner","$rootScope",
function(d,e){function f(a,c,d){var e=!1;c&&(c=G(c)?c.split(" "):J(c)?c:[],m(c,function(c){c&&(e=!0,a[c]=d)}));return e}function h(){m(c,function(c){var d=a.get(c);if(d){var e=Jf(c.attr("class")),f="",h="";m(d,function(a,c){a!==!!e[c]&&(a?f+=(f.length?" ":"")+c:h+=(h.length?" ":"")+c)});m(c,function(a){f&&zb(a,f);h&&yb(a,h)});a.remove(c)}});c.length=0}return{enabled:y,on:y,off:y,pin:y,push:function(g,l,k,n){n&&n();k=k||{};k.from&&g.css(k.from);k.to&&g.css(k.to);if(k.addClass||k.removeClass)if(l=k.addClass,
n=k.removeClass,k=a.get(g)||{},l=f(k,l,!0),n=f(k,n,!1),l||n)a.put(g,k),c.push(g),1===c.length&&e.$$postDigest(h);return new d}}}]},Re=["$provide",function(a){var c=this;this.$$registeredAnimations=Object.create(null);this.register=function(d,e){if(d&&"."!==d.charAt(0))throw Nd("notcsel",d);var f=d+"-animation";c.$$registeredAnimations[d.substr(1)]=f;a.factory(f,e)};this.classNameFilter=function(a){if(1===arguments.length&&(this.$$classNameFilter=a instanceof RegExp?a:null)&&/(\s+|\/)ng-animate(\s+|\/)/.test(this.$$classNameFilter.toString()))throw Nd("nongcls",
"ng-animate");return this.$$classNameFilter};this.$get=["$$animateQueue",function(a){function c(a,d,e){if(e){var l;a:{for(l=0;l<e.length;l++){var k=e[l];if(1===k.nodeType){l=k;break a}}l=void 0}!l||l.parentNode||l.previousElementSibling||(e=null)}e?e.after(a):d.prepend(a)}return{on:a.on,off:a.off,pin:a.pin,enabled:a.enabled,cancel:function(a){a.end&&a.end()},enter:function(f,h,g,l){h=h&&B(h);g=g&&B(g);h=h||g.parent();c(f,h,g);return a.push(f,"enter",Ia(l))},move:function(f,h,g,l){h=h&&B(h);g=g&&B(g);
h=h||g.parent();c(f,h,g);return a.push(f,"move",Ia(l))},leave:function(c,e){return a.push(c,"leave",Ia(e),function(){c.remove()})},addClass:function(c,e,g){g=Ia(g);g.addClass=ib(g.addclass,e);return a.push(c,"addClass",g)},removeClass:function(c,e,g){g=Ia(g);g.removeClass=ib(g.removeClass,e);return a.push(c,"removeClass",g)},setClass:function(c,e,g,l){l=Ia(l);l.addClass=ib(l.addClass,e);l.removeClass=ib(l.removeClass,g);return a.push(c,"setClass",l)},animate:function(c,e,g,l,k){k=Ia(k);k.from=k.from?
P(k.from,e):e;k.to=k.to?P(k.to,g):g;k.tempClasses=ib(k.tempClasses,l||"ng-inline-animate");return a.push(c,"animate",k)}}}]}],Se=function(){this.$get=["$$rAF","$q",function(a,c){var d=function(){};d.prototype={done:function(a){this.defer&&this.defer[!0===a?"reject":"resolve"]()},end:function(){this.done()},cancel:function(){this.done(!0)},getPromise:function(){this.defer||(this.defer=c.defer());return this.defer.promise},then:function(a,c){return this.getPromise().then(a,c)},"catch":function(a){return this.getPromise()["catch"](a)},
"finally":function(a){return this.getPromise()["finally"](a)}};return function(c,f){function h(){a(function(){f.addClass&&(c.addClass(f.addClass),f.addClass=null);f.removeClass&&(c.removeClass(f.removeClass),f.removeClass=null);f.to&&(c.css(f.to),f.to=null);g||l.done();g=!0});return l}f.cleanupStyles&&(f.from=f.to=null);f.from&&(c.css(f.from),f.from=null);var g,l=new d;return{start:h,end:h}}}]},ga=I("$compile");Dc.$inject=["$provide","$$sanitizeUriProvider"];var Wc=/^((?:x|data)[\:\-_])/i,Of=I("$controller"),
Vc=/^(\S+)(\s+as\s+(\w+))?$/,$e=function(){this.$get=["$document",function(a){return function(c){c?!c.nodeType&&c instanceof B&&(c=c[0]):c=a[0].body;return c.offsetWidth+1}}]},ad="application/json",$b={"Content-Type":ad+";charset=utf-8"},Qf=/^\[|^\{(?!\{)/,Rf={"[":/]$/,"{":/}$/},Pf=/^\)\]\}',?\n/,og=I("$http"),ed=function(a){return function(){throw og("legacy",a);}},La=da.$interpolateMinErr=I("$interpolate");La.throwNoconcat=function(a){throw La("noconcat",a);};La.interr=function(a,c){return La("interr",
a,c.toString())};var pg=/^([^\?#]*)(\?([^#]*))?(#(.*))?$/,Tf={http:80,https:443,ftp:21},Db=I("$location"),qg={$$html5:!1,$$replace:!1,absUrl:Eb("$$absUrl"),url:function(a){if(v(a))return this.$$url;var c=pg.exec(a);(c[1]||""===a)&&this.path(decodeURIComponent(c[1]));(c[2]||c[1]||""===a)&&this.search(c[3]||"");this.hash(c[5]||"");return this},protocol:Eb("$$protocol"),host:Eb("$$host"),port:Eb("$$port"),path:jd("$$path",function(a){a=null!==a?a.toString():"";return"/"==a.charAt(0)?a:"/"+a}),search:function(a,
c){switch(arguments.length){case 0:return this.$$search;case 1:if(G(a)||V(a))a=a.toString(),this.$$search=yc(a);else if(C(a))a=ha(a,{}),m(a,function(c,e){null==c&&delete a[e]}),this.$$search=a;else throw Db("isrcharg");break;default:v(c)||null===c?delete this.$$search[a]:this.$$search[a]=c}this.$$compose();return this},hash:jd("$$hash",function(a){return null!==a?a.toString():""}),replace:function(){this.$$replace=!0;return this}};m([id,cc,bc],function(a){a.prototype=Object.create(qg);a.prototype.state=
function(c){if(!arguments.length)return this.$$state;if(a!==bc||!this.$$html5)throw Db("nostate");this.$$state=v(c)?null:c;return this}});var Z=I("$parse"),Uf=Function.prototype.call,Vf=Function.prototype.apply,Wf=Function.prototype.bind,Lb=fa();m("+ - * / % === !== == != < > <= >= && || ! = |".split(" "),function(a){Lb[a]=!0});var rg={n:"\n",f:"\f",r:"\r",t:"\t",v:"\v","'":"'",'"':'"'},ec=function(a){this.options=a};ec.prototype={constructor:ec,lex:function(a){this.text=a;this.index=0;for(this.tokens=
[];this.index<this.text.length;)if(a=this.text.charAt(this.index),'"'===a||"'"===a)this.readString(a);else if(this.isNumber(a)||"."===a&&this.isNumber(this.peek()))this.readNumber();else if(this.isIdent(a))this.readIdent();else if(this.is(a,"(){}[].,;:?"))this.tokens.push({index:this.index,text:a}),this.index++;else if(this.isWhitespace(a))this.index++;else{var c=a+this.peek(),d=c+this.peek(2),e=Lb[c],f=Lb[d];Lb[a]||e||f?(a=f?d:e?c:a,this.tokens.push({index:this.index,text:a,operator:!0}),this.index+=
a.length):this.throwError("Unexpected next character ",this.index,this.index+1)}return this.tokens},is:function(a,c){return-1!==c.indexOf(a)},peek:function(a){a=a||1;return this.index+a<this.text.length?this.text.charAt(this.index+a):!1},isNumber:function(a){return"0"<=a&&"9">=a&&"string"===typeof a},isWhitespace:function(a){return" "===a||"\r"===a||"\t"===a||"\n"===a||"\v"===a||"\u00a0"===a},isIdent:function(a){return"a"<=a&&"z">=a||"A"<=a&&"Z">=a||"_"===a||"$"===a},isExpOperator:function(a){return"-"===
a||"+"===a||this.isNumber(a)},throwError:function(a,c,d){d=d||this.index;c=A(c)?"s "+c+"-"+this.index+" ["+this.text.substring(c,d)+"]":" "+d;throw Z("lexerr",a,c,this.text);},readNumber:function(){for(var a="",c=this.index;this.index<this.text.length;){var d=F(this.text.charAt(this.index));if("."==d||this.isNumber(d))a+=d;else{var e=this.peek();if("e"==d&&this.isExpOperator(e))a+=d;else if(this.isExpOperator(d)&&e&&this.isNumber(e)&&"e"==a.charAt(a.length-1))a+=d;else if(!this.isExpOperator(d)||
e&&this.isNumber(e)||"e"!=a.charAt(a.length-1))break;else this.throwError("Invalid exponent")}this.index++}this.tokens.push({index:c,text:a,constant:!0,value:Number(a)})},readIdent:function(){for(var a=this.index;this.index<this.text.length;){var c=this.text.charAt(this.index);if(!this.isIdent(c)&&!this.isNumber(c))break;this.index++}this.tokens.push({index:a,text:this.text.slice(a,this.index),identifier:!0})},readString:function(a){var c=this.index;this.index++;for(var d="",e=a,f=!1;this.index<this.text.length;){var h=
this.text.charAt(this.index),e=e+h;if(f)"u"===h?(f=this.text.substring(this.index+1,this.index+5),f.match(/[\da-f]{4}/i)||this.throwError("Invalid unicode escape [\\u"+f+"]"),this.index+=4,d+=String.fromCharCode(parseInt(f,16))):d+=rg[h]||h,f=!1;else if("\\"===h)f=!0;else{if(h===a){this.index++;this.tokens.push({index:c,text:e,constant:!0,value:d});return}d+=h}this.index++}this.throwError("Unterminated quote",c)}};var s=function(a,c){this.lexer=a;this.options=c};s.Program="Program";s.ExpressionStatement=
"ExpressionStatement";s.AssignmentExpression="AssignmentExpression";s.ConditionalExpression="ConditionalExpression";s.LogicalExpression="LogicalExpression";s.BinaryExpression="BinaryExpression";s.UnaryExpression="UnaryExpression";s.CallExpression="CallExpression";s.MemberExpression="MemberExpression";s.Identifier="Identifier";s.Literal="Literal";s.ArrayExpression="ArrayExpression";s.Property="Property";s.ObjectExpression="ObjectExpression";s.ThisExpression="ThisExpression";s.NGValueParameter="NGValueParameter";
s.prototype={ast:function(a){this.text=a;this.tokens=this.lexer.lex(a);a=this.program();0!==this.tokens.length&&this.throwError("is an unexpected token",this.tokens[0]);return a},program:function(){for(var a=[];;)if(0<this.tokens.length&&!this.peek("}",")",";","]")&&a.push(this.expressionStatement()),!this.expect(";"))return{type:s.Program,body:a}},expressionStatement:function(){return{type:s.ExpressionStatement,expression:this.filterChain()}},filterChain:function(){for(var a=this.expression();this.expect("|");)a=
this.filter(a);return a},expression:function(){return this.assignment()},assignment:function(){var a=this.ternary();this.expect("=")&&(a={type:s.AssignmentExpression,left:a,right:this.assignment(),operator:"="});return a},ternary:function(){var a=this.logicalOR(),c,d;return this.expect("?")&&(c=this.expression(),this.consume(":"))?(d=this.expression(),{type:s.ConditionalExpression,test:a,alternate:c,consequent:d}):a},logicalOR:function(){for(var a=this.logicalAND();this.expect("||");)a={type:s.LogicalExpression,
operator:"||",left:a,right:this.logicalAND()};return a},logicalAND:function(){for(var a=this.equality();this.expect("&&");)a={type:s.LogicalExpression,operator:"&&",left:a,right:this.equality()};return a},equality:function(){for(var a=this.relational(),c;c=this.expect("==","!=","===","!==");)a={type:s.BinaryExpression,operator:c.text,left:a,right:this.relational()};return a},relational:function(){for(var a=this.additive(),c;c=this.expect("<",">","<=",">=");)a={type:s.BinaryExpression,operator:c.text,
left:a,right:this.additive()};return a},additive:function(){for(var a=this.multiplicative(),c;c=this.expect("+","-");)a={type:s.BinaryExpression,operator:c.text,left:a,right:this.multiplicative()};return a},multiplicative:function(){for(var a=this.unary(),c;c=this.expect("*","/","%");)a={type:s.BinaryExpression,operator:c.text,left:a,right:this.unary()};return a},unary:function(){var a;return(a=this.expect("+","-","!"))?{type:s.UnaryExpression,operator:a.text,prefix:!0,argument:this.unary()}:this.primary()},
primary:function(){var a;this.expect("(")?(a=this.filterChain(),this.consume(")")):this.expect("[")?a=this.arrayDeclaration():this.expect("{")?a=this.object():this.constants.hasOwnProperty(this.peek().text)?a=ha(this.constants[this.consume().text]):this.peek().identifier?a=this.identifier():this.peek().constant?a=this.constant():this.throwError("not a primary expression",this.peek());for(var c;c=this.expect("(","[",".");)"("===c.text?(a={type:s.CallExpression,callee:a,arguments:this.parseArguments()},
this.consume(")")):"["===c.text?(a={type:s.MemberExpression,object:a,property:this.expression(),computed:!0},this.consume("]")):"."===c.text?a={type:s.MemberExpression,object:a,property:this.identifier(),computed:!1}:this.throwError("IMPOSSIBLE");return a},filter:function(a){a=[a];for(var c={type:s.CallExpression,callee:this.identifier(),arguments:a,filter:!0};this.expect(":");)a.push(this.expression());return c},parseArguments:function(){var a=[];if(")"!==this.peekToken().text){do a.push(this.expression());
while(this.expect(","))}return a},identifier:function(){var a=this.consume();a.identifier||this.throwError("is not a valid identifier",a);return{type:s.Identifier,name:a.text}},constant:function(){return{type:s.Literal,value:this.consume().value}},arrayDeclaration:function(){var a=[];if("]"!==this.peekToken().text){do{if(this.peek("]"))break;a.push(this.expression())}while(this.expect(","))}this.consume("]");return{type:s.ArrayExpression,elements:a}},object:function(){var a=[],c;if("}"!==this.peekToken().text){do{if(this.peek("}"))break;
c={type:s.Property,kind:"init"};this.peek().constant?c.key=this.constant():this.peek().identifier?c.key=this.identifier():this.throwError("invalid key",this.peek());this.consume(":");c.value=this.expression();a.push(c)}while(this.expect(","))}this.consume("}");return{type:s.ObjectExpression,properties:a}},throwError:function(a,c){throw Z("syntax",c.text,a,c.index+1,this.text,this.text.substring(c.index));},consume:function(a){if(0===this.tokens.length)throw Z("ueoe",this.text);var c=this.expect(a);
c||this.throwError("is unexpected, expecting ["+a+"]",this.peek());return c},peekToken:function(){if(0===this.tokens.length)throw Z("ueoe",this.text);return this.tokens[0]},peek:function(a,c,d,e){return this.peekAhead(0,a,c,d,e)},peekAhead:function(a,c,d,e,f){if(this.tokens.length>a){a=this.tokens[a];var h=a.text;if(h===c||h===d||h===e||h===f||!(c||d||e||f))return a}return!1},expect:function(a,c,d,e){return(a=this.peek(a,c,d,e))?(this.tokens.shift(),a):!1},constants:{"true":{type:s.Literal,value:!0},
"false":{type:s.Literal,value:!1},"null":{type:s.Literal,value:null},undefined:{type:s.Literal,value:w},"this":{type:s.ThisExpression}}};sd.prototype={compile:function(a,c){var d=this,e=this.astBuilder.ast(a);this.state={nextId:0,filters:{},expensiveChecks:c,fn:{vars:[],body:[],own:{}},assign:{vars:[],body:[],own:{}},inputs:[]};U(e,d.$filter);var f="",h;this.stage="assign";if(h=qd(e))this.state.computing="assign",f=this.nextId(),this.recurse(h,f),this.return_(f),f="fn.assign="+this.generateFunction("assign",
"s,v,l");h=od(e.body);d.stage="inputs";m(h,function(a,c){var e="fn"+c;d.state[e]={vars:[],body:[],own:{}};d.state.computing=e;var f=d.nextId();d.recurse(a,f);d.return_(f);d.state.inputs.push(e);a.watchId=c});this.state.computing="fn";this.stage="main";this.recurse(e);f='"'+this.USE+" "+this.STRICT+'";\n'+this.filterPrefix()+"var fn="+this.generateFunction("fn","s,l,a,i")+f+this.watchFns()+"return fn;";f=(new Function("$filter","ensureSafeMemberName","ensureSafeObject","ensureSafeFunction","getStringValue",
"ensureSafeAssignContext","ifDefined","plus","text",f))(this.$filter,Xa,Ba,ld,kd,md,Xf,nd,a);this.state=this.stage=w;f.literal=rd(e);f.constant=e.constant;return f},USE:"use",STRICT:"strict",watchFns:function(){var a=[],c=this.state.inputs,d=this;m(c,function(c){a.push("var "+c+"="+d.generateFunction(c,"s"))});c.length&&a.push("fn.inputs=["+c.join(",")+"];");return a.join("")},generateFunction:function(a,c){return"function("+c+"){"+this.varsPrefix(a)+this.body(a)+"};"},filterPrefix:function(){var a=
[],c=this;m(this.state.filters,function(d,e){a.push(d+"=$filter("+c.escape(e)+")")});return a.length?"var "+a.join(",")+";":""},varsPrefix:function(a){return this.state[a].vars.length?"var "+this.state[a].vars.join(",")+";":""},body:function(a){return this.state[a].body.join("")},recurse:function(a,c,d,e,f,h){var g,l,k=this,n,p;e=e||y;if(!h&&A(a.watchId))c=c||this.nextId(),this.if_("i",this.lazyAssign(c,this.computedMember("i",a.watchId)),this.lazyRecurse(a,c,d,e,f,!0));else switch(a.type){case s.Program:m(a.body,
function(c,d){k.recurse(c.expression,w,w,function(a){l=a});d!==a.body.length-1?k.current().body.push(l,";"):k.return_(l)});break;case s.Literal:p=this.escape(a.value);this.assign(c,p);e(p);break;case s.UnaryExpression:this.recurse(a.argument,w,w,function(a){l=a});p=a.operator+"("+this.ifDefined(l,0)+")";this.assign(c,p);e(p);break;case s.BinaryExpression:this.recurse(a.left,w,w,function(a){g=a});this.recurse(a.right,w,w,function(a){l=a});p="+"===a.operator?this.plus(g,l):"-"===a.operator?this.ifDefined(g,
0)+a.operator+this.ifDefined(l,0):"("+g+")"+a.operator+"("+l+")";this.assign(c,p);e(p);break;case s.LogicalExpression:c=c||this.nextId();k.recurse(a.left,c);k.if_("&&"===a.operator?c:k.not(c),k.lazyRecurse(a.right,c));e(c);break;case s.ConditionalExpression:c=c||this.nextId();k.recurse(a.test,c);k.if_(c,k.lazyRecurse(a.alternate,c),k.lazyRecurse(a.consequent,c));e(c);break;case s.Identifier:c=c||this.nextId();d&&(d.context="inputs"===k.stage?"s":this.assign(this.nextId(),this.getHasOwnProperty("l",
a.name)+"?l:s"),d.computed=!1,d.name=a.name);Xa(a.name);k.if_("inputs"===k.stage||k.not(k.getHasOwnProperty("l",a.name)),function(){k.if_("inputs"===k.stage||"s",function(){f&&1!==f&&k.if_(k.not(k.nonComputedMember("s",a.name)),k.lazyAssign(k.nonComputedMember("s",a.name),"{}"));k.assign(c,k.nonComputedMember("s",a.name))})},c&&k.lazyAssign(c,k.nonComputedMember("l",a.name)));(k.state.expensiveChecks||Fb(a.name))&&k.addEnsureSafeObject(c);e(c);break;case s.MemberExpression:g=d&&(d.context=this.nextId())||
this.nextId();c=c||this.nextId();k.recurse(a.object,g,w,function(){k.if_(k.notNull(g),function(){if(a.computed)l=k.nextId(),k.recurse(a.property,l),k.getStringValue(l),k.addEnsureSafeMemberName(l),f&&1!==f&&k.if_(k.not(k.computedMember(g,l)),k.lazyAssign(k.computedMember(g,l),"{}")),p=k.ensureSafeObject(k.computedMember(g,l)),k.assign(c,p),d&&(d.computed=!0,d.name=l);else{Xa(a.property.name);f&&1!==f&&k.if_(k.not(k.nonComputedMember(g,a.property.name)),k.lazyAssign(k.nonComputedMember(g,a.property.name),
"{}"));p=k.nonComputedMember(g,a.property.name);if(k.state.expensiveChecks||Fb(a.property.name))p=k.ensureSafeObject(p);k.assign(c,p);d&&(d.computed=!1,d.name=a.property.name)}},function(){k.assign(c,"undefined")});e(c)},!!f);break;case s.CallExpression:c=c||this.nextId();a.filter?(l=k.filter(a.callee.name),n=[],m(a.arguments,function(a){var c=k.nextId();k.recurse(a,c);n.push(c)}),p=l+"("+n.join(",")+")",k.assign(c,p),e(c)):(l=k.nextId(),g={},n=[],k.recurse(a.callee,l,g,function(){k.if_(k.notNull(l),
function(){k.addEnsureSafeFunction(l);m(a.arguments,function(a){k.recurse(a,k.nextId(),w,function(a){n.push(k.ensureSafeObject(a))})});g.name?(k.state.expensiveChecks||k.addEnsureSafeObject(g.context),p=k.member(g.context,g.name,g.computed)+"("+n.join(",")+")"):p=l+"("+n.join(",")+")";p=k.ensureSafeObject(p);k.assign(c,p)},function(){k.assign(c,"undefined")});e(c)}));break;case s.AssignmentExpression:l=this.nextId();g={};if(!pd(a.left))throw Z("lval");this.recurse(a.left,w,g,function(){k.if_(k.notNull(g.context),
function(){k.recurse(a.right,l);k.addEnsureSafeObject(k.member(g.context,g.name,g.computed));k.addEnsureSafeAssignContext(g.context);p=k.member(g.context,g.name,g.computed)+a.operator+l;k.assign(c,p);e(c||p)})},1);break;case s.ArrayExpression:n=[];m(a.elements,function(a){k.recurse(a,k.nextId(),w,function(a){n.push(a)})});p="["+n.join(",")+"]";this.assign(c,p);e(p);break;case s.ObjectExpression:n=[];m(a.properties,function(a){k.recurse(a.value,k.nextId(),w,function(c){n.push(k.escape(a.key.type===
s.Identifier?a.key.name:""+a.key.value)+":"+c)})});p="{"+n.join(",")+"}";this.assign(c,p);e(p);break;case s.ThisExpression:this.assign(c,"s");e("s");break;case s.NGValueParameter:this.assign(c,"v"),e("v")}},getHasOwnProperty:function(a,c){var d=a+"."+c,e=this.current().own;e.hasOwnProperty(d)||(e[d]=this.nextId(!1,a+"&&("+this.escape(c)+" in "+a+")"));return e[d]},assign:function(a,c){if(a)return this.current().body.push(a,"=",c,";"),a},filter:function(a){this.state.filters.hasOwnProperty(a)||(this.state.filters[a]=
this.nextId(!0));return this.state.filters[a]},ifDefined:function(a,c){return"ifDefined("+a+","+this.escape(c)+")"},plus:function(a,c){return"plus("+a+","+c+")"},return_:function(a){this.current().body.push("return ",a,";")},if_:function(a,c,d){if(!0===a)c();else{var e=this.current().body;e.push("if(",a,"){");c();e.push("}");d&&(e.push("else{"),d(),e.push("}"))}},not:function(a){return"!("+a+")"},notNull:function(a){return a+"!=null"},nonComputedMember:function(a,c){return a+"."+c},computedMember:function(a,
c){return a+"["+c+"]"},member:function(a,c,d){return d?this.computedMember(a,c):this.nonComputedMember(a,c)},addEnsureSafeObject:function(a){this.current().body.push(this.ensureSafeObject(a),";")},addEnsureSafeMemberName:function(a){this.current().body.push(this.ensureSafeMemberName(a),";")},addEnsureSafeFunction:function(a){this.current().body.push(this.ensureSafeFunction(a),";")},addEnsureSafeAssignContext:function(a){this.current().body.push(this.ensureSafeAssignContext(a),";")},ensureSafeObject:function(a){return"ensureSafeObject("+
a+",text)"},ensureSafeMemberName:function(a){return"ensureSafeMemberName("+a+",text)"},ensureSafeFunction:function(a){return"ensureSafeFunction("+a+",text)"},getStringValue:function(a){this.assign(a,"getStringValue("+a+",text)")},ensureSafeAssignContext:function(a){return"ensureSafeAssignContext("+a+",text)"},lazyRecurse:function(a,c,d,e,f,h){var g=this;return function(){g.recurse(a,c,d,e,f,h)}},lazyAssign:function(a,c){var d=this;return function(){d.assign(a,c)}},stringEscapeRegex:/[^ a-zA-Z0-9]/g,
stringEscapeFn:function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)},escape:function(a){if(G(a))return"'"+a.replace(this.stringEscapeRegex,this.stringEscapeFn)+"'";if(V(a))return a.toString();if(!0===a)return"true";if(!1===a)return"false";if(null===a)return"null";if("undefined"===typeof a)return"undefined";throw Z("esc");},nextId:function(a,c){var d="v"+this.state.nextId++;a||this.current().vars.push(d+(c?"="+c:""));return d},current:function(){return this.state[this.state.computing]}};
td.prototype={compile:function(a,c){var d=this,e=this.astBuilder.ast(a);this.expression=a;this.expensiveChecks=c;U(e,d.$filter);var f,h;if(f=qd(e))h=this.recurse(f);f=od(e.body);var g;f&&(g=[],m(f,function(a,c){var e=d.recurse(a);a.input=e;g.push(e);a.watchId=c}));var l=[];m(e.body,function(a){l.push(d.recurse(a.expression))});f=0===e.body.length?function(){}:1===e.body.length?l[0]:function(a,c){var d;m(l,function(e){d=e(a,c)});return d};h&&(f.assign=function(a,c,d){return h(a,d,c)});g&&(f.inputs=
g);f.literal=rd(e);f.constant=e.constant;return f},recurse:function(a,c,d){var e,f,h=this,g;if(a.input)return this.inputs(a.input,a.watchId);switch(a.type){case s.Literal:return this.value(a.value,c);case s.UnaryExpression:return f=this.recurse(a.argument),this["unary"+a.operator](f,c);case s.BinaryExpression:return e=this.recurse(a.left),f=this.recurse(a.right),this["binary"+a.operator](e,f,c);case s.LogicalExpression:return e=this.recurse(a.left),f=this.recurse(a.right),this["binary"+a.operator](e,
f,c);case s.ConditionalExpression:return this["ternary?:"](this.recurse(a.test),this.recurse(a.alternate),this.recurse(a.consequent),c);case s.Identifier:return Xa(a.name,h.expression),h.identifier(a.name,h.expensiveChecks||Fb(a.name),c,d,h.expression);case s.MemberExpression:return e=this.recurse(a.object,!1,!!d),a.computed||(Xa(a.property.name,h.expression),f=a.property.name),a.computed&&(f=this.recurse(a.property)),a.computed?this.computedMember(e,f,c,d,h.expression):this.nonComputedMember(e,f,
h.expensiveChecks,c,d,h.expression);case s.CallExpression:return g=[],m(a.arguments,function(a){g.push(h.recurse(a))}),a.filter&&(f=this.$filter(a.callee.name)),a.filter||(f=this.recurse(a.callee,!0)),a.filter?function(a,d,e,h){for(var r=[],m=0;m<g.length;++m)r.push(g[m](a,d,e,h));a=f.apply(w,r,h);return c?{context:w,name:w,value:a}:a}:function(a,d,e,p){var r=f(a,d,e,p),m;if(null!=r.value){Ba(r.context,h.expression);ld(r.value,h.expression);m=[];for(var s=0;s<g.length;++s)m.push(Ba(g[s](a,d,e,p),
h.expression));m=Ba(r.value.apply(r.context,m),h.expression)}return c?{value:m}:m};case s.AssignmentExpression:return e=this.recurse(a.left,!0,1),f=this.recurse(a.right),function(a,d,g,p){var r=e(a,d,g,p);a=f(a,d,g,p);Ba(r.value,h.expression);md(r.context);r.context[r.name]=a;return c?{value:a}:a};case s.ArrayExpression:return g=[],m(a.elements,function(a){g.push(h.recurse(a))}),function(a,d,e,f){for(var h=[],m=0;m<g.length;++m)h.push(g[m](a,d,e,f));return c?{value:h}:h};case s.ObjectExpression:return g=
[],m(a.properties,function(a){g.push({key:a.key.type===s.Identifier?a.key.name:""+a.key.value,value:h.recurse(a.value)})}),function(a,d,e,f){for(var h={},m=0;m<g.length;++m)h[g[m].key]=g[m].value(a,d,e,f);return c?{value:h}:h};case s.ThisExpression:return function(a){return c?{value:a}:a};case s.NGValueParameter:return function(a,d,e,f){return c?{value:e}:e}}},"unary+":function(a,c){return function(d,e,f,h){d=a(d,e,f,h);d=A(d)?+d:0;return c?{value:d}:d}},"unary-":function(a,c){return function(d,e,
f,h){d=a(d,e,f,h);d=A(d)?-d:0;return c?{value:d}:d}},"unary!":function(a,c){return function(d,e,f,h){d=!a(d,e,f,h);return c?{value:d}:d}},"binary+":function(a,c,d){return function(e,f,h,g){var l=a(e,f,h,g);e=c(e,f,h,g);l=nd(l,e);return d?{value:l}:l}},"binary-":function(a,c,d){return function(e,f,h,g){var l=a(e,f,h,g);e=c(e,f,h,g);l=(A(l)?l:0)-(A(e)?e:0);return d?{value:l}:l}},"binary*":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)*c(e,f,h,g);return d?{value:e}:e}},"binary/":function(a,c,
d){return function(e,f,h,g){e=a(e,f,h,g)/c(e,f,h,g);return d?{value:e}:e}},"binary%":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)%c(e,f,h,g);return d?{value:e}:e}},"binary===":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)===c(e,f,h,g);return d?{value:e}:e}},"binary!==":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)!==c(e,f,h,g);return d?{value:e}:e}},"binary==":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)==c(e,f,h,g);return d?{value:e}:e}},"binary!=":function(a,c,
d){return function(e,f,h,g){e=a(e,f,h,g)!=c(e,f,h,g);return d?{value:e}:e}},"binary<":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)<c(e,f,h,g);return d?{value:e}:e}},"binary>":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)>c(e,f,h,g);return d?{value:e}:e}},"binary<=":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)<=c(e,f,h,g);return d?{value:e}:e}},"binary>=":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)>=c(e,f,h,g);return d?{value:e}:e}},"binary&&":function(a,c,d){return function(e,
f,h,g){e=a(e,f,h,g)&&c(e,f,h,g);return d?{value:e}:e}},"binary||":function(a,c,d){return function(e,f,h,g){e=a(e,f,h,g)||c(e,f,h,g);return d?{value:e}:e}},"ternary?:":function(a,c,d,e){return function(f,h,g,l){f=a(f,h,g,l)?c(f,h,g,l):d(f,h,g,l);return e?{value:f}:f}},value:function(a,c){return function(){return c?{context:w,name:w,value:a}:a}},identifier:function(a,c,d,e,f){return function(h,g,l,k){h=g&&a in g?g:h;e&&1!==e&&h&&!h[a]&&(h[a]={});g=h?h[a]:w;c&&Ba(g,f);return d?{context:h,name:a,value:g}:
g}},computedMember:function(a,c,d,e,f){return function(h,g,l,k){var n=a(h,g,l,k),p,m;null!=n&&(p=c(h,g,l,k),p=kd(p),Xa(p,f),e&&1!==e&&n&&!n[p]&&(n[p]={}),m=n[p],Ba(m,f));return d?{context:n,name:p,value:m}:m}},nonComputedMember:function(a,c,d,e,f,h){return function(g,l,k,n){g=a(g,l,k,n);f&&1!==f&&g&&!g[c]&&(g[c]={});l=null!=g?g[c]:w;(d||Fb(c))&&Ba(l,h);return e?{context:g,name:c,value:l}:l}},inputs:function(a,c){return function(d,e,f,h){return h?h[c]:a(d,e,f)}}};var fc=function(a,c,d){this.lexer=
a;this.$filter=c;this.options=d;this.ast=new s(this.lexer);this.astCompiler=d.csp?new td(this.ast,c):new sd(this.ast,c)};fc.prototype={constructor:fc,parse:function(a){return this.astCompiler.compile(a,this.options.expensiveChecks)}};fa();fa();var Yf=Object.prototype.valueOf,Ca=I("$sce"),oa={HTML:"html",CSS:"css",URL:"url",RESOURCE_URL:"resourceUrl",JS:"js"},ga=I("$compile"),$=X.createElement("a"),xd=Aa(Q.location.href);yd.$inject=["$document"];Kc.$inject=["$provide"];zd.$inject=["$locale"];Bd.$inject=
["$locale"];var hc=".",hg={yyyy:aa("FullYear",4),yy:aa("FullYear",2,0,!0),y:aa("FullYear",1),MMMM:Hb("Month"),MMM:Hb("Month",!0),MM:aa("Month",2,1),M:aa("Month",1,1),dd:aa("Date",2),d:aa("Date",1),HH:aa("Hours",2),H:aa("Hours",1),hh:aa("Hours",2,-12),h:aa("Hours",1,-12),mm:aa("Minutes",2),m:aa("Minutes",1),ss:aa("Seconds",2),s:aa("Seconds",1),sss:aa("Milliseconds",3),EEEE:Hb("Day"),EEE:Hb("Day",!0),a:function(a,c){return 12>a.getHours()?c.AMPMS[0]:c.AMPMS[1]},Z:function(a,c,d){a=-1*d;return a=(0<=
a?"+":"")+(Gb(Math[0<a?"floor":"ceil"](a/60),2)+Gb(Math.abs(a%60),2))},ww:Fd(2),w:Fd(1),G:ic,GG:ic,GGG:ic,GGGG:function(a,c){return 0>=a.getFullYear()?c.ERANAMES[0]:c.ERANAMES[1]}},gg=/((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,fg=/^\-?\d+$/;Ad.$inject=["$locale"];var cg=qa(F),dg=qa(sb);Cd.$inject=["$parse"];var he=qa({restrict:"E",compile:function(a,c){if(!c.href&&!c.xlinkHref)return function(a,c){if("a"===c[0].nodeName.toLowerCase()){var f="[object SVGAnimatedString]"===
va.call(c.prop("href"))?"xlink:href":"href";c.on("click",function(a){c.attr(f)||a.preventDefault()})}}}}),tb={};m(Bb,function(a,c){function d(a,d,f){a.$watch(f[e],function(a){f.$set(c,!!a)})}if("multiple"!=a){var e=ya("ng-"+c),f=d;"checked"===a&&(f=function(a,c,f){f.ngModel!==f[e]&&d(a,c,f)});tb[e]=function(){return{restrict:"A",priority:100,link:f}}}});m($c,function(a,c){tb[c]=function(){return{priority:100,link:function(a,e,f){if("ngPattern"===c&&"/"==f.ngPattern.charAt(0)&&(e=f.ngPattern.match(jg))){f.$set("ngPattern",
new RegExp(e[1],e[2]));return}a.$watch(f[c],function(a){f.$set(c,a)})}}}});m(["src","srcset","href"],function(a){var c=ya("ng-"+a);tb[c]=function(){return{priority:99,link:function(d,e,f){var h=a,g=a;"href"===a&&"[object SVGAnimatedString]"===va.call(e.prop("href"))&&(g="xlinkHref",f.$attr[g]="xlink:href",h=null);f.$observe(c,function(c){c?(f.$set(g,c),Wa&&h&&e.prop(h,f[g])):"href"===a&&f.$set(g,null)})}}}});var Ib={$addControl:y,$$renameControl:function(a,c){a.$name=c},$removeControl:y,$setValidity:y,
$setDirty:y,$setPristine:y,$setSubmitted:y};Gd.$inject=["$element","$attrs","$scope","$animate","$interpolate"];var Od=function(a){return["$timeout","$parse",function(c,d){function e(a){return""===a?d('this[""]').assign:d(a).assign||y}return{name:"form",restrict:a?"EAC":"E",require:["form","^^?form"],controller:Gd,compile:function(d,h){d.addClass(Ya).addClass(mb);var g=h.name?"name":a&&h.ngForm?"ngForm":!1;return{pre:function(a,d,f,h){var m=h[0];if(!("action"in f)){var t=function(c){a.$apply(function(){m.$commitViewValue();
m.$setSubmitted()});c.preventDefault()};d[0].addEventListener("submit",t,!1);d.on("$destroy",function(){c(function(){d[0].removeEventListener("submit",t,!1)},0,!1)})}(h[1]||m.$$parentForm).$addControl(m);var s=g?e(m.$name):y;g&&(s(a,m),f.$observe(g,function(c){m.$name!==c&&(s(a,w),m.$$parentForm.$$renameControl(m,c),s=e(m.$name),s(a,m))}));d.on("$destroy",function(){m.$$parentForm.$removeControl(m);s(a,w);P(m,Ib)})}}}}}]},ie=Od(),ve=Od(!0),ig=/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/,
sg=/^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/,tg=/^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i,ug=/^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/,Pd=/^(\d{4})-(\d{2})-(\d{2})$/,Qd=/^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,lc=/^(\d{4})-W(\d\d)$/,Rd=/^(\d{4})-(\d\d)$/,Sd=/^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,Td={text:function(a,c,d,e,f,h){jb(a,c,d,e,f,h);jc(e)},date:kb("date",
Pd,Kb(Pd,["yyyy","MM","dd"]),"yyyy-MM-dd"),"datetime-local":kb("datetimelocal",Qd,Kb(Qd,"yyyy MM dd HH mm ss sss".split(" ")),"yyyy-MM-ddTHH:mm:ss.sss"),time:kb("time",Sd,Kb(Sd,["HH","mm","ss","sss"]),"HH:mm:ss.sss"),week:kb("week",lc,function(a,c){if(ea(a))return a;if(G(a)){lc.lastIndex=0;var d=lc.exec(a);if(d){var e=+d[1],f=+d[2],h=d=0,g=0,l=0,k=Ed(e),f=7*(f-1);c&&(d=c.getHours(),h=c.getMinutes(),g=c.getSeconds(),l=c.getMilliseconds());return new Date(e,0,k.getDate()+f,d,h,g,l)}}return NaN},"yyyy-Www"),
month:kb("month",Rd,Kb(Rd,["yyyy","MM"]),"yyyy-MM"),number:function(a,c,d,e,f,h){Id(a,c,d,e);jb(a,c,d,e,f,h);e.$$parserName="number";e.$parsers.push(function(a){return e.$isEmpty(a)?null:ug.test(a)?parseFloat(a):w});e.$formatters.push(function(a){if(!e.$isEmpty(a)){if(!V(a))throw lb("numfmt",a);a=a.toString()}return a});if(A(d.min)||d.ngMin){var g;e.$validators.min=function(a){return e.$isEmpty(a)||v(g)||a>=g};d.$observe("min",function(a){A(a)&&!V(a)&&(a=parseFloat(a,10));g=V(a)&&!isNaN(a)?a:w;e.$validate()})}if(A(d.max)||
d.ngMax){var l;e.$validators.max=function(a){return e.$isEmpty(a)||v(l)||a<=l};d.$observe("max",function(a){A(a)&&!V(a)&&(a=parseFloat(a,10));l=V(a)&&!isNaN(a)?a:w;e.$validate()})}},url:function(a,c,d,e,f,h){jb(a,c,d,e,f,h);jc(e);e.$$parserName="url";e.$validators.url=function(a,c){var d=a||c;return e.$isEmpty(d)||sg.test(d)}},email:function(a,c,d,e,f,h){jb(a,c,d,e,f,h);jc(e);e.$$parserName="email";e.$validators.email=function(a,c){var d=a||c;return e.$isEmpty(d)||tg.test(d)}},radio:function(a,c,
d,e){v(d.name)&&c.attr("name",++nb);c.on("click",function(a){c[0].checked&&e.$setViewValue(d.value,a&&a.type)});e.$render=function(){c[0].checked=d.value==e.$viewValue};d.$observe("value",e.$render)},checkbox:function(a,c,d,e,f,h,g,l){var k=Jd(l,a,"ngTrueValue",d.ngTrueValue,!0),n=Jd(l,a,"ngFalseValue",d.ngFalseValue,!1);c.on("click",function(a){e.$setViewValue(c[0].checked,a&&a.type)});e.$render=function(){c[0].checked=e.$viewValue};e.$isEmpty=function(a){return!1===a};e.$formatters.push(function(a){return ka(a,
k)});e.$parsers.push(function(a){return a?k:n})},hidden:y,button:y,submit:y,reset:y,file:y},Ec=["$browser","$sniffer","$filter","$parse",function(a,c,d,e){return{restrict:"E",require:["?ngModel"],link:{pre:function(f,h,g,l){l[0]&&(Td[F(g.type)]||Td.text)(f,h,g,l[0],c,a,d,e)}}}}],vg=/^(true|false|\d+)$/,Ne=function(){return{restrict:"A",priority:100,compile:function(a,c){return vg.test(c.ngValue)?function(a,c,f){f.$set("value",a.$eval(f.ngValue))}:function(a,c,f){a.$watch(f.ngValue,function(a){f.$set("value",
a)})}}}},ne=["$compile",function(a){return{restrict:"AC",compile:function(c){a.$$addBindingClass(c);return function(c,e,f){a.$$addBindingInfo(e,f.ngBind);e=e[0];c.$watch(f.ngBind,function(a){e.textContent=v(a)?"":a})}}}}],pe=["$interpolate","$compile",function(a,c){return{compile:function(d){c.$$addBindingClass(d);return function(d,f,h){d=a(f.attr(h.$attr.ngBindTemplate));c.$$addBindingInfo(f,d.expressions);f=f[0];h.$observe("ngBindTemplate",function(a){f.textContent=v(a)?"":a})}}}}],oe=["$sce","$parse",
"$compile",function(a,c,d){return{restrict:"A",compile:function(e,f){var h=c(f.ngBindHtml),g=c(f.ngBindHtml,function(a){return(a||"").toString()});d.$$addBindingClass(e);return function(c,e,f){d.$$addBindingInfo(e,f.ngBindHtml);c.$watch(g,function(){e.html(a.getTrustedHtml(h(c))||"")})}}}}],Me=qa({restrict:"A",require:"ngModel",link:function(a,c,d,e){e.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),qe=kc("",!0),se=kc("Odd",0),re=kc("Even",1),te=Na({compile:function(a,c){c.$set("ngCloak",
w);a.removeClass("ng-cloak")}}),ue=[function(){return{restrict:"A",scope:!0,controller:"@",priority:500}}],Jc={},wg={blur:!0,focus:!0};m("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "),function(a){var c=ya("ng-"+a);Jc[c]=["$parse","$rootScope",function(d,e){return{restrict:"A",compile:function(f,h){var g=d(h[c],null,!0);return function(c,d){d.on(a,function(d){var f=function(){g(c,{$event:d})};
wg[a]&&e.$$phase?c.$evalAsync(f):c.$apply(f)})}}}}]});var xe=["$animate",function(a){return{multiElement:!0,transclude:"element",priority:600,terminal:!0,restrict:"A",$$tlb:!0,link:function(c,d,e,f,h){var g,l,k;c.$watch(e.ngIf,function(c){c?l||h(function(c,f){l=f;c[c.length++]=X.createComment(" end ngIf: "+e.ngIf+" ");g={clone:c};a.enter(c,d.parent(),d)}):(k&&(k.remove(),k=null),l&&(l.$destroy(),l=null),g&&(k=rb(g.clone),a.leave(k).then(function(){k=null}),g=null))})}}}],ye=["$templateRequest","$anchorScroll",
"$animate",function(a,c,d){return{restrict:"ECA",priority:400,terminal:!0,transclude:"element",controller:da.noop,compile:function(e,f){var h=f.ngInclude||f.src,g=f.onload||"",l=f.autoscroll;return function(e,f,m,r,t){var s=0,v,u,q,z=function(){u&&(u.remove(),u=null);v&&(v.$destroy(),v=null);q&&(d.leave(q).then(function(){u=null}),u=q,q=null)};e.$watch(h,function(h){var m=function(){!A(l)||l&&!e.$eval(l)||c()},p=++s;h?(a(h,!0).then(function(a){if(p===s){var c=e.$new();r.template=a;a=t(c,function(a){z();
d.enter(a,null,f).then(m)});v=c;q=a;v.$emit("$includeContentLoaded",h);e.$eval(g)}},function(){p===s&&(z(),e.$emit("$includeContentError",h))}),e.$emit("$includeContentRequested",h)):(z(),r.template=null)})}}}}],Pe=["$compile",function(a){return{restrict:"ECA",priority:-400,require:"ngInclude",link:function(c,d,e,f){/SVG/.test(d[0].toString())?(d.empty(),a(Mc(f.template,X).childNodes)(c,function(a){d.append(a)},{futureParentElement:d})):(d.html(f.template),a(d.contents())(c))}}}],ze=Na({priority:450,
compile:function(){return{pre:function(a,c,d){a.$eval(d.ngInit)}}}}),Le=function(){return{restrict:"A",priority:100,require:"ngModel",link:function(a,c,d,e){var f=c.attr(d.$attr.ngList)||", ",h="false"!==d.ngTrim,g=h?T(f):f;e.$parsers.push(function(a){if(!v(a)){var c=[];a&&m(a.split(g),function(a){a&&c.push(h?T(a):a)});return c}});e.$formatters.push(function(a){return J(a)?a.join(f):w});e.$isEmpty=function(a){return!a||!a.length}}}},mb="ng-valid",Kd="ng-invalid",Ya="ng-pristine",Jb="ng-dirty",Md=
"ng-pending",lb=I("ngModel"),xg=["$scope","$exceptionHandler","$attrs","$element","$parse","$animate","$timeout","$rootScope","$q","$interpolate",function(a,c,d,e,f,h,g,l,k,n){this.$modelValue=this.$viewValue=Number.NaN;this.$$rawModelValue=w;this.$validators={};this.$asyncValidators={};this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$untouched=!0;this.$touched=!1;this.$pristine=!0;this.$dirty=!1;this.$valid=!0;this.$invalid=!1;this.$error={};this.$$success={};this.$pending=
w;this.$name=n(d.name||"",!1)(a);this.$$parentForm=Ib;var p=f(d.ngModel),r=p.assign,t=p,s=r,K=null,u,q=this;this.$$setOptions=function(a){if((q.$options=a)&&a.getterSetter){var c=f(d.ngModel+"()"),g=f(d.ngModel+"($$$p)");t=function(a){var d=p(a);x(d)&&(d=c(a));return d};s=function(a,c){x(p(a))?g(a,{$$$p:q.$modelValue}):r(a,q.$modelValue)}}else if(!p.assign)throw lb("nonassign",d.ngModel,xa(e));};this.$render=y;this.$isEmpty=function(a){return v(a)||""===a||null===a||a!==a};var z=0;Hd({ctrl:this,$element:e,
set:function(a,c){a[c]=!0},unset:function(a,c){delete a[c]},$animate:h});this.$setPristine=function(){q.$dirty=!1;q.$pristine=!0;h.removeClass(e,Jb);h.addClass(e,Ya)};this.$setDirty=function(){q.$dirty=!0;q.$pristine=!1;h.removeClass(e,Ya);h.addClass(e,Jb);q.$$parentForm.$setDirty()};this.$setUntouched=function(){q.$touched=!1;q.$untouched=!0;h.setClass(e,"ng-untouched","ng-touched")};this.$setTouched=function(){q.$touched=!0;q.$untouched=!1;h.setClass(e,"ng-touched","ng-untouched")};this.$rollbackViewValue=
function(){g.cancel(K);q.$viewValue=q.$$lastCommittedViewValue;q.$render()};this.$validate=function(){if(!V(q.$modelValue)||!isNaN(q.$modelValue)){var a=q.$$rawModelValue,c=q.$valid,d=q.$modelValue,e=q.$options&&q.$options.allowInvalid;q.$$runValidators(a,q.$$lastCommittedViewValue,function(f){e||c===f||(q.$modelValue=f?a:w,q.$modelValue!==d&&q.$$writeModelToScope())})}};this.$$runValidators=function(a,c,d){function e(){var d=!0;m(q.$validators,function(e,f){var h=e(a,c);d=d&&h;g(f,h)});return d?
!0:(m(q.$asyncValidators,function(a,c){g(c,null)}),!1)}function f(){var d=[],e=!0;m(q.$asyncValidators,function(f,h){var k=f(a,c);if(!k||!x(k.then))throw lb("$asyncValidators",k);g(h,w);d.push(k.then(function(){g(h,!0)},function(a){e=!1;g(h,!1)}))});d.length?k.all(d).then(function(){h(e)},y):h(!0)}function g(a,c){l===z&&q.$setValidity(a,c)}function h(a){l===z&&d(a)}z++;var l=z;(function(){var a=q.$$parserName||"parse";if(v(u))g(a,null);else return u||(m(q.$validators,function(a,c){g(c,null)}),m(q.$asyncValidators,
function(a,c){g(c,null)})),g(a,u),u;return!0})()?e()?f():h(!1):h(!1)};this.$commitViewValue=function(){var a=q.$viewValue;g.cancel(K);if(q.$$lastCommittedViewValue!==a||""===a&&q.$$hasNativeValidators)q.$$lastCommittedViewValue=a,q.$pristine&&this.$setDirty(),this.$$parseAndValidate()};this.$$parseAndValidate=function(){var c=q.$$lastCommittedViewValue;if(u=v(c)?w:!0)for(var d=0;d<q.$parsers.length;d++)if(c=q.$parsers[d](c),v(c)){u=!1;break}V(q.$modelValue)&&isNaN(q.$modelValue)&&(q.$modelValue=t(a));
var e=q.$modelValue,f=q.$options&&q.$options.allowInvalid;q.$$rawModelValue=c;f&&(q.$modelValue=c,q.$modelValue!==e&&q.$$writeModelToScope());q.$$runValidators(c,q.$$lastCommittedViewValue,function(a){f||(q.$modelValue=a?c:w,q.$modelValue!==e&&q.$$writeModelToScope())})};this.$$writeModelToScope=function(){s(a,q.$modelValue);m(q.$viewChangeListeners,function(a){try{a()}catch(d){c(d)}})};this.$setViewValue=function(a,c){q.$viewValue=a;q.$options&&!q.$options.updateOnDefault||q.$$debounceViewValueCommit(c)};
this.$$debounceViewValueCommit=function(c){var d=0,e=q.$options;e&&A(e.debounce)&&(e=e.debounce,V(e)?d=e:V(e[c])?d=e[c]:V(e["default"])&&(d=e["default"]));g.cancel(K);d?K=g(function(){q.$commitViewValue()},d):l.$$phase?q.$commitViewValue():a.$apply(function(){q.$commitViewValue()})};a.$watch(function(){var c=t(a);if(c!==q.$modelValue&&(q.$modelValue===q.$modelValue||c===c)){q.$modelValue=q.$$rawModelValue=c;u=w;for(var d=q.$formatters,e=d.length,f=c;e--;)f=d[e](f);q.$viewValue!==f&&(q.$viewValue=
q.$$lastCommittedViewValue=f,q.$render(),q.$$runValidators(c,f,y))}return c})}],Ke=["$rootScope",function(a){return{restrict:"A",require:["ngModel","^?form","^?ngModelOptions"],controller:xg,priority:1,compile:function(c){c.addClass(Ya).addClass("ng-untouched").addClass(mb);return{pre:function(a,c,f,h){var g=h[0];c=h[1]||g.$$parentForm;g.$$setOptions(h[2]&&h[2].$options);c.$addControl(g);f.$observe("name",function(a){g.$name!==a&&g.$$parentForm.$$renameControl(g,a)});a.$on("$destroy",function(){g.$$parentForm.$removeControl(g)})},
post:function(c,e,f,h){var g=h[0];if(g.$options&&g.$options.updateOn)e.on(g.$options.updateOn,function(a){g.$$debounceViewValueCommit(a&&a.type)});e.on("blur",function(e){g.$touched||(a.$$phase?c.$evalAsync(g.$setTouched):c.$apply(g.$setTouched))})}}}}}],yg=/(\s+|^)default(\s+|$)/,Oe=function(){return{restrict:"A",controller:["$scope","$attrs",function(a,c){var d=this;this.$options=ha(a.$eval(c.ngModelOptions));A(this.$options.updateOn)?(this.$options.updateOnDefault=!1,this.$options.updateOn=T(this.$options.updateOn.replace(yg,
function(){d.$options.updateOnDefault=!0;return" "}))):this.$options.updateOnDefault=!0}]}},Ae=Na({terminal:!0,priority:1E3}),zg=I("ngOptions"),Ag=/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,Ie=["$compile","$parse",function(a,c){function d(a,d,e){function f(a,c,d,e,g){this.selectValue=a;this.viewValue=c;this.label=
d;this.group=e;this.disabled=g}function n(a){var c;if(!s&&Da(a))c=a;else{c=[];for(var d in a)a.hasOwnProperty(d)&&"$"!==d.charAt(0)&&c.push(d)}return c}var m=a.match(Ag);if(!m)throw zg("iexp",a,xa(d));var r=m[5]||m[7],s=m[6];a=/ as /.test(m[0])&&m[1];var v=m[9];d=c(m[2]?m[1]:r);var w=a&&c(a)||d,u=v&&c(v),q=v?function(a,c){return u(e,c)}:function(a){return Ga(a)},z=function(a,c){return q(a,x(a,c))},y=c(m[2]||m[1]),A=c(m[3]||""),O=c(m[4]||""),H=c(m[8]),B={},x=s?function(a,c){B[s]=c;B[r]=a;return B}:
function(a){B[r]=a;return B};return{trackBy:v,getTrackByValue:z,getWatchables:c(H,function(a){var c=[];a=a||[];for(var d=n(a),f=d.length,g=0;g<f;g++){var h=a===d?g:d[g],k=x(a[h],h),h=q(a[h],k);c.push(h);if(m[2]||m[1])h=y(e,k),c.push(h);m[4]&&(k=O(e,k),c.push(k))}return c}),getOptions:function(){for(var a=[],c={},d=H(e)||[],g=n(d),h=g.length,m=0;m<h;m++){var p=d===g?m:g[m],r=x(d[p],p),s=w(e,r),p=q(s,r),t=y(e,r),u=A(e,r),r=O(e,r),s=new f(p,s,t,u,r);a.push(s);c[p]=s}return{items:a,selectValueMap:c,getOptionFromViewValue:function(a){return c[z(a)]},
getViewValueFromOption:function(a){return v?da.copy(a.viewValue):a.viewValue}}}}}var e=X.createElement("option"),f=X.createElement("optgroup");return{restrict:"A",terminal:!0,require:["select","?ngModel"],link:function(c,g,l,k){function n(a,c){a.element=c;c.disabled=a.disabled;a.label!==c.label&&(c.label=a.label,c.textContent=a.label);a.value!==c.value&&(c.value=a.selectValue)}function p(a,c,d,e){c&&F(c.nodeName)===d?d=c:(d=e.cloneNode(!1),c?a.insertBefore(d,c):a.appendChild(d));return d}function r(a){for(var c;a;)c=
a.nextSibling,Wb(a),a=c}function s(a){var c=q&&q[0],d=H&&H[0];if(c||d)for(;a&&(a===c||a===d||c&&8===c.nodeType);)a=a.nextSibling;return a}function v(){var a=x&&u.readValue();x=C.getOptions();var c={},d=g[0].firstChild;O&&g.prepend(q);d=s(d);x.items.forEach(function(a){var h,k;a.group?(h=c[a.group],h||(h=p(g[0],d,"optgroup",f),d=h.nextSibling,h.label=a.group,h=c[a.group]={groupElement:h,currentOptionElement:h.firstChild}),k=p(h.groupElement,h.currentOptionElement,"option",e),n(a,k),h.currentOptionElement=
k.nextSibling):(k=p(g[0],d,"option",e),n(a,k),d=k.nextSibling)});Object.keys(c).forEach(function(a){r(c[a].currentOptionElement)});r(d);w.$render();if(!w.$isEmpty(a)){var h=u.readValue();(C.trackBy?ka(a,h):a===h)||(w.$setViewValue(h),w.$render())}}var w=k[1];if(w){var u=k[0];k=l.multiple;for(var q,z=0,y=g.children(),A=y.length;z<A;z++)if(""===y[z].value){q=y.eq(z);break}var O=!!q,H=B(e.cloneNode(!1));H.val("?");var x,C=d(l.ngOptions,g,c);k?(w.$isEmpty=function(a){return!a||0===a.length},u.writeValue=
function(a){x.items.forEach(function(a){a.element.selected=!1});a&&a.forEach(function(a){(a=x.getOptionFromViewValue(a))&&!a.disabled&&(a.element.selected=!0)})},u.readValue=function(){var a=g.val()||[],c=[];m(a,function(a){(a=x.selectValueMap[a])&&!a.disabled&&c.push(x.getViewValueFromOption(a))});return c},C.trackBy&&c.$watchCollection(function(){if(J(w.$viewValue))return w.$viewValue.map(function(a){return C.getTrackByValue(a)})},function(){w.$render()})):(u.writeValue=function(a){var c=x.getOptionFromViewValue(a);
c&&!c.disabled?g[0].value!==c.selectValue&&(H.remove(),O||q.remove(),g[0].value=c.selectValue,c.element.selected=!0,c.element.setAttribute("selected","selected")):null===a||O?(H.remove(),O||g.prepend(q),g.val(""),q.prop("selected",!0),q.attr("selected",!0)):(O||q.remove(),g.prepend(H),g.val("?"),H.prop("selected",!0),H.attr("selected",!0))},u.readValue=function(){var a=x.selectValueMap[g.val()];return a&&!a.disabled?(O||q.remove(),H.remove(),x.getViewValueFromOption(a)):null},C.trackBy&&c.$watch(function(){return C.getTrackByValue(w.$viewValue)},
function(){w.$render()}));O?(q.remove(),a(q)(c),q.removeClass("ng-scope")):q=B(e.cloneNode(!1));v();c.$watchCollection(C.getWatchables,v)}}}}],Be=["$locale","$interpolate","$log",function(a,c,d){var e=/{}/g,f=/^when(Minus)?(.+)$/;return{link:function(h,g,l){function k(a){g.text(a||"")}var n=l.count,p=l.$attr.when&&g.attr(l.$attr.when),r=l.offset||0,s=h.$eval(p)||{},w={},A=c.startSymbol(),u=c.endSymbol(),q=A+n+"-"+r+u,z=da.noop,x;m(l,function(a,c){var d=f.exec(c);d&&(d=(d[1]?"-":"")+F(d[2]),s[d]=g.attr(l.$attr[c]))});
m(s,function(a,d){w[d]=c(a.replace(e,q))});h.$watch(n,function(c){var e=parseFloat(c),f=isNaN(e);f||e in s||(e=a.pluralCat(e-r));e===x||f&&V(x)&&isNaN(x)||(z(),f=w[e],v(f)?(null!=c&&d.debug("ngPluralize: no rule defined for '"+e+"' in "+p),z=y,k()):z=h.$watch(f,k),x=e)})}}}],Ce=["$parse","$animate",function(a,c){var d=I("ngRepeat"),e=function(a,c,d,e,k,m,p){a[d]=e;k&&(a[k]=m);a.$index=c;a.$first=0===c;a.$last=c===p-1;a.$middle=!(a.$first||a.$last);a.$odd=!(a.$even=0===(c&1))};return{restrict:"A",
multiElement:!0,transclude:"element",priority:1E3,terminal:!0,$$tlb:!0,compile:function(f,h){var g=h.ngRepeat,l=X.createComment(" end ngRepeat: "+g+" "),k=g.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);if(!k)throw d("iexp",g);var n=k[1],p=k[2],r=k[3],s=k[4],k=n.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);if(!k)throw d("iidexp",n);var v=k[3]||k[1],y=k[2];if(r&&(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(r)||/^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(r)))throw d("badident",
r);var u,q,z,A,x={$id:Ga};s?u=a(s):(z=function(a,c){return Ga(c)},A=function(a){return a});return function(a,f,h,k,n){u&&(q=function(c,d,e){y&&(x[y]=c);x[v]=d;x.$index=e;return u(a,x)});var s=fa();a.$watchCollection(p,function(h){var k,p,t=f[0],u,x=fa(),C,G,J,M,I,F,L;r&&(a[r]=h);if(Da(h))I=h,p=q||z;else for(L in p=q||A,I=[],h)ta.call(h,L)&&"$"!==L.charAt(0)&&I.push(L);C=I.length;L=Array(C);for(k=0;k<C;k++)if(G=h===I?k:I[k],J=h[G],M=p(G,J,k),s[M])F=s[M],delete s[M],x[M]=F,L[k]=F;else{if(x[M])throw m(L,
function(a){a&&a.scope&&(s[a.id]=a)}),d("dupes",g,M,J);L[k]={id:M,scope:w,clone:w};x[M]=!0}for(u in s){F=s[u];M=rb(F.clone);c.leave(M);if(M[0].parentNode)for(k=0,p=M.length;k<p;k++)M[k].$$NG_REMOVED=!0;F.scope.$destroy()}for(k=0;k<C;k++)if(G=h===I?k:I[k],J=h[G],F=L[k],F.scope){u=t;do u=u.nextSibling;while(u&&u.$$NG_REMOVED);F.clone[0]!=u&&c.move(rb(F.clone),null,B(t));t=F.clone[F.clone.length-1];e(F.scope,k,v,J,y,G,C)}else n(function(a,d){F.scope=d;var f=l.cloneNode(!1);a[a.length++]=f;c.enter(a,
null,B(t));t=f;F.clone=a;x[F.id]=F;e(F.scope,k,v,J,y,G,C)});s=x})}}}}],De=["$animate",function(a){return{restrict:"A",multiElement:!0,link:function(c,d,e){c.$watch(e.ngShow,function(c){a[c?"removeClass":"addClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],we=["$animate",function(a){return{restrict:"A",multiElement:!0,link:function(c,d,e){c.$watch(e.ngHide,function(c){a[c?"addClass":"removeClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],Ee=Na(function(a,c,d){a.$watch(d.ngStyle,
function(a,d){d&&a!==d&&m(d,function(a,d){c.css(d,"")});a&&c.css(a)},!0)}),Fe=["$animate",function(a){return{require:"ngSwitch",controller:["$scope",function(){this.cases={}}],link:function(c,d,e,f){var h=[],g=[],l=[],k=[],n=function(a,c){return function(){a.splice(c,1)}};c.$watch(e.ngSwitch||e.on,function(c){var d,e;d=0;for(e=l.length;d<e;++d)a.cancel(l[d]);d=l.length=0;for(e=k.length;d<e;++d){var s=rb(g[d].clone);k[d].$destroy();(l[d]=a.leave(s)).then(n(l,d))}g.length=0;k.length=0;(h=f.cases["!"+
c]||f.cases["?"])&&m(h,function(c){c.transclude(function(d,e){k.push(e);var f=c.element;d[d.length++]=X.createComment(" end ngSwitchWhen: ");g.push({clone:d});a.enter(d,f.parent(),f)})})})}}}],Ge=Na({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,c,d,e,f){e.cases["!"+d.ngSwitchWhen]=e.cases["!"+d.ngSwitchWhen]||[];e.cases["!"+d.ngSwitchWhen].push({transclude:f,element:c})}}),He=Na({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,
c,d,e,f){e.cases["?"]=e.cases["?"]||[];e.cases["?"].push({transclude:f,element:c})}}),Je=Na({restrict:"EAC",link:function(a,c,d,e,f){if(!f)throw I("ngTransclude")("orphan",xa(c));f(function(a){c.empty();c.append(a)})}}),je=["$templateCache",function(a){return{restrict:"E",terminal:!0,compile:function(c,d){"text/ng-template"==d.type&&a.put(d.id,c[0].text)}}}],Bg={$setViewValue:y,$render:y},Cg=["$element","$scope","$attrs",function(a,c,d){var e=this,f=new Ua;e.ngModelCtrl=Bg;e.unknownOption=B(X.createElement("option"));
e.renderUnknownOption=function(c){c="? "+Ga(c)+" ?";e.unknownOption.val(c);a.prepend(e.unknownOption);a.val(c)};c.$on("$destroy",function(){e.renderUnknownOption=y});e.removeUnknownOption=function(){e.unknownOption.parent()&&e.unknownOption.remove()};e.readValue=function(){e.removeUnknownOption();return a.val()};e.writeValue=function(c){e.hasOption(c)?(e.removeUnknownOption(),a.val(c),""===c&&e.emptyOption.prop("selected",!0)):null==c&&e.emptyOption?(e.removeUnknownOption(),a.val("")):e.renderUnknownOption(c)};
e.addOption=function(a,c){Ta(a,'"option value"');""===a&&(e.emptyOption=c);var d=f.get(a)||0;f.put(a,d+1)};e.removeOption=function(a){var c=f.get(a);c&&(1===c?(f.remove(a),""===a&&(e.emptyOption=w)):f.put(a,c-1))};e.hasOption=function(a){return!!f.get(a)}}],ke=function(){return{restrict:"E",require:["select","?ngModel"],controller:Cg,link:function(a,c,d,e){var f=e[1];if(f){var h=e[0];h.ngModelCtrl=f;f.$render=function(){h.writeValue(f.$viewValue)};c.on("change",function(){a.$apply(function(){f.$setViewValue(h.readValue())})});
if(d.multiple){h.readValue=function(){var a=[];m(c.find("option"),function(c){c.selected&&a.push(c.value)});return a};h.writeValue=function(a){var d=new Ua(a);m(c.find("option"),function(a){a.selected=A(d.get(a.value))})};var g,l=NaN;a.$watch(function(){l!==f.$viewValue||ka(g,f.$viewValue)||(g=ja(f.$viewValue),f.$render());l=f.$viewValue});f.$isEmpty=function(a){return!a||0===a.length}}}}}},me=["$interpolate",function(a){return{restrict:"E",priority:100,compile:function(c,d){if(A(d.value))var e=a(d.value,
!0);else{var f=a(c.text(),!0);f||d.$set("value",c.text())}return function(a,c,d){function k(a){p.addOption(a,c);p.ngModelCtrl.$render();c[0].hasAttribute("selected")&&(c[0].selected=!0)}var m=c.parent(),p=m.data("$selectController")||m.parent().data("$selectController");if(p&&p.ngModelCtrl){if(e){var r;d.$observe("value",function(a){A(r)&&p.removeOption(r);r=a;k(a)})}else f?a.$watch(f,function(a,c){d.$set("value",a);c!==a&&p.removeOption(c);k(a)}):k(d.value);c.on("$destroy",function(){p.removeOption(d.value);
p.ngModelCtrl.$render()})}}}}}],le=qa({restrict:"E",terminal:!1}),Gc=function(){return{restrict:"A",require:"?ngModel",link:function(a,c,d,e){e&&(d.required=!0,e.$validators.required=function(a,c){return!d.required||!e.$isEmpty(c)},d.$observe("required",function(){e.$validate()}))}}},Fc=function(){return{restrict:"A",require:"?ngModel",link:function(a,c,d,e){if(e){var f,h=d.ngPattern||d.pattern;d.$observe("pattern",function(a){G(a)&&0<a.length&&(a=new RegExp("^"+a+"$"));if(a&&!a.test)throw I("ngPattern")("noregexp",
h,a,xa(c));f=a||w;e.$validate()});e.$validators.pattern=function(a,c){return e.$isEmpty(c)||v(f)||f.test(c)}}}}},Ic=function(){return{restrict:"A",require:"?ngModel",link:function(a,c,d,e){if(e){var f=-1;d.$observe("maxlength",function(a){a=Y(a);f=isNaN(a)?-1:a;e.$validate()});e.$validators.maxlength=function(a,c){return 0>f||e.$isEmpty(c)||c.length<=f}}}}},Hc=function(){return{restrict:"A",require:"?ngModel",link:function(a,c,d,e){if(e){var f=0;d.$observe("minlength",function(a){f=Y(a)||0;e.$validate()});
e.$validators.minlength=function(a,c){return e.$isEmpty(c)||c.length>=f}}}}};Q.angular.bootstrap?console.log("WARNING: Tried to load angular more than once."):(ce(),ee(da),da.module("ngLocale",[],["$provide",function(a){function c(a){a+="";var c=a.indexOf(".");return-1==c?0:a.length-c-1}a.value("$locale",{DATETIME_FORMATS:{AMPMS:["AM","PM"],DAY:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ERANAMES:["Before Christ","Anno Domini"],ERAS:["BC","AD"],FIRSTDAYOFWEEK:6,MONTH:"January February March April May June July August September October November December".split(" "),
SHORTDAY:"Sun Mon Tue Wed Thu Fri Sat".split(" "),SHORTMONTH:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),WEEKENDRANGE:[5,6],fullDate:"EEEE, MMMM d, y",longDate:"MMMM d, y",medium:"MMM d, y h:mm:ss a",mediumDate:"MMM d, y",mediumTime:"h:mm:ss a","short":"M/d/yy h:mm a",shortDate:"M/d/yy",shortTime:"h:mm a"},NUMBER_FORMATS:{CURRENCY_SYM:"$",DECIMAL_SEP:".",GROUP_SEP:",",PATTERNS:[{gSize:3,lgSize:3,maxFrac:3,minFrac:0,minInt:1,negPre:"-",negSuf:"",posPre:"",posSuf:""},{gSize:3,lgSize:3,
maxFrac:2,minFrac:2,minInt:1,negPre:"-\u00a4",negSuf:"",posPre:"\u00a4",posSuf:""}]},id:"en-us",pluralCat:function(a,e){var f=a|0,h=e;w===h&&(h=Math.min(c(a),3));Math.pow(10,h);return 1==f&&0==h?"one":"other"}})}]),B(X).ready(function(){Zd(X,zc)}))})(window,document);!window.angular.$$csp().noInlineStyle&&window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
//# sourceMappingURL=angular.min.js.map

/*
 AngularJS v1.4.7
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(p,c,C){'use strict';function v(r,h,g){return{restrict:"ECA",terminal:!0,priority:400,transclude:"element",link:function(a,f,b,d,y){function z(){k&&(g.cancel(k),k=null);l&&(l.$destroy(),l=null);m&&(k=g.leave(m),k.then(function(){k=null}),m=null)}function x(){var b=r.current&&r.current.locals;if(c.isDefined(b&&b.$template)){var b=a.$new(),d=r.current;m=y(b,function(b){g.enter(b,null,m||f).then(function(){!c.isDefined(t)||t&&!a.$eval(t)||h()});z()});l=d.scope=b;l.$emit("$viewContentLoaded");
l.$eval(w)}else z()}var l,m,k,t=b.autoscroll,w=b.onload||"";a.$on("$routeChangeSuccess",x);x()}}}function A(c,h,g){return{restrict:"ECA",priority:-400,link:function(a,f){var b=g.current,d=b.locals;f.html(d.$template);var y=c(f.contents());b.controller&&(d.$scope=a,d=h(b.controller,d),b.controllerAs&&(a[b.controllerAs]=d),f.data("$ngControllerController",d),f.children().data("$ngControllerController",d));y(a)}}}p=c.module("ngRoute",["ng"]).provider("$route",function(){function r(a,f){return c.extend(Object.create(a),
f)}function h(a,c){var b=c.caseInsensitiveMatch,d={originalPath:a,regexp:a},g=d.keys=[];a=a.replace(/([().])/g,"\\$1").replace(/(\/)?:(\w+)([\?\*])?/g,function(a,c,b,d){a="?"===d?d:null;d="*"===d?d:null;g.push({name:b,optional:!!a});c=c||"";return""+(a?"":c)+"(?:"+(a?c:"")+(d&&"(.+?)"||"([^/]+)")+(a||"")+")"+(a||"")}).replace(/([\/$\*])/g,"\\$1");d.regexp=new RegExp("^"+a+"$",b?"i":"");return d}var g={};this.when=function(a,f){var b=c.copy(f);c.isUndefined(b.reloadOnSearch)&&(b.reloadOnSearch=!0);
c.isUndefined(b.caseInsensitiveMatch)&&(b.caseInsensitiveMatch=this.caseInsensitiveMatch);g[a]=c.extend(b,a&&h(a,b));if(a){var d="/"==a[a.length-1]?a.substr(0,a.length-1):a+"/";g[d]=c.extend({redirectTo:a},h(d,b))}return this};this.caseInsensitiveMatch=!1;this.otherwise=function(a){"string"===typeof a&&(a={redirectTo:a});this.when(null,a);return this};this.$get=["$rootScope","$location","$routeParams","$q","$injector","$templateRequest","$sce",function(a,f,b,d,h,p,x){function l(b){var e=s.current;
(v=(n=k())&&e&&n.$$route===e.$$route&&c.equals(n.pathParams,e.pathParams)&&!n.reloadOnSearch&&!w)||!e&&!n||a.$broadcast("$routeChangeStart",n,e).defaultPrevented&&b&&b.preventDefault()}function m(){var u=s.current,e=n;if(v)u.params=e.params,c.copy(u.params,b),a.$broadcast("$routeUpdate",u);else if(e||u)w=!1,(s.current=e)&&e.redirectTo&&(c.isString(e.redirectTo)?f.path(t(e.redirectTo,e.params)).search(e.params).replace():f.url(e.redirectTo(e.pathParams,f.path(),f.search())).replace()),d.when(e).then(function(){if(e){var a=
c.extend({},e.resolve),b,f;c.forEach(a,function(b,e){a[e]=c.isString(b)?h.get(b):h.invoke(b,null,null,e)});c.isDefined(b=e.template)?c.isFunction(b)&&(b=b(e.params)):c.isDefined(f=e.templateUrl)&&(c.isFunction(f)&&(f=f(e.params)),c.isDefined(f)&&(e.loadedTemplateUrl=x.valueOf(f),b=p(f)));c.isDefined(b)&&(a.$template=b);return d.all(a)}}).then(function(f){e==s.current&&(e&&(e.locals=f,c.copy(e.params,b)),a.$broadcast("$routeChangeSuccess",e,u))},function(b){e==s.current&&a.$broadcast("$routeChangeError",
e,u,b)})}function k(){var a,b;c.forEach(g,function(d,g){var q;if(q=!b){var h=f.path();q=d.keys;var l={};if(d.regexp)if(h=d.regexp.exec(h)){for(var k=1,m=h.length;k<m;++k){var n=q[k-1],p=h[k];n&&p&&(l[n.name]=p)}q=l}else q=null;else q=null;q=a=q}q&&(b=r(d,{params:c.extend({},f.search(),a),pathParams:a}),b.$$route=d)});return b||g[null]&&r(g[null],{params:{},pathParams:{}})}function t(a,b){var d=[];c.forEach((a||"").split(":"),function(a,c){if(0===c)d.push(a);else{var f=a.match(/(\w+)(?:[?*])?(.*)/),
g=f[1];d.push(b[g]);d.push(f[2]||"");delete b[g]}});return d.join("")}var w=!1,n,v,s={routes:g,reload:function(){w=!0;a.$evalAsync(function(){l();m()})},updateParams:function(a){if(this.current&&this.current.$$route)a=c.extend({},this.current.params,a),f.path(t(this.current.$$route.originalPath,a)),f.search(a);else throw B("norout");}};a.$on("$locationChangeStart",l);a.$on("$locationChangeSuccess",m);return s}]});var B=c.$$minErr("ngRoute");p.provider("$routeParams",function(){this.$get=function(){return{}}});
p.directive("ngView",v);p.directive("ngView",A);v.$inject=["$route","$anchorScroll","$animate"];A.$inject=["$compile","$controller","$route"]})(window,window.angular);
//# sourceMappingURL=angular-route.min.js.map

/*
 AngularJS v1.4.7
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(x,s,y){'use strict';function t(f,k,p){n.directive(f,["$parse","$swipe",function(c,e){return function(l,m,g){function h(a){if(!b)return!1;var d=Math.abs(a.y-b.y);a=(a.x-b.x)*k;return r&&75>d&&0<a&&30<a&&.3>d/a}var d=c(g[f]),b,r,a=["touch"];s.isDefined(g.ngSwipeDisableMouse)||a.push("mouse");e.bind(m,{start:function(a,d){b=a;r=!0},cancel:function(a){r=!1},end:function(a,b){h(a)&&l.$apply(function(){m.triggerHandler(p);d(l,{$event:b})})}},a)}}])}var n=s.module("ngTouch",[]);n.factory("$swipe",
[function(){function f(c){c=c.originalEvent||c;var e=c.touches&&c.touches.length?c.touches:[c];c=c.changedTouches&&c.changedTouches[0]||e[0];return{x:c.clientX,y:c.clientY}}function k(c,e){var l=[];s.forEach(c,function(c){(c=p[c][e])&&l.push(c)});return l.join(" ")}var p={mouse:{start:"mousedown",move:"mousemove",end:"mouseup"},touch:{start:"touchstart",move:"touchmove",end:"touchend",cancel:"touchcancel"}};return{bind:function(c,e,l){var m,g,h,d,b=!1;l=l||["mouse","touch"];c.on(k(l,"start"),function(a){h=
f(a);b=!0;g=m=0;d=h;e.start&&e.start(h,a)});var r=k(l,"cancel");if(r)c.on(r,function(a){b=!1;e.cancel&&e.cancel(a)});c.on(k(l,"move"),function(a){if(b&&h){var c=f(a);m+=Math.abs(c.x-d.x);g+=Math.abs(c.y-d.y);d=c;10>m&&10>g||(g>m?(b=!1,e.cancel&&e.cancel(a)):(a.preventDefault(),e.move&&e.move(c,a)))}});c.on(k(l,"end"),function(a){b&&(b=!1,e.end&&e.end(f(a),a))})}}}]);n.config(["$provide",function(f){f.decorator("ngClickDirective",["$delegate",function(k){k.shift();return k}])}]);n.directive("ngClick",
["$parse","$timeout","$rootElement",function(f,k,p){function c(d,b,c){for(var a=0;a<d.length;a+=2){var e=d[a+1],g=c;if(25>Math.abs(d[a]-b)&&25>Math.abs(e-g))return d.splice(a,a+2),!0}return!1}function e(d){if(!(2500<Date.now()-m)){var b=d.touches&&d.touches.length?d.touches:[d],e=b[0].clientX,b=b[0].clientY;if(!(1>e&&1>b||h&&h[0]===e&&h[1]===b)){h&&(h=null);var a=d.target;"label"===s.lowercase(a.nodeName||a[0]&&a[0].nodeName)&&(h=[e,b]);c(g,e,b)||(d.stopPropagation(),d.preventDefault(),d.target&&
d.target.blur&&d.target.blur())}}}function l(d){d=d.touches&&d.touches.length?d.touches:[d];var b=d[0].clientX,c=d[0].clientY;g.push(b,c);k(function(){for(var a=0;a<g.length;a+=2)if(g[a]==b&&g[a+1]==c){g.splice(a,a+2);break}},2500,!1)}var m,g,h;return function(d,b,h){var a=f(h.ngClick),k=!1,q,n,t,v;b.on("touchstart",function(a){k=!0;q=a.target?a.target:a.srcElement;3==q.nodeType&&(q=q.parentNode);b.addClass("ng-click-active");n=Date.now();a=a.originalEvent||a;a=(a.touches&&a.touches.length?a.touches:
[a])[0];t=a.clientX;v=a.clientY});b.on("touchcancel",function(a){k=!1;b.removeClass("ng-click-active")});b.on("touchend",function(a){var d=Date.now()-n,f=a.originalEvent||a,u=(f.changedTouches&&f.changedTouches.length?f.changedTouches:f.touches&&f.touches.length?f.touches:[f])[0],f=u.clientX,u=u.clientY,w=Math.sqrt(Math.pow(f-t,2)+Math.pow(u-v,2));k&&750>d&&12>w&&(g||(p[0].addEventListener("click",e,!0),p[0].addEventListener("touchstart",l,!0),g=[]),m=Date.now(),c(g,f,u),q&&q.blur(),s.isDefined(h.disabled)&&
!1!==h.disabled||b.triggerHandler("click",[a]));k=!1;b.removeClass("ng-click-active")});b.onclick=function(a){};b.on("click",function(b,c){d.$apply(function(){a(d,{$event:c||b})})});b.on("mousedown",function(a){b.addClass("ng-click-active")});b.on("mousemove mouseup",function(a){b.removeClass("ng-click-active")})}}]);t("ngSwipeLeft",-1,"swipeleft");t("ngSwipeRight",1,"swiperight")})(window,window.angular);
//# sourceMappingURL=angular-touch.min.js.map

/*
 AngularJS v1.4.7
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(G,t,Ra){'use strict';function va(a,b,c){if(!a)throw ngMinErr("areq",b||"?",c||"required");return a}function wa(a,b){if(!a&&!b)return"";if(!a)return b;if(!b)return a;W(a)&&(a=a.join(" "));W(b)&&(b=b.join(" "));return a+" "+b}function Ha(a){var b={};a&&(a.to||a.from)&&(b.to=a.to,b.from=a.from);return b}function S(a,b,c){var d="";a=W(a)?a:a&&M(a)&&a.length?a.split(/\s+/):[];q(a,function(a,u){a&&0<a.length&&(d+=0<u?" ":"",d+=c?b+a:a+b)});return d}function Ia(a){if(a instanceof J)switch(a.length){case 0:return[];
case 1:if(1===a[0].nodeType)return a;break;default:return J(la(a))}if(1===a.nodeType)return J(a)}function la(a){if(!a[0])return a;for(var b=0;b<a.length;b++){var c=a[b];if(1==c.nodeType)return c}}function Ja(a,b,c){q(b,function(b){a.addClass(b,c)})}function Ka(a,b,c){q(b,function(b){a.removeClass(b,c)})}function P(a){return function(b,c){c.addClass&&(Ja(a,b,c.addClass),c.addClass=null);c.removeClass&&(Ka(a,b,c.removeClass),c.removeClass=null)}}function ha(a){a=a||{};if(!a.$$prepared){var b=a.domOperation||
L;a.domOperation=function(){a.$$domOperationFired=!0;b();b=L};a.$$prepared=!0}return a}function da(a,b){xa(a,b);ya(a,b)}function xa(a,b){b.from&&(a.css(b.from),b.from=null)}function ya(a,b){b.to&&(a.css(b.to),b.to=null)}function Q(a,b,c){var d=(b.addClass||"")+" "+(c.addClass||""),g=(b.removeClass||"")+" "+(c.removeClass||"");a=La(a.attr("class"),d,g);c.preparationClasses&&(b.preparationClasses=X(c.preparationClasses,b.preparationClasses),delete c.preparationClasses);d=b.domOperation!==L?b.domOperation:
null;za(b,c);d&&(b.domOperation=d);b.addClass=a.addClass?a.addClass:null;b.removeClass=a.removeClass?a.removeClass:null;return b}function La(a,b,c){function d(a){M(a)&&(a=a.split(" "));var b={};q(a,function(a){a.length&&(b[a]=!0)});return b}var g={};a=d(a);b=d(b);q(b,function(a,b){g[b]=1});c=d(c);q(c,function(a,b){g[b]=1===g[b]?null:-1});var u={addClass:"",removeClass:""};q(g,function(b,c){var g,d;1===b?(g="addClass",d=!a[c]):-1===b&&(g="removeClass",d=a[c]);d&&(u[g].length&&(u[g]+=" "),u[g]+=c)});
return u}function H(a){return a instanceof t.element?a[0]:a}function Ma(a,b,c){var d="";b&&(d=S(b,"ng-",!0));c.addClass&&(d=X(d,S(c.addClass,"-add")));c.removeClass&&(d=X(d,S(c.removeClass,"-remove")));d.length&&(c.preparationClasses=d,a.addClass(d))}function ia(a,b){var c=b?"-"+b+"s":"";ea(a,[fa,c]);return[fa,c]}function ma(a,b){var c=b?"paused":"",d=T+"PlayState";ea(a,[d,c]);return[d,c]}function ea(a,b){a.style[b[0]]=b[1]}function X(a,b){return a?b?a+" "+b:a:b}function Aa(a,b,c){var d=Object.create(null),
g=a.getComputedStyle(b)||{};q(c,function(a,b){var c=g[a];if(c){var f=c.charAt(0);if("-"===f||"+"===f||0<=f)c=Na(c);0===c&&(c=null);d[b]=c}});return d}function Na(a){var b=0;a=a.split(/\s*,\s*/);q(a,function(a){"s"==a.charAt(a.length-1)&&(a=a.substring(0,a.length-1));a=parseFloat(a)||0;b=b?Math.max(a,b):a});return b}function na(a){return 0===a||null!=a}function Ba(a,b){var c=N,d=a+"s";b?c+="Duration":d+=" linear all";return[c,d]}function Ca(){var a=Object.create(null);return{flush:function(){a=Object.create(null)},
count:function(b){return(b=a[b])?b.total:0},get:function(b){return(b=a[b])&&b.value},put:function(b,c){a[b]?a[b].total++:a[b]={total:1,value:c}}}}function Da(a,b,c){q(c,function(c){a[c]=U(a[c])?a[c]:b.style.getPropertyValue(c)})}var L=t.noop,za=t.extend,J=t.element,q=t.forEach,W=t.isArray,M=t.isString,oa=t.isObject,pa=t.isUndefined,U=t.isDefined,Ea=t.isFunction,qa=t.isElement,N,ra,T,sa;pa(G.ontransitionend)&&U(G.onwebkittransitionend)?(N="WebkitTransition",ra="webkitTransitionEnd transitionend"):
(N="transition",ra="transitionend");pa(G.onanimationend)&&U(G.onwebkitanimationend)?(T="WebkitAnimation",sa="webkitAnimationEnd animationend"):(T="animation",sa="animationend");var ja=T+"Delay",ta=T+"Duration",fa=N+"Delay";G=N+"Duration";var Oa={transitionDuration:G,transitionDelay:fa,transitionProperty:N+"Property",animationDuration:ta,animationDelay:ja,animationIterationCount:T+"IterationCount"},Pa={transitionDuration:G,transitionDelay:fa,animationDuration:ta,animationDelay:ja};t.module("ngAnimate",
[]).directive("ngAnimateChildren",[function(){return function(a,b,c){a=c.ngAnimateChildren;t.isString(a)&&0===a.length?b.data("$$ngAnimateChildren",!0):c.$observe("ngAnimateChildren",function(a){b.data("$$ngAnimateChildren","on"===a||"true"===a)})}}]).factory("$$rAFScheduler",["$$rAF",function(a){function b(a){d=d.concat(a);c()}function c(){if(d.length){for(var b=d.shift(),z=0;z<b.length;z++)b[z]();g||a(function(){g||c()})}}var d,g;d=b.queue=[];b.waitUntilQuiet=function(b){g&&g();g=a(function(){g=
null;b();c()})};return b}]).factory("$$AnimateRunner",["$q","$sniffer","$$animateAsyncRun",function(a,b,c){function d(a){this.setHost(a);this._doneCallbacks=[];this._runInAnimationFrame=c();this._state=0}d.chain=function(a,b){function c(){if(d===a.length)b(!0);else a[d](function(a){!1===a?b(!1):(d++,c())})}var d=0;c()};d.all=function(a,b){function c(z){f=f&&z;++d===a.length&&b(f)}var d=0,f=!0;q(a,function(a){a.done(c)})};d.prototype={setHost:function(a){this.host=a||{}},done:function(a){2===this._state?
a():this._doneCallbacks.push(a)},progress:L,getPromise:function(){if(!this.promise){var b=this;this.promise=a(function(a,c){b.done(function(b){!1===b?c():a()})})}return this.promise},then:function(a,b){return this.getPromise().then(a,b)},"catch":function(a){return this.getPromise()["catch"](a)},"finally":function(a){return this.getPromise()["finally"](a)},pause:function(){this.host.pause&&this.host.pause()},resume:function(){this.host.resume&&this.host.resume()},end:function(){this.host.end&&this.host.end();
this._resolve(!0)},cancel:function(){this.host.cancel&&this.host.cancel();this._resolve(!1)},complete:function(a){var b=this;0===b._state&&(b._state=1,b._runInAnimationFrame(function(){b._resolve(a)}))},_resolve:function(a){2!==this._state&&(q(this._doneCallbacks,function(b){b(a)}),this._doneCallbacks.length=0,this._state=2)}};return d}]).factory("$$animateAsyncRun",["$$rAF",function(a){function b(b){c.push(b);1<c.length||a(function(){for(var a=0;a<c.length;a++)c[a]();c=[]})}var c=[];return function(){var a=
!1;b(function(){a=!0});return function(c){a?c():b(c)}}}]).provider("$$animateQueue",["$animateProvider",function(a){function b(a,b,c,q){return d[a].some(function(a){return a(b,c,q)})}function c(a,b){a=a||{};var c=0<(a.addClass||"").length,d=0<(a.removeClass||"").length;return b?c&&d:c||d}var d=this.rules={skip:[],cancel:[],join:[]};d.join.push(function(a,b,d){return!b.structural&&c(b.options)});d.skip.push(function(a,b,d){return!b.structural&&!c(b.options)});d.skip.push(function(a,b,c){return"leave"==
c.event&&b.structural});d.skip.push(function(a,b,c){return c.structural&&2===c.state&&!b.structural});d.cancel.push(function(a,b,c){return c.structural&&b.structural});d.cancel.push(function(a,b,c){return 2===c.state&&b.structural});d.cancel.push(function(a,b,c){a=b.options;c=c.options;return a.addClass&&a.addClass===c.removeClass||a.removeClass&&a.removeClass===c.addClass});this.$get=["$$rAF","$rootScope","$rootElement","$document","$$HashMap","$$animation","$$AnimateRunner","$templateRequest","$$jqLite",
"$$forceReflow",function(d,u,z,x,f,k,$,t,h,I){function A(){var a=!1;return function(b){a?b():u.$$postDigest(function(){a=!0;b()})}}function Y(a,b){var c=H(a),e=[],d=v[b];d&&q(d,function(a){a.node.contains(c)&&e.push(a.callback)});return e}function E(a,e,l){function n(b,c,e,v){z(function(){var b=Y(a,c);b.length&&d(function(){q(b,function(b){b(a,e,v)})})});b.progress(c,e,v)}function v(b){var c=a,e=l;e.preparationClasses&&(c.removeClass(e.preparationClasses),e.preparationClasses=null);e.activeClasses&&
(c.removeClass(e.activeClasses),e.activeClasses=null);Ga(a,l);da(a,l);l.domOperation();f.complete(!b)}var s,C;if(a=Ia(a))s=H(a),C=a.parent();l=ha(l);var f=new $,z=A();W(l.addClass)&&(l.addClass=l.addClass.join(" "));l.addClass&&!M(l.addClass)&&(l.addClass=null);W(l.removeClass)&&(l.removeClass=l.removeClass.join(" "));l.removeClass&&!M(l.removeClass)&&(l.removeClass=null);l.from&&!oa(l.from)&&(l.from=null);l.to&&!oa(l.to)&&(l.to=null);if(!s)return v(),f;var h=[s.className,l.addClass,l.removeClass].join(" ");
if(!Qa(h))return v(),f;var E=0<=["enter","move","leave"].indexOf(e),x=!F||D.get(s),h=!x&&m.get(s)||{},I=!!h.state;x||I&&1==h.state||(x=!ka(a,C,e));if(x)return v(),f;E&&w(a);C={structural:E,element:a,event:e,close:v,options:l,runner:f};if(I){if(b("skip",a,C,h)){if(2===h.state)return v(),f;Q(a,h.options,l);return h.runner}if(b("cancel",a,C,h))if(2===h.state)h.runner.end();else if(h.structural)h.close();else return Q(a,h.options,C.options),h.runner;else if(b("join",a,C,h))if(2===h.state)Q(a,l,{});else return Ma(a,
E?e:null,l),e=C.event=h.event,l=Q(a,h.options,C.options),h.runner}else Q(a,l,{});(I=C.structural)||(I="animate"===C.event&&0<Object.keys(C.options.to||{}).length||c(C.options));if(!I)return v(),y(a),f;var t=(h.counter||0)+1;C.counter=t;r(a,1,C);u.$$postDigest(function(){var b=m.get(s),d=!b,b=b||{},h=0<(a.parent()||[]).length&&("animate"===b.event||b.structural||c(b.options));if(d||b.counter!==t||!h){d&&(Ga(a,l),da(a,l));if(d||E&&b.event!==e)l.domOperation(),f.end();h||y(a)}else e=!b.structural&&c(b.options,
!0)?"setClass":b.event,r(a,2),b=k(a,e,b.options),b.done(function(b){v(!b);(b=m.get(s))&&b.counter===t&&y(H(a));n(f,e,"close",{})}),f.setHost(b),n(f,e,"start",{})});return f}function w(a){a=H(a).querySelectorAll("[data-ng-animate]");q(a,function(a){var b=parseInt(a.getAttribute("data-ng-animate")),c=m.get(a);switch(b){case 2:c.runner.end();case 1:c&&m.remove(a)}})}function y(a){a=H(a);a.removeAttribute("data-ng-animate");m.remove(a)}function e(a,b){return H(a)===H(b)}function ka(a,b,c){c=J(x[0].body);
var d=e(a,c)||"HTML"===a[0].nodeName,v=e(a,z),n=!1,y;for((a=a.data("$ngAnimatePin"))&&(b=a);b&&b.length;){v||(v=e(b,z));a=b[0];if(1!==a.nodeType)break;var r=m.get(a)||{};n||(n=r.structural||D.get(a));if(pa(y)||!0===y)a=b.data("$$ngAnimateChildren"),U(a)&&(y=a);if(n&&!1===y)break;v||(v=e(b,z),v||(a=b.data("$ngAnimatePin"))&&(b=a));d||(d=e(b,c));b=b.parent()}return(!n||y)&&v&&d}function r(a,b,c){c=c||{};c.state=b;a=H(a);a.setAttribute("data-ng-animate",b);c=(b=m.get(a))?za(b,c):c;m.put(a,c)}var m=new f,
D=new f,F=null,s=u.$watch(function(){return 0===t.totalPendingRequests},function(a){a&&(s(),u.$$postDigest(function(){u.$$postDigest(function(){null===F&&(F=!0)})}))}),v={},n=a.classNameFilter(),Qa=n?function(a){return n.test(a)}:function(){return!0},Ga=P(h);return{on:function(a,b,c){b=la(b);v[a]=v[a]||[];v[a].push({node:b,callback:c})},off:function(a,b,c){function e(a,b,c){var d=la(b);return a.filter(function(a){return!(a.node===d&&(!c||a.callback===c))})}var d=v[a];d&&(v[a]=1===arguments.length?
null:e(d,b,c))},pin:function(a,b){va(qa(a),"element","not an element");va(qa(b),"parentElement","not an element");a.data("$ngAnimatePin",b)},push:function(a,b,c,e){c=c||{};c.domOperation=e;return E(a,b,c)},enabled:function(a,b){var c=arguments.length;if(0===c)b=!!F;else if(qa(a)){var e=H(a),d=D.get(e);1===c?b=!d:(b=!!b)?d&&D.remove(e):D.put(e,!0)}else b=F=!!a;return b}}}]}]).provider("$$animation",["$animateProvider",function(a){function b(a){return a.data("$$animationRunner")}var c=this.drivers=
[];this.$get=["$$jqLite","$rootScope","$injector","$$AnimateRunner","$$HashMap","$$rAFScheduler",function(a,g,u,z,x,f){function k(a){function b(a){if(a.processed)return a;a.processed=!0;var e=a.domNode,d=e.parentNode;f.put(e,a);for(var r;d;){if(r=f.get(d)){r.processed||(r=b(r));break}d=d.parentNode}(r||c).children.push(a);return a}var c={children:[]},d,f=new x;for(d=0;d<a.length;d++){var g=a[d];f.put(g.domNode,a[d]={domNode:g.domNode,fn:g.fn,children:[]})}for(d=0;d<a.length;d++)b(a[d]);return function(a){var b=
[],c=[],d;for(d=0;d<a.children.length;d++)c.push(a.children[d]);a=c.length;var m=0,f=[];for(d=0;d<c.length;d++){var g=c[d];0>=a&&(a=m,m=0,b.push(f),f=[]);f.push(g.fn);g.children.forEach(function(a){m++;c.push(a)});a--}f.length&&b.push(f);return b}(c)}var $=[],t=P(a);return function(h,x,A){function Y(a){a=a.hasAttribute("ng-animate-ref")?[a]:a.querySelectorAll("[ng-animate-ref]");var b=[];q(a,function(a){var c=a.getAttribute("ng-animate-ref");c&&c.length&&b.push(a)});return b}function E(a){var b=[],
c={};q(a,function(a,e){var d=H(a.element),v=0<=["enter","move"].indexOf(a.event),d=a.structural?Y(d):[];if(d.length){var m=v?"to":"from";q(d,function(a){var b=a.getAttribute("ng-animate-ref");c[b]=c[b]||{};c[b][m]={animationID:e,element:J(a)}})}else b.push(a)});var e={},d={};q(c,function(c,m){var f=c.from,y=c.to;if(f&&y){var g=a[f.animationID],r=a[y.animationID],s=f.animationID.toString();if(!d[s]){var h=d[s]={structural:!0,beforeStart:function(){g.beforeStart();r.beforeStart()},close:function(){g.close();
r.close()},classes:w(g.classes,r.classes),from:g,to:r,anchors:[]};h.classes.length?b.push(h):(b.push(g),b.push(r))}d[s].anchors.push({out:f.element,"in":y.element})}else f=f?f.animationID:y.animationID,y=f.toString(),e[y]||(e[y]=!0,b.push(a[f]))});return b}function w(a,b){a=a.split(" ");b=b.split(" ");for(var c=[],e=0;e<a.length;e++){var d=a[e];if("ng-"!==d.substring(0,3))for(var m=0;m<b.length;m++)if(d===b[m]){c.push(d);break}}return c.join(" ")}function y(a){for(var b=c.length-1;0<=b;b--){var e=
c[b];if(u.has(e)&&(e=u.get(e)(a)))return e}}function e(a,c){a.from&&a.to?(b(a.from.element).setHost(c),b(a.to.element).setHost(c)):b(a.element).setHost(c)}function ka(){var a=b(h);!a||"leave"===x&&A.$$domOperationFired||a.end()}function r(b){h.off("$destroy",ka);h.removeData("$$animationRunner");t(h,A);da(h,A);A.domOperation();s&&a.removeClass(h,s);h.removeClass("ng-animate");D.complete(!b)}A=ha(A);var m=0<=["enter","move","leave"].indexOf(x),D=new z({end:function(){r()},cancel:function(){r(!0)}});
if(!c.length)return r(),D;h.data("$$animationRunner",D);var F=wa(h.attr("class"),wa(A.addClass,A.removeClass)),s=A.tempClasses;s&&(F+=" "+s,A.tempClasses=null);$.push({element:h,classes:F,event:x,structural:m,options:A,beforeStart:function(){h.addClass("ng-animate");s&&a.addClass(h,s)},close:r});h.on("$destroy",ka);if(1<$.length)return D;g.$$postDigest(function(){var a=[];q($,function(c){b(c.element)?a.push(c):c.close()});$.length=0;var c=E(a),d=[];q(c,function(a){d.push({domNode:H(a.from?a.from.element:
a.element),fn:function(){a.beforeStart();var c,d=a.close;if(b(a.anchors?a.from.element||a.to.element:a.element)){var m=y(a);m&&(c=m.start)}c?(c=c(),c.done(function(a){d(!a)}),e(a,c)):d()}})});f(k(d))});return D}}]}]).provider("$animateCss",["$animateProvider",function(a){var b=Ca(),c=Ca();this.$get=["$window","$$jqLite","$$AnimateRunner","$timeout","$$forceReflow","$sniffer","$$rAFScheduler","$animate",function(a,g,u,z,x,f,k,t){function Fa(a,b){var c=a.parentNode;return(c.$$ngAnimateParentKey||(c.$$ngAnimateParentKey=
++E))+"-"+a.getAttribute("class")+"-"+b}function h(f,e,h,r){var m;0<b.count(h)&&(m=c.get(h),m||(e=S(e,"-stagger"),g.addClass(f,e),m=Aa(a,f,r),m.animationDuration=Math.max(m.animationDuration,0),m.transitionDuration=Math.max(m.transitionDuration,0),g.removeClass(f,e),c.put(h,m)));return m||{}}function I(a){w.push(a);k.waitUntilQuiet(function(){b.flush();c.flush();for(var a=x(),d=0;d<w.length;d++)w[d](a);w.length=0})}function A(c,e,f){e=b.get(f);e||(e=Aa(a,c,Oa),"infinite"===e.animationIterationCount&&
(e.animationIterationCount=1));b.put(f,e);c=e;f=c.animationDelay;e=c.transitionDelay;c.maxDelay=f&&e?Math.max(f,e):f||e;c.maxDuration=Math.max(c.animationDuration*c.animationIterationCount,c.transitionDuration);return c}var Y=P(g),E=0,w=[];return function(a,c){function d(){m()}function r(){m(!0)}function m(b){if(!(E||ua&&l)){E=!0;l=!1;c.$$skipPreparationClasses||g.removeClass(a,Z);g.removeClass(a,X);ma(n,!1);ia(n,!1);q(w,function(a){n.style[a[0]]=""});Y(a,c);da(a,c);Object.keys(v).length&&q(v,function(a,
b){a?n.style.setProperty(b,a):n.style.removeProperty(b)});if(c.onDone)c.onDone();G&&G.complete(!b)}}function D(a){p.blockTransition&&ia(n,a);p.blockKeyframeAnimation&&ma(n,!!a)}function F(){G=new u({end:d,cancel:r});I(L);m();return{$$willAnimate:!1,start:function(){return G},end:d}}function s(){function b(){if(!E){D(!1);q(w,function(a){n.style[a[0]]=a[1]});Y(a,c);g.addClass(a,X);if(p.recalculateTimingStyles){ga=n.className+" "+Z;aa=Fa(n,ga);B=A(n,ga,aa);V=B.maxDelay;C=Math.max(V,0);K=B.maxDuration;
if(0===K){m();return}p.hasTransitions=0<B.transitionDuration;p.hasAnimations=0<B.animationDuration}p.applyAnimationDelay&&(V="boolean"!==typeof c.delay&&na(c.delay)?parseFloat(c.delay):V,C=Math.max(V,0),B.animationDelay=V,ca=[ja,V+"s"],w.push(ca),n.style[ca[0]]=ca[1]);M=1E3*C;P=1E3*K;if(c.easing){var s,k=c.easing;p.hasTransitions&&(s=N+"TimingFunction",w.push([s,k]),n.style[s]=k);p.hasAnimations&&(s=T+"TimingFunction",w.push([s,k]),n.style[s]=k)}B.transitionDuration&&h.push(ra);B.animationDuration&&
h.push(sa);r=Date.now();var l=M+1.5*P;s=r+l;var k=a.data("$$animateCss")||[],x=!0;if(k.length){var F=k[0];(x=s>F.expectedEndTime)?z.cancel(F.timer):k.push(m)}x&&(l=z(d,l,!1),k[0]={timer:l,expectedEndTime:s},k.push(m),a.data("$$animateCss",k));a.on(h.join(" "),f);c.to&&(c.cleanupStyles&&Da(v,n,Object.keys(c.to)),ya(a,c))}}function d(){var b=a.data("$$animateCss");if(b){for(var c=1;c<b.length;c++)b[c]();a.removeData("$$animateCss")}}function f(a){a.stopPropagation();var b=a.originalEvent||a;a=b.$manualTimeStamp||
b.timeStamp||Date.now();b=parseFloat(b.elapsedTime.toFixed(3));Math.max(a-r,0)>=M&&b>=K&&(ua=!0,m())}if(!E)if(n.parentNode){var r,h=[],s=function(a){if(ua)l&&a&&(l=!1,m());else if(l=!a,B.animationDuration)if(a=ma(n,l),l)w.push(a);else{var b=w,c=b.indexOf(a);0<=a&&b.splice(c,1)}},k=0<U&&(B.transitionDuration&&0===R.transitionDuration||B.animationDuration&&0===R.animationDuration)&&Math.max(R.animationDelay,R.transitionDelay);k?z(b,Math.floor(k*U*1E3),!1):b();J.resume=function(){s(!0)};J.pause=function(){s(!1)}}else m()}
var v={},n=H(a);if(!n||!n.parentNode||!t.enabled())return F();c=ha(c);var w=[],x=a.attr("class"),k=Ha(c),E,l,ua,G,J,C,M,K,P;if(0===c.duration||!f.animations&&!f.transitions)return F();var ba=c.event&&W(c.event)?c.event.join(" "):c.event,Q="",O="";ba&&c.structural?Q=S(ba,"ng-",!0):ba&&(Q=ba);c.addClass&&(O+=S(c.addClass,"-add"));c.removeClass&&(O.length&&(O+=" "),O+=S(c.removeClass,"-remove"));c.applyClassesEarly&&O.length&&Y(a,c);var Z=[Q,O].join(" ").trim(),ga=x+" "+Z,X=S(Z,"-active"),x=k.to&&0<
Object.keys(k.to).length;if(!(0<(c.keyframeStyle||"").length||x||Z))return F();var aa,R;0<c.stagger?(k=parseFloat(c.stagger),R={transitionDelay:k,animationDelay:k,transitionDuration:0,animationDuration:0}):(aa=Fa(n,ga),R=h(n,Z,aa,Pa));c.$$skipPreparationClasses||g.addClass(a,Z);c.transitionStyle&&(k=[N,c.transitionStyle],ea(n,k),w.push(k));0<=c.duration&&(k=0<n.style[N].length,k=Ba(c.duration,k),ea(n,k),w.push(k));c.keyframeStyle&&(k=[T,c.keyframeStyle],ea(n,k),w.push(k));var U=R?0<=c.staggerIndex?
c.staggerIndex:b.count(aa):0;(ba=0===U)&&!c.skipBlocking&&ia(n,9999);var B=A(n,ga,aa),V=B.maxDelay;C=Math.max(V,0);K=B.maxDuration;var p={};p.hasTransitions=0<B.transitionDuration;p.hasAnimations=0<B.animationDuration;p.hasTransitionAll=p.hasTransitions&&"all"==B.transitionProperty;p.applyTransitionDuration=x&&(p.hasTransitions&&!p.hasTransitionAll||p.hasAnimations&&!p.hasTransitions);p.applyAnimationDuration=c.duration&&p.hasAnimations;p.applyTransitionDelay=na(c.delay)&&(p.applyTransitionDuration||
p.hasTransitions);p.applyAnimationDelay=na(c.delay)&&p.hasAnimations;p.recalculateTimingStyles=0<O.length;if(p.applyTransitionDuration||p.applyAnimationDuration)K=c.duration?parseFloat(c.duration):K,p.applyTransitionDuration&&(p.hasTransitions=!0,B.transitionDuration=K,k=0<n.style[N+"Property"].length,w.push(Ba(K,k))),p.applyAnimationDuration&&(p.hasAnimations=!0,B.animationDuration=K,w.push([ta,K+"s"]));if(0===K&&!p.recalculateTimingStyles)return F();if(null!=c.delay){var ca=parseFloat(c.delay);
p.applyTransitionDelay&&w.push([fa,ca+"s"]);p.applyAnimationDelay&&w.push([ja,ca+"s"])}null==c.duration&&0<B.transitionDuration&&(p.recalculateTimingStyles=p.recalculateTimingStyles||ba);M=1E3*C;P=1E3*K;c.skipBlocking||(p.blockTransition=0<B.transitionDuration,p.blockKeyframeAnimation=0<B.animationDuration&&0<R.animationDelay&&0===R.animationDuration);c.from&&(c.cleanupStyles&&Da(v,n,Object.keys(c.from)),xa(a,c));p.blockTransition||p.blockKeyframeAnimation?D(K):c.skipBlocking||ia(n,!1);return{$$willAnimate:!0,
end:d,start:function(){if(!E)return J={end:d,cancel:r,resume:null,pause:null},G=new u(J),I(s),G}}}}]}]).provider("$$animateCssDriver",["$$animationProvider",function(a){a.drivers.push("$$animateCssDriver");this.$get=["$animateCss","$rootScope","$$AnimateRunner","$rootElement","$sniffer","$$jqLite","$document",function(a,c,d,g,u,z,x){function f(a){return a.replace(/\bng-\S+\b/g,"")}function k(a,b){M(a)&&(a=a.split(" "));M(b)&&(b=b.split(" "));return a.filter(function(a){return-1===b.indexOf(a)}).join(" ")}
function t(c,h,g){function x(a){var b={},c=H(a).getBoundingClientRect();q(["width","height","top","left"],function(a){var d=c[a];switch(a){case "top":d+=I.scrollTop;break;case "left":d+=I.scrollLeft}b[a]=Math.floor(d)+"px"});return b}function e(){var c=f(g.attr("class")||""),d=k(c,m),c=k(m,c),d=a(r,{to:x(g),addClass:"ng-anchor-in "+d,removeClass:"ng-anchor-out "+c,delay:!0});return d.$$willAnimate?d:null}function z(){r.remove();h.removeClass("ng-animate-shim");g.removeClass("ng-animate-shim")}var r=
J(H(h).cloneNode(!0)),m=f(r.attr("class")||"");h.addClass("ng-animate-shim");g.addClass("ng-animate-shim");r.addClass("ng-anchor");A.append(r);var D;c=function(){var c=a(r,{addClass:"ng-anchor-out",delay:!0,from:x(h)});return c.$$willAnimate?c:null}();if(!c&&(D=e(),!D))return z();var F=c||D;return{start:function(){function a(){c&&c.end()}var b,c=F.start();c.done(function(){c=null;if(!D&&(D=e()))return c=D.start(),c.done(function(){c=null;z();b.complete()}),c;z();b.complete()});return b=new d({end:a,
cancel:a})}}}function G(a,b,c,f){var e=h(a,L),g=h(b,L),k=[];q(f,function(a){(a=t(c,a.out,a["in"]))&&k.push(a)});if(e||g||0!==k.length)return{start:function(){function a(){q(b,function(a){a.end()})}var b=[];e&&b.push(e.start());g&&b.push(g.start());q(k,function(a){b.push(a.start())});var c=new d({end:a,cancel:a});d.all(b,function(a){c.complete(a)});return c}}}function h(c){var d=c.element,f=c.options||{};c.structural&&(f.event=c.event,f.structural=!0,f.applyClassesEarly=!0,"leave"===c.event&&(f.onDone=
f.domOperation));f.preparationClasses&&(f.event=X(f.event,f.preparationClasses));c=a(d,f);return c.$$willAnimate?c:null}if(!u.animations&&!u.transitions)return L;var I=x[0].body;c=H(g);var A=J(c.parentNode&&11===c.parentNode.nodeType||I.contains(c)?c:I);P(z);return function(a){return a.from&&a.to?G(a.from,a.to,a.classes,a.anchors):h(a)}}]}]).provider("$$animateJs",["$animateProvider",function(a){this.$get=["$injector","$$AnimateRunner","$$jqLite",function(b,c,d){function g(c){c=W(c)?c:c.split(" ");
for(var d=[],f={},g=0;g<c.length;g++){var q=c[g],u=a.$$registeredAnimations[q];u&&!f[q]&&(d.push(b.get(u)),f[q]=!0)}return d}var u=P(d);return function(a,b,d,k){function t(){k.domOperation();u(a,k)}function G(a,b,d,f,e){switch(d){case "animate":b=[b,f.from,f.to,e];break;case "setClass":b=[b,A,H,e];break;case "addClass":b=[b,A,e];break;case "removeClass":b=[b,H,e];break;default:b=[b,e]}b.push(f);if(a=a.apply(a,b))if(Ea(a.start)&&(a=a.start()),a instanceof c)a.done(e);else if(Ea(a))return a;return L}
function h(a,b,d,e,f){var g=[];q(e,function(e){var h=e[f];h&&g.push(function(){var e,f,g=!1,k=function(a){g||(g=!0,(f||L)(a),e.complete(!a))};e=new c({end:function(){k()},cancel:function(){k(!0)}});f=G(h,a,b,d,function(a){k(!1===a)});return e})});return g}function I(a,b,d,e,f){var g=h(a,b,d,e,f);if(0===g.length){var k,u;"beforeSetClass"===f?(k=h(a,"removeClass",d,e,"beforeRemoveClass"),u=h(a,"addClass",d,e,"beforeAddClass")):"setClass"===f&&(k=h(a,"removeClass",d,e,"removeClass"),u=h(a,"addClass",
d,e,"addClass"));k&&(g=g.concat(k));u&&(g=g.concat(u))}if(0!==g.length)return function(a){var b=[];g.length&&q(g,function(a){b.push(a())});b.length?c.all(b,a):a();return function(a){q(b,function(b){a?b.cancel():b.end()})}}}3===arguments.length&&oa(d)&&(k=d,d=null);k=ha(k);d||(d=a.attr("class")||"",k.addClass&&(d+=" "+k.addClass),k.removeClass&&(d+=" "+k.removeClass));var A=k.addClass,H=k.removeClass,E=g(d),w,y;if(E.length){var e,J;"leave"==b?(J="leave",e="afterLeave"):(J="before"+b.charAt(0).toUpperCase()+
b.substr(1),e=b);"enter"!==b&&"move"!==b&&(w=I(a,b,k,E,J));y=I(a,b,k,E,e)}if(w||y)return{start:function(){function b(c){f=!0;t();da(a,k);g.complete(c)}var d,e=[];w&&e.push(function(a){d=w(a)});e.length?e.push(function(a){t();a(!0)}):t();y&&e.push(function(a){d=y(a)});var f=!1,g=new c({end:function(){f||((d||L)(void 0),b(void 0))},cancel:function(){f||((d||L)(!0),b(!0))}});c.chain(e,b);return g}}}}]}]).provider("$$animateJsDriver",["$$animationProvider",function(a){a.drivers.push("$$animateJsDriver");
this.$get=["$$animateJs","$$AnimateRunner",function(a,c){function d(c){return a(c.element,c.event,c.classes,c.options)}return function(a){if(a.from&&a.to){var b=d(a.from),t=d(a.to);if(b||t)return{start:function(){function a(){return function(){q(d,function(a){a.end()})}}var d=[];b&&d.push(b.start());t&&d.push(t.start());c.all(d,function(a){g.complete(a)});var g=new c({end:a(),cancel:a()});return g}}}else return d(a)}}]}])})(window,window.angular);
//# sourceMappingURL=angular-animate.min.js.map

/*
 AngularJS v1.4.7
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(n,h,p){'use strict';function E(a){var f=[];r(f,h.noop).chars(a);return f.join("")}function g(a,f){var d={},c=a.split(","),b;for(b=0;b<c.length;b++)d[f?h.lowercase(c[b]):c[b]]=!0;return d}function F(a,f){function d(a,b,d,l){b=h.lowercase(b);if(s[b])for(;e.last()&&t[e.last()];)c("",e.last());u[b]&&e.last()==b&&c("",b);(l=v[b]||!!l)||e.push(b);var m={};d.replace(G,function(b,a,f,c,d){m[a]=q(f||c||d||"")});f.start&&f.start(b,m,l)}function c(b,a){var c=0,d;if(a=h.lowercase(a))for(c=e.length-
1;0<=c&&e[c]!=a;c--);if(0<=c){for(d=e.length-1;d>=c;d--)f.end&&f.end(e[d]);e.length=c}}"string"!==typeof a&&(a=null===a||"undefined"===typeof a?"":""+a);var b,k,e=[],m=a,l;for(e.last=function(){return e[e.length-1]};a;){l="";k=!0;if(e.last()&&w[e.last()])a=a.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*"+e.last()+"[^>]*>","i"),function(a,b){b=b.replace(H,"$1").replace(I,"$1");f.chars&&f.chars(q(b));return""}),c("",e.last());else{if(0===a.indexOf("\x3c!--"))b=a.indexOf("--",4),0<=b&&a.lastIndexOf("--\x3e",
b)===b&&(f.comment&&f.comment(a.substring(4,b)),a=a.substring(b+3),k=!1);else if(x.test(a)){if(b=a.match(x))a=a.replace(b[0],""),k=!1}else if(J.test(a)){if(b=a.match(y))a=a.substring(b[0].length),b[0].replace(y,c),k=!1}else K.test(a)&&((b=a.match(z))?(b[4]&&(a=a.substring(b[0].length),b[0].replace(z,d)),k=!1):(l+="<",a=a.substring(1)));k&&(b=a.indexOf("<"),l+=0>b?a:a.substring(0,b),a=0>b?"":a.substring(b),f.chars&&f.chars(q(l)))}if(a==m)throw L("badparse",a);m=a}c()}function q(a){if(!a)return"";A.innerHTML=
a.replace(/</g,"&lt;");return A.textContent}function B(a){return a.replace(/&/g,"&amp;").replace(M,function(a){var d=a.charCodeAt(0);a=a.charCodeAt(1);return"&#"+(1024*(d-55296)+(a-56320)+65536)+";"}).replace(N,function(a){return"&#"+a.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}function r(a,f){var d=!1,c=h.bind(a,a.push);return{start:function(a,k,e){a=h.lowercase(a);!d&&w[a]&&(d=a);d||!0!==C[a]||(c("<"),c(a),h.forEach(k,function(d,e){var k=h.lowercase(e),g="img"===a&&"src"===k||
"background"===k;!0!==O[k]||!0===D[k]&&!f(d,g)||(c(" "),c(e),c('="'),c(B(d)),c('"'))}),c(e?"/>":">"))},end:function(a){a=h.lowercase(a);d||!0!==C[a]||(c("</"),c(a),c(">"));a==d&&(d=!1)},chars:function(a){d||c(B(a))}}}var L=h.$$minErr("$sanitize"),z=/^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,y=/^<\/\s*([\w:-]+)[^>]*>/,G=/([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,K=/^</,J=/^<\//,H=/\x3c!--(.*?)--\x3e/g,x=/<!DOCTYPE([^>]*?)>/i,
I=/<!\[CDATA\[(.*?)]]\x3e/g,M=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,N=/([^\#-~| |!])/g,v=g("area,br,col,hr,img,wbr");n=g("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");p=g("rp,rt");var u=h.extend({},p,n),s=h.extend({},n,g("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul")),t=h.extend({},p,g("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
n=g("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan,use");var w=g("script,style"),C=h.extend({},v,s,t,u,n),D=g("background,cite,href,longdesc,src,usemap,xlink:href");n=g("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width");
p=g("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan",
!0);var O=h.extend({},D,p,n),A=document.createElement("pre");h.module("ngSanitize",[]).provider("$sanitize",function(){this.$get=["$$sanitizeUri",function(a){return function(f){var d=[];F(f,r(d,function(c,b){return!/^unsafe/.test(a(c,b))}));return d.join("")}}]});h.module("ngSanitize").filter("linky",["$sanitize",function(a){var f=/((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,d=/^mailto:/i;return function(c,b){function k(a){a&&g.push(E(a))}function e(a,
c){g.push("<a ");h.isDefined(b)&&g.push('target="',b,'" ');g.push('href="',a.replace(/"/g,"&quot;"),'">');k(c);g.push("</a>")}if(!c)return c;for(var m,l=c,g=[],n,p;m=l.match(f);)n=m[0],m[2]||m[4]||(n=(m[3]?"http://":"mailto:")+n),p=m.index,k(l.substr(0,p)),e(n,m[0].replace(d,"")),l=l.substring(p+m[0].length);k(l);return a(g.join(""))}}])})(window,window.angular);
//# sourceMappingURL=angular-sanitize.min.js.map

/*
 AngularJS v1.4.7
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(z,h,A){'use strict';function m(h){return["$animate",function(r){return{restrict:"AE",transclude:"element",terminal:!0,require:"^^ngMessages",link:function(n,f,a,g,l){var c=f[0],p,h=a.ngMessage||a.when;a=a.ngMessageExp||a.whenExp;var k=function(b){p=b?v(b)?b:b.split(/[\s,]+/):null;g.reRender()};a?(k(n.$eval(a)),n.$watchCollection(a,k)):k(h);var e,q;g.register(c,q={test:function(b){var a=p;b=a?v(a)?0<=a.indexOf(b):a.hasOwnProperty(b):void 0;return b},attach:function(){e||l(n,function(b){r.enter(b,
null,f);e=b;var a=e.$$attachId=g.getAttachId();e.on("$destroy",function(){e&&e.$$attachId===a&&(g.deregister(c),q.detach())})})},detach:function(){if(e){var b=e;e=null;r.leave(b)}}})}}}]}var v=h.isArray,w=h.forEach,x=h.isString,y=h.element;h.module("ngMessages",[]).directive("ngMessages",["$animate",function(h){function r(f,a){return x(a)&&0===a.length||n(f.$eval(a))}function n(f){return x(f)?f.length:!!f}return{require:"ngMessages",restrict:"AE",controller:["$element","$scope","$attrs",function(f,
a,g){function l(b,a){for(var d=a,f=[];d&&d!==b;){var c=d.$$ngMessageNode;if(c&&c.length)return k[c];d.childNodes.length&&-1==f.indexOf(d)?(f.push(d),d=d.childNodes[d.childNodes.length-1]):d=d.previousSibling||d.parentNode}}var c=this,p=0,m=0;this.getAttachId=function(){return m++};var k=this.messages={},e,q;this.render=function(b){b=b||{};e=!1;q=b;for(var p=r(a,g.ngMessagesMultiple)||r(a,g.multiple),d=[],k={},s=c.head,l=!1,m=0;null!=s;){m++;var t=s.message,u=!1;l||w(b,function(a,b){!u&&n(a)&&t.test(b)&&
!k[b]&&(u=k[b]=!0,t.attach())});u?l=!p:d.push(t);s=s.next}w(d,function(b){b.detach()});d.length!==m?h.setClass(f,"ng-active","ng-inactive"):h.setClass(f,"ng-inactive","ng-active")};a.$watchCollection(g.ngMessages||g["for"],c.render);this.reRender=function(){e||(e=!0,a.$evalAsync(function(){e&&q&&c.render(q)}))};this.register=function(b,a){var d=p.toString();k[d]={message:a};var e=f[0],g=k[d];c.head?(e=l(e,b))?(g.next=e.next,e.next=g):(g.next=c.head,c.head=g):c.head=g;b.$$ngMessageNode=d;p++;c.reRender()};
this.deregister=function(b){var a=b.$$ngMessageNode;delete b.$$ngMessageNode;var d=k[a];(b=l(f[0],b))?b.next=d.next:c.head=d.next;delete k[a];c.reRender()}}]}}]).directive("ngMessagesInclude",["$templateRequest","$document","$compile",function(h,m,n){return{restrict:"AE",require:"^^ngMessages",link:function(f,a,g){var l=g.ngMessagesInclude||g.src;h(l).then(function(c){n(c)(f,function(c){a.after(c);c=y(m[0].createComment(" ngMessagesInclude: "+l+" "));a.after(c);a.remove()})})}}}]).directive("ngMessage",
m("AE")).directive("ngMessageExp",m("A"))})(window,window.angular);
//# sourceMappingURL=angular-messages.min.js.map

/**
 * An Angular module that gives you access to the browsers local storage
 * @version v0.1.5 - 2014-11-04
 * @link https://github.com/grevory/angular-local-storage
 * @author grevory <greg@gregpike.ca>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */!function(a,b){"use strict";function c(a){return/^-?\d+\.?\d*$/.test(a.replace(/["']/g,""))}var d=b.isDefined,e=b.isUndefined,f=b.isNumber,g=b.isObject,h=b.isArray,i=b.extend,j=b.toJson,k=b.fromJson,l=b.module("LocalStorageModule",[]);l.provider("localStorageService",function(){this.prefix="ls",this.storageType="localStorage",this.cookie={expiry:30,path:"/"},this.notify={setItem:!0,removeItem:!1},this.setPrefix=function(a){return this.prefix=a,this},this.setStorageType=function(a){return this.storageType=a,this},this.setStorageCookie=function(a,b){return this.cookie={expiry:a,path:b},this},this.setStorageCookieDomain=function(a){return this.cookie.domain=a,this},this.setNotify=function(a,b){return this.notify={setItem:a,removeItem:b},this},this.$get=["$rootScope","$window","$document","$parse",function(a,b,l,m){var n,o=this,p=o.prefix,q=o.cookie,r=o.notify,s=o.storageType;l?l[0]&&(l=l[0]):l=document,"."!==p.substr(-1)&&(p=p?p+".":"");var t=function(a){return p+a},u=function(){try{var c=s in b&&null!==b[s],d=t("__"+Math.round(1e7*Math.random()));return c&&(n=b[s],n.setItem(d,""),n.removeItem(d)),c}catch(e){return s="cookie",a.$broadcast("LocalStorageModule.notification.error",e.message),!1}}(),v=function(b,c){if(e(c)?c=null:(g(c)||h(c)||f(+c||c))&&(c=j(c)),!u||"cookie"===o.storageType)return u||a.$broadcast("LocalStorageModule.notification.warning","LOCAL_STORAGE_NOT_SUPPORTED"),r.setItem&&a.$broadcast("LocalStorageModule.notification.setitem",{key:b,newvalue:c,storageType:"cookie"}),B(b,c);try{(g(c)||h(c))&&(c=j(c)),n&&n.setItem(t(b),c),r.setItem&&a.$broadcast("LocalStorageModule.notification.setitem",{key:b,newvalue:c,storageType:o.storageType})}catch(d){return a.$broadcast("LocalStorageModule.notification.error",d.message),B(b,c)}return!0},w=function(b){if(!u||"cookie"===o.storageType)return u||a.$broadcast("LocalStorageModule.notification.warning","LOCAL_STORAGE_NOT_SUPPORTED"),C(b);var d=n?n.getItem(t(b)):null;return d&&"null"!==d?"{"===d.charAt(0)||"["===d.charAt(0)||c(d)?k(d):d:null},x=function(b){if(!u||"cookie"===o.storageType)return u||a.$broadcast("LocalStorageModule.notification.warning","LOCAL_STORAGE_NOT_SUPPORTED"),r.removeItem&&a.$broadcast("LocalStorageModule.notification.removeitem",{key:b,storageType:"cookie"}),D(b);try{n.removeItem(t(b)),r.removeItem&&a.$broadcast("LocalStorageModule.notification.removeitem",{key:b,storageType:o.storageType})}catch(c){return a.$broadcast("LocalStorageModule.notification.error",c.message),D(b)}return!0},y=function(){if(!u)return a.$broadcast("LocalStorageModule.notification.warning","LOCAL_STORAGE_NOT_SUPPORTED"),!1;var b=p.length,c=[];for(var d in n)if(d.substr(0,b)===p)try{c.push(d.substr(b))}catch(e){return a.$broadcast("LocalStorageModule.notification.error",e.Description),[]}return c},z=function(b){b=b||"";var c=p.slice(0,-1),d=new RegExp(c+"."+b);if(!u||"cookie"===o.storageType)return u||a.$broadcast("LocalStorageModule.notification.warning","LOCAL_STORAGE_NOT_SUPPORTED"),E();var e=p.length;for(var f in n)if(d.test(f))try{x(f.substr(e))}catch(g){return a.$broadcast("LocalStorageModule.notification.error",g.message),E()}return!0},A=function(){try{return b.navigator.cookieEnabled||"cookie"in l&&(l.cookie.length>0||(l.cookie="test").indexOf.call(l.cookie,"test")>-1)}catch(c){return a.$broadcast("LocalStorageModule.notification.error",c.message),!1}}(),B=function(b,c){if(e(c))return!1;if((h(c)||g(c))&&(c=j(c)),!A)return a.$broadcast("LocalStorageModule.notification.error","COOKIES_NOT_SUPPORTED"),!1;try{var d="",f=new Date,i="";if(null===c?(f.setTime(f.getTime()+-864e5),d="; expires="+f.toGMTString(),c=""):0!==q.expiry&&(f.setTime(f.getTime()+24*q.expiry*60*60*1e3),d="; expires="+f.toGMTString()),b){var k="; path="+q.path;q.domain&&(i="; domain="+q.domain),l.cookie=t(b)+"="+encodeURIComponent(c)+d+k+i}}catch(m){return a.$broadcast("LocalStorageModule.notification.error",m.message),!1}return!0},C=function(b){if(!A)return a.$broadcast("LocalStorageModule.notification.error","COOKIES_NOT_SUPPORTED"),!1;for(var c=l.cookie&&l.cookie.split(";")||[],d=0;d<c.length;d++){for(var e=c[d];" "===e.charAt(0);)e=e.substring(1,e.length);if(0===e.indexOf(t(b)+"=")){var f=decodeURIComponent(e.substring(p.length+b.length+1,e.length));try{var g=JSON.parse(f);return k(g)}catch(h){return f}}}return null},D=function(a){B(a,null)},E=function(){for(var a=null,b=p.length,c=l.cookie.split(";"),d=0;d<c.length;d++){for(a=c[d];" "===a.charAt(0);)a=a.substring(1,a.length);var e=a.substring(b,a.indexOf("="));D(e)}},F=function(){return s},G=function(a,b,c,e){e=e||b;var f=w(e);return null===f&&d(c)?f=c:g(f)&&g(c)&&(f=i(c,f)),m(b).assign(a,f),a.$watch(b,function(a){v(e,a)},g(a[b]))},H=function(){for(var a=0,c=b[s],d=0;d<c.length;d++)0===c.key(d).indexOf(p)&&a++;return a};return{isSupported:u,getStorageType:F,set:v,add:v,get:w,keys:y,remove:x,clearAll:z,bind:G,deriveKey:t,length:H,cookie:{isSupported:A,set:B,add:B,get:C,remove:D,clearAll:E}}}]})}(window,window.angular);
// PouchDB 5.3.1
//
// (c) 2012-2016 Dale Harvey and the PouchDB team
// PouchDB may be freely distributed under the Apache license, version 2.0.
// For all details and documentation:
// http://pouchdb.com

// Includes changes by CommonTime:
//
// - If window.cordova === false, then we ignore the user agent string as we assume we are running
//   on a desktop (not device) and therefore the user agent string which is normally used to determine
//   platform is probably being spoofed by device emulation
//

(function (f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f()
    } else if (typeof define === "function" && define.amd) {
        define([], f)
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window
        } else if (typeof global !== "undefined") {
            g = global
        } else if (typeof self !== "undefined") {
            g = self
        } else {
            g = this
        }
        g.PouchDB = f()
    }
})(function () {
    var define, module, exports;
    return (function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a)return a(o, !0);
                    if (i)return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f
                }
                var l = n[o] = { exports: {} };
                t[o][0].call(l.exports, function (e) {
                    var n = t[o][1][e];
                    return s(n ? n : e)
                }, l, l.exports, e, t, n, r)
            }
            return n[o].exports
        }

        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++)s(r[o]);
        return s
    })({
        1: [
            function (_dereq_, module, exports) {
                'use strict';

                module.exports = argsArray;

                function argsArray(fun) {
                    return function () {
                        var len = arguments.length;
                        if (len) {
                            var args = [];
                            var i = -1;
                            while (++i < len) {
                                args[i] = arguments[i];
                            }
                            return fun.call(this, args);
                        } else {
                            return fun.call(this, []);
                        }
                    };
                }
            }, {}
        ], 2: [
            function (_dereq_, module, exports) {

                /**
                 * This is the web browser implementation of `debug()`.
                 *
                 * Expose `debug()` as the module.
                 */

                exports = module.exports = _dereq_(3);
                exports.log = log;
                exports.formatArgs = formatArgs;
                exports.save = save;
                exports.load = load;
                exports.useColors = useColors;
                exports.storage = 'undefined' != typeof chrome
                && 'undefined' != typeof chrome.storage
                    ? chrome.storage.local
                    : localstorage();

                /**
                 * Colors.
                 */

                exports.colors = [
                    'lightseagreen',
                    'forestgreen',
                    'goldenrod',
                    'dodgerblue',
                    'darkorchid',
                    'crimson'
                ];

                /**
                 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
                 * and the Firebug extension (any Firefox version) are known
                 * to support "%c" CSS customizations.
                 *
                 * TODO: add a `localStorage` variable to explicitly enable/disable colors
                 */

                function useColors() {
                    // is webkit? http://stackoverflow.com/a/16459606/376773
                    return ('WebkitAppearance' in document.documentElement.style) ||
                        // is firebug? http://stackoverflow.com/a/398120/376773
                        (window.console && (console.firebug || (console.exception && console.table))) ||
                        // is firefox >= v31?
                        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                        (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
                }

                /**
                 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
                 */

                exports.formatters.j = function (v) {
                    return JSON.stringify(v);
                };


                /**
                 * Colorize log arguments if enabled.
                 *
                 * @api public
                 */

                function formatArgs() {
                    var args = arguments;
                    var useColors = this.useColors;

                    args[0] = (useColors ? '%c' : '')
                        + this.namespace
                        + (useColors ? ' %c' : ' ')
                        + args[0]
                        + (useColors ? '%c ' : ' ')
                        + '+' + exports.humanize(this.diff);

                    if (!useColors) return args;

                    var c = 'color: ' + this.color;
                    args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

                    // the final "%c" is somewhat tricky, because there could be other
                    // arguments passed either before or after the %c, so we need to
                    // figure out the correct index to insert the CSS into
                    var index = 0;
                    var lastC = 0;
                    args[0].replace(/%[a-z%]/g, function (match) {
                        if ('%%' === match) return;
                        index++;
                        if ('%c' === match) {
                            // we only are interested in the *last* %c
                            // (the user may have provided their own)
                            lastC = index;
                        }
                    });

                    args.splice(lastC, 0, c);
                    return args;
                }

                /**
                 * Invokes `console.log()` when available.
                 * No-op when `console.log` is not a "function".
                 *
                 * @api public
                 */

                function log() {
                    // this hackery is required for IE8/9, where
                    // the `console.log` function doesn't have 'apply'
                    return 'object' === typeof console
                        && console.log
                        && Function.prototype.apply.call(console.log, console, arguments);
                }

                /**
                 * Save `namespaces`.
                 *
                 * @param {String} namespaces
                 * @api private
                 */

                function save(namespaces) {
                    try {
                        if (null == namespaces) {
                            exports.storage.removeItem('debug');
                        } else {
                            exports.storage.debug = namespaces;
                        }
                    } catch (e) {
                    }
                }

                /**
                 * Load `namespaces`.
                 *
                 * @return {String} returns the previously persisted debug modes
                 * @api private
                 */

                function load() {
                    var r;
                    try {
                        r = exports.storage.debug;
                    } catch (e) {
                    }
                    return r;
                }

                /**
                 * Enable namespaces listed in `localStorage.debug` initially.
                 */

                exports.enable(load());

                /**
                 * Localstorage attempts to return the localstorage.
                 *
                 * This is necessary because safari throws
                 * when a user disables cookies/localstorage
                 * and you attempt to access it.
                 *
                 * @return {LocalStorage}
                 * @api private
                 */

                function localstorage() {
                    try {
                        return window.localStorage;
                    } catch (e) {
                    }
                }

            }, { "3": 3 }
        ], 3: [
            function (_dereq_, module, exports) {

                /**
                 * This is the common logic for both the Node.js and web browser
                 * implementations of `debug()`.
                 *
                 * Expose `debug()` as the module.
                 */

                exports = module.exports = debug;
                exports.coerce = coerce;
                exports.disable = disable;
                exports.enable = enable;
                exports.enabled = enabled;
                exports.humanize = _dereq_(9);

                /**
                 * The currently active debug mode names, and names to skip.
                 */

                exports.names = [];
                exports.skips = [];

                /**
                 * Map of special "%n" handling functions, for the debug "format" argument.
                 *
                 * Valid key names are a single, lowercased letter, i.e. "n".
                 */

                exports.formatters = {};

                /**
                 * Previously assigned color.
                 */

                var prevColor = 0;

                /**
                 * Previous log timestamp.
                 */

                var prevTime;

                /**
                 * Select a color.
                 *
                 * @return {Number}
                 * @api private
                 */

                function selectColor() {
                    return exports.colors[prevColor++ % exports.colors.length];
                }

                /**
                 * Create a debugger with the given `namespace`.
                 *
                 * @param {String} namespace
                 * @return {Function}
                 * @api public
                 */

                function debug(namespace) {

                    // define the `disabled` version
                    function disabled() {
                    }

                    disabled.enabled = false;

                    // define the `enabled` version
                    function enabled() {

                        var self = enabled;

                        // set `diff` timestamp
                        var curr = +new Date();
                        var ms = curr - (prevTime || curr);
                        self.diff = ms;
                        self.prev = prevTime;
                        self.curr = curr;
                        prevTime = curr;

                        // add the `color` if not set
                        if (null == self.useColors) self.useColors = exports.useColors();
                        if (null == self.color && self.useColors) self.color = selectColor();

                        var args = Array.prototype.slice.call(arguments);

                        args[0] = exports.coerce(args[0]);

                        if ('string' !== typeof args[0]) {
                            // anything else let's inspect with %o
                            args = ['%o'].concat(args);
                        }

                        // apply any `formatters` transformations
                        var index = 0;
                        args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
                            // if we encounter an escaped % then don't increase the array index
                            if (match === '%%') return match;
                            index++;
                            var formatter = exports.formatters[format];
                            if ('function' === typeof formatter) {
                                var val = args[index];
                                match = formatter.call(self, val);

                                // now we need to remove `args[index]` since it's inlined in the `format`
                                args.splice(index, 1);
                                index--;
                            }
                            return match;
                        });

                        if ('function' === typeof exports.formatArgs) {
                            args = exports.formatArgs.apply(self, args);
                        }
                        var logFn = enabled.log || exports.log || console.log.bind(console);
                        logFn.apply(self, args);
                    }

                    enabled.enabled = true;

                    var fn = exports.enabled(namespace) ? enabled : disabled;

                    fn.namespace = namespace;

                    return fn;
                }

                /**
                 * Enables a debug mode by namespaces. This can include modes
                 * separated by a colon and wildcards.
                 *
                 * @param {String} namespaces
                 * @api public
                 */

                function enable(namespaces) {
                    exports.save(namespaces);

                    var split = (namespaces || '').split(/[\s,]+/);
                    var len = split.length;

                    for (var i = 0; i < len; i++) {
                        if (!split[i]) continue; // ignore empty strings
                        namespaces = split[i].replace(/\*/g, '.*?');
                        if (namespaces[0] === '-') {
                            exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
                        } else {
                            exports.names.push(new RegExp('^' + namespaces + '$'));
                        }
                    }
                }

                /**
                 * Disable debug output.
                 *
                 * @api public
                 */

                function disable() {
                    exports.enable('');
                }

                /**
                 * Returns true if the given mode name is enabled, false otherwise.
                 *
                 * @param {String} name
                 * @return {Boolean}
                 * @api public
                 */

                function enabled(name) {
                    var i, len;
                    for (i = 0, len = exports.skips.length; i < len; i++) {
                        if (exports.skips[i].test(name)) {
                            return false;
                        }
                    }
                    for (i = 0, len = exports.names.length; i < len; i++) {
                        if (exports.names[i].test(name)) {
                            return true;
                        }
                    }
                    return false;
                }

                /**
                 * Coerce `val`.
                 *
                 * @param {Mixed} val
                 * @return {Mixed}
                 * @api private
                 */

                function coerce(val) {
                    if (val instanceof Error) return val.stack || val.message;
                    return val;
                }

            }, { "9": 9 }
        ], 4: [
            function (_dereq_, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

                function EventEmitter() {
                    this._events = this._events || {};
                    this._maxListeners = this._maxListeners || undefined;
                }

                module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
                EventEmitter.EventEmitter = EventEmitter;

                EventEmitter.prototype._events = undefined;
                EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
                EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
                EventEmitter.prototype.setMaxListeners = function (n) {
                    if (!isNumber(n) || n < 0 || isNaN(n))
                        throw TypeError('n must be a positive number');
                    this._maxListeners = n;
                    return this;
                };

                EventEmitter.prototype.emit = function (type) {
                    var er, handler, len, args, i, listeners;

                    if (!this._events)
                        this._events = {};

                    // If there is no 'error' event listener then throw.
                    if (type === 'error') {
                        if (!this._events.error ||
                            (isObject(this._events.error) && !this._events.error.length)) {
                            er = arguments[1];
                            if (er instanceof Error) {
                                throw er; // Unhandled 'error' event
                            }
                            throw TypeError('Uncaught, unspecified "error" event.');
                        }
                    }

                    handler = this._events[type];

                    if (isUndefined(handler))
                        return false;

                    if (isFunction(handler)) {
                        switch (arguments.length) {
                            // fast cases
                            case 1:
                                handler.call(this);
                                break;
                            case 2:
                                handler.call(this, arguments[1]);
                                break;
                            case 3:
                                handler.call(this, arguments[1], arguments[2]);
                                break;
                            // slower
                            default:
                                args = Array.prototype.slice.call(arguments, 1);
                                handler.apply(this, args);
                        }
                    } else if (isObject(handler)) {
                        args = Array.prototype.slice.call(arguments, 1);
                        listeners = handler.slice();
                        len = listeners.length;
                        for (i = 0; i < len; i++)
                            listeners[i].apply(this, args);
                    }

                    return true;
                };

                EventEmitter.prototype.addListener = function (type, listener) {
                    var m;

                    if (!isFunction(listener))
                        throw TypeError('listener must be a function');

                    if (!this._events)
                        this._events = {};

                    // To avoid recursion in the case that type === "newListener"! Before
                    // adding it to the listeners, first emit "newListener".
                    if (this._events.newListener)
                        this.emit('newListener', type,
                            isFunction(listener.listener) ?
                                listener.listener : listener);

                    if (!this._events[type])
                    // Optimize the case of one listener. Don't need the extra array object.
                        this._events[type] = listener;
                    else if (isObject(this._events[type]))
                    // If we've already got an array, just append.
                        this._events[type].push(listener);
                    else
                    // Adding the second element, need to change to array.
                        this._events[type] = [this._events[type], listener];

                    // Check for listener leak
                    if (isObject(this._events[type]) && !this._events[type].warned) {
                        if (!isUndefined(this._maxListeners)) {
                            m = this._maxListeners;
                        } else {
                            m = EventEmitter.defaultMaxListeners;
                        }

                        if (m && m > 0 && this._events[type].length > m) {
                            this._events[type].warned = true;
                            console.error('(node) warning: possible EventEmitter memory ' +
                                'leak detected. %d listeners added. ' +
                                'Use emitter.setMaxListeners() to increase limit.',
                                this._events[type].length);
                            if (typeof console.trace === 'function') {
                                // not supported in IE 10
                                console.trace();
                            }
                        }
                    }

                    return this;
                };

                EventEmitter.prototype.on = EventEmitter.prototype.addListener;

                EventEmitter.prototype.once = function (type, listener) {
                    if (!isFunction(listener))
                        throw TypeError('listener must be a function');

                    var fired = false;

                    function g() {
                        this.removeListener(type, g);

                        if (!fired) {
                            fired = true;
                            listener.apply(this, arguments);
                        }
                    }

                    g.listener = listener;
                    this.on(type, g);

                    return this;
                };

// emits a 'removeListener' event iff the listener was removed
                EventEmitter.prototype.removeListener = function (type, listener) {
                    var list, position, length, i;

                    if (!isFunction(listener))
                        throw TypeError('listener must be a function');

                    if (!this._events || !this._events[type])
                        return this;

                    list = this._events[type];
                    length = list.length;
                    position = -1;

                    if (list === listener ||
                        (isFunction(list.listener) && list.listener === listener)) {
                        delete this._events[type];
                        if (this._events.removeListener)
                            this.emit('removeListener', type, listener);

                    } else if (isObject(list)) {
                        for (i = length; i-- > 0;) {
                            if (list[i] === listener ||
                                (list[i].listener && list[i].listener === listener)) {
                                position = i;
                                break;
                            }
                        }

                        if (position < 0)
                            return this;

                        if (list.length === 1) {
                            list.length = 0;
                            delete this._events[type];
                        } else {
                            list.splice(position, 1);
                        }

                        if (this._events.removeListener)
                            this.emit('removeListener', type, listener);
                    }

                    return this;
                };

                EventEmitter.prototype.removeAllListeners = function (type) {
                    var key, listeners;

                    if (!this._events)
                        return this;

                    // not listening for removeListener, no need to emit
                    if (!this._events.removeListener) {
                        if (arguments.length === 0)
                            this._events = {};
                        else if (this._events[type])
                            delete this._events[type];
                        return this;
                    }

                    // emit removeListener for all listeners on all events
                    if (arguments.length === 0) {
                        for (key in this._events) {
                            if (key === 'removeListener') continue;
                            this.removeAllListeners(key);
                        }
                        this.removeAllListeners('removeListener');
                        this._events = {};
                        return this;
                    }

                    listeners = this._events[type];

                    if (isFunction(listeners)) {
                        this.removeListener(type, listeners);
                    } else if (listeners) {
                        // LIFO order
                        while (listeners.length)
                            this.removeListener(type, listeners[listeners.length - 1]);
                    }
                    delete this._events[type];

                    return this;
                };

                EventEmitter.prototype.listeners = function (type) {
                    var ret;
                    if (!this._events || !this._events[type])
                        ret = [];
                    else if (isFunction(this._events[type]))
                        ret = [this._events[type]];
                    else
                        ret = this._events[type].slice();
                    return ret;
                };

                EventEmitter.prototype.listenerCount = function (type) {
                    if (this._events) {
                        var evlistener = this._events[type];

                        if (isFunction(evlistener))
                            return 1;
                        else if (evlistener)
                            return evlistener.length;
                    }
                    return 0;
                };

                EventEmitter.listenerCount = function (emitter, type) {
                    return emitter.listenerCount(type);
                };

                function isFunction(arg) {
                    return typeof arg === 'function';
                }

                function isNumber(arg) {
                    return typeof arg === 'number';
                }

                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }

                function isUndefined(arg) {
                    return arg === void 0;
                }

            }, {}
        ], 5: [
            function (_dereq_, module, exports) {
                (function (global) {
                    'use strict';
                    var Mutation = global.MutationObserver || global.WebKitMutationObserver;

                    var scheduleDrain;

                    {
                        if (Mutation) {
                            var called = 0;
                            var observer = new Mutation(nextTick);
                            var element = global.document.createTextNode('');
                            observer.observe(element, {
                                characterData: true
                            });
                            scheduleDrain = function () {
                                element.data = (called = ++called % 2);
                            };
                        } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
                            var channel = new global.MessageChannel();
                            channel.port1.onmessage = nextTick;
                            scheduleDrain = function () {
                                channel.port2.postMessage(0);
                            };
                        } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
                            scheduleDrain = function () {

                                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                                var scriptEl = global.document.createElement('script');
                                scriptEl.onreadystatechange = function () {
                                    nextTick();

                                    scriptEl.onreadystatechange = null;
                                    scriptEl.parentNode.removeChild(scriptEl);
                                    scriptEl = null;
                                };
                                global.document.documentElement.appendChild(scriptEl);
                            };
                        } else {
                            scheduleDrain = function () {
                                setTimeout(nextTick, 0);
                            };
                        }
                    }

                    var draining;
                    var queue = [];
//named nextTick for less confusing stack traces
                    function nextTick() {
                        draining = true;
                        var i, oldQueue;
                        var len = queue.length;
                        while (len) {
                            oldQueue = queue;
                            queue = [];
                            i = -1;
                            while (++i < len) {
                                oldQueue[i]();
                            }
                            len = queue.length;
                        }
                        draining = false;
                    }

                    module.exports = immediate;
                    function immediate(task) {
                        if (queue.push(task) === 1 && !draining) {
                            scheduleDrain();
                        }
                    }

                }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, {}
        ], 6: [
            function (_dereq_, module, exports) {
                if (typeof Object.create === 'function') {
                    // implementation from standard node.js 'util' module
                    module.exports = function inherits(ctor, superCtor) {
                        ctor.super_ = superCtor
                        ctor.prototype = Object.create(superCtor.prototype, {
                            constructor: {
                                value: ctor,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                    };
                } else {
                    // old school shim for old browsers
                    module.exports = function inherits(ctor, superCtor) {
                        ctor.super_ = superCtor
                        var TempCtor = function () {
                        }
                        TempCtor.prototype = superCtor.prototype
                        ctor.prototype = new TempCtor()
                        ctor.prototype.constructor = ctor
                    }
                }

            }, {}
        ], 7: [
            function (_dereq_, module, exports) {
                (function (factory) {
                    if (typeof exports === 'object') {
                        factory(exports);
                    } else {
                        factory(this);
                    }
                }).call(this, function (root) {

                    var slice = Array.prototype.slice,
                        each = Array.prototype.forEach;

                    var extend = function (obj) {
                        if (typeof obj !== 'object') throw obj + ' is not an object';

                        var sources = slice.call(arguments, 1);

                        each.call(sources, function (source) {
                            if (source) {
                                for (var prop in source) {
                                    if (typeof source[prop] === 'object' && obj[prop]) {
                                        extend.call(obj, obj[prop], source[prop]);
                                    } else {
                                        obj[prop] = source[prop];
                                    }
                                }
                            }
                        });

                        return obj;
                    }

                    root.extend = extend;
                });

            }, {}
        ], 8: [
            function (_dereq_, module, exports) {
                'use strict';
                var immediate = _dereq_(5);

                /* istanbul ignore next */
                function INTERNAL() {
                }

                var handlers = {};

                var REJECTED = ['REJECTED'];
                var FULFILLED = ['FULFILLED'];
                var PENDING = ['PENDING'];

                module.exports = exports = Promise;

                function Promise(resolver) {
                    if (typeof resolver !== 'function') {
                        throw new TypeError('resolver must be a function');
                    }
                    this.state = PENDING;
                    this.queue = [];
                    this.outcome = void 0;
                    if (resolver !== INTERNAL) {
                        safelyResolveThenable(this, resolver);
                    }
                }

                Promise.prototype["catch"] = function (onRejected) {
                    return this.then(null, onRejected);
                };
                Promise.prototype.then = function (onFulfilled, onRejected) {
                    if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
                        typeof onRejected !== 'function' && this.state === REJECTED) {
                        return this;
                    }
                    var promise = new this.constructor(INTERNAL);
                    if (this.state !== PENDING) {
                        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
                        unwrap(promise, resolver, this.outcome);
                    } else {
                        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
                    }

                    return promise;
                };
                function QueueItem(promise, onFulfilled, onRejected) {
                    this.promise = promise;
                    if (typeof onFulfilled === 'function') {
                        this.onFulfilled = onFulfilled;
                        this.callFulfilled = this.otherCallFulfilled;
                    }
                    if (typeof onRejected === 'function') {
                        this.onRejected = onRejected;
                        this.callRejected = this.otherCallRejected;
                    }
                }

                QueueItem.prototype.callFulfilled = function (value) {
                    handlers.resolve(this.promise, value);
                };
                QueueItem.prototype.otherCallFulfilled = function (value) {
                    unwrap(this.promise, this.onFulfilled, value);
                };
                QueueItem.prototype.callRejected = function (value) {
                    handlers.reject(this.promise, value);
                };
                QueueItem.prototype.otherCallRejected = function (value) {
                    unwrap(this.promise, this.onRejected, value);
                };

                function unwrap(promise, func, value) {
                    immediate(function () {
                        var returnValue;
                        try {
                            returnValue = func(value);
                        } catch (e) {
                            return handlers.reject(promise, e);
                        }
                        if (returnValue === promise) {
                            handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
                        } else {
                            handlers.resolve(promise, returnValue);
                        }
                    });
                }

                handlers.resolve = function (self, value) {
                    var result = tryCatch(getThen, value);
                    if (result.status === 'error') {
                        return handlers.reject(self, result.value);
                    }
                    var thenable = result.value;

                    if (thenable) {
                        safelyResolveThenable(self, thenable);
                    } else {
                        self.state = FULFILLED;
                        self.outcome = value;
                        var i = -1;
                        var len = self.queue.length;
                        while (++i < len) {
                            self.queue[i].callFulfilled(value);
                        }
                    }
                    return self;
                };
                handlers.reject = function (self, error) {
                    self.state = REJECTED;
                    self.outcome = error;
                    var i = -1;
                    var len = self.queue.length;
                    while (++i < len) {
                        self.queue[i].callRejected(error);
                    }
                    return self;
                };

                function getThen(obj) {
                    // Make sure we only access the accessor once as required by the spec
                    var then = obj && obj.then;
                    if (obj && typeof obj === 'object' && typeof then === 'function') {
                        return function appyThen() {
                            then.apply(obj, arguments);
                        };
                    }
                }

                function safelyResolveThenable(self, thenable) {
                    // Either fulfill, reject or reject with error
                    var called = false;

                    function onError(value) {
                        if (called) {
                            return;
                        }
                        called = true;
                        handlers.reject(self, value);
                    }

                    function onSuccess(value) {
                        if (called) {
                            return;
                        }
                        called = true;
                        handlers.resolve(self, value);
                    }

                    function tryToUnwrap() {
                        thenable(onSuccess, onError);
                    }

                    var result = tryCatch(tryToUnwrap);
                    if (result.status === 'error') {
                        onError(result.value);
                    }
                }

                function tryCatch(func, value) {
                    var out = {};
                    try {
                        out.value = func(value);
                        out.status = 'success';
                    } catch (e) {
                        out.status = 'error';
                        out.value = e;
                    }
                    return out;
                }

                exports.resolve = resolve;
                function resolve(value) {
                    if (value instanceof this) {
                        return value;
                    }
                    return handlers.resolve(new this(INTERNAL), value);
                }

                exports.reject = reject;
                function reject(reason) {
                    var promise = new this(INTERNAL);
                    return handlers.reject(promise, reason);
                }

                exports.all = all;
                function all(iterable) {
                    var self = this;
                    if (Object.prototype.toString.call(iterable) !== '[object Array]') {
                        return this.reject(new TypeError('must be an array'));
                    }

                    var len = iterable.length;
                    var called = false;
                    if (!len) {
                        return this.resolve([]);
                    }

                    var values = new Array(len);
                    var resolved = 0;
                    var i = -1;
                    var promise = new this(INTERNAL);

                    while (++i < len) {
                        allResolver(iterable[i], i);
                    }
                    return promise;
                    function allResolver(value, i) {
                        self.resolve(value).then(resolveFromAll, function (error) {
                            if (!called) {
                                called = true;
                                handlers.reject(promise, error);
                            }
                        });
                        function resolveFromAll(outValue) {
                            values[i] = outValue;
                            if (++resolved === len && !called) {
                                called = true;
                                handlers.resolve(promise, values);
                            }
                        }
                    }
                }

                exports.race = race;
                function race(iterable) {
                    var self = this;
                    if (Object.prototype.toString.call(iterable) !== '[object Array]') {
                        return this.reject(new TypeError('must be an array'));
                    }

                    var len = iterable.length;
                    var called = false;
                    if (!len) {
                        return this.resolve([]);
                    }

                    var i = -1;
                    var promise = new this(INTERNAL);

                    while (++i < len) {
                        resolver(iterable[i]);
                    }
                    return promise;
                    function resolver(value) {
                        self.resolve(value).then(function (response) {
                            if (!called) {
                                called = true;
                                handlers.resolve(promise, response);
                            }
                        }, function (error) {
                            if (!called) {
                                called = true;
                                handlers.reject(promise, error);
                            }
                        });
                    }
                }

            }, { "5": 5 }
        ], 9: [
            function (_dereq_, module, exports) {
                /**
                 * Helpers.
                 */

                var s = 1000;
                var m = s * 60;
                var h = m * 60;
                var d = h * 24;
                var y = d * 365.25;

                /**
                 * Parse or format the given `val`.
                 *
                 * Options:
                 *
                 *  - `long` verbose formatting [false]
                 *
                 * @param {String|Number} val
                 * @param {Object} options
                 * @return {String|Number}
                 * @api public
                 */

                module.exports = function (val, options) {
                    options = options || {};
                    if ('string' == typeof val) return parse(val);
                    return options.long
                        ? long(val)
                        : short(val);
                };

                /**
                 * Parse the given `str` and return milliseconds.
                 *
                 * @param {String} str
                 * @return {Number}
                 * @api private
                 */

                function parse(str) {
                    str = '' + str;
                    if (str.length > 10000) return;
                    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
                    if (!match) return;
                    var n = parseFloat(match[1]);
                    var type = (match[2] || 'ms').toLowerCase();
                    switch (type) {
                        case 'years':
                        case 'year':
                        case 'yrs':
                        case 'yr':
                        case 'y':
                            return n * y;
                        case 'days':
                        case 'day':
                        case 'd':
                            return n * d;
                        case 'hours':
                        case 'hour':
                        case 'hrs':
                        case 'hr':
                        case 'h':
                            return n * h;
                        case 'minutes':
                        case 'minute':
                        case 'mins':
                        case 'min':
                        case 'm':
                            return n * m;
                        case 'seconds':
                        case 'second':
                        case 'secs':
                        case 'sec':
                        case 's':
                            return n * s;
                        case 'milliseconds':
                        case 'millisecond':
                        case 'msecs':
                        case 'msec':
                        case 'ms':
                            return n;
                    }
                }

                /**
                 * Short format for `ms`.
                 *
                 * @param {Number} ms
                 * @return {String}
                 * @api private
                 */

                function short(ms) {
                    if (ms >= d) return Math.round(ms / d) + 'd';
                    if (ms >= h) return Math.round(ms / h) + 'h';
                    if (ms >= m) return Math.round(ms / m) + 'm';
                    if (ms >= s) return Math.round(ms / s) + 's';
                    return ms + 'ms';
                }

                /**
                 * Long format for `ms`.
                 *
                 * @param {Number} ms
                 * @return {String}
                 * @api private
                 */

                function long(ms) {
                    return plural(ms, d, 'day')
                        || plural(ms, h, 'hour')
                        || plural(ms, m, 'minute')
                        || plural(ms, s, 'second')
                        || ms + ' ms';
                }

                /**
                 * Pluralization helper.
                 */

                function plural(ms, n, name) {
                    if (ms < n) return;
                    if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
                    return Math.ceil(ms / n) + ' ' + name + 's';
                }

            }, {}
        ], 10: [
            function (_dereq_, module, exports) {
                'use strict';

                var MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE
                var MAGNITUDE_DIGITS = 3; // ditto
                var SEP = ''; // set to '_' for easier debugging

                var utils = _dereq_(11);

                exports.collate = function (a, b) {

                    if (a === b) {
                        return 0;
                    }

                    a = exports.normalizeKey(a);
                    b = exports.normalizeKey(b);

                    var ai = collationIndex(a);
                    var bi = collationIndex(b);
                    if ((ai - bi) !== 0) {
                        return ai - bi;
                    }
                    if (a === null) {
                        return 0;
                    }
                    switch (typeof a) {
                        case 'number':
                            return a - b;
                        case 'boolean':
                            return a === b ? 0 : (a < b ? -1 : 1);
                        case 'string':
                            return stringCollate(a, b);
                    }
                    return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);
                };

// couch considers null/NaN/Infinity/-Infinity === undefined,
// for the purposes of mapreduce indexes. also, dates get stringified.
                exports.normalizeKey = function (key) {
                    switch (typeof key) {
                        case 'undefined':
                            return null;
                        case 'number':
                            if (key === Infinity || key === -Infinity || isNaN(key)) {
                                return null;
                            }
                            return key;
                        case 'object':
                            var origKey = key;
                            if (Array.isArray(key)) {
                                var len = key.length;
                                key = new Array(len);
                                for (var i = 0; i < len; i++) {
                                    key[i] = exports.normalizeKey(origKey[i]);
                                }
                            } else if (key instanceof Date) {
                                return key.toJSON();
                            } else if (key !== null) { // generic object
                                key = {};
                                for (var k in origKey) {
                                    if (origKey.hasOwnProperty(k)) {
                                        var val = origKey[k];
                                        if (typeof val !== 'undefined') {
                                            key[k] = exports.normalizeKey(val);
                                        }
                                    }
                                }
                            }
                    }
                    return key;
                };

                function indexify(key) {
                    if (key !== null) {
                        switch (typeof key) {
                            case 'boolean':
                                return key ? 1 : 0;
                            case 'number':
                                return numToIndexableString(key);
                            case 'string':
                                // We've to be sure that key does not contain \u0000
                                // Do order-preserving replacements:
                                // 0 -> 1, 1
                                // 1 -> 1, 2
                                // 2 -> 2, 2
                                return key
                                    .replace(/\u0002/g, '\u0002\u0002')
                                    .replace(/\u0001/g, '\u0001\u0002')
                                    .replace(/\u0000/g, '\u0001\u0001');
                            case 'object':
                                var isArray = Array.isArray(key);
                                var arr = isArray ? key : Object.keys(key);
                                var i = -1;
                                var len = arr.length;
                                var result = '';
                                if (isArray) {
                                    while (++i < len) {
                                        result += exports.toIndexableString(arr[i]);
                                    }
                                } else {
                                    while (++i < len) {
                                        var objKey = arr[i];
                                        result += exports.toIndexableString(objKey) +
                                            exports.toIndexableString(key[objKey]);
                                    }
                                }
                                return result;
                        }
                    }
                    return '';
                }

// convert the given key to a string that would be appropriate
// for lexical sorting, e.g. within a database, where the
// sorting is the same given by the collate() function.
                exports.toIndexableString = function (key) {
                    var zero = '\u0000';
                    key = exports.normalizeKey(key);
                    return collationIndex(key) + SEP + indexify(key) + zero;
                };

                function parseNumber(str, i) {
                    var originalIdx = i;
                    var num;
                    var zero = str[i] === '1';
                    if (zero) {
                        num = 0;
                        i++;
                    } else {
                        var neg = str[i] === '0';
                        i++;
                        var numAsString = '';
                        var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);
                        var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;
                        if (neg) {
                            magnitude = -magnitude;
                        }
                        i += MAGNITUDE_DIGITS;
                        while (true) {
                            var ch = str[i];
                            if (ch === '\u0000') {
                                break;
                            } else {
                                numAsString += ch;
                            }
                            i++;
                        }
                        numAsString = numAsString.split('.');
                        if (numAsString.length === 1) {
                            num = parseInt(numAsString, 10);
                        } else {
                            num = parseFloat(numAsString[0] + '.' + numAsString[1]);
                        }
                        if (neg) {
                            num = num - 10;
                        }
                        if (magnitude !== 0) {
                            // parseFloat is more reliable than pow due to rounding errors
                            // e.g. Number.MAX_VALUE would return Infinity if we did
                            // num * Math.pow(10, magnitude);
                            num = parseFloat(num + 'e' + magnitude);
                        }
                    }
                    return { num: num, length: i - originalIdx };
                }

// move up the stack while parsing
// this function moved outside of parseIndexableString for performance
                function pop(stack, metaStack) {
                    var obj = stack.pop();

                    if (metaStack.length) {
                        var lastMetaElement = metaStack[metaStack.length - 1];
                        if (obj === lastMetaElement.element) {
                            // popping a meta-element, e.g. an object whose value is another object
                            metaStack.pop();
                            lastMetaElement = metaStack[metaStack.length - 1];
                        }
                        var element = lastMetaElement.element;
                        var lastElementIndex = lastMetaElement.index;
                        if (Array.isArray(element)) {
                            element.push(obj);
                        } else if (lastElementIndex === stack.length - 2) { // obj with key+value
                            var key = stack.pop();
                            element[key] = obj;
                        } else {
                            stack.push(obj); // obj with key only
                        }
                    }
                }

                exports.parseIndexableString = function (str) {
                    var stack = [];
                    var metaStack = []; // stack for arrays and objects
                    var i = 0;

                    while (true) {
                        var collationIndex = str[i++];
                        if (collationIndex === '\u0000') {
                            if (stack.length === 1) {
                                return stack.pop();
                            } else {
                                pop(stack, metaStack);
                                continue;
                            }
                        }
                        switch (collationIndex) {
                            case '1':
                                stack.push(null);
                                break;
                            case '2':
                                stack.push(str[i] === '1');
                                i++;
                                break;
                            case '3':
                                var parsedNum = parseNumber(str, i);
                                stack.push(parsedNum.num);
                                i += parsedNum.length;
                                break;
                            case '4':
                                var parsedStr = '';
                                while (true) {
                                    var ch = str[i];
                                    if (ch === '\u0000') {
                                        break;
                                    }
                                    parsedStr += ch;
                                    i++;
                                }
                                // perform the reverse of the order-preserving replacement
                                // algorithm (see above)
                                parsedStr = parsedStr.replace(/\u0001\u0001/g, '\u0000')
                                    .replace(/\u0001\u0002/g, '\u0001')
                                    .replace(/\u0002\u0002/g, '\u0002');
                                stack.push(parsedStr);
                                break;
                            case '5':
                                var arrayElement = { element: [], index: stack.length };
                                stack.push(arrayElement.element);
                                metaStack.push(arrayElement);
                                break;
                            case '6':
                                var objElement = { element: {}, index: stack.length };
                                stack.push(objElement.element);
                                metaStack.push(objElement);
                                break;
                            default:
                                throw new Error(
                                    'bad collationIndex or unexpectedly reached end of input: ' + collationIndex);
                        }
                    }
                };

                function arrayCollate(a, b) {
                    var len = Math.min(a.length, b.length);
                    for (var i = 0; i < len; i++) {
                        var sort = exports.collate(a[i], b[i]);
                        if (sort !== 0) {
                            return sort;
                        }
                    }
                    return (a.length === b.length) ? 0 :
                        (a.length > b.length) ? 1 : -1;
                }

                function stringCollate(a, b) {
                    // See: https://github.com/daleharvey/pouchdb/issues/40
                    // This is incompatible with the CouchDB implementation, but its the
                    // best we can do for now
                    return (a === b) ? 0 : ((a > b) ? 1 : -1);
                }

                function objectCollate(a, b) {
                    var ak = Object.keys(a), bk = Object.keys(b);
                    var len = Math.min(ak.length, bk.length);
                    for (var i = 0; i < len; i++) {
                        // First sort the keys
                        var sort = exports.collate(ak[i], bk[i]);
                        if (sort !== 0) {
                            return sort;
                        }
                        // if the keys are equal sort the values
                        sort = exports.collate(a[ak[i]], b[bk[i]]);
                        if (sort !== 0) {
                            return sort;
                        }

                    }
                    return (ak.length === bk.length) ? 0 :
                        (ak.length > bk.length) ? 1 : -1;
                }

// The collation is defined by erlangs ordered terms
// the atoms null, true, false come first, then numbers, strings,
// arrays, then objects
// null/undefined/NaN/Infinity/-Infinity are all considered null
                function collationIndex(x) {
                    var id = ['boolean', 'number', 'string', 'object'];
                    var idx = id.indexOf(typeof x);
                    //false if -1 otherwise true, but fast!!!!1
                    if (~idx) {
                        if (x === null) {
                            return 1;
                        }
                        if (Array.isArray(x)) {
                            return 5;
                        }
                        return idx < 3 ? (idx + 2) : (idx + 3);
                    }
                    if (Array.isArray(x)) {
                        return 5;
                    }
                }

// conversion:
// x yyy zz...zz
// x = 0 for negative, 1 for 0, 2 for positive
// y = exponent (for negative numbers negated) moved so that it's >= 0
// z = mantisse
                function numToIndexableString(num) {

                    if (num === 0) {
                        return '1';
                    }

                    // convert number to exponential format for easier and
                    // more succinct string sorting
                    var expFormat = num.toExponential().split(/e\+?/);
                    var magnitude = parseInt(expFormat[1], 10);

                    var neg = num < 0;

                    var result = neg ? '0' : '2';

                    // first sort by magnitude
                    // it's easier if all magnitudes are positive
                    var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);
                    var magString = utils.padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);

                    result += SEP + magString;

                    // then sort by the factor
                    var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)
                    if (neg) { // for negative reverse ordering
                        factor = 10 - factor;
                    }

                    var factorStr = factor.toFixed(20);

                    // strip zeros from the end
                    factorStr = factorStr.replace(/\.?0+$/, '');

                    result += SEP + factorStr;

                    return result;
                }

            }, { "11": 11 }
        ], 11: [
            function (_dereq_, module, exports) {
                'use strict';

                function pad(str, padWith, upToLength) {
                    var padding = '';
                    var targetLength = upToLength - str.length;
                    while (padding.length < targetLength) {
                        padding += padWith;
                    }
                    return padding;
                }

                exports.padLeft = function (str, padWith, upToLength) {
                    var padding = pad(str, padWith, upToLength);
                    return padding + str;
                };

                exports.padRight = function (str, padWith, upToLength) {
                    var padding = pad(str, padWith, upToLength);
                    return str + padding;
                };

                exports.stringLexCompare = function (a, b) {

                    var aLen = a.length;
                    var bLen = b.length;

                    var i;
                    for (i = 0; i < aLen; i++) {
                        if (i === bLen) {
                            // b is shorter substring of a
                            return 1;
                        }
                        var aChar = a.charAt(i);
                        var bChar = b.charAt(i);
                        if (aChar !== bChar) {
                            return aChar < bChar ? -1 : 1;
                        }
                    }

                    if (aLen < bLen) {
                        // a is shorter substring of b
                        return -1;
                    }

                    return 0;
                };

                /*
                 * returns the decimal form for the given integer, i.e. writes
                 * out all the digits (in base-10) instead of using scientific notation
                 */
                exports.intToDecimalForm = function (int) {

                    var isNeg = int < 0;
                    var result = '';

                    do {
                        var remainder = isNeg ? -Math.ceil(int % 10) : Math.floor(int % 10);

                        result = remainder + result;
                        int = isNeg ? Math.ceil(int / 10) : Math.floor(int / 10);
                    } while (int);


                    if (isNeg && result !== '0') {
                        result = '-' + result;
                    }

                    return result;
                };
            }, {}
        ], 12: [
            function (_dereq_, module, exports) {
                'use strict';
                exports.Map = LazyMap; // TODO: use ES6 map
                exports.Set = LazySet; // TODO: use ES6 set
// based on https://github.com/montagejs/collections
                function LazyMap() {
                    this.store = {};
                }

                LazyMap.prototype.mangle = function (key) {
                    if (typeof key !== "string") {
                        throw new TypeError("key must be a string but Got " + key);
                    }
                    return '$' + key;
                };
                LazyMap.prototype.unmangle = function (key) {
                    return key.substring(1);
                };
                LazyMap.prototype.get = function (key) {
                    var mangled = this.mangle(key);
                    if (mangled in this.store) {
                        return this.store[mangled];
                    }
                    return void 0;
                };
                LazyMap.prototype.set = function (key, value) {
                    var mangled = this.mangle(key);
                    this.store[mangled] = value;
                    return true;
                };
                LazyMap.prototype.has = function (key) {
                    var mangled = this.mangle(key);
                    return mangled in this.store;
                };
                LazyMap.prototype.delete = function (key) {
                    var mangled = this.mangle(key);
                    if (mangled in this.store) {
                        delete this.store[mangled];
                        return true;
                    }
                    return false;
                };
                LazyMap.prototype.forEach = function (cb) {
                    var keys = Object.keys(this.store);
                    for (var i = 0, len = keys.length; i < len; i++) {
                        var key = keys[i];
                        var value = this.store[key];
                        key = this.unmangle(key);
                        cb(value, key);
                    }
                };

                function LazySet(array) {
                    this.store = new LazyMap();

                    // init with an array
                    if (array && Array.isArray(array)) {
                        for (var i = 0, len = array.length; i < len; i++) {
                            this.add(array[i]);
                        }
                    }
                }

                LazySet.prototype.add = function (key) {
                    return this.store.set(key, true);
                };
                LazySet.prototype.has = function (key) {
                    return this.store.has(key);
                };
                LazySet.prototype.delete = function (key) {
                    return this.store.delete(key);
                };

            }, {}
        ], 13: [
            function (_dereq_, module, exports) {
// shim for using process in browser

                var process = module.exports = {};
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;

                function cleanUpNextTick() {
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }

                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = setTimeout(cleanUpNextTick);
                    draining = true;

                    var len = queue.length;
                    while (len) {
                        currentQueue = queue;
                        queue = [];
                        while (++queueIndex < len) {
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    clearTimeout(timeout);
                }

                process.nextTick = function (fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for (var i = 1; i < arguments.length; i++) {
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        setTimeout(drainQueue, 0);
                    }
                };

// v8 likes predictible objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }

                Item.prototype.run = function () {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ''; // empty string to avoid regexp issues
                process.versions = {};

                function noop() {
                }

                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;

                process.binding = function (name) {
                    throw new Error('process.binding is not supported');
                };

                process.cwd = function () {
                    return '/'
                };
                process.chdir = function (dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function () {
                    return 0;
                };

            }, {}
        ], 14: [
            function (_dereq_, module, exports) {
// Generated by CoffeeScript 1.9.2
                (function () {
                    var hasProp = {}.hasOwnProperty,
                        slice = [].slice;

                    module.exports = function (source, scope) {
                        var key, keys, value, values;
                        keys = [];
                        values = [];
                        for (key in scope) {
                            if (!hasProp.call(scope, key)) continue;
                            value = scope[key];
                            if (key === 'this') {
                                continue;
                            }
                            keys.push(key);
                            values.push(value);
                        }
                        return Function.apply(null, slice.call(keys).concat([source])).apply(scope["this"], values);
                    };

                }).call(this);

            }, {}
        ], 15: [
            function (_dereq_, module, exports) {
                (function (factory) {
                    if (typeof exports === 'object') {
                        // Node/CommonJS
                        module.exports = factory();
                    } else if (typeof define === 'function' && define.amd) {
                        // AMD
                        define(factory);
                    } else {
                        // Browser globals (with support for web workers)
                        var glob;

                        try {
                            glob = window;
                        } catch (e) {
                            glob = self;
                        }

                        glob.SparkMD5 = factory();
                    }
                }(function (undefined) {

                    'use strict';

                    /*
                     * Fastest md5 implementation around (JKM md5).
                     * Credits: Joseph Myers
                     *
                     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
                     * @see http://jsperf.com/md5-shootout/7
                     */

                    /* this function is much faster,
                     so if possible we use it. Some IEs
                     are the only ones I know of that
                     need the idiotic second function,
                     generated by an if clause.  */
                    var add32 = function (a, b) {
                            return (a + b) & 0xFFFFFFFF;
                        },
                        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


                    function cmn(q, a, b, x, s, t) {
                        a = add32(add32(a, q), add32(x, t));
                        return add32((a << s) | (a >>> (32 - s)), b);
                    }

                    function ff(a, b, c, d, x, s, t) {
                        return cmn((b & c) | ((~b) & d), a, b, x, s, t);
                    }

                    function gg(a, b, c, d, x, s, t) {
                        return cmn((b & d) | (c & (~d)), a, b, x, s, t);
                    }

                    function hh(a, b, c, d, x, s, t) {
                        return cmn(b ^ c ^ d, a, b, x, s, t);
                    }

                    function ii(a, b, c, d, x, s, t) {
                        return cmn(c ^ (b | (~d)), a, b, x, s, t);
                    }

                    function md5cycle(x, k) {
                        var a = x[0],
                            b = x[1],
                            c = x[2],
                            d = x[3];

                        a = ff(a, b, c, d, k[0], 7, -680876936);
                        d = ff(d, a, b, c, k[1], 12, -389564586);
                        c = ff(c, d, a, b, k[2], 17, 606105819);
                        b = ff(b, c, d, a, k[3], 22, -1044525330);
                        a = ff(a, b, c, d, k[4], 7, -176418897);
                        d = ff(d, a, b, c, k[5], 12, 1200080426);
                        c = ff(c, d, a, b, k[6], 17, -1473231341);
                        b = ff(b, c, d, a, k[7], 22, -45705983);
                        a = ff(a, b, c, d, k[8], 7, 1770035416);
                        d = ff(d, a, b, c, k[9], 12, -1958414417);
                        c = ff(c, d, a, b, k[10], 17, -42063);
                        b = ff(b, c, d, a, k[11], 22, -1990404162);
                        a = ff(a, b, c, d, k[12], 7, 1804603682);
                        d = ff(d, a, b, c, k[13], 12, -40341101);
                        c = ff(c, d, a, b, k[14], 17, -1502002290);
                        b = ff(b, c, d, a, k[15], 22, 1236535329);

                        a = gg(a, b, c, d, k[1], 5, -165796510);
                        d = gg(d, a, b, c, k[6], 9, -1069501632);
                        c = gg(c, d, a, b, k[11], 14, 643717713);
                        b = gg(b, c, d, a, k[0], 20, -373897302);
                        a = gg(a, b, c, d, k[5], 5, -701558691);
                        d = gg(d, a, b, c, k[10], 9, 38016083);
                        c = gg(c, d, a, b, k[15], 14, -660478335);
                        b = gg(b, c, d, a, k[4], 20, -405537848);
                        a = gg(a, b, c, d, k[9], 5, 568446438);
                        d = gg(d, a, b, c, k[14], 9, -1019803690);
                        c = gg(c, d, a, b, k[3], 14, -187363961);
                        b = gg(b, c, d, a, k[8], 20, 1163531501);
                        a = gg(a, b, c, d, k[13], 5, -1444681467);
                        d = gg(d, a, b, c, k[2], 9, -51403784);
                        c = gg(c, d, a, b, k[7], 14, 1735328473);
                        b = gg(b, c, d, a, k[12], 20, -1926607734);

                        a = hh(a, b, c, d, k[5], 4, -378558);
                        d = hh(d, a, b, c, k[8], 11, -2022574463);
                        c = hh(c, d, a, b, k[11], 16, 1839030562);
                        b = hh(b, c, d, a, k[14], 23, -35309556);
                        a = hh(a, b, c, d, k[1], 4, -1530992060);
                        d = hh(d, a, b, c, k[4], 11, 1272893353);
                        c = hh(c, d, a, b, k[7], 16, -155497632);
                        b = hh(b, c, d, a, k[10], 23, -1094730640);
                        a = hh(a, b, c, d, k[13], 4, 681279174);
                        d = hh(d, a, b, c, k[0], 11, -358537222);
                        c = hh(c, d, a, b, k[3], 16, -722521979);
                        b = hh(b, c, d, a, k[6], 23, 76029189);
                        a = hh(a, b, c, d, k[9], 4, -640364487);
                        d = hh(d, a, b, c, k[12], 11, -421815835);
                        c = hh(c, d, a, b, k[15], 16, 530742520);
                        b = hh(b, c, d, a, k[2], 23, -995338651);

                        a = ii(a, b, c, d, k[0], 6, -198630844);
                        d = ii(d, a, b, c, k[7], 10, 1126891415);
                        c = ii(c, d, a, b, k[14], 15, -1416354905);
                        b = ii(b, c, d, a, k[5], 21, -57434055);
                        a = ii(a, b, c, d, k[12], 6, 1700485571);
                        d = ii(d, a, b, c, k[3], 10, -1894986606);
                        c = ii(c, d, a, b, k[10], 15, -1051523);
                        b = ii(b, c, d, a, k[1], 21, -2054922799);
                        a = ii(a, b, c, d, k[8], 6, 1873313359);
                        d = ii(d, a, b, c, k[15], 10, -30611744);
                        c = ii(c, d, a, b, k[6], 15, -1560198380);
                        b = ii(b, c, d, a, k[13], 21, 1309151649);
                        a = ii(a, b, c, d, k[4], 6, -145523070);
                        d = ii(d, a, b, c, k[11], 10, -1120210379);
                        c = ii(c, d, a, b, k[2], 15, 718787259);
                        b = ii(b, c, d, a, k[9], 21, -343485551);

                        x[0] = add32(a, x[0]);
                        x[1] = add32(b, x[1]);
                        x[2] = add32(c, x[2]);
                        x[3] = add32(d, x[3]);
                    }

                    function md5blk(s) {
                        var md5blks = [],
                            i;
                        /* Andy King said do it this way. */

                        for (i = 0; i < 64; i += 4) {
                            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
                        }
                        return md5blks;
                    }

                    function md5blk_array(a) {
                        var md5blks = [],
                            i;
                        /* Andy King said do it this way. */

                        for (i = 0; i < 64; i += 4) {
                            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
                        }
                        return md5blks;
                    }

                    function md51(s) {
                        var n = s.length,
                            state = [1732584193, -271733879, -1732584194, 271733878],
                            i,
                            length,
                            tail,
                            tmp,
                            lo,
                            hi;

                        for (i = 64; i <= n; i += 64) {
                            md5cycle(state, md5blk(s.substring(i - 64, i)));
                        }
                        s = s.substring(i - 64);
                        length = s.length;
                        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                        for (i = 0; i < length; i += 1) {
                            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
                        }
                        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                        if (i > 55) {
                            md5cycle(state, tail);
                            for (i = 0; i < 16; i += 1) {
                                tail[i] = 0;
                            }
                        }

                        // Beware that the final length might not fit in 32 bits so we take care of that
                        tmp = n * 8;
                        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
                        lo = parseInt(tmp[2], 16);
                        hi = parseInt(tmp[1], 16) || 0;

                        tail[14] = lo;
                        tail[15] = hi;

                        md5cycle(state, tail);
                        return state;
                    }

                    function md51_array(a) {
                        var n = a.length,
                            state = [1732584193, -271733879, -1732584194, 271733878],
                            i,
                            length,
                            tail,
                            tmp,
                            lo,
                            hi;

                        for (i = 64; i <= n; i += 64) {
                            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
                        }

                        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
                        // containing the last element of the parent array if the sub array specified starts
                        // beyond the length of the parent array - weird.
                        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
                        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

                        length = a.length;
                        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                        for (i = 0; i < length; i += 1) {
                            tail[i >> 2] |= a[i] << ((i % 4) << 3);
                        }

                        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                        if (i > 55) {
                            md5cycle(state, tail);
                            for (i = 0; i < 16; i += 1) {
                                tail[i] = 0;
                            }
                        }

                        // Beware that the final length might not fit in 32 bits so we take care of that
                        tmp = n * 8;
                        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
                        lo = parseInt(tmp[2], 16);
                        hi = parseInt(tmp[1], 16) || 0;

                        tail[14] = lo;
                        tail[15] = hi;

                        md5cycle(state, tail);

                        return state;
                    }

                    function rhex(n) {
                        var s = '',
                            j;
                        for (j = 0; j < 4; j += 1) {
                            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
                        }
                        return s;
                    }

                    function hex(x) {
                        var i;
                        for (i = 0; i < x.length; i += 1) {
                            x[i] = rhex(x[i]);
                        }
                        return x.join('');
                    }

                    // In some cases the fast add32 function cannot be used..
                    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
                        add32 = function (x, y) {
                            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                            return (msw << 16) | (lsw & 0xFFFF);
                        };
                    }

                    // ---------------------------------------------------

                    /**
                     * ArrayBuffer slice polyfill.
                     *
                     * @see https://github.com/ttaubert/node-arraybuffer-slice
                     */

                    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
                        (function () {
                            function clamp(val, length) {
                                val = (val | 0) || 0;

                                if (val < 0) {
                                    return Math.max(val + length, 0);
                                }

                                return Math.min(val, length);
                            }

                            ArrayBuffer.prototype.slice = function (from, to) {
                                var length = this.byteLength,
                                    begin = clamp(from, length),
                                    end = length,
                                    num,
                                    target,
                                    targetArray,
                                    sourceArray;

                                if (to !== undefined) {
                                    end = clamp(to, length);
                                }

                                if (begin > end) {
                                    return new ArrayBuffer(0);
                                }

                                num = end - begin;
                                target = new ArrayBuffer(num);
                                targetArray = new Uint8Array(target);

                                sourceArray = new Uint8Array(this, begin, num);
                                targetArray.set(sourceArray);

                                return target;
                            };
                        })();
                    }

                    // ---------------------------------------------------

                    /**
                     * Helpers.
                     */

                    function toUtf8(str) {
                        if (/[\u0080-\uFFFF]/.test(str)) {
                            str = unescape(encodeURIComponent(str));
                        }

                        return str;
                    }

                    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
                        var length = str.length,
                            buff = new ArrayBuffer(length),
                            arr = new Uint8Array(buff),
                            i;

                        for (i = 0; i < length; i += 1) {
                            arr[i] = str.charCodeAt(i);
                        }

                        return returnUInt8Array ? arr : buff;
                    }

                    function arrayBuffer2Utf8Str(buff) {
                        return String.fromCharCode.apply(null, new Uint8Array(buff));
                    }

                    function concatenateArrayBuffers(first, second, returnUInt8Array) {
                        var result = new Uint8Array(first.byteLength + second.byteLength);

                        result.set(new Uint8Array(first));
                        result.set(new Uint8Array(second), first.byteLength);

                        return returnUInt8Array ? result : result.buffer;
                    }

                    function hexToBinaryString(hex) {
                        var bytes = [],
                            length = hex.length,
                            x;

                        for (x = 0; x < length - 1; x += 2) {
                            bytes.push(parseInt(hex.substr(x, 2), 16));
                        }

                        return String.fromCharCode.apply(String, bytes);
                    }

                    // ---------------------------------------------------

                    /**
                     * SparkMD5 OOP implementation.
                     *
                     * Use this class to perform an incremental md5, otherwise use the
                     * static methods instead.
                     */

                    function SparkMD5() {
                        // call reset to init the instance
                        this.reset();
                    }

                    /**
                     * Appends a string.
                     * A conversion will be applied if an utf8 string is detected.
                     *
                     * @param {String} str The string to be appended
                     *
                     * @return {SparkMD5} The instance itself
                     */
                    SparkMD5.prototype.append = function (str) {
                        // Converts the string to utf8 bytes if necessary
                        // Then append as binary
                        this.appendBinary(toUtf8(str));

                        return this;
                    };

                    /**
                     * Appends a binary string.
                     *
                     * @param {String} contents The binary string to be appended
                     *
                     * @return {SparkMD5} The instance itself
                     */
                    SparkMD5.prototype.appendBinary = function (contents) {
                        this._buff += contents;
                        this._length += contents.length;

                        var length = this._buff.length,
                            i;

                        for (i = 64; i <= length; i += 64) {
                            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
                        }

                        this._buff = this._buff.substring(i - 64);

                        return this;
                    };

                    /**
                     * Finishes the incremental computation, reseting the internal state and
                     * returning the result.
                     *
                     * @param {Boolean} raw True to get the raw string, false to get the hex string
                     *
                     * @return {String} The result
                     */
                    SparkMD5.prototype.end = function (raw) {
                        var buff = this._buff,
                            length = buff.length,
                            i,
                            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            ret;

                        for (i = 0; i < length; i += 1) {
                            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
                        }

                        this._finish(tail, length);
                        ret = hex(this._hash);

                        if (raw) {
                            ret = hexToBinaryString(ret);
                        }

                        this.reset();

                        return ret;
                    };

                    /**
                     * Resets the internal state of the computation.
                     *
                     * @return {SparkMD5} The instance itself
                     */
                    SparkMD5.prototype.reset = function () {
                        this._buff = '';
                        this._length = 0;
                        this._hash = [1732584193, -271733879, -1732584194, 271733878];

                        return this;
                    };

                    /**
                     * Gets the internal state of the computation.
                     *
                     * @return {Object} The state
                     */
                    SparkMD5.prototype.getState = function () {
                        return {
                            buff: this._buff,
                            length: this._length,
                            hash: this._hash
                        };
                    };

                    /**
                     * Gets the internal state of the computation.
                     *
                     * @param {Object} state The state
                     *
                     * @return {SparkMD5} The instance itself
                     */
                    SparkMD5.prototype.setState = function (state) {
                        this._buff = state.buff;
                        this._length = state.length;
                        this._hash = state.hash;

                        return this;
                    };

                    /**
                     * Releases memory used by the incremental buffer and other additional
                     * resources. If you plan to use the instance again, use reset instead.
                     */
                    SparkMD5.prototype.destroy = function () {
                        delete this._hash;
                        delete this._buff;
                        delete this._length;
                    };

                    /**
                     * Finish the final calculation based on the tail.
                     *
                     * @param {Array}  tail   The tail (will be modified)
                     * @param {Number} length The length of the remaining buffer
                     */
                    SparkMD5.prototype._finish = function (tail, length) {
                        var i = length,
                            tmp,
                            lo,
                            hi;

                        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                        if (i > 55) {
                            md5cycle(this._hash, tail);
                            for (i = 0; i < 16; i += 1) {
                                tail[i] = 0;
                            }
                        }

                        // Do the final computation based on the tail and length
                        // Beware that the final length may not fit in 32 bits so we take care of that
                        tmp = this._length * 8;
                        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
                        lo = parseInt(tmp[2], 16);
                        hi = parseInt(tmp[1], 16) || 0;

                        tail[14] = lo;
                        tail[15] = hi;
                        md5cycle(this._hash, tail);
                    };

                    /**
                     * Performs the md5 hash on a string.
                     * A conversion will be applied if utf8 string is detected.
                     *
                     * @param {String}  str The string
                     * @param {Boolean} raw True to get the raw string, false to get the hex string
                     *
                     * @return {String} The result
                     */
                    SparkMD5.hash = function (str, raw) {
                        // Converts the string to utf8 bytes if necessary
                        // Then compute it using the binary function
                        return SparkMD5.hashBinary(toUtf8(str), raw);
                    };

                    /**
                     * Performs the md5 hash on a binary string.
                     *
                     * @param {String}  content The binary string
                     * @param {Boolean} raw     True to get the raw string, false to get the hex string
                     *
                     * @return {String} The result
                     */
                    SparkMD5.hashBinary = function (content, raw) {
                        var hash = md51(content),
                            ret = hex(hash);

                        return raw ? hexToBinaryString(ret) : ret;
                    };

                    // ---------------------------------------------------

                    /**
                     * SparkMD5 OOP implementation for array buffers.
                     *
                     * Use this class to perform an incremental md5 ONLY for array buffers.
                     */
                    SparkMD5.ArrayBuffer = function () {
                        // call reset to init the instance
                        this.reset();
                    };

                    /**
                     * Appends an array buffer.
                     *
                     * @param {ArrayBuffer} arr The array to be appended
                     *
                     * @return {SparkMD5.ArrayBuffer} The instance itself
                     */
                    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
                        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
                            length = buff.length,
                            i;

                        this._length += arr.byteLength;

                        for (i = 64; i <= length; i += 64) {
                            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
                        }

                        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

                        return this;
                    };

                    /**
                     * Finishes the incremental computation, reseting the internal state and
                     * returning the result.
                     *
                     * @param {Boolean} raw True to get the raw string, false to get the hex string
                     *
                     * @return {String} The result
                     */
                    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
                        var buff = this._buff,
                            length = buff.length,
                            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            i,
                            ret;

                        for (i = 0; i < length; i += 1) {
                            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
                        }

                        this._finish(tail, length);
                        ret = hex(this._hash);

                        if (raw) {
                            ret = hexToBinaryString(ret);
                        }

                        this.reset();

                        return ret;
                    };

                    /**
                     * Resets the internal state of the computation.
                     *
                     * @return {SparkMD5.ArrayBuffer} The instance itself
                     */
                    SparkMD5.ArrayBuffer.prototype.reset = function () {
                        this._buff = new Uint8Array(0);
                        this._length = 0;
                        this._hash = [1732584193, -271733879, -1732584194, 271733878];

                        return this;
                    };

                    /**
                     * Gets the internal state of the computation.
                     *
                     * @return {Object} The state
                     */
                    SparkMD5.ArrayBuffer.prototype.getState = function () {
                        var state = SparkMD5.prototype.getState.call(this);

                        // Convert buffer to a string
                        state.buff = arrayBuffer2Utf8Str(state.buff);

                        return state;
                    };

                    /**
                     * Gets the internal state of the computation.
                     *
                     * @param {Object} state The state
                     *
                     * @return {SparkMD5.ArrayBuffer} The instance itself
                     */
                    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
                        // Convert string to buffer
                        state.buff = utf8Str2ArrayBuffer(state.buff, true);

                        return SparkMD5.prototype.setState.call(this, state);
                    };

                    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

                    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

                    /**
                     * Performs the md5 hash on an array buffer.
                     *
                     * @param {ArrayBuffer} arr The array buffer
                     * @param {Boolean}     raw True to get the raw string, false to get the hex one
                     *
                     * @return {String} The result
                     */
                    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
                        var hash = md51_array(new Uint8Array(arr)),
                            ret = hex(hash);

                        return raw ? hexToBinaryString(ret) : ret;
                    };

                    return SparkMD5;
                }));

            }, {}
        ], 16: [
            function (_dereq_, module, exports) {
                'use strict';

                /**
                 * Stringify/parse functions that don't operate
                 * recursively, so they avoid call stack exceeded
                 * errors.
                 */
                exports.stringify = function stringify(input) {
                    var queue = [];
                    queue.push({ obj: input });

                    var res = '';
                    var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;
                    while ((next = queue.pop())) {
                        obj = next.obj;
                        prefix = next.prefix || '';
                        val = next.val || '';
                        res += prefix;
                        if (val) {
                            res += val;
                        } else if (typeof obj !== 'object') {
                            res += typeof obj === 'undefined' ? null : JSON.stringify(obj);
                        } else if (obj === null) {
                            res += 'null';
                        } else if (Array.isArray(obj)) {
                            queue.push({ val: ']' });
                            for (i = obj.length - 1; i >= 0; i--) {
                                arrayPrefix = i === 0 ? '' : ',';
                                queue.push({ obj: obj[i], prefix: arrayPrefix });
                            }
                            queue.push({ val: '[' });
                        } else { // object
                            keys = [];
                            for (k in obj) {
                                if (obj.hasOwnProperty(k)) {
                                    keys.push(k);
                                }
                            }
                            queue.push({ val: '}' });
                            for (i = keys.length - 1; i >= 0; i--) {
                                key = keys[i];
                                value = obj[key];
                                objPrefix = (i > 0 ? ',' : '');
                                objPrefix += JSON.stringify(key) + ':';
                                queue.push({ obj: value, prefix: objPrefix });
                            }
                            queue.push({ val: '{' });
                        }
                    }
                    return res;
                };

// Convenience function for the parse function.
// This pop function is basically copied from
// pouchCollate.parseIndexableString
                function pop(obj, stack, metaStack) {
                    var lastMetaElement = metaStack[metaStack.length - 1];
                    if (obj === lastMetaElement.element) {
                        // popping a meta-element, e.g. an object whose value is another object
                        metaStack.pop();
                        lastMetaElement = metaStack[metaStack.length - 1];
                    }
                    var element = lastMetaElement.element;
                    var lastElementIndex = lastMetaElement.index;
                    if (Array.isArray(element)) {
                        element.push(obj);
                    } else if (lastElementIndex === stack.length - 2) { // obj with key+value
                        var key = stack.pop();
                        element[key] = obj;
                    } else {
                        stack.push(obj); // obj with key only
                    }
                }

                exports.parse = function (str) {
                    var stack = [];
                    var metaStack = []; // stack for arrays and objects
                    var i = 0;
                    var collationIndex, parsedNum, numChar;
                    var parsedString, lastCh, numConsecutiveSlashes, ch;
                    var arrayElement, objElement;
                    while (true) {
                        collationIndex = str[i++];
                        if (collationIndex === '}' ||
                            collationIndex === ']' ||
                            typeof collationIndex === 'undefined') {
                            if (stack.length === 1) {
                                return stack.pop();
                            } else {
                                pop(stack.pop(), stack, metaStack);
                                continue;
                            }
                        }
                        switch (collationIndex) {
                            case ' ':
                            case '\t':
                            case '\n':
                            case ':':
                            case ',':
                                break;
                            case 'n':
                                i += 3; // 'ull'
                                pop(null, stack, metaStack);
                                break;
                            case 't':
                                i += 3; // 'rue'
                                pop(true, stack, metaStack);
                                break;
                            case 'f':
                                i += 4; // 'alse'
                                pop(false, stack, metaStack);
                                break;
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                            case '-':
                                parsedNum = '';
                                i--;
                                while (true) {
                                    numChar = str[i++];
                                    if (/[\d\.\-e\+]/.test(numChar)) {
                                        parsedNum += numChar;
                                    } else {
                                        i--;
                                        break;
                                    }
                                }
                                pop(parseFloat(parsedNum), stack, metaStack);
                                break;
                            case '"':
                                parsedString = '';
                                lastCh = void 0;
                                numConsecutiveSlashes = 0;
                                while (true) {
                                    ch = str[i++];
                                    if (ch !== '"' || (lastCh === '\\' &&
                                        numConsecutiveSlashes % 2 === 1)) {
                                        parsedString += ch;
                                        lastCh = ch;
                                        if (lastCh === '\\') {
                                            numConsecutiveSlashes++;
                                        } else {
                                            numConsecutiveSlashes = 0;
                                        }
                                    } else {
                                        break;
                                    }
                                }
                                pop(JSON.parse('"' + parsedString + '"'), stack, metaStack);
                                break;
                            case '[':
                                arrayElement = { element: [], index: stack.length };
                                stack.push(arrayElement.element);
                                metaStack.push(arrayElement);
                                break;
                            case '{':
                                objElement = { element: {}, index: stack.length };
                                stack.push(objElement.element);
                                metaStack.push(objElement);
                                break;
                            default:
                                throw new Error(
                                    'unexpectedly reached end of input: ' + collationIndex);
                        }
                    }
                };

            }, {}
        ], 17: [
            function (_dereq_, module, exports) {
                (function (process, global) {
                    'use strict';

                    function _interopDefault(ex) {
                        return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex;
                    }

                    var jsExtend = _dereq_(7);
                    var jsExtend__default = _interopDefault(jsExtend);
                    var debug = _interopDefault(_dereq_(2));
                    var inherits = _interopDefault(_dereq_(6));
                    var lie = _interopDefault(_dereq_(8));
                    var pouchdbCollections = _dereq_(12);
                    var getArguments = _interopDefault(_dereq_(1));
                    var events = _dereq_(4);
                    var scopedEval = _interopDefault(_dereq_(14));
                    var pouchCollate = _dereq_(10);
                    var pouchCollate__default = _interopDefault(pouchCollate);
                    var Md5 = _interopDefault(_dereq_(15));
                    var vuvuzela = _interopDefault(_dereq_(16));

                    /* istanbul ignore next */
                    var PouchPromise = typeof Promise === 'function' ? Promise : lie;

// like underscore/lodash _.pick()
                    function pick(obj, arr) {
                        var res = {};
                        for (var i = 0, len = arr.length; i < len; i++) {
                            var prop = arr[i];
                            if (prop in obj) {
                                res[prop] = obj[prop];
                            }
                        }
                        return res;
                    }

                    function isBinaryObject(object) {
                        return object instanceof ArrayBuffer ||
                            (typeof Blob !== 'undefined' && object instanceof Blob);
                    }

                    function cloneArrayBuffer(buff) {
                        if (typeof buff.slice === 'function') {
                            return buff.slice(0);
                        }
                        // IE10-11 slice() polyfill
                        var target = new ArrayBuffer(buff.byteLength);
                        var targetArray = new Uint8Array(target);
                        var sourceArray = new Uint8Array(buff);
                        targetArray.set(sourceArray);
                        return target;
                    }

                    function cloneBinaryObject(object) {
                        if (object instanceof ArrayBuffer) {
                            return cloneArrayBuffer(object);
                        }
                        var size = object.size;
                        var type = object.type;
                        // Blob
                        if (typeof object.slice === 'function') {
                            return object.slice(0, size, type);
                        }
                        // PhantomJS slice() replacement
                        return object.webkitSlice(0, size, type);
                    }

                    function clone(object) {
                        var newObject;
                        var i;
                        var len;

                        if (!object || typeof object !== 'object') {
                            return object;
                        }

                        if (Array.isArray(object)) {
                            newObject = [];
                            for (i = 0, len = object.length; i < len; i++) {
                                newObject[i] = clone(object[i]);
                            }
                            return newObject;
                        }

                        // special case: to avoid inconsistencies between IndexedDB
                        // and other backends, we automatically stringify Dates
                        if (object instanceof Date) {
                            return object.toISOString();
                        }

                        if (isBinaryObject(object)) {
                            return cloneBinaryObject(object);
                        }

                        newObject = {};
                        for (i in object) {
                            if (Object.prototype.hasOwnProperty.call(object, i)) {
                                var value = clone(object[i]);
                                if (typeof value !== 'undefined') {
                                    newObject[i] = value;
                                }
                            }
                        }
                        return newObject;
                    }

                    function once(fun) {
                        var called = false;
                        return getArguments(function (args) {
                            /* istanbul ignore if */
                            if (called) {
                                // this is a smoke test and should never actually happen
                                throw new Error('once called more than once');
                            } else {
                                called = true;
                                fun.apply(this, args);
                            }
                        });
                    }

                    function toPromise(func) {
                        //create the function we will be returning
                        return getArguments(function (args) {
                            // Clone arguments
                            args = clone(args);
                            var self = this;
                            var tempCB =
                                (typeof args[args.length - 1] === 'function') ? args.pop() : false;
                            // if the last argument is a function, assume its a callback
                            var usedCB;
                            if (tempCB) {
                                // if it was a callback, create a new callback which calls it,
                                // but do so async so we don't trap any errors
                                usedCB = function (err, resp) {
                                    process.nextTick(function () {
                                        tempCB(err, resp);
                                    });
                                };
                            }
                            var promise = new PouchPromise(function (fulfill, reject) {
                                var resp;
                                try {
                                    var callback = once(function (err, mesg) {
                                        if (err) {
                                            reject(err);
                                        } else {
                                            fulfill(mesg);
                                        }
                                    });
                                    // create a callback for this invocation
                                    // apply the function in the orig context
                                    args.push(callback);
                                    resp = func.apply(self, args);
                                    if (resp && typeof resp.then === 'function') {
                                        fulfill(resp);
                                    }
                                } catch (e) {
                                    reject(e);
                                }
                            });
                            // if there is a callback, call it back
                            if (usedCB) {
                                promise.then(function (result) {
                                    usedCB(null, result);
                                }, usedCB);
                            }
                            return promise;
                        });
                    }

                    var log = debug('pouchdb:api');

                    function adapterFun(name, callback) {
                        function logApiCall(self, name, args) {
                            /* istanbul ignore if */
                            if (log.enabled) {
                                var logArgs = [self._db_name, name];
                                for (var i = 0; i < args.length - 1; i++) {
                                    logArgs.push(args[i]);
                                }
                                log.apply(null, logArgs);

                                // override the callback itself to log the response
                                var origCallback = args[args.length - 1];
                                args[args.length - 1] = function (err, res) {
                                    var responseArgs = [self._db_name, name];
                                    responseArgs = responseArgs.concat(
                                        err ? ['error', err] : ['success', res]
                                    );
                                    log.apply(null, responseArgs);
                                    origCallback(err, res);
                                };
                            }
                        }

                        return toPromise(getArguments(function (args) {
                            if (this._closed) {
                                return PouchPromise.reject(new Error('database is closed'));
                            }
                            if (this._destroyed) {
                                return PouchPromise.reject(new Error('database is destroyed'));
                            }
                            var self = this;
                            logApiCall(self, name, args);
                            if (!this.taskqueue.isReady) {
                                return new PouchPromise(function (fulfill, reject) {
                                    self.taskqueue.addTask(function (failed) {
                                        if (failed) {
                                            reject(failed);
                                        } else {
                                            fulfill(self[name].apply(self, args));
                                        }
                                    });
                                });
                            }
                            return callback.apply(this, args);
                        }));
                    }

// this is essentially the "update sugar" function from daleharvey/pouchdb#1388
// the diffFun tells us what delta to apply to the doc.  it either returns
// the doc, or false if it doesn't need to do an update after all
                    function upsert(db, docId, diffFun) {
                        return new PouchPromise(function (fulfill, reject) {
                            db.get(docId, function (err, doc) {
                                if (err) {
                                    /* istanbul ignore next */
                                    if (err.status !== 404) {
                                        return reject(err);
                                    }
                                    doc = {};
                                }

                                // the user might change the _rev, so save it for posterity
                                var docRev = doc._rev;
                                var newDoc = diffFun(doc);

                                if (!newDoc) {
                                    // if the diffFun returns falsy, we short-circuit as
                                    // an optimization
                                    return fulfill({ updated: false, rev: docRev });
                                }

                                // users aren't allowed to modify these values,
                                // so reset them here
                                newDoc._id = docId;
                                newDoc._rev = docRev;
                                fulfill(tryAndPut(db, newDoc, diffFun));
                            });
                        });
                    }

                    function tryAndPut(db, doc, diffFun) {
                        return db.put(doc).then(function (res) {
                            return {
                                updated: true,
                                rev: res.rev
                            };
                        }, function (err) {
                            /* istanbul ignore next */
                            if (err.status !== 409) {
                                throw err;
                            }
                            return upsert(db, doc._id, diffFun);
                        });
                    }

// We fetch all leafs of the revision tree, and sort them based on tree length
// and whether they were deleted, undeleted documents with the longest revision
// tree (most edits) win
// The final sort algorithm is slightly documented in a sidebar here:
// http://guide.couchdb.org/draft/conflicts.html
                    function winningRev(metadata) {
                        var winningId;
                        var winningPos;
                        var winningDeleted;
                        var toVisit = metadata.rev_tree.slice();
                        var node;
                        while ((node = toVisit.pop())) {
                            var tree = node.ids;
                            var branches = tree[2];
                            var pos = node.pos;
                            if (branches.length) { // non-leaf
                                for (var i = 0, len = branches.length; i < len; i++) {
                                    toVisit.push({ pos: pos + 1, ids: branches[i] });
                                }
                                continue;
                            }
                            var deleted = !!tree[1].deleted;
                            var id = tree[0];
                            // sort by deleted, then pos, then id
                            if (!winningId || (winningDeleted !== deleted ? winningDeleted :
                                    winningPos !== pos ? winningPos < pos : winningId < id)) {
                                winningId = id;
                                winningPos = pos;
                                winningDeleted = deleted;
                            }
                        }

                        return winningPos + '-' + winningId;
                    }

                    function getTrees(node) {
                        return node.ids;
                    }

// check if a specific revision of a doc has been deleted
//  - metadata: the metadata object from the doc store
//  - rev: (optional) the revision to check. defaults to winning revision
                    function isDeleted(metadata, rev) {
                        if (!rev) {
                            rev = winningRev(metadata);
                        }
                        var id = rev.substring(rev.indexOf('-') + 1);
                        var toVisit = metadata.rev_tree.map(getTrees);

                        var tree;
                        while ((tree = toVisit.pop())) {
                            if (tree[0] === id) {
                                return !!tree[1].deleted;
                            }
                            toVisit = toVisit.concat(tree[2]);
                        }
                    }

                    function evalFilter(input) {
                        return scopedEval('return ' + input + ';', {});
                    }

                    function evalView(input) {
                        /* jshint evil:true */
                        return new Function('doc', [
                            'var emitted = false;',
                            'var emit = function (a, b) {',
                            '  emitted = true;',
                            '};',
                            'var view = ' + input + ';',
                            'view(doc);',
                            'if (emitted) {',
                            '  return true;',
                            '}'
                        ].join('\n'));
                    }

                    function parseDesignDocFunctionName(s) {
                        if (!s) {
                            return null;
                        }
                        var parts = s.split('/');
                        if (parts.length === 2) {
                            return parts;
                        }
                        if (parts.length === 1) {
                            return [s, s];
                        }
                        return null;
                    }

                    function normalizeDesignDocFunctionName(s) {
                        var normalized = parseDesignDocFunctionName(s);
                        return normalized ? normalized.join('/') : null;
                    }

// Pretty much all below can be combined into a higher order function to
// traverse revisions
// The return value from the callback will be passed as context to all
// children of that node
                    function traverseRevTree(revs, callback) {
                        var toVisit = revs.slice();

                        var node;
                        while ((node = toVisit.pop())) {
                            var pos = node.pos;
                            var tree = node.ids;
                            var branches = tree[2];
                            var newCtx =
                                callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);
                            for (var i = 0, len = branches.length; i < len; i++) {
                                toVisit.push({ pos: pos + 1, ids: branches[i], ctx: newCtx });
                            }
                        }
                    }

                    function sortByPos(a, b) {
                        return a.pos - b.pos;
                    }

                    function collectLeaves(revs) {
                        var leaves = [];
                        traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {
                            if (isLeaf) {
                                leaves.push({ rev: pos + "-" + id, pos: pos, opts: opts });
                            }
                        });
                        leaves.sort(sortByPos).reverse();
                        for (var i = 0, len = leaves.length; i < len; i++) {
                            delete leaves[i].pos;
                        }
                        return leaves;
                    }

// returns revs of all conflicts that is leaves such that
// 1. are not deleted and
// 2. are different than winning revision
                    function collectConflicts(metadata) {
                        var win = winningRev(metadata);
                        var leaves = collectLeaves(metadata.rev_tree);
                        var conflicts = [];
                        for (var i = 0, len = leaves.length; i < len; i++) {
                            var leaf = leaves[i];
                            if (leaf.rev !== win && !leaf.opts.deleted) {
                                conflicts.push(leaf.rev);
                            }
                        }
                        return conflicts;
                    }

                    inherits(PouchError, Error);

                    function PouchError(opts) {
                        Error.call(this, opts.reason);
                        this.status = opts.status;
                        this.name = opts.error;
                        this.message = opts.reason;
                        this.error = true;
                    }

                    PouchError.prototype.toString = function () {
                        return JSON.stringify({
                            status: this.status,
                            name: this.name,
                            message: this.message,
                            reason: this.reason
                        });
                    };

                    var UNAUTHORIZED = new PouchError({
                        status: 401,
                        error: 'unauthorized',
                        reason: "Name or password is incorrect."
                    });

                    var MISSING_BULK_DOCS = new PouchError({
                        status: 400,
                        error: 'bad_request',
                        reason: "Missing JSON list of 'docs'"
                    });

                    var MISSING_DOC = new PouchError({
                        status: 404,
                        error: 'not_found',
                        reason: 'missing'
                    });

                    var REV_CONFLICT = new PouchError({
                        status: 409,
                        error: 'conflict',
                        reason: 'Document update conflict'
                    });

                    var INVALID_ID = new PouchError({
                        status: 400,
                        error: 'invalid_id',
                        reason: '_id field must contain a string'
                    });

                    var MISSING_ID = new PouchError({
                        status: 412,
                        error: 'missing_id',
                        reason: '_id is required for puts'
                    });

                    var RESERVED_ID = new PouchError({
                        status: 400,
                        error: 'bad_request',
                        reason: 'Only reserved document ids may start with underscore.'
                    });

                    var NOT_OPEN = new PouchError({
                        status: 412,
                        error: 'precondition_failed',
                        reason: 'Database not open'
                    });

                    var UNKNOWN_ERROR = new PouchError({
                        status: 500,
                        error: 'unknown_error',
                        reason: 'Database encountered an unknown error'
                    });

                    var BAD_ARG = new PouchError({
                        status: 500,
                        error: 'badarg',
                        reason: 'Some query argument is invalid'
                    });

                    var INVALID_REQUEST = new PouchError({
                        status: 400,
                        error: 'invalid_request',
                        reason: 'Request was invalid'
                    });

                    var QUERY_PARSE_ERROR = new PouchError({
                        status: 400,
                        error: 'query_parse_error',
                        reason: 'Some query parameter is invalid'
                    });

                    var DOC_VALIDATION = new PouchError({
                        status: 500,
                        error: 'doc_validation',
                        reason: 'Bad special document member'
                    });

                    var BAD_REQUEST = new PouchError({
                        status: 400,
                        error: 'bad_request',
                        reason: 'Something wrong with the request'
                    });

                    var NOT_AN_OBJECT = new PouchError({
                        status: 400,
                        error: 'bad_request',
                        reason: 'Document must be a JSON object'
                    });

                    var DB_MISSING = new PouchError({
                        status: 404,
                        error: 'not_found',
                        reason: 'Database not found'
                    });

                    var IDB_ERROR = new PouchError({
                        status: 500,
                        error: 'indexed_db_went_bad',
                        reason: 'unknown'
                    });

                    var WSQ_ERROR = new PouchError({
                        status: 500,
                        error: 'web_sql_went_bad',
                        reason: 'unknown'
                    });

                    var LDB_ERROR = new PouchError({
                        status: 500,
                        error: 'levelDB_went_went_bad',
                        reason: 'unknown'
                    });

                    var FORBIDDEN = new PouchError({
                        status: 403,
                        error: 'forbidden',
                        reason: 'Forbidden by design doc validate_doc_update function'
                    });

                    var INVALID_REV = new PouchError({
                        status: 400,
                        error: 'bad_request',
                        reason: 'Invalid rev format'
                    });

                    var FILE_EXISTS = new PouchError({
                        status: 412,
                        error: 'file_exists',
                        reason: 'The database could not be created, the file already exists.'
                    });

                    var MISSING_STUB = new PouchError({
                        status: 412,
                        error: 'missing_stub'
                    });

                    var INVALID_URL = new PouchError({
                        status: 413,
                        error: 'invalid_url',
                        reason: 'Provided URL is invalid'
                    });

                    var allErrors = {
                        UNAUTHORIZED: UNAUTHORIZED,
                        MISSING_BULK_DOCS: MISSING_BULK_DOCS,
                        MISSING_DOC: MISSING_DOC,
                        REV_CONFLICT: REV_CONFLICT,
                        INVALID_ID: INVALID_ID,
                        MISSING_ID: MISSING_ID,
                        RESERVED_ID: RESERVED_ID,
                        NOT_OPEN: NOT_OPEN,
                        UNKNOWN_ERROR: UNKNOWN_ERROR,
                        BAD_ARG: BAD_ARG,
                        INVALID_REQUEST: INVALID_REQUEST,
                        QUERY_PARSE_ERROR: QUERY_PARSE_ERROR,
                        DOC_VALIDATION: DOC_VALIDATION,
                        BAD_REQUEST: BAD_REQUEST,
                        NOT_AN_OBJECT: NOT_AN_OBJECT,
                        DB_MISSING: DB_MISSING,
                        WSQ_ERROR: WSQ_ERROR,
                        LDB_ERROR: LDB_ERROR,
                        FORBIDDEN: FORBIDDEN,
                        INVALID_REV: INVALID_REV,
                        FILE_EXISTS: FILE_EXISTS,
                        MISSING_STUB: MISSING_STUB,
                        IDB_ERROR: IDB_ERROR,
                        INVALID_URL: INVALID_URL
                    };

                    function createError(error, reason, name) {
                        function CustomPouchError(reason) {
                            // inherit error properties from our parent error manually
                            // so as to allow proper JSON parsing.
                            /* jshint ignore:start */
                            for (var p in error) {
                                if (typeof error[p] !== 'function') {
                                    this[p] = error[p];
                                }
                            }
                            /* jshint ignore:end */
                            if (name !== undefined) {
                                this.name = name;
                            }
                            if (reason !== undefined) {
                                this.reason = reason;
                            }
                        }

                        CustomPouchError.prototype = PouchError.prototype;
                        return new CustomPouchError(reason);
                    }

// Find one of the errors defined above based on the value
// of the specified property.
// If reason is provided prefer the error matching that reason.
// This is for differentiating between errors with the same name and status,
// eg, bad_request.
                    var getErrorTypeByProp = function (prop, value, reason) {
                        var keys = Object.keys(allErrors).filter(function (key) {
                            var error = allErrors[key];
                            return typeof error !== 'function' && error[prop] === value;
                        });
                        var key = reason && keys.filter(function (key) {
                                var error = allErrors[key];
                                return error.message === reason;
                            })[0] || keys[0];
                        return (key) ? allErrors[key] : null;
                    };

                    function generateErrorFromResponse(res) {
                        var error, errName, errType, errMsg, errReason;

                        errName = (res.error === true && typeof res.name === 'string') ?
                            res.name :
                            res.error;
                        errReason = res.reason;
                        errType = getErrorTypeByProp('name', errName, errReason);

                        if (res.missing ||
                            errReason === 'missing' ||
                            errReason === 'deleted' ||
                            errName === 'not_found') {
                            errType = MISSING_DOC;
                        } else if (errName === 'doc_validation') {
                            // doc validation needs special treatment since
                            // res.reason depends on the validation error.
                            // see utils.js
                            errType = DOC_VALIDATION;
                            errMsg = errReason;
                        } else if (errName === 'bad_request' && errType.message !== errReason) {
                            // if bad_request error already found based on reason don't override.
                            errType = BAD_REQUEST;
                        }

                        // fallback to error by status or unknown error.
                        if (!errType) {
                            errType = getErrorTypeByProp('status', res.status, errReason) ||
                                UNKNOWN_ERROR;
                        }

                        error = createError(errType, errReason, errName);

                        // Keep custom message.
                        if (errMsg) {
                            error.message = errMsg;
                        }

                        // Keep helpful response data in our error messages.
                        if (res.id) {
                            error.id = res.id;
                        }
                        if (res.status) {
                            error.status = res.status;
                        }
                        if (res.missing) {
                            error.missing = res.missing;
                        }

                        return error;
                    }

                    inherits(Changes, events.EventEmitter);

                    function Changes(db, opts, callback) {
                        events.EventEmitter.call(this);
                        var self = this;
                        this.db = db;
                        opts = opts ? clone(opts) : {};
                        var complete = opts.complete = once(function (err, resp) {
                            if (err) {
                                self.emit('error', err);
                            } else {
                                self.emit('complete', resp);
                            }
                            self.removeAllListeners();
                            db.removeListener('destroyed', onDestroy);
                        });
                        if (callback) {
                            self.on('complete', function (resp) {
                                callback(null, resp);
                            });
                            self.on('error', callback);
                        }
                        function onDestroy() {
                            self.cancel();
                        }

                        db.once('destroyed', onDestroy);

                        opts.onChange = function (change) {
                            /* istanbul ignore if */
                            if (opts.isCancelled) {
                                return;
                            }
                            self.emit('change', change);
                            if (self.startSeq && self.startSeq <= change.seq) {
                                self.startSeq = false;
                            }
                        };

                        var promise = new PouchPromise(function (fulfill, reject) {
                            opts.complete = function (err, res) {
                                if (err) {
                                    reject(err);
                                } else {
                                    fulfill(res);
                                }
                            };
                        });
                        self.once('cancel', function () {
                            db.removeListener('destroyed', onDestroy);
                            opts.complete(null, { status: 'cancelled' });
                        });
                        this.then = promise.then.bind(promise);
                        this['catch'] = promise['catch'].bind(promise);
                        this.then(function (result) {
                            complete(null, result);
                        }, complete);


                        if (!db.taskqueue.isReady) {
                            db.taskqueue.addTask(function () {
                                if (self.isCancelled) {
                                    self.emit('cancel');
                                } else {
                                    self.doChanges(opts);
                                }
                            });
                        } else {
                            self.doChanges(opts);
                        }
                    }

                    Changes.prototype.cancel = function () {
                        this.isCancelled = true;
                        if (this.db.taskqueue.isReady) {
                            this.emit('cancel');
                        }
                    };
                    function processChange(doc, metadata, opts) {
                        var changeList = [{ rev: doc._rev }];
                        if (opts.style === 'all_docs') {
                            changeList = collectLeaves(metadata.rev_tree)
                                .map(function (x) {
                                    return { rev: x.rev };
                                });
                        }
                        var change = {
                            id: metadata.id,
                            changes: changeList,
                            doc: doc
                        };

                        if (isDeleted(metadata, doc._rev)) {
                            change.deleted = true;
                        }
                        if (opts.conflicts) {
                            change.doc._conflicts = collectConflicts(metadata);
                            if (!change.doc._conflicts.length) {
                                delete change.doc._conflicts;
                            }
                        }
                        return change;
                    }

                    Changes.prototype.doChanges = function (opts) {
                        var self = this;
                        var callback = opts.complete;

                        opts = clone(opts);
                        if ('live' in opts && !('continuous' in opts)) {
                            opts.continuous = opts.live;
                        }
                        opts.processChange = processChange;

                        if (opts.since === 'latest') {
                            opts.since = 'now';
                        }
                        if (!opts.since) {
                            opts.since = 0;
                        }
                        if (opts.since === 'now') {
                            this.db.info().then(function (info) {
                                /* istanbul ignore if */
                                if (self.isCancelled) {
                                    callback(null, { status: 'cancelled' });
                                    return;
                                }
                                opts.since = info.update_seq;
                                self.doChanges(opts);
                            }, callback);
                            return;
                        }

                        if (opts.continuous && opts.since !== 'now') {
                            this.db.info().then(function (info) {
                                self.startSeq = info.update_seq;
                                /* istanbul ignore next */
                            }, function (err) {
                                if (err.id === 'idbNull') {
                                    // db closed before this returned thats ok
                                    return;
                                }
                                throw err;
                            });
                        }

                        if (opts.filter && typeof opts.filter === 'string') {
                            if (opts.filter === '_view') {
                                opts.view = normalizeDesignDocFunctionName(opts.view);
                            } else {
                                opts.filter = normalizeDesignDocFunctionName(opts.filter);
                            }

                            if (this.db.type() !== 'http' && !opts.doc_ids) {
                                return this.filterChanges(opts);
                            }
                        }

                        if (!('descending' in opts)) {
                            opts.descending = false;
                        }

                        // 0 and 1 should return 1 document
                        opts.limit = opts.limit === 0 ? 1 : opts.limit;
                        opts.complete = callback;
                        var newPromise = this.db._changes(opts);
                        if (newPromise && typeof newPromise.cancel === 'function') {
                            var cancel = self.cancel;
                            self.cancel = getArguments(function (args) {
                                newPromise.cancel();
                                cancel.apply(this, args);
                            });
                        }
                    };

                    Changes.prototype.filterChanges = function (opts) {
                        var self = this;
                        var callback = opts.complete;
                        if (opts.filter === '_view') {
                            if (!opts.view || typeof opts.view !== 'string') {
                                var err = createError(BAD_REQUEST,
                                    '`view` filter parameter not found or invalid.');
                                return callback(err);
                            }
                            // fetch a view from a design doc, make it behave like a filter
                            var viewName = parseDesignDocFunctionName(opts.view);
                            this.db.getView(viewName[0], viewName[1], function (err, view) {
                                /* istanbul ignore if */
                                if (self.isCancelled) {
                                    return callback(null, { status: 'cancelled' });
                                }
                                /* istanbul ignore next */
                                if (err) {
                                    return callback(generateErrorFromResponse(err));
                                }
                                if (!view.map) {
                                    return callback(createError(MISSING_DOC));
                                }
                                opts.filter = evalView(view.map);
                                self.doChanges(opts);
                            });
                        } else {
                            // fetch a filter from a design doc
                            var filterName = parseDesignDocFunctionName(opts.filter);
                            if (!filterName) {
                                return self.doChanges(opts);
                            }
                            this.db.getFilter(filterName[0], filterName[1], function (err, filterFun) {
                                /* istanbul ignore if */
                                if (self.isCancelled) {
                                    return callback(null, { status: 'cancelled' });
                                }
                                /* istanbul ignore next */
                                if (err) {
                                    return callback(generateErrorFromResponse(err));
                                }
                                opts.filter = evalFilter(filterFun);
                                self.doChanges(opts);
                            });
                        }
                    };

// shim for P/CouchDB adapters that don't directly implement _bulk_get
                    function bulkGet(db, opts, callback) {
                        var requests = Array.isArray(opts) ? opts : opts.docs;

                        // consolidate into one request per doc if possible
                        var requestsById = {};
                        requests.forEach(function (request) {
                            if (request.id in requestsById) {
                                requestsById[request.id].push(request);
                            } else {
                                requestsById[request.id] = [request];
                            }
                        });

                        var numDocs = Object.keys(requestsById).length;
                        var numDone = 0;
                        var perDocResults = new Array(numDocs);

                        function collapseResults() {
                            var results = [];
                            perDocResults.forEach(function (res) {
                                res.docs.forEach(function (info) {
                                    results.push({
                                        id: res.id,
                                        docs: [info]
                                    });
                                });
                            });
                            callback(null, { results: results });
                        }

                        function checkDone() {
                            if (++numDone === numDocs) {
                                collapseResults();
                            }
                        }

                        function gotResult(i, id, docs) {
                            perDocResults[i] = { id: id, docs: docs };
                            checkDone();
                        }

                        Object.keys(requestsById).forEach(function (docId, i) {

                            var docRequests = requestsById[docId];

                            // just use the first request as the "template"
                            // TODO: The _bulk_get API allows for more subtle use cases than this,
                            // but for now it is unlikely that there will be a mix of different
                            // "atts_since" or "attachments" in the same request, since it's just
                            // replicate.js that is using this for the moment.
                            // Also, atts_since is aspirational, since we don't support it yet.
                            var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);
                            docOpts.open_revs = docRequests.map(function (request) {
                                // rev is optional, open_revs disallowed
                                return request.rev;
                            });

                            // remove falsey / undefined revisions
                            docOpts.open_revs = docOpts.open_revs.filter(function (e) {
                                return e;
                            });

                            var formatResult = function (result) {
                                return result;
                            };

                            if (docOpts.open_revs.length === 0) {
                                delete docOpts.open_revs;

                                // when fetching only the "winning" leaf,
                                // transform the result so it looks like an open_revs
                                // request
                                formatResult = function (result) {
                                    return [
                                        {
                                            ok: result
                                        }
                                    ];
                                };
                            }

                            // globally-supplied options
                            ['revs', 'attachments', 'binary'].forEach(function (param) {
                                if (param in opts) {
                                    docOpts[param] = opts[param];
                                }
                            });
                            db.get(docId, docOpts, function (err, res) {
                                gotResult(i, docId, err ? [{ error: err }] : formatResult(res));
                            });
                        });
                    }

                    function isLocalId(id) {
                        return (/^_local/).test(id);
                    }

// build up a list of all the paths to the leafs in this revision tree
                    function rootToLeaf(revs) {
                        var paths = [];
                        var toVisit = revs.slice();
                        var node;
                        while ((node = toVisit.pop())) {
                            var pos = node.pos;
                            var tree = node.ids;
                            var id = tree[0];
                            var opts = tree[1];
                            var branches = tree[2];
                            var isLeaf = branches.length === 0;

                            var history = node.history ? node.history.slice() : [];
                            history.push({ id: id, opts: opts });
                            if (isLeaf) {
                                paths.push({ pos: (pos + 1 - history.length), ids: history });
                            }
                            for (var i = 0, len = branches.length; i < len; i++) {
                                toVisit.push({ pos: pos + 1, ids: branches[i], history: history });
                            }
                        }
                        return paths.reverse();
                    }

// BEGIN Math.uuid.js

                    /*!
                     Math.uuid.js (v1.4)
                     http://www.broofa.com
                     mailto:robert@broofa.com

                     Copyright (c) 2010 Robert Kieffer
                     Dual licensed under the MIT and GPL licenses.
                     */

                    /*
                     * Generate a random uuid.
                     *
                     * USAGE: Math.uuid(length, radix)
                     *   length - the desired number of characters
                     *   radix  - the number of allowable values for each character.
                     *
                     * EXAMPLES:
                     *   // No arguments  - returns RFC4122, version 4 ID
                     *   >>> Math.uuid()
                     *   "92329D39-6F5C-4520-ABFC-AAB64544E172"
                     *
                     *   // One argument - returns ID of the specified length
                     *   >>> Math.uuid(15)     // 15 character ID (default base=62)
                     *   "VcydxgltxrVZSTV"
                     *
                     *   // Two arguments - returns ID of the specified length, and radix.
                     *   // (Radix must be <= 62)
                     *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)
                     *   "01001010"
                     *   >>> Math.uuid(8, 10) // 8 character ID (base=10)
                     *   "47473046"
                     *   >>> Math.uuid(8, 16) // 8 character ID (base=16)
                     *   "098F4D35"
                     */
                    var chars = (
                        '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
                        'abcdefghijklmnopqrstuvwxyz'
                    ).split('');

                    function getValue(radix) {
                        return 0 | Math.random() * radix;
                    }

                    function uuid(len, radix) {
                        radix = radix || chars.length;
                        var out = '';
                        var i = -1;

                        if (len) {
                            // Compact form
                            while (++i < len) {
                                out += chars[getValue(radix)];
                            }
                            return out;
                        }
                        // rfc4122, version 4 form
                        // Fill in random data.  At i==19 set the high bits of clock sequence as
                        // per rfc4122, sec. 4.1.5
                        while (++i < 36) {
                            switch (i) {
                                case 8:
                                case 13:
                                case 18:
                                case 23:
                                    out += '-';
                                    break;
                                case 19:
                                    out += chars[(getValue(16) & 0x3) | 0x8];
                                    break;
                                default:
                                    out += chars[getValue(16)];
                            }
                        }

                        return out;
                    }

                    function toObject(array) {
                        return array.reduce(function (obj, item) {
                            obj[item] = true;
                            return obj;
                        }, {});
                    }

// List of top level reserved words for doc
                    var reservedWords = toObject([
                        '_id',
                        '_rev',
                        '_attachments',
                        '_deleted',
                        '_revisions',
                        '_revs_info',
                        '_conflicts',
                        '_deleted_conflicts',
                        '_local_seq',
                        '_rev_tree',
                        //replication documents
                        '_replication_id',
                        '_replication_state',
                        '_replication_state_time',
                        '_replication_state_reason',
                        '_replication_stats',
                        // Specific to Couchbase Sync Gateway
                        '_removed'
                    ]);

// List of reserved words that should end up the document
                    var dataWords = toObject([
                        '_attachments',
                        //replication documents
                        '_replication_id',
                        '_replication_state',
                        '_replication_state_time',
                        '_replication_state_reason',
                        '_replication_stats'
                    ]);

// Determine id an ID is valid
//   - invalid IDs begin with an underescore that does not begin '_design' or
//     '_local'
//   - any other string value is a valid id
// Returns the specific error object for each case
                    function invalidIdError(id) {
                        var err;
                        if (!id) {
                            err = createError(MISSING_ID);
                        } else if (typeof id !== 'string') {
                            err = createError(INVALID_ID);
                        } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {
                            err = createError(RESERVED_ID);
                        }
                        if (err) {
                            throw err;
                        }
                    }

                    function parseRevisionInfo(rev) {
                        if (!/^\d+\-./.test(rev)) {
                            return createError(INVALID_REV);
                        }
                        var idx = rev.indexOf('-');
                        var left = rev.substring(0, idx);
                        var right = rev.substring(idx + 1);
                        return {
                            prefix: parseInt(left, 10),
                            id: right
                        };
                    }

                    function makeRevTreeFromRevisions(revisions, opts) {
                        var pos = revisions.start - revisions.ids.length + 1;

                        var revisionIds = revisions.ids;
                        var ids = [revisionIds[0], opts, []];

                        for (var i = 1, len = revisionIds.length; i < len; i++) {
                            ids = [revisionIds[i], { status: 'missing' }, [ids]];
                        }

                        return [
                            {
                                pos: pos,
                                ids: ids
                            }
                        ];
                    }

// Preprocess documents, parse their revisions, assign an id and a
// revision for new writes that are missing them, etc
                    function parseDoc(doc, newEdits) {

                        var nRevNum;
                        var newRevId;
                        var revInfo;
                        var opts = { status: 'available' };
                        if (doc._deleted) {
                            opts.deleted = true;
                        }

                        if (newEdits) {
                            if (!doc._id) {
                                doc._id = uuid();
                            }
                            newRevId = uuid(32, 16).toLowerCase();
                            if (doc._rev) {
                                revInfo = parseRevisionInfo(doc._rev);
                                if (revInfo.error) {
                                    return revInfo;
                                }
                                doc._rev_tree = [
                                    {
                                        pos: revInfo.prefix,
                                        ids: [revInfo.id, { status: 'missing' }, [[newRevId, opts, []]]]
                                    }
                                ];
                                nRevNum = revInfo.prefix + 1;
                            } else {
                                doc._rev_tree = [
                                    {
                                        pos: 1,
                                        ids: [newRevId, opts, []]
                                    }
                                ];
                                nRevNum = 1;
                            }
                        } else {
                            if (doc._revisions) {
                                doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);
                                nRevNum = doc._revisions.start;
                                newRevId = doc._revisions.ids[0];
                            }
                            if (!doc._rev_tree) {
                                revInfo = parseRevisionInfo(doc._rev);
                                if (revInfo.error) {
                                    return revInfo;
                                }
                                nRevNum = revInfo.prefix;
                                newRevId = revInfo.id;
                                doc._rev_tree = [
                                    {
                                        pos: nRevNum,
                                        ids: [newRevId, opts, []]
                                    }
                                ];
                            }
                        }

                        invalidIdError(doc._id);

                        doc._rev = nRevNum + '-' + newRevId;

                        var result = { metadata: {}, data: {} };
                        for (var key in doc) {
                            /* istanbul ignore else */
                            if (Object.prototype.hasOwnProperty.call(doc, key)) {
                                var specialKey = key[0] === '_';
                                if (specialKey && !reservedWords[key]) {
                                    var error = createError(DOC_VALIDATION, key);
                                    error.message = DOC_VALIDATION.message + ': ' + key;
                                    throw error;
                                } else if (specialKey && !dataWords[key]) {
                                    result.metadata[key.slice(1)] = doc[key];
                                } else {
                                    result.data[key] = doc[key];
                                }
                            }
                        }
                        return result;
                    }

                    /*
                     * A generic pouch adapter
                     */

                    function compare(left, right) {
                        return left < right ? -1 : left > right ? 1 : 0;
                    }

// returns first element of arr satisfying callback predicate
                    function arrayFirst(arr, callback) {
                        for (var i = 0; i < arr.length; i++) {
                            if (callback(arr[i], i) === true) {
                                return arr[i];
                            }
                        }
                    }

// Wrapper for functions that call the bulkdocs api with a single doc,
// if the first result is an error, return an error
                    function yankError(callback) {
                        return function (err, results) {
                            if (err || (results[0] && results[0].error)) {
                                callback(err || results[0]);
                            } else {
                                callback(null, results.length ? results[0] : results);
                            }
                        };
                    }

// clean docs given to us by the user
                    function cleanDocs(docs) {
                        for (var i = 0; i < docs.length; i++) {
                            var doc = docs[i];
                            if (doc._deleted) {
                                delete doc._attachments; // ignore atts for deleted docs
                            } else if (doc._attachments) {
                                // filter out extraneous keys from _attachments
                                var atts = Object.keys(doc._attachments);
                                for (var j = 0; j < atts.length; j++) {
                                    var att = atts[j];
                                    doc._attachments[att] = pick(doc._attachments[att],
                                        ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);
                                }
                            }
                        }
                    }

// compare two docs, first by _id then by _rev
                    function compareByIdThenRev(a, b) {
                        var idCompare = compare(a._id, b._id);
                        if (idCompare !== 0) {
                            return idCompare;
                        }
                        var aStart = a._revisions ? a._revisions.start : 0;
                        var bStart = b._revisions ? b._revisions.start : 0;
                        return compare(aStart, bStart);
                    }

// for every node in a revision tree computes its distance from the closest
// leaf
                    function computeHeight(revs) {
                        var height = {};
                        var edges = [];
                        traverseRevTree(revs, function (isLeaf, pos, id, prnt) {
                            var rev = pos + "-" + id;
                            if (isLeaf) {
                                height[rev] = 0;
                            }
                            if (prnt !== undefined) {
                                edges.push({ from: prnt, to: rev });
                            }
                            return rev;
                        });

                        edges.reverse();
                        edges.forEach(function (edge) {
                            if (height[edge.from] === undefined) {
                                height[edge.from] = 1 + height[edge.to];
                            } else {
                                height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);
                            }
                        });
                        return height;
                    }

                    function allDocsKeysQuery(api, opts, callback) {
                        var keys = ('limit' in opts) ?
                            opts.keys.slice(opts.skip, opts.limit + opts.skip) :
                            (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;
                        if (opts.descending) {
                            keys.reverse();
                        }
                        if (!keys.length) {
                            return api._allDocs({ limit: 0 }, callback);
                        }
                        var finalResults = {
                            offset: opts.skip
                        };
                        return PouchPromise.all(keys.map(function (key) {
                            var subOpts = jsExtend.extend({ key: key, deleted: 'ok' }, opts);
                            ['limit', 'skip', 'keys'].forEach(function (optKey) {
                                delete subOpts[optKey];
                            });
                            return new PouchPromise(function (resolve, reject) {
                                api._allDocs(subOpts, function (err, res) {
                                    /* istanbul ignore if */
                                    if (err) {
                                        return reject(err);
                                    }
                                    finalResults.total_rows = res.total_rows;
                                    resolve(res.rows[0] || { key: key, error: 'not_found' });
                                });
                            });
                        })).then(function (results) {
                            finalResults.rows = results;
                            return finalResults;
                        });
                    }

// all compaction is done in a queue, to avoid attaching
// too many listeners at once
                    function doNextCompaction(self) {
                        var task = self._compactionQueue[0];
                        var opts = task.opts;
                        var callback = task.callback;
                        self.get('_local/compaction')["catch"](function () {
                            return false;
                        }).then(function (doc) {
                            if (doc && doc.last_seq) {
                                opts.last_seq = doc.last_seq;
                            }
                            self._compact(opts, function (err, res) {
                                /* istanbul ignore if */
                                if (err) {
                                    callback(err);
                                } else {
                                    callback(null, res);
                                }
                                process.nextTick(function () {
                                    self._compactionQueue.shift();
                                    if (self._compactionQueue.length) {
                                        doNextCompaction(self);
                                    }
                                });
                            });
                        });
                    }

                    function attachmentNameError(name) {
                        if (name.charAt(0) === '_') {
                            return name + 'is not a valid attachment name, attachment ' +
                                'names cannot start with \'_\'';
                        }
                        return false;
                    }

                    function cacheUpdateRequired(api, cache, designDocName, callback) {
                        cache.seq = cache.seq || 0;
                        var changesOpts = {
                            doc_ids: ['_design/' + designDocName],
                            limit: 1,
                            since: cache.seq
                        };
                        api.changes(changesOpts).then(function (res) {
                            var latestSeq = res.results && res.results.length && res.results[0].seq;
                            if (latestSeq && latestSeq > cache.seq) {
                                // invalidate the cache
                                cache.seq = latestSeq;
                                delete cache.promise;
                            }
                            callback();
                        })["catch"](callback);
                    }

                    function getDesignDocCache(api, designDocName, callback) {
                        api._ddocCache = api._ddocCache || {};
                        api._ddocCache[designDocName] = api._ddocCache[designDocName] || {};
                        var cache = api._ddocCache[designDocName];
                        cacheUpdateRequired(api, cache, designDocName, function (err) {
                            if (err) {
                                return callback(err);
                            }
                            if (!cache.promise) {
                                cache.promise = new PouchPromise(function (resolve, reject) {
                                    api._get('_design/' + designDocName, {}, function (err, res) {
                                        if (err) {
                                            return reject(err);
                                        }
                                        var cache = {};
                                        ['views', 'filters'].forEach(function (propertyName) {
                                            cache[propertyName] = res.doc[propertyName];
                                        });
                                        resolve(cache);
                                    });
                                });
                            }
                            cache.promise.then(function (cache) {
                                callback(null, cache);
                            })["catch"](callback);
                        });
                    }

                    function getDesignDocProperty(api, designDocName, propertyName,
                                                  propertyElement, callback) {
                        getDesignDocCache(api, designDocName, function (err, designDoc) {
                            if (err) {
                                return callback(err);
                            }
                            var element = designDoc[propertyName] &&
                                designDoc[propertyName][propertyElement];
                            if (!element) {
                                return callback(createError(MISSING_DOC));
                            }
                            callback(null, element);
                        });
                    }

                    inherits(AbstractPouchDB, events.EventEmitter);

                    function AbstractPouchDB() {
                        events.EventEmitter.call(this);
                    }

                    AbstractPouchDB.prototype.post =
                        adapterFun('post', function (doc, opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }
                            if (typeof doc !== 'object' || Array.isArray(doc)) {
                                return callback(createError(NOT_AN_OBJECT));
                            }
                            this.bulkDocs({ docs: [doc] }, opts, yankError(callback));
                        });

                    AbstractPouchDB.prototype.put =
                        adapterFun('put', getArguments(function (args) {
                            var temp, temptype, opts, callback;
                            var doc = args.shift();
                            var id = '_id' in doc;
                            if (typeof doc !== 'object' || Array.isArray(doc)) {
                                callback = args.pop();
                                return callback(createError(NOT_AN_OBJECT));
                            }

                            /* eslint no-constant-condition: 0 */
                            while (true) {
                                temp = args.shift();
                                temptype = typeof temp;
                                if (temptype === "string" && !id) {
                                    doc._id = temp;
                                    id = true;
                                } else if (temptype === "string" && id && !('_rev' in doc)) {
                                    doc._rev = temp;
                                } else if (temptype === "object") {
                                    opts = temp;
                                } else if (temptype === "function") {
                                    callback = temp;
                                }
                                if (!args.length) {
                                    break;
                                }
                            }
                            opts = opts || {};
                            invalidIdError(doc._id);
                            if (isLocalId(doc._id) && typeof this._putLocal === 'function') {
                                if (doc._deleted) {
                                    return this._removeLocal(doc, callback);
                                } else {
                                    return this._putLocal(doc, callback);
                                }
                            }
                            this.bulkDocs({ docs: [doc] }, opts, yankError(callback));
                        }));

                    AbstractPouchDB.prototype.putAttachment =
                        adapterFun('putAttachment', function (docId, attachmentId, rev,
                                                              blob, type) {
                            var api = this;
                            if (typeof type === 'function') {
                                type = blob;
                                blob = rev;
                                rev = null;
                            }
                            // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267
                            /* istanbul ignore if */
                            if (typeof type === 'undefined') {
                                type = blob;
                                blob = rev;
                                rev = null;
                            }

                            function createAttachment(doc) {
                                doc._attachments = doc._attachments || {};
                                doc._attachments[attachmentId] = {
                                    content_type: type,
                                    data: blob
                                };
                                return api.put(doc);
                            }

                            return api.get(docId).then(function (doc) {
                                if (doc._rev !== rev) {
                                    throw createError(REV_CONFLICT);
                                }

                                return createAttachment(doc);
                            }, function (err) {
                                // create new doc
                                /* istanbul ignore else */
                                if (err.reason === MISSING_DOC.message) {
                                    return createAttachment({ _id: docId });
                                } else {
                                    throw err;
                                }
                            });
                        });

                    AbstractPouchDB.prototype.removeAttachment =
                        adapterFun('removeAttachment', function (docId, attachmentId, rev,
                                                                 callback) {
                            var self = this;
                            self.get(docId, function (err, obj) {
                                /* istanbul ignore if */
                                if (err) {
                                    callback(err);
                                    return;
                                }
                                if (obj._rev !== rev) {
                                    callback(createError(REV_CONFLICT));
                                    return;
                                }
                                /* istanbul ignore if */
                                if (!obj._attachments) {
                                    return callback();
                                }
                                delete obj._attachments[attachmentId];
                                if (Object.keys(obj._attachments).length === 0) {
                                    delete obj._attachments;
                                }
                                self.put(obj, callback);
                            });
                        });

                    AbstractPouchDB.prototype.remove =
                        adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {
                            var doc;
                            if (typeof optsOrRev === 'string') {
                                // id, rev, opts, callback style
                                doc = {
                                    _id: docOrId,
                                    _rev: optsOrRev
                                };
                                if (typeof opts === 'function') {
                                    callback = opts;
                                    opts = {};
                                }
                            } else {
                                // doc, opts, callback style
                                doc = docOrId;
                                if (typeof optsOrRev === 'function') {
                                    callback = optsOrRev;
                                    opts = {};
                                } else {
                                    callback = opts;
                                    opts = optsOrRev;
                                }
                            }
                            opts = opts || {};
                            opts.was_delete = true;
                            var newDoc = { _id: doc._id, _rev: (doc._rev || opts.rev) };
                            newDoc._deleted = true;
                            if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {
                                return this._removeLocal(doc, callback);
                            }
                            this.bulkDocs({ docs: [newDoc] }, opts, yankError(callback));
                        });

                    AbstractPouchDB.prototype.revsDiff =
                        adapterFun('revsDiff', function (req, opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }
                            var ids = Object.keys(req);

                            if (!ids.length) {
                                return callback(null, {});
                            }

                            var count = 0;
                            var missing = new pouchdbCollections.Map();

                            function addToMissing(id, revId) {
                                if (!missing.has(id)) {
                                    missing.set(id, { missing: [] });
                                }
                                missing.get(id).missing.push(revId);
                            }

                            function processDoc(id, rev_tree) {
                                // Is this fast enough? Maybe we should switch to a set simulated by a map
                                var missingForId = req[id].slice(0);
                                traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,
                                                                    opts) {
                                    var rev = pos + '-' + revHash;
                                    var idx = missingForId.indexOf(rev);
                                    if (idx === -1) {
                                        return;
                                    }

                                    missingForId.splice(idx, 1);
                                    /* istanbul ignore if */
                                    if (opts.status !== 'available') {
                                        addToMissing(id, rev);
                                    }
                                });

                                // Traversing the tree is synchronous, so now `missingForId` contains
                                // revisions that were not found in the tree
                                missingForId.forEach(function (rev) {
                                    addToMissing(id, rev);
                                });
                            }

                            ids.map(function (id) {
                                this._getRevisionTree(id, function (err, rev_tree) {
                                    if (err && err.status === 404 && err.message === 'missing') {
                                        missing.set(id, { missing: req[id] });
                                    } else if (err) {
                                        /* istanbul ignore next */
                                        return callback(err);
                                    } else {
                                        processDoc(id, rev_tree);
                                    }

                                    if (++count === ids.length) {
                                        // convert LazyMap to object
                                        var missingObj = {};
                                        missing.forEach(function (value, key) {
                                            missingObj[key] = value;
                                        });
                                        return callback(null, missingObj);
                                    }
                                });
                            }, this);
                        });

// _bulk_get API for faster replication, as described in
// https://github.com/apache/couchdb-chttpd/pull/33
// At the "abstract" level, it will just run multiple get()s in
// parallel, because this isn't much of a performance cost
// for local databases (except the cost of multiple transactions, which is
// small). The http adapter overrides this in order
// to do a more efficient single HTTP request.
                    AbstractPouchDB.prototype.bulkGet =
                        adapterFun('bulkGet', function (opts, callback) {
                            bulkGet(this, opts, callback);
                        });

// compact one document and fire callback
// by compacting we mean removing all revisions which
// are further from the leaf in revision tree than max_height
                    AbstractPouchDB.prototype.compactDocument =
                        adapterFun('compactDocument', function (docId, maxHeight, callback) {
                            var self = this;
                            this._getRevisionTree(docId, function (err, revTree) {
                                /* istanbul ignore if */
                                if (err) {
                                    return callback(err);
                                }
                                var height = computeHeight(revTree);
                                var candidates = [];
                                var revs = [];
                                Object.keys(height).forEach(function (rev) {
                                    if (height[rev] > maxHeight) {
                                        candidates.push(rev);
                                    }
                                });

                                traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {
                                    var rev = pos + '-' + revHash;
                                    if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {
                                        revs.push(rev);
                                    }
                                });
                                self._doCompaction(docId, revs, callback);
                            });
                        });

// compact the whole database using single document
// compaction
                    AbstractPouchDB.prototype.compact =
                        adapterFun('compact', function (opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }

                            var self = this;
                            opts = opts || {};

                            self._compactionQueue = self._compactionQueue || [];
                            self._compactionQueue.push({ opts: opts, callback: callback });
                            if (self._compactionQueue.length === 1) {
                                doNextCompaction(self);
                            }
                        });
                    AbstractPouchDB.prototype._compact = function (opts, callback) {
                        var self = this;
                        var changesOpts = {
                            return_docs: false,
                            last_seq: opts.last_seq || 0
                        };
                        var promises = [];

                        function onChange(row) {
                            promises.push(self.compactDocument(row.id, 0));
                        }

                        function onComplete(resp) {
                            var lastSeq = resp.last_seq;
                            PouchPromise.all(promises).then(function () {
                                return upsert(self, '_local/compaction', function deltaFunc(doc) {
                                    if (!doc.last_seq || doc.last_seq < lastSeq) {
                                        doc.last_seq = lastSeq;
                                        return doc;
                                    }
                                    return false; // somebody else got here first, don't update
                                });
                            }).then(function () {
                                callback(null, { ok: true });
                            })["catch"](callback);
                        }

                        self.changes(changesOpts)
                            .on('change', onChange)
                            .on('complete', onComplete)
                            .on('error', callback);
                    };
                    /* Begin api wrappers. Specific functionality to storage belongs in the
                     _[method] */
                    AbstractPouchDB.prototype.get =
                        adapterFun('get', function (id, opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }
                            if (typeof id !== 'string') {
                                return callback(createError(INVALID_ID));
                            }
                            if (isLocalId(id) && typeof this._getLocal === 'function') {
                                return this._getLocal(id, callback);
                            }
                            var leaves = [], self = this;

                            function finishOpenRevs() {
                                var result = [];
                                var count = leaves.length;
                                /* istanbul ignore if */
                                if (!count) {
                                    return callback(null, result);
                                }
                                // order with open_revs is unspecified
                                leaves.forEach(function (leaf) {
                                    self.get(id, {
                                        rev: leaf,
                                        revs: opts.revs,
                                        attachments: opts.attachments
                                    }, function (err, doc) {
                                        if (!err) {
                                            result.push({ ok: doc });
                                        } else {
                                            result.push({ missing: leaf });
                                        }
                                        count--;
                                        if (!count) {
                                            callback(null, result);
                                        }
                                    });
                                });
                            }

                            if (opts.open_revs) {
                                if (opts.open_revs === "all") {
                                    this._getRevisionTree(id, function (err, rev_tree) {
                                        if (err) {
                                            return callback(err);
                                        }
                                        leaves = collectLeaves(rev_tree).map(function (leaf) {
                                            return leaf.rev;
                                        });
                                        finishOpenRevs();
                                    });
                                } else {
                                    if (Array.isArray(opts.open_revs)) {
                                        leaves = opts.open_revs;
                                        for (var i = 0; i < leaves.length; i++) {
                                            var l = leaves[i];
                                            // looks like it's the only thing couchdb checks
                                            if (!(typeof(l) === "string" && /^\d+-/.test(l))) {
                                                return callback(createError(INVALID_REV));
                                            }
                                        }
                                        finishOpenRevs();
                                    } else {
                                        return callback(createError(UNKNOWN_ERROR,
                                            'function_clause'));
                                    }
                                }
                                return; // open_revs does not like other options
                            }

                            return this._get(id, opts, function (err, result) {
                                if (err) {
                                    return callback(err);
                                }

                                var doc = result.doc;
                                var metadata = result.metadata;
                                var ctx = result.ctx;

                                if (opts.conflicts) {
                                    var conflicts = collectConflicts(metadata);
                                    if (conflicts.length) {
                                        doc._conflicts = conflicts;
                                    }
                                }

                                if (isDeleted(metadata, doc._rev)) {
                                    doc._deleted = true;
                                }

                                if (opts.revs || opts.revs_info) {
                                    var paths = rootToLeaf(metadata.rev_tree);
                                    var path = arrayFirst(paths, function (arr) {
                                        return arr.ids.map(function (x) {
                                                return x.id;
                                            })
                                                .indexOf(doc._rev.split('-')[1]) !== -1;
                                    });

                                    var indexOfRev = path.ids.map(function (x) {
                                            return x.id;
                                        })
                                            .indexOf(doc._rev.split('-')[1]) + 1;
                                    var howMany = path.ids.length - indexOfRev;
                                    path.ids.splice(indexOfRev, howMany);
                                    path.ids.reverse();

                                    if (opts.revs) {
                                        doc._revisions = {
                                            start: (path.pos + path.ids.length) - 1,
                                            ids: path.ids.map(function (rev) {
                                                return rev.id;
                                            })
                                        };
                                    }
                                    if (opts.revs_info) {
                                        var pos = path.pos + path.ids.length;
                                        doc._revs_info = path.ids.map(function (rev) {
                                            pos--;
                                            return {
                                                rev: pos + '-' + rev.id,
                                                status: rev.opts.status
                                            };
                                        });
                                    }
                                }

                                if (opts.attachments && doc._attachments) {
                                    var attachments = doc._attachments;
                                    var count = Object.keys(attachments).length;
                                    if (count === 0) {
                                        return callback(null, doc);
                                    }
                                    Object.keys(attachments).forEach(function (key) {
                                        this._getAttachment(attachments[key], {
                                            binary: opts.binary,
                                            ctx: ctx
                                        }, function (err, data) {
                                            var att = doc._attachments[key];
                                            att.data = data;
                                            delete att.stub;
                                            delete att.length;
                                            if (!--count) {
                                                callback(null, doc);
                                            }
                                        });
                                    }, self);
                                } else {
                                    if (doc._attachments) {
                                        for (var key in doc._attachments) {
                                            /* istanbul ignore else */
                                            if (doc._attachments.hasOwnProperty(key)) {
                                                doc._attachments[key].stub = true;
                                            }
                                        }
                                    }
                                    callback(null, doc);
                                }
                            });
                        });

                    AbstractPouchDB.prototype.getView =
                        adapterFun('getView', function (designDocName, viewName, callback) {
                            getDesignDocProperty(this, designDocName, 'views', viewName, callback);
                        });

                    AbstractPouchDB.prototype.getFilter =
                        adapterFun('getFilter', function (designDocName, filterName, callback) {
                            getDesignDocProperty(this, designDocName, 'filters', filterName, callback);
                        });

                    AbstractPouchDB.prototype.getAttachment =
                        adapterFun('getAttachment', function (docId, attachmentId, opts,
                                                              callback) {
                            var self = this;
                            if (opts instanceof Function) {
                                callback = opts;
                                opts = {};
                            }
                            this._get(docId, opts, function (err, res) {
                                if (err) {
                                    return callback(err);
                                }
                                if (res.doc._attachments && res.doc._attachments[attachmentId]) {
                                    opts.ctx = res.ctx;
                                    opts.binary = true;
                                    self._getAttachment(res.doc._attachments[attachmentId], opts, callback);
                                } else {
                                    return callback(createError(MISSING_DOC));
                                }
                            });
                        });

                    AbstractPouchDB.prototype.allDocs =
                        adapterFun('allDocs', function (opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }
                            opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;
                            if (opts.start_key) {
                                opts.startkey = opts.start_key;
                            }
                            if (opts.end_key) {
                                opts.endkey = opts.end_key;
                            }
                            if ('keys' in opts) {
                                if (!Array.isArray(opts.keys)) {
                                    return callback(new TypeError('options.keys must be an array'));
                                }
                                var incompatibleOpt =
                                    ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {
                                        return incompatibleOpt in opts;
                                    })[0];
                                if (incompatibleOpt) {
                                    callback(createError(QUERY_PARSE_ERROR,
                                        'Query parameter `' + incompatibleOpt +
                                        '` is not compatible with multi-get'
                                    ));
                                    return;
                                }
                                if (this.type() !== 'http') {
                                    return allDocsKeysQuery(this, opts, callback);
                                }
                            }

                            return this._allDocs(opts, callback);
                        });

                    AbstractPouchDB.prototype.changes = function (opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        return new Changes(this, opts, callback);
                    };

                    AbstractPouchDB.prototype.close =
                        adapterFun('close', function (callback) {
                            this._closed = true;
                            return this._close(callback);
                        });

                    AbstractPouchDB.prototype.info = adapterFun('info', function (callback) {
                        var self = this;
                        this._info(function (err, info) {
                            if (err) {
                                return callback(err);
                            }
                            // assume we know better than the adapter, unless it informs us
                            info.db_name = info.db_name || self._db_name;
                            info.auto_compaction = !!(self.auto_compaction && self.type() !== 'http');
                            info.adapter = self.type();
                            callback(null, info);
                        });
                    });

                    AbstractPouchDB.prototype.id = adapterFun('id', function (callback) {
                        return this._id(callback);
                    });

                    AbstractPouchDB.prototype.type = function () {
                        /* istanbul ignore next */
                        return (typeof this._type === 'function') ? this._type() : this.adapter;
                    };

                    AbstractPouchDB.prototype.bulkDocs =
                        adapterFun('bulkDocs', function (req, opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }

                            opts = opts || {};

                            if (Array.isArray(req)) {
                                req = {
                                    docs: req
                                };
                            }

                            if (!req || !req.docs || !Array.isArray(req.docs)) {
                                return callback(createError(MISSING_BULK_DOCS));
                            }

                            for (var i = 0; i < req.docs.length; ++i) {
                                if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {
                                    return callback(createError(NOT_AN_OBJECT));
                                }
                            }

                            var attachmentError;
                            req.docs.forEach(function (doc) {
                                if (doc._attachments) {
                                    Object.keys(doc._attachments).forEach(function (name) {
                                        attachmentError = attachmentError || attachmentNameError(name);
                                    });
                                }
                            });

                            if (attachmentError) {
                                return callback(createError(BAD_REQUEST, attachmentError));
                            }

                            if (!('new_edits' in opts)) {
                                if ('new_edits' in req) {
                                    opts.new_edits = req.new_edits;
                                } else {
                                    opts.new_edits = true;
                                }
                            }

                            if (!opts.new_edits && this.type() !== 'http') {
                                // ensure revisions of the same doc are sorted, so that
                                // the local adapter processes them correctly (#2935)
                                req.docs.sort(compareByIdThenRev);
                            }

                            cleanDocs(req.docs);

                            return this._bulkDocs(req, opts, function (err, res) {
                                if (err) {
                                    return callback(err);
                                }
                                if (!opts.new_edits) {
                                    // this is what couch does when new_edits is false
                                    res = res.filter(function (x) {
                                        return x.error;
                                    });
                                }
                                callback(null, res);
                            });
                        });

                    AbstractPouchDB.prototype.registerDependentDatabase =
                        adapterFun('registerDependentDatabase', function (dependentDb,
                                                                          callback) {
                            var depDB = new this.constructor(dependentDb, this.__opts);

                            function diffFun(doc) {
                                doc.dependentDbs = doc.dependentDbs || {};
                                if (doc.dependentDbs[dependentDb]) {
                                    return false; // no update required
                                }
                                doc.dependentDbs[dependentDb] = true;
                                return doc;
                            }

                            upsert(this, '_local/_pouch_dependentDbs', diffFun)
                                .then(function () {
                                    callback(null, { db: depDB });
                                })["catch"](callback);
                        });

                    AbstractPouchDB.prototype.destroy =
                        adapterFun('destroy', function (opts, callback) {

                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }

                            var self = this;
                            var usePrefix = 'use_prefix' in self ? self.use_prefix : true;

                            function destroyDb() {
                                // call destroy method of the particular adaptor
                                self._destroy(opts, function (err, resp) {
                                    if (err) {
                                        return callback(err);
                                    }
                                    self._destroyed = true;
                                    self.emit('destroyed');
                                    callback(null, resp || { 'ok': true });
                                });
                            }

                            if (self.type() === 'http') {
                                // no need to check for dependent DBs if it's a remote DB
                                return destroyDb();
                            }

                            self.get('_local/_pouch_dependentDbs', function (err, localDoc) {
                                if (err) {
                                    /* istanbul ignore if */
                                    if (err.status !== 404) {
                                        return callback(err);
                                    } else { // no dependencies
                                        return destroyDb();
                                    }
                                }
                                var dependentDbs = localDoc.dependentDbs;
                                var PouchDB = self.constructor;
                                var deletedMap = Object.keys(dependentDbs).map(function (name) {
                                    // use_prefix is only false in the browser
                                    /* istanbul ignore next */
                                    var trueName = usePrefix ?
                                        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;
                                    return new PouchDB(trueName, self.__opts).destroy();
                                });
                                PouchPromise.all(deletedMap).then(destroyDb, callback);
                            });
                        });

                    function TaskQueue() {
                        this.isReady = false;
                        this.failed = false;
                        this.queue = [];
                    }

                    TaskQueue.prototype.execute = function () {
                        var fun;
                        if (this.failed) {
                            while ((fun = this.queue.shift())) {
                                fun(this.failed);
                            }
                        } else {
                            while ((fun = this.queue.shift())) {
                                fun();
                            }
                        }
                    };

                    TaskQueue.prototype.fail = function (err) {
                        this.failed = err;
                        this.execute();
                    };

                    TaskQueue.prototype.ready = function (db) {
                        this.isReady = true;
                        this.db = db;
                        this.execute();
                    };

                    TaskQueue.prototype.addTask = function (fun) {
                        this.queue.push(fun);
                        if (this.failed) {
                            this.execute();
                        }
                    };

                    function defaultCallback(err) {
                        /* istanbul ignore next */
                        if (err && global.debug) {
                            console.error(err);
                        }
                    }

// OK, so here's the deal. Consider this code:
//     var db1 = new PouchDB('foo');
//     var db2 = new PouchDB('foo');
//     db1.destroy();
// ^ these two both need to emit 'destroyed' events,
// as well as the PouchDB constructor itself.
// So we have one db object (whichever one got destroy() called on it)
// responsible for emitting the initial event, which then gets emitted
// by the constructor, which then broadcasts it to any other dbs
// that may have been created with the same name.
                    function prepareForDestruction(self, opts) {
                        var name = opts.originalName;
                        var ctor = self.constructor;
                        var destructionListeners = ctor._destructionListeners;

                        function onDestroyed() {
                            ctor.emit('destroyed', name);
                        }

                        function onConstructorDestroyed() {
                            self.removeListener('destroyed', onDestroyed);
                            self.emit('destroyed', self);
                        }

                        self.once('destroyed', onDestroyed);

                        // in setup.js, the constructor is primed to listen for destroy events
                        if (!destructionListeners.has(name)) {
                            destructionListeners.set(name, []);
                        }
                        destructionListeners.get(name).push(onConstructorDestroyed);
                    }

                    inherits(PouchDB, AbstractPouchDB);
                    function PouchDB(name, opts, callback) {

                        if (!(this instanceof PouchDB)) {
                            return new PouchDB(name, opts, callback);
                        }
                        var self = this;
                        if (typeof opts === 'function' || typeof opts === 'undefined') {
                            callback = opts;
                            opts = {};
                        }

                        if (name && typeof name === 'object') {
                            opts = name;
                            name = undefined;
                        }
                        if (typeof callback === 'undefined') {
                            callback = defaultCallback;
                        }
                        name = name || opts.name;
                        opts = clone(opts);
                        // if name was specified via opts, ignore for the sake of dependentDbs
                        delete opts.name;
                        this.__opts = opts;
                        var oldCB = callback;
                        self.auto_compaction = opts.auto_compaction;
                        self.prefix = PouchDB.prefix;
                        AbstractPouchDB.call(self);
                        self.taskqueue = new TaskQueue();
                        var promise = new PouchPromise(function (fulfill, reject) {
                            callback = function (err, resp) {
                                /* istanbul ignore if */
                                if (err) {
                                    return reject(err);
                                }
                                delete resp.then;
                                fulfill(resp);
                            };

                            opts = clone(opts);
                            var originalName = opts.name || name;
                            var backend, error;
                            (function () {
                                try {

                                    if (typeof originalName !== 'string') {
                                        error = new Error('Missing/invalid DB name');
                                        error.code = 400;
                                        throw error;
                                    }

                                    backend = PouchDB.parseAdapter(originalName, opts);

                                    opts.originalName = originalName;
                                    opts.name = backend.name;
                                    if (opts.prefix && backend.adapter !== 'http' &&
                                        backend.adapter !== 'https') {
                                        opts.name = opts.prefix + opts.name;
                                    }
                                    opts.adapter = opts.adapter || backend.adapter;
                                    self._adapter = opts.adapter;
                                    debug('pouchdb:adapter')('Picked adapter: ' + opts.adapter);

                                    self._db_name = originalName;
                                    if (!PouchDB.adapters[opts.adapter]) {
                                        error = new Error('Adapter is missing');
                                        error.code = 404;
                                        throw error;
                                    }

                                    /* istanbul ignore if */
                                    if (!PouchDB.adapters[opts.adapter].valid()) {
                                        error = new Error('Invalid Adapter');
                                        error.code = 404;
                                        throw error;
                                    }
                                } catch (err) {
                                    self.taskqueue.fail(err);
                                }
                            }());
                            if (error) {
                                return reject(error); // constructor error, see above
                            }
                            self.adapter = opts.adapter;

                            // needs access to PouchDB;
                            self.replicate = {};

                            self.replicate.from = function (url, opts, callback) {
                                return self.constructor.replicate(url, self, opts, callback);
                            };

                            self.replicate.to = function (url, opts, callback) {
                                return self.constructor.replicate(self, url, opts, callback);
                            };

                            self.sync = function (dbName, opts, callback) {
                                return self.constructor.sync(self, dbName, opts, callback);
                            };

                            self.replicate.sync = self.sync;

                            PouchDB.adapters[opts.adapter].call(self, opts, function (err) {
                                /* istanbul ignore if */
                                if (err) {
                                    self.taskqueue.fail(err);
                                    callback(err);
                                    return;
                                }
                                prepareForDestruction(self, opts);

                                self.emit('created', self);
                                PouchDB.emit('created', opts.originalName);
                                self.taskqueue.ready(self);
                                callback(null, self);
                            });

                        });
                        promise.then(function (resp) {
                            oldCB(null, resp);
                        }, oldCB);
                        self.then = promise.then.bind(promise);
                        self["catch"] = promise["catch"].bind(promise);
                    }

                    PouchDB.debug = debug;

                    function isChromeApp() {
                        return (typeof chrome !== "undefined" &&
                        typeof chrome.storage !== "undefined" &&
                        typeof chrome.storage.local !== "undefined");
                    }

                    var hasLocal;

                    if (isChromeApp()) {
                        hasLocal = false;
                    } else {
                        try {
                            localStorage.setItem('_pouch_check_localstorage', 1);
                            hasLocal = !!localStorage.getItem('_pouch_check_localstorage');
                        } catch (e) {
                            hasLocal = false;
                        }
                    }

                    function hasLocalStorage() {
                        return hasLocal;
                    }

                    PouchDB.adapters = {};
                    PouchDB.preferredAdapters = [];

                    PouchDB.prefix = '_pouch_';

                    var eventEmitter = new events.EventEmitter();

                    function setUpEventEmitter(Pouch) {
                        Object.keys(events.EventEmitter.prototype).forEach(function (key) {
                            if (typeof events.EventEmitter.prototype[key] === 'function') {
                                Pouch[key] = eventEmitter[key].bind(eventEmitter);
                            }
                        });

                        // these are created in constructor.js, and allow us to notify each DB with
                        // the same name that it was destroyed, via the constructor object
                        var destructListeners = Pouch._destructionListeners = new pouchdbCollections.Map();
                        Pouch.on('destroyed', function onConstructorDestroyed(name) {
                            if (!destructListeners.has(name)) {
                                return;
                            }
                            destructListeners.get(name).forEach(function (callback) {
                                callback();
                            });
                            destructListeners["delete"](name);
                        });
                    }

                    setUpEventEmitter(PouchDB);

                    PouchDB.parseAdapter = function (name, opts) {
                        var match = name.match(/([a-z\-]*):\/\/(.*)/);
                        var adapter, adapterName;
                        if (match) {
                            // the http adapter expects the fully qualified name
                            name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];
                            adapter = match[1];
                            /* istanbul ignore if */
                            if (!PouchDB.adapters[adapter].valid()) {
                                throw 'Invalid adapter';
                            }
                            return { name: name, adapter: match[1] };
                        }

                        // check for browsers that have been upgraded from websql-only to websql+idb
                        var skipIdb = 'idb' in PouchDB.adapters && 'websql' in PouchDB.adapters &&
                            hasLocalStorage() &&
                            localStorage['_pouch__websqldb_' + PouchDB.prefix + name];


                        if (opts.adapter) {
                            adapterName = opts.adapter;
                        } else if (typeof opts !== 'undefined' && opts.db) {
                            adapterName = 'leveldb';
                        } else { // automatically determine adapter
                            for (var i = 0; i < PouchDB.preferredAdapters.length; ++i) {
                                adapterName = PouchDB.preferredAdapters[i];
                                if (adapterName in PouchDB.adapters) {
                                    /* istanbul ignore if */
                                    if (skipIdb && adapterName === 'idb') {
                                        // log it, because this can be confusing during development
                                        console.log('PouchDB is downgrading "' + name + '" to WebSQL to' +
                                            ' avoid data loss, because it was already opened with WebSQL.');
                                        continue; // keep using websql to avoid user data loss
                                    }
                                    break;
                                }
                            }
                        }

                        adapter = PouchDB.adapters[adapterName];

                        // if adapter is invalid, then an error will be thrown later
                        var usePrefix = (adapter && 'use_prefix' in adapter) ?
                            adapter.use_prefix : true;

                        return {
                            name: usePrefix ? (PouchDB.prefix + name) : name,
                            adapter: adapterName
                        };
                    };

                    PouchDB.adapter = function (id, obj, addToPreferredAdapters) {
                        if (obj.valid()) {
                            PouchDB.adapters[id] = obj;
                            if (addToPreferredAdapters) {
                                PouchDB.preferredAdapters.push(id);
                            }
                        }
                    };

                    PouchDB.plugin = function (obj) {
                        Object.keys(obj).forEach(function (id) {
                            PouchDB.prototype[id] = obj[id];
                        });

                        return PouchDB;
                    };

                    PouchDB.defaults = function (defaultOpts) {
                        function PouchAlt(name, opts, callback) {
                            if (!(this instanceof PouchAlt)) {
                                return new PouchAlt(name, opts, callback);
                            }

                            if (typeof opts === 'function' || typeof opts === 'undefined') {
                                callback = opts;
                                opts = {};
                            }
                            if (name && typeof name === 'object') {
                                opts = name;
                                name = undefined;
                            }

                            opts = jsExtend.extend({}, defaultOpts, opts);
                            PouchDB.call(this, name, opts, callback);
                        }

                        inherits(PouchAlt, PouchDB);

                        setUpEventEmitter(PouchAlt);

                        PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();
                        Object.keys(PouchDB).forEach(function (key) {
                            if (!(key in PouchAlt)) {
                                PouchAlt[key] = PouchDB[key];
                            }
                        });

                        return PouchAlt;
                    };

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor (e.g.
// old QtWebKit versions, Android < 4.4).
                    function createBlob(parts, properties) {
                        /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
                        parts = parts || [];
                        properties = properties || {};
                        try {
                            return new Blob(parts, properties);
                        } catch (e) {
                            if (e.name !== "TypeError") {
                                throw e;
                            }
                            var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
                                typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
                                    typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :
                                        WebKitBlobBuilder;
                            var builder = new Builder();
                            for (var i = 0; i < parts.length; i += 1) {
                                builder.append(parts[i]);
                            }
                            return builder.getBlob(properties.type);
                        }
                    }

// simplified API. universal browser support is assumed
                    function readAsArrayBuffer(blob, callback) {
                        if (typeof FileReader === 'undefined') {
                            // fix for Firefox in a web worker:
                            // https://bugzilla.mozilla.org/show_bug.cgi?id=901097
                            return callback(new FileReaderSync().readAsArrayBuffer(blob));
                        }

                        var reader = new FileReader();
                        reader.onloadend = function (e) {
                            var result = e.target.result || new ArrayBuffer(0);
                            callback(result);
                        };
                        reader.readAsArrayBuffer(blob);
                    }

                    function wrappedFetch() {
                        var wrappedPromise = {};

                        var promise = new PouchPromise(function (resolve, reject) {
                            wrappedPromise.resolve = resolve;
                            wrappedPromise.reject = reject;
                        });

                        var args = new Array(arguments.length);

                        for (var i = 0; i < args.length; i++) {
                            args[i] = arguments[i];
                        }

                        wrappedPromise.promise = promise;

                        PouchPromise.resolve().then(function () {
                            return fetch.apply(null, args);
                        }).then(function (response) {
                            wrappedPromise.resolve(response);
                        })["catch"](function (error) {
                            wrappedPromise.reject(error);
                        });

                        return wrappedPromise;
                    }

                    function fetchRequest(options, callback) {
                        var wrappedPromise, timer, response;

                        var headers = new Headers();

                        var fetchOptions = {
                            method: options.method,
                            credentials: 'include',
                            headers: headers
                        };

                        if (options.json) {
                            headers.set('Accept', 'application/json');
                            headers.set('Content-Type', options.headers['Content-Type'] ||
                                'application/json');
                        }

                        if (options.body && (options.body instanceof Blob)) {
                            readAsArrayBuffer(options.body, function (arrayBuffer) {
                                fetchOptions.body = arrayBuffer;
                            });
                        } else if (options.body &&
                            options.processData &&
                            typeof options.body !== 'string') {
                            fetchOptions.body = JSON.stringify(options.body);
                        } else if ('body' in options) {
                            fetchOptions.body = options.body;
                        } else {
                            fetchOptions.body = null;
                        }

                        Object.keys(options.headers).forEach(function (key) {
                            if (options.headers.hasOwnProperty(key)) {
                                headers.set(key, options.headers[key]);
                            }
                        });

                        wrappedPromise = wrappedFetch(options.url, fetchOptions);

                        if (options.timeout > 0) {
                            timer = setTimeout(function () {
                                wrappedPromise.reject(new Error('Load timeout for resource: ' +
                                    options.url));
                            }, options.timeout);
                        }

                        wrappedPromise.promise.then(function (fetchResponse) {
                            response = {
                                statusCode: fetchResponse.status
                            };

                            if (options.timeout > 0) {
                                clearTimeout(timer);
                            }

                            if (response.statusCode >= 200 && response.statusCode < 300) {
                                return options.binary ? fetchResponse.blob() : fetchResponse.text();
                            }

                            return fetchResponse.json();
                        }).then(function (result) {
                            if (response.statusCode >= 200 && response.statusCode < 300) {
                                callback(null, response, result);
                            } else {
                                callback(result, response);
                            }
                        })["catch"](function (error) {
                            callback(error, response);
                        });

                        return { abort: wrappedPromise.reject };
                    }

                    function xhRequest(options, callback) {

                        var xhr, timer;

                        var abortReq = function () {
                            xhr.abort();
                        };

                        if (options.xhr) {
                            xhr = new options.xhr();
                        } else {
                            xhr = new XMLHttpRequest();
                        }

                        try {
                            xhr.open(options.method, options.url);
                        } catch (exception) {
                            /* error code hardcoded to throw INVALID_URL */
                            callback(exception, { statusCode: 413 });
                        }

                        xhr.withCredentials = ('withCredentials' in options) ?
                            options.withCredentials : true;

                        if (options.method === 'GET') {
                            delete options.headers['Content-Type'];
                        } else if (options.json) {
                            options.headers.Accept = 'application/json';
                            options.headers['Content-Type'] = options.headers['Content-Type'] ||
                                'application/json';
                            if (options.body &&
                                options.processData &&
                                typeof options.body !== "string") {
                                options.body = JSON.stringify(options.body);
                            }
                        }

                        if (options.binary) {
                            xhr.responseType = 'arraybuffer';
                        }

                        if (!('body' in options)) {
                            options.body = null;
                        }

                        for (var key in options.headers) {
                            if (options.headers.hasOwnProperty(key)) {
                                xhr.setRequestHeader(key, options.headers[key]);
                            }
                        }

                        if (options.timeout > 0) {
                            timer = setTimeout(abortReq, options.timeout);
                            xhr.onprogress = function () {
                                clearTimeout(timer);
                                timer = setTimeout(abortReq, options.timeout);
                            };
                            if (typeof xhr.upload !== 'undefined') { // does not exist in ie9
                                xhr.upload.onprogress = xhr.onprogress;
                            }
                        }

                        xhr.onreadystatechange = function () {
                            if (xhr.readyState !== 4) {
                                return;
                            }

                            var response = {
                                statusCode: xhr.status
                            };

                            if (xhr.status >= 200 && xhr.status < 300) {
                                var data;
                                if (options.binary) {
                                    data = createBlob([xhr.response || ''], {
                                        type: xhr.getResponseHeader('Content-Type')
                                    });
                                } else {
                                    data = xhr.responseText;
                                }
                                callback(null, response, data);
                            } else {
                                var err = {};
                                try {
                                    err = JSON.parse(xhr.response);
                                } catch (e) {
                                }
                                callback(err, response);
                            }
                        };

                        if (options.body && (options.body instanceof Blob)) {
                            readAsArrayBuffer(options.body, function (arrayBuffer) {
                                xhr.send(arrayBuffer);
                            });
                        } else {
                            xhr.send(options.body);
                        }

                        return { abort: abortReq };
                    }

                    function testXhr() {
                        try {
                            new XMLHttpRequest();
                            return true;
                        } catch (err) {
                            return false;
                        }
                    }

                    var hasXhr = testXhr();

                    function ajax$1(options, callback) {
                        if (hasXhr || options.xhr) {
                            return xhRequest(options, callback);
                        } else {
                            return fetchRequest(options, callback);
                        }
                    }

// the blob already has a type; do nothing
                    var res = function () {
                    };

                    function defaultBody() {
                        return '';
                    }

                    function ajaxCore(options, callback) {

                        options = clone(options);

                        var defaultOptions = {
                            method: "GET",
                            headers: {},
                            json: true,
                            processData: true,
                            timeout: 10000,
                            cache: false
                        };

                        options = jsExtend.extend(defaultOptions, options);

                        function onSuccess(obj, resp, cb) {
                            if (!options.binary && options.json && typeof obj === 'string') {
                                try {
                                    obj = JSON.parse(obj);
                                } catch (e) {
                                    // Probably a malformed JSON from server
                                    return cb(e);
                                }
                            }
                            if (Array.isArray(obj)) {
                                obj = obj.map(function (v) {
                                    if (v.error || v.missing) {
                                        return generateErrorFromResponse(v);
                                    } else {
                                        return v;
                                    }
                                });
                            }
                            if (options.binary) {
                                res(obj, resp);
                            }
                            cb(null, obj, resp);
                        }

                        function onError(err, cb) {
                            var errParsed, errObj;
                            if (err.code && err.status) {
                                var err2 = new Error(err.message || err.code);
                                err2.status = err.status;
                                return cb(err2);
                            }
                            // We always get code && status in node
                            /* istanbul ignore next */
                            try {
                                errParsed = JSON.parse(err.responseText);
                                //would prefer not to have a try/catch clause
                                errObj = generateErrorFromResponse(errParsed);
                            } catch (e) {
                                errObj = generateErrorFromResponse(err);
                            }
                            /* istanbul ignore next */
                            cb(errObj);
                        }


                        if (options.json) {
                            if (!options.binary) {
                                options.headers.Accept = 'application/json';
                            }
                            options.headers['Content-Type'] = options.headers['Content-Type'] ||
                                'application/json';
                        }

                        if (options.binary) {
                            options.encoding = null;
                            options.json = false;
                        }

                        if (!options.processData) {
                            options.json = false;
                        }

                        return ajax$1(options, function (err, response, body) {
                            if (err) {
                                err.status = response ? response.statusCode : 400;
                                return onError(err, callback);
                            }

                            var error;
                            var content_type = response.headers && response.headers['content-type'];
                            var data = body || defaultBody();

                            // CouchDB doesn't always return the right content-type for JSON data, so
                            // we check for ^{ and }$ (ignoring leading/trailing whitespace)
                            if (!options.binary && (options.json || !options.processData) &&
                                typeof data !== 'object' &&
                                (/json/.test(content_type) ||
                                (/^[\s]*\{/.test(data) && /\}[\s]*$/.test(data)))) {
                                try {
                                    data = JSON.parse(data.toString());
                                } catch (e) {
                                }
                            }

                            if (response.statusCode >= 200 && response.statusCode < 300) {
                                onSuccess(data, response, callback);
                            } else {
                                error = generateErrorFromResponse(data);
                                error.status = response.statusCode;
                                callback(error);
                            }
                        });
                    }

                    function ajax(opts, callback) {

                        // cache-buster, specifically designed to work around IE's aggressive caching
                        // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/
                        // Also Safari caches POSTs, so we need to cache-bust those too.
                        var ua = (navigator && navigator.userAgent) ?
                            navigator.userAgent.toLowerCase() : '';

                        var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;
                        var isIE = ua.indexOf('msie') !== -1;
                        var isEdge = ua.indexOf('edge') !== -1;

                        var shouldCacheBust = (isSafari && opts.method === 'POST') ||
                            ((isIE || isEdge) && opts.method === 'GET');

                        var cache = 'cache' in opts ? opts.cache : true;

                        if (shouldCacheBust || !cache) {
                            var hasArgs = opts.url.indexOf('?') !== -1;
                            opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();
                        }

                        return ajaxCore(opts, callback);
                    }

// originally parseUri 1.2.2, now patched by us
// (c) Steven Levithan <stevenlevithan.com>
// MIT License
                    var keys = [
                        "source", "protocol", "authority", "userInfo", "user", "password",
                        "host", "port", "relative", "path", "directory", "file", "query", "anchor"
                    ];
                    var qName = "queryKey";
                    var qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;

// use the "loose" parser
                    /* jshint maxlen: false */
                    var parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

                    function parseUri(str) {
                        var m = parser.exec(str);
                        var uri = {};
                        var i = 14;

                        while (i--) {
                            var key = keys[i];
                            var value = m[i] || "";
                            var encoded = ['user', 'password'].indexOf(key) !== -1;
                            uri[key] = encoded ? decodeURIComponent(value) : value;
                        }

                        uri[qName] = {};
                        uri[keys[12]].replace(qParser, function ($0, $1, $2) {
                            if ($1) {
                                uri[qName][$1] = $2;
                            }
                        });

                        return uri;
                    }

                    var atob$1 = function (str) {
                        return atob(str);
                    };

                    var btoa$1 = function (str) {
                        return btoa(str);
                    };

// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
                    function binaryStringToArrayBuffer(bin) {
                        var length = bin.length;
                        var buf = new ArrayBuffer(length);
                        var arr = new Uint8Array(buf);
                        for (var i = 0; i < length; i++) {
                            arr[i] = bin.charCodeAt(i);
                        }
                        return buf;
                    }

                    function binStringToBluffer(binString, type) {
                        return createBlob([binaryStringToArrayBuffer(binString)], { type: type });
                    }

                    var extend$1 = jsExtend__default.extend;

                    var utils = {
                        ajax: ajax,
                        parseUri: parseUri,
                        uuid: uuid,
                        Promise: PouchPromise,
                        atob: atob$1,
                        btoa: btoa$1,
                        binaryStringToBlobOrBuffer: binStringToBluffer,
                        clone: clone,
                        extend: extend$1,
                        createError: createError
                    };

                    function tryFilter(filter, doc, req) {
                        try {
                            return !filter(doc, req);
                        } catch (err) {
                            var msg = 'Filter function threw: ' + err.toString();
                            return createError(BAD_REQUEST, msg);
                        }
                    }

                    function filterChange(opts) {
                        var req = {};
                        var hasFilter = opts.filter && typeof opts.filter === 'function';
                        req.query = opts.query_params;

                        return function filter(change) {
                            if (!change.doc) {
                                // CSG sends events on the changes feed that don't have documents,
                                // this hack makes a whole lot of existing code robust.
                                change.doc = {};
                            }

                            var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);

                            if (typeof filterReturn === 'object') {
                                return filterReturn;
                            }

                            if (filterReturn) {
                                return false;
                            }

                            if (!opts.include_docs) {
                                delete change.doc;
                            } else if (!opts.attachments) {
                                for (var att in change.doc._attachments) {
                                    /* istanbul ignore else */
                                    if (change.doc._attachments.hasOwnProperty(att)) {
                                        change.doc._attachments[att].stub = true;
                                    }
                                }
                            }
                            return true;
                        };
                    }

// designed to give info to browser users, who are disturbed
// when they see http errors in the console
                    function explainError(status, str) {
                        if ('console' in global && 'info' in console) {
                            console.info('The above ' + status + ' is totally normal. ' + str);
                        }
                    }

                    var collate$1 = pouchCollate__default.collate;

                    var CHECKPOINT_VERSION = 1;
                    var REPLICATOR = "pouchdb";
// This is an arbitrary number to limit the
// amount of replication history we save in the checkpoint.
// If we save too much, the checkpoing docs will become very big,
// if we save fewer, we'll run a greater risk of having to
// read all the changes from 0 when checkpoint PUTs fail
// CouchDB 2.0 has a more involved history pruning,
// but let's go for the simple version for now.
                    var CHECKPOINT_HISTORY_SIZE = 5;
                    var LOWEST_SEQ = 0;

                    function updateCheckpoint(db, id, checkpoint, session, returnValue) {
                        return db.get(id)["catch"](function (err) {
                            if (err.status === 404) {
                                if (db.type() === 'http') {
                                    explainError(
                                        404, 'PouchDB is just checking if a remote checkpoint exists.'
                                    );
                                }
                                return {
                                    session_id: session,
                                    _id: id,
                                    history: [],
                                    replicator: REPLICATOR,
                                    version: CHECKPOINT_VERSION
                                };
                            }
                            throw err;
                        }).then(function (doc) {
                            if (returnValue.cancelled) {
                                return;
                            }
                            // Filter out current entry for this replication
                            doc.history = (doc.history || []).filter(function (item) {
                                return item.session_id !== session;
                            });

                            // Add the latest checkpoint to history
                            doc.history.unshift({
                                last_seq: checkpoint,
                                session_id: session
                            });

                            // Just take the last pieces in history, to
                            // avoid really big checkpoint docs.
                            // see comment on history size above
                            doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);

                            doc.version = CHECKPOINT_VERSION;
                            doc.replicator = REPLICATOR;

                            doc.session_id = session;
                            doc.last_seq = checkpoint;

                            return db.put(doc)["catch"](function (err) {
                                if (err.status === 409) {
                                    // retry; someone is trying to write a checkpoint simultaneously
                                    return updateCheckpoint(db, id, checkpoint, session, returnValue);
                                }
                                throw err;
                            });
                        });
                    }

                    function Checkpointer(src, target, id, returnValue) {
                        this.src = src;
                        this.target = target;
                        this.id = id;
                        this.returnValue = returnValue;
                    }

                    Checkpointer.prototype.writeCheckpoint = function (checkpoint, session) {
                        var self = this;
                        return this.updateTarget(checkpoint, session).then(function () {
                            return self.updateSource(checkpoint, session);
                        });
                    };

                    Checkpointer.prototype.updateTarget = function (checkpoint, session) {
                        return updateCheckpoint(this.target, this.id, checkpoint,
                            session, this.returnValue);
                    };

                    Checkpointer.prototype.updateSource = function (checkpoint, session) {
                        var self = this;
                        if (this.readOnlySource) {
                            return PouchPromise.resolve(true);
                        }
                        return updateCheckpoint(this.src, this.id, checkpoint,
                            session, this.returnValue)[
                            "catch"](function (err) {
                            if (isForbiddenError(err)) {
                                self.readOnlySource = true;
                                return true;
                            }
                            throw err;
                        });
                    };

                    var comparisons = {
                        "undefined": function (targetDoc, sourceDoc) {
                            // This is the previous comparison function
                            if (collate$1(targetDoc.last_seq, sourceDoc.last_seq) === 0) {
                                return sourceDoc.last_seq;
                            }
                            /* istanbul ignore next */
                            return 0;
                        },
                        "1": function (targetDoc, sourceDoc) {
                            // This is the comparison function ported from CouchDB
                            return compareReplicationLogs(sourceDoc, targetDoc).last_seq;
                        }
                    };

                    Checkpointer.prototype.getCheckpoint = function () {
                        var self = this;
                        return self.target.get(self.id).then(function (targetDoc) {
                            if (self.readOnlySource) {
                                return PouchPromise.resolve(targetDoc.last_seq);
                            }

                            return self.src.get(self.id).then(function (sourceDoc) {
                                // Since we can't migrate an old version doc to a new one
                                // (no session id), we just go with the lowest seq in this case
                                /* istanbul ignore if */
                                if (targetDoc.version !== sourceDoc.version) {
                                    return LOWEST_SEQ;
                                }

                                var version;
                                if (targetDoc.version) {
                                    version = targetDoc.version.toString();
                                } else {
                                    version = "undefined";
                                }

                                if (version in comparisons) {
                                    return comparisons[version](targetDoc, sourceDoc);
                                }
                                /* istanbul ignore next */
                                return LOWEST_SEQ;
                            }, function (err) {
                                if (err.status === 404 && targetDoc.last_seq) {
                                    return self.src.put({
                                        _id: self.id,
                                        last_seq: LOWEST_SEQ
                                    }).then(function () {
                                        return LOWEST_SEQ;
                                    }, function (err) {
                                        if (isForbiddenError(err)) {
                                            self.readOnlySource = true;
                                            return targetDoc.last_seq;
                                        }
                                        /* istanbul ignore next */
                                        return LOWEST_SEQ;
                                    });
                                }
                                throw err;
                            });
                        })["catch"](function (err) {
                            if (err.status !== 404) {
                                throw err;
                            }
                            return LOWEST_SEQ;
                        });
                    };
// This checkpoint comparison is ported from CouchDBs source
// they come from here:
// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906

                    function compareReplicationLogs(srcDoc, tgtDoc) {
                        if (srcDoc.session_id === tgtDoc.session_id) {
                            return {
                                last_seq: srcDoc.last_seq,
                                history: srcDoc.history || []
                            };
                        }

                        var sourceHistory = srcDoc.history || [];
                        var targetHistory = tgtDoc.history || [];
                        return compareReplicationHistory(sourceHistory, targetHistory);
                    }

                    function compareReplicationHistory(sourceHistory, targetHistory) {
                        // the erlang loop via function arguments is not so easy to repeat in JS
                        // therefore, doing this as recursion
                        var S = sourceHistory[0];
                        var sourceRest = sourceHistory.slice(1);
                        var T = targetHistory[0];
                        var targetRest = targetHistory.slice(1);

                        if (!S || targetHistory.length === 0) {
                            return {
                                last_seq: LOWEST_SEQ,
                                history: []
                            };
                        }

                        var sourceId = S.session_id;
                        /* istanbul ignore if */
                        if (hasSessionId(sourceId, targetHistory)) {
                            return {
                                last_seq: S.last_seq,
                                history: sourceHistory
                            };
                        }

                        var targetId = T.session_id;
                        if (hasSessionId(targetId, sourceRest)) {
                            return {
                                last_seq: T.last_seq,
                                history: targetRest
                            };
                        }

                        return compareReplicationHistory(sourceRest, targetRest);
                    }

                    function hasSessionId(sessionId, history) {
                        var props = history[0];
                        var rest = history.slice(1);

                        if (!sessionId || history.length === 0) {
                            return false;
                        }

                        if (sessionId === props.session_id) {
                            return true;
                        }

                        return hasSessionId(sessionId, rest);
                    }

                    function isForbiddenError(err) {
                        return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;
                    }

                    var STARTING_BACK_OFF = 0;

                    function randomNumber(min, max) {
                        min = parseInt(min, 10) || 0;
                        max = parseInt(max, 10);
                        if (max !== max || max <= min) {
                            max = (min || 1) << 1; //doubling
                        } else {
                            max = max + 1;
                        }
                        var ratio = Math.random();
                        var range = max - min;

                        return ~~(range * ratio + min); // ~~ coerces to an int, but fast.
                    }

                    function defaultBackOff(min) {
                        var max = 0;
                        if (!min) {
                            max = 2000;
                        }
                        return randomNumber(min, max);
                    }

                    function backOff(opts, returnValue, error, callback) {
                        if (opts.retry === false) {
                            returnValue.emit('error', error);
                            returnValue.removeAllListeners();
                            return;
                        }
                        if (typeof opts.back_off_function !== 'function') {
                            opts.back_off_function = defaultBackOff;
                        }
                        returnValue.emit('requestError', error);
                        if (returnValue.state === 'active' || returnValue.state === 'pending') {
                            returnValue.emit('paused', error);
                            returnValue.state = 'stopped';
                            returnValue.once('active', function () {
                                opts.current_back_off = STARTING_BACK_OFF;
                            });
                        }

                        opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;
                        opts.current_back_off = opts.back_off_function(opts.current_back_off);
                        setTimeout(callback, opts.current_back_off);
                    }

                    var setImmediateShim = global.setImmediate || global.setTimeout;
                    var MD5_CHUNK_SIZE = 32768;

                    function rawToBase64(raw) {
                        return btoa$1(raw);
                    }

                    function appendBuffer(buffer, data, start, end) {
                        if (start > 0 || end < data.byteLength) {
                            // only create a subarray if we really need to
                            data = new Uint8Array(data, start,
                                Math.min(end, data.byteLength) - start);
                        }
                        buffer.append(data);
                    }

                    function appendString(buffer, data, start, end) {
                        if (start > 0 || end < data.length) {
                            // only create a substring if we really need to
                            data = data.substring(start, end);
                        }
                        buffer.appendBinary(data);
                    }

                    var md5 = toPromise(function (data, callback) {
                        var inputIsString = typeof data === 'string';
                        var len = inputIsString ? data.length : data.byteLength;
                        var chunkSize = Math.min(MD5_CHUNK_SIZE, len);
                        var chunks = Math.ceil(len / chunkSize);
                        var currentChunk = 0;
                        var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();

                        var append = inputIsString ? appendString : appendBuffer;

                        function loadNextChunk() {
                            var start = currentChunk * chunkSize;
                            var end = start + chunkSize;
                            currentChunk++;
                            if (currentChunk < chunks) {
                                append(buffer, data, start, end);
                                setImmediateShim(loadNextChunk);
                            } else {
                                append(buffer, data, start, end);
                                var raw = buffer.end(true);
                                var base64 = rawToBase64(raw);
                                callback(null, base64);
                                buffer.destroy();
                            }
                        }

                        loadNextChunk();
                    });

                    function sortObjectPropertiesByKey(queryParams) {
                        return Object.keys(queryParams).sort(pouchCollate.collate).reduce(function (result, key) {
                            result[key] = queryParams[key];
                            return result;
                        }, {});
                    }

// Generate a unique id particular to this replication.
// Not guaranteed to align perfectly with CouchDB's rep ids.
                    function generateReplicationId(src, target, opts) {
                        var docIds = opts.doc_ids ? opts.doc_ids.sort(pouchCollate.collate) : '';
                        var filterFun = opts.filter ? opts.filter.toString() : '';
                        var queryParams = '';
                        var filterViewName = '';

                        if (opts.filter && opts.query_params) {
                            queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));
                        }

                        if (opts.filter && opts.filter === '_view') {
                            filterViewName = opts.view.toString();
                        }

                        return PouchPromise.all([src.id(), target.id()]).then(function (res) {
                            var queryData = res[0] + res[1] + filterFun + filterViewName +
                                queryParams + docIds;
                            return md5(queryData);
                        }).then(function (md5sum) {
                            // can't use straight-up md5 alphabet, because
                            // the char '/' is interpreted as being for attachments,
                            // and + is also not url-safe
                            md5sum = md5sum.replace(/\//g, '.').replace(/\+/g, '_');
                            return '_local/' + md5sum;
                        });
                    }

                    function isGenOne(rev) {
                        return /^1-/.test(rev);
                    }

                    function createBulkGetOpts(diffs) {
                        var requests = [];
                        Object.keys(diffs).forEach(function (id) {
                            var missingRevs = diffs[id].missing;
                            missingRevs.forEach(function (missingRev) {
                                requests.push({
                                    id: id,
                                    rev: missingRev
                                });
                            });
                        });

                        return {
                            docs: requests,
                            revs: true,
                            attachments: true,
                            binary: true
                        };
                    }

//
// Fetch all the documents from the src as described in the "diffs",
// which is a mapping of docs IDs to revisions. If the state ever
// changes to "cancelled", then the returned promise will be rejected.
// Else it will be resolved with a list of fetched documents.
//
                    function getDocs(src, diffs, state) {
                        diffs = clone(diffs); // we do not need to modify this

                        var resultDocs = [];

                        function getAllDocs() {

                            var bulkGetOpts = createBulkGetOpts(diffs);

                            if (!bulkGetOpts.docs.length) { // optimization: skip empty requests
                                return;
                            }

                            return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {
                                /* istanbul ignore if */
                                if (state.cancelled) {
                                    throw new Error('cancelled');
                                }
                                bulkGetResponse.results.forEach(function (bulkGetInfo) {
                                    bulkGetInfo.docs.forEach(function (doc) {
                                        if (doc.ok) {
                                            resultDocs.push(doc.ok);
                                        }
                                    });
                                });
                            });
                        }

                        function hasAttachments(doc) {
                            return doc._attachments && Object.keys(doc._attachments).length > 0;
                        }

                        function fetchRevisionOneDocs(ids) {
                            // Optimization: fetch gen-1 docs and attachments in
                            // a single request using _all_docs
                            return src.allDocs({
                                keys: ids,
                                include_docs: true
                            }).then(function (res) {
                                if (state.cancelled) {
                                    throw new Error('cancelled');
                                }
                                res.rows.forEach(function (row) {
                                    if (row.deleted || !row.doc || !isGenOne(row.value.rev) ||
                                        hasAttachments(row.doc)) {
                                        // if any of these conditions apply, we need to fetch using get()
                                        return;
                                    }

                                    // the doc we got back from allDocs() is sufficient
                                    resultDocs.push(row.doc);
                                    delete diffs[row.id];
                                });
                            });
                        }

                        function getRevisionOneDocs() {
                            // filter out the generation 1 docs and get them
                            // leaving the non-generation one docs to be got otherwise
                            var ids = Object.keys(diffs).filter(function (id) {
                                var missing = diffs[id].missing;
                                return missing.length === 1 && isGenOne(missing[0]);
                            });
                            if (ids.length > 0) {
                                return fetchRevisionOneDocs(ids);
                            }
                        }

                        function returnDocs() {
                            return resultDocs;
                        }

                        return PouchPromise.resolve()
                            .then(getRevisionOneDocs)
                            .then(getAllDocs)
                            .then(returnDocs);
                    }

                    function replicate(src, target, opts, returnValue, result) {
                        var batches = [];               // list of batches to be processed
                        var currentBatch;               // the batch currently being processed
                        var pendingBatch = {
                            seq: 0,
                            changes: [],
                            docs: []
                        }; // next batch, not yet ready to be processed
                        var writingCheckpoint = false;  // true while checkpoint is being written
                        var changesCompleted = false;   // true when all changes received
                        var replicationCompleted = false; // true when replication has completed
                        var last_seq = 0;
                        var continuous = opts.continuous || opts.live || false;
                        var batch_size = opts.batch_size || 100;
                        var batches_limit = opts.batches_limit || 10;
                        var changesPending = false;     // true while src.changes is running
                        var doc_ids = opts.doc_ids;
                        var repId;
                        var checkpointer;
                        var allErrors = [];
                        var changedDocs = [];
                        // Like couchdb, every replication gets a unique session id
                        var session = uuid();

                        result = result || {
                                ok: true,
                                start_time: new Date(),
                                docs_read: 0,
                                docs_written: 0,
                                doc_write_failures: 0,
                                errors: []
                            };

                        var changesOpts = {};
                        returnValue.ready(src, target);

                        function initCheckpointer() {
                            if (checkpointer) {
                                return PouchPromise.resolve();
                            }
                            return generateReplicationId(src, target, opts).then(function (res) {
                                repId = res;
                                checkpointer = new Checkpointer(src, target, repId, returnValue);
                            });
                        }

                        function writeDocs() {
                            changedDocs = [];

                            if (currentBatch.docs.length === 0) {
                                return;
                            }
                            var docs = currentBatch.docs;
                            return target.bulkDocs({ docs: docs, new_edits: false }).then(function (res) {
                                if (returnValue.cancelled) {
                                    completeReplication();
                                    throw new Error('cancelled');
                                }
                                var errors = [];
                                var errorsById = {};
                                res.forEach(function (res) {
                                    if (res.error) {
                                        result.doc_write_failures++;
                                        errors.push(res);
                                        errorsById[res.id] = res;
                                    }
                                });
                                allErrors = allErrors.concat(errors);
                                result.docs_written += currentBatch.docs.length - errors.length;
                                var non403s = errors.filter(function (error) {
                                    return error.name !== 'unauthorized' && error.name !== 'forbidden';
                                });

                                docs.forEach(function (doc) {
                                    var error = errorsById[doc._id];
                                    if (error) {
                                        returnValue.emit('denied', clone(error));
                                    } else {
                                        changedDocs.push(doc);
                                    }
                                });

                                if (non403s.length > 0) {
                                    var error = new Error('bulkDocs error');
                                    error.other_errors = errors;
                                    abortReplication('target.bulkDocs failed to write docs', error);
                                    throw new Error('bulkWrite partial failure');
                                }
                            }, function (err) {
                                result.doc_write_failures += docs.length;
                                throw err;
                            });
                        }

                        function finishBatch() {
                            result.last_seq = last_seq = currentBatch.seq;
                            var outResult = clone(result);
                            if (changedDocs.length) {
                                outResult.docs = changedDocs;
                                returnValue.emit('change', outResult);
                            }
                            writingCheckpoint = true;
                            return checkpointer.writeCheckpoint(currentBatch.seq,
                                session).then(function () {
                                writingCheckpoint = false;
                                if (returnValue.cancelled) {
                                    completeReplication();
                                    throw new Error('cancelled');
                                }
                                currentBatch = undefined;
                                getChanges();
                            })["catch"](function (err) {
                                writingCheckpoint = false;
                                abortReplication('writeCheckpoint completed with error', err);
                                throw err;
                            });
                        }

                        function getDiffs() {
                            var diff = {};
                            currentBatch.changes.forEach(function (change) {
                                // Couchbase Sync Gateway emits these, but we can ignore them
                                /* istanbul ignore if */
                                if (change.id === "_user/") {
                                    return;
                                }
                                diff[change.id] = change.changes.map(function (x) {
                                    return x.rev;
                                });
                            });
                            return target.revsDiff(diff).then(function (diffs) {
                                if (returnValue.cancelled) {
                                    completeReplication();
                                    throw new Error('cancelled');
                                }
                                // currentBatch.diffs elements are deleted as the documents are written
                                currentBatch.diffs = diffs;
                            });
                        }

                        function getBatchDocs() {
                            return getDocs(src, currentBatch.diffs, returnValue).then(function (docs) {
                                docs.forEach(function (doc) {
                                    delete currentBatch.diffs[doc._id];
                                    result.docs_read++;
                                    currentBatch.docs.push(doc);
                                });
                            });
                        }

                        function startNextBatch() {
                            if (returnValue.cancelled || currentBatch) {
                                return;
                            }
                            if (batches.length === 0) {
                                processPendingBatch(true);
                                return;
                            }
                            currentBatch = batches.shift();
                            getDiffs()
                                .then(getBatchDocs)
                                .then(writeDocs)
                                .then(finishBatch)
                                .then(startNextBatch)[
                                "catch"](function (err) {
                                abortReplication('batch processing terminated with error', err);
                            });
                        }


                        function processPendingBatch(immediate) {
                            if (pendingBatch.changes.length === 0) {
                                if (batches.length === 0 && !currentBatch) {
                                    if ((continuous && changesOpts.live) || changesCompleted) {
                                        returnValue.state = 'pending';
                                        returnValue.emit('paused');
                                    }
                                    if (changesCompleted) {
                                        completeReplication();
                                    }
                                }
                                return;
                            }
                            if (
                                immediate ||
                                changesCompleted ||
                                pendingBatch.changes.length >= batch_size
                            ) {
                                batches.push(pendingBatch);
                                pendingBatch = {
                                    seq: 0,
                                    changes: [],
                                    docs: []
                                };
                                if (returnValue.state === 'pending' || returnValue.state === 'stopped') {
                                    returnValue.state = 'active';
                                    returnValue.emit('active');
                                }
                                startNextBatch();
                            }
                        }


                        function abortReplication(reason, err) {
                            if (replicationCompleted) {
                                return;
                            }
                            if (!err.message) {
                                err.message = reason;
                            }
                            result.ok = false;
                            result.status = 'aborting';
                            result.errors.push(err);
                            allErrors = allErrors.concat(err);
                            batches = [];
                            pendingBatch = {
                                seq: 0,
                                changes: [],
                                docs: []
                            };
                            completeReplication();
                        }


                        function completeReplication() {
                            if (replicationCompleted) {
                                return;
                            }
                            if (returnValue.cancelled) {
                                result.status = 'cancelled';
                                if (writingCheckpoint) {
                                    return;
                                }
                            }
                            result.status = result.status || 'complete';
                            result.end_time = new Date();
                            result.last_seq = last_seq;
                            replicationCompleted = true;
                            var non403s = allErrors.filter(function (error) {
                                return error.name !== 'unauthorized' && error.name !== 'forbidden';
                            });
                            if (non403s.length > 0) {
                                var error = allErrors.pop();
                                if (allErrors.length > 0) {
                                    error.other_errors = allErrors;
                                }
                                error.result = result;
                                backOff(opts, returnValue, error, function () {
                                    replicate(src, target, opts, returnValue);
                                });
                            } else {
                                result.errors = allErrors;
                                returnValue.emit('complete', result);
                                returnValue.removeAllListeners();
                            }
                        }


                        function onChange(change) {
                            if (returnValue.cancelled) {
                                return completeReplication();
                            }
                            var filter = filterChange(opts)(change);
                            if (!filter) {
                                return;
                            }
                            pendingBatch.seq = change.seq;
                            pendingBatch.changes.push(change);
                            processPendingBatch(changesOpts.live);
                        }


                        function onChangesComplete(changes) {
                            changesPending = false;
                            if (returnValue.cancelled) {
                                return completeReplication();
                            }

                            // if no results were returned then we're done,
                            // else fetch more
                            if (changes.results.length > 0) {
                                changesOpts.since = changes.last_seq;
                                getChanges();
                            } else {
                                if (continuous) {
                                    changesOpts.live = true;
                                    getChanges();
                                } else {
                                    changesCompleted = true;
                                }
                            }
                            processPendingBatch(true);
                        }


                        function onChangesError(err) {
                            changesPending = false;
                            /* istanbul ignore if */
                            if (returnValue.cancelled) {
                                return completeReplication();
                            }
                            abortReplication('changes rejected', err);
                        }


                        function getChanges() {
                            if (!(
                                    !changesPending && !changesCompleted &&
                                    batches.length < batches_limit
                                )) {
                                return;
                            }
                            changesPending = true;
                            function abortChanges() {
                                changes.cancel();
                            }

                            function removeListener() {
                                returnValue.removeListener('cancel', abortChanges);
                            }

                            if (returnValue._changes) { // remove old changes() and listeners
                                returnValue.removeListener('cancel', returnValue._abortChanges);
                                returnValue._changes.cancel();
                            }
                            returnValue.once('cancel', abortChanges);

                            var changes = src.changes(changesOpts)
                                .on('change', onChange);
                            changes.then(removeListener, removeListener);
                            changes.then(onChangesComplete)[
                                "catch"](onChangesError);

                            if (opts.retry) {
                                // save for later so we can cancel if necessary
                                returnValue._changes = changes;
                                returnValue._abortChanges = abortChanges;
                            }
                        }


                        function startChanges() {
                            initCheckpointer().then(function () {
                                if (returnValue.cancelled) {
                                    completeReplication();
                                    return;
                                }
                                return checkpointer.getCheckpoint().then(function (checkpoint) {
                                    last_seq = checkpoint;
                                    changesOpts = {
                                        since: last_seq,
                                        limit: batch_size,
                                        batch_size: batch_size,
                                        style: 'all_docs',
                                        doc_ids: doc_ids,
                                        return_docs: true // required so we know when we're done
                                    };
                                    if (opts.filter) {
                                        if (typeof opts.filter !== 'string') {
                                            // required for the client-side filter in onChange
                                            changesOpts.include_docs = true;
                                        } else { // ddoc filter
                                            changesOpts.filter = opts.filter;
                                        }
                                    }
                                    if ('heartbeat' in opts) {
                                        changesOpts.heartbeat = opts.heartbeat;
                                    }
                                    if ('timeout' in opts) {
                                        changesOpts.timeout = opts.timeout;
                                    }
                                    if (opts.query_params) {
                                        changesOpts.query_params = opts.query_params;
                                    }
                                    if (opts.view) {
                                        changesOpts.view = opts.view;
                                    }
                                    getChanges();
                                });
                            })["catch"](function (err) {
                                abortReplication('getCheckpoint rejected with ', err);
                            });
                        }

                        /* istanbul ignore next */
                        function onCheckpointError(err) {
                            writingCheckpoint = false;
                            abortReplication('writeCheckpoint completed with error', err);
                            throw err;
                        }

                        /* istanbul ignore if */
                        if (returnValue.cancelled) { // cancelled immediately
                            completeReplication();
                            return;
                        }

                        if (!returnValue._addedListeners) {
                            returnValue.once('cancel', completeReplication);

                            if (typeof opts.complete === 'function') {
                                returnValue.once('error', opts.complete);
                                returnValue.once('complete', function (result) {
                                    opts.complete(null, result);
                                });
                            }
                            returnValue._addedListeners = true;
                        }

                        if (typeof opts.since === 'undefined') {
                            startChanges();
                        } else {
                            initCheckpointer().then(function () {
                                writingCheckpoint = true;
                                return checkpointer.writeCheckpoint(opts.since, session);
                            }).then(function () {
                                writingCheckpoint = false;
                                /* istanbul ignore if */
                                if (returnValue.cancelled) {
                                    completeReplication();
                                    return;
                                }
                                last_seq = opts.since;
                                startChanges();
                            })["catch"](onCheckpointError);
                        }
                    }

// We create a basic promise so the caller can cancel the replication possibly
// before we have actually started listening to changes etc
                    inherits(Replication, events.EventEmitter);
                    function Replication() {
                        events.EventEmitter.call(this);
                        this.cancelled = false;
                        this.state = 'pending';
                        var self = this;
                        var promise = new PouchPromise(function (fulfill, reject) {
                            self.once('complete', fulfill);
                            self.once('error', reject);
                        });
                        self.then = function (resolve, reject) {
                            return promise.then(resolve, reject);
                        };
                        self["catch"] = function (reject) {
                            return promise["catch"](reject);
                        };
                        // As we allow error handling via "error" event as well,
                        // put a stub in here so that rejecting never throws UnhandledError.
                        self["catch"](function () {
                        });
                    }

                    Replication.prototype.cancel = function () {
                        this.cancelled = true;
                        this.state = 'cancelled';
                        this.emit('cancel');
                    };

                    Replication.prototype.ready = function (src, target) {
                        var self = this;
                        if (self._readyCalled) {
                            return;
                        }
                        self._readyCalled = true;

                        function onDestroy() {
                            self.cancel();
                        }

                        src.once('destroyed', onDestroy);
                        target.once('destroyed', onDestroy);
                        function cleanup() {
                            src.removeListener('destroyed', onDestroy);
                            target.removeListener('destroyed', onDestroy);
                        }

                        self.once('complete', cleanup);
                    };

                    function toPouch(db, opts) {
                        var PouchConstructor = opts.PouchConstructor;
                        if (typeof db === 'string') {
                            return new PouchConstructor(db, opts);
                        } else {
                            return db;
                        }
                    }

                    function replicateWrapper(src, target, opts, callback) {

                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        if (typeof opts === 'undefined') {
                            opts = {};
                        }

                        if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {
                            throw createError(BAD_REQUEST,
                                "`doc_ids` filter parameter is not a list.");
                        }

                        opts.complete = callback;
                        opts = clone(opts);
                        opts.continuous = opts.continuous || opts.live;
                        opts.retry = ('retry' in opts) ? opts.retry : false;
                        /*jshint validthis:true */
                        opts.PouchConstructor = opts.PouchConstructor || this;
                        var replicateRet = new Replication(opts);
                        var srcPouch = toPouch(src, opts);
                        var targetPouch = toPouch(target, opts);
                        replicate(srcPouch, targetPouch, opts, replicateRet);
                        return replicateRet;
                    }

                    var replication = {
                        replicate: replicateWrapper,
                        toPouch: toPouch
                    };

                    var replicate$1 = replication.replicate;
                    inherits(Sync, events.EventEmitter);
                    function sync(src, target, opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        if (typeof opts === 'undefined') {
                            opts = {};
                        }
                        opts = clone(opts);
                        /*jshint validthis:true */
                        opts.PouchConstructor = opts.PouchConstructor || this;
                        src = replication.toPouch(src, opts);
                        target = replication.toPouch(target, opts);
                        return new Sync(src, target, opts, callback);
                    }

                    function Sync(src, target, opts, callback) {
                        var self = this;
                        this.canceled = false;

                        var optsPush = opts.push ? jsExtend.extend({}, opts, opts.push) : opts;
                        var optsPull = opts.pull ? jsExtend.extend({}, opts, opts.pull) : opts;

                        this.push = replicate$1(src, target, optsPush);
                        this.pull = replicate$1(target, src, optsPull);

                        this.pushPaused = true;
                        this.pullPaused = true;

                        function pullChange(change) {
                            self.emit('change', {
                                direction: 'pull',
                                change: change
                            });
                        }

                        function pushChange(change) {
                            self.emit('change', {
                                direction: 'push',
                                change: change
                            });
                        }

                        function pushDenied(doc) {
                            self.emit('denied', {
                                direction: 'push',
                                doc: doc
                            });
                        }

                        function pullDenied(doc) {
                            self.emit('denied', {
                                direction: 'pull',
                                doc: doc
                            });
                        }

                        function pushPaused() {
                            self.pushPaused = true;
                            if (self.pullPaused) {
                                self.emit('paused');
                            }
                        }

                        function pullPaused() {
                            self.pullPaused = true;
                            if (self.pushPaused) {
                                self.emit('paused');
                            }
                        }

                        function pushActive() {
                            self.pushPaused = false;
                            if (self.pullPaused) {
                                self.emit('active', {
                                    direction: 'push'
                                });
                            }
                        }

                        function pullActive() {
                            self.pullPaused = false;
                            /* istanbul ignore if */
                            if (self.pushPaused) {
                                self.emit('active', {
                                    direction: 'pull'
                                });
                            }
                        }

                        var removed = {};

                        function removeAll(type) { // type is 'push' or 'pull'
                            return function (event, func) {
                                var isChange = event === 'change' &&
                                    (func === pullChange || func === pushChange);
                                var isDenied = event === 'denied' &&
                                    (func === pullDenied || func === pushDenied);
                                var isPaused = event === 'paused' &&
                                    (func === pullPaused || func === pushPaused);
                                var isActive = event === 'active' &&
                                    (func === pullActive || func === pushActive);

                                if (isChange || isDenied || isPaused || isActive) {
                                    if (!(event in removed)) {
                                        removed[event] = {};
                                    }
                                    removed[event][type] = true;
                                    if (Object.keys(removed[event]).length === 2) {
                                        // both push and pull have asked to be removed
                                        self.removeAllListeners(event);
                                    }
                                }
                            };
                        }

                        if (opts.live) {
                            this.push.on('complete', self.pull.cancel.bind(self.pull));
                            this.pull.on('complete', self.push.cancel.bind(self.push));
                        }

                        this.on('newListener', function (event) {
                            if (event === 'change') {
                                self.pull.on('change', pullChange);
                                self.push.on('change', pushChange);
                            } else if (event === 'denied') {
                                self.pull.on('denied', pullDenied);
                                self.push.on('denied', pushDenied);
                            } else if (event === 'active') {
                                self.pull.on('active', pullActive);
                                self.push.on('active', pushActive);
                            } else if (event === 'paused') {
                                self.pull.on('paused', pullPaused);
                                self.push.on('paused', pushPaused);
                            }
                        });

                        this.on('removeListener', function (event) {
                            if (event === 'change') {
                                self.pull.removeListener('change', pullChange);
                                self.push.removeListener('change', pushChange);
                            } else if (event === 'denied') {
                                self.pull.removeListener('denied', pullDenied);
                                self.push.removeListener('denied', pushDenied);
                            } else if (event === 'active') {
                                self.pull.removeListener('active', pullActive);
                                self.push.removeListener('active', pushActive);
                            } else if (event === 'paused') {
                                self.pull.removeListener('paused', pullPaused);
                                self.push.removeListener('paused', pushPaused);
                            }
                        });

                        this.pull.on('removeListener', removeAll('pull'));
                        this.push.on('removeListener', removeAll('push'));

                        var promise = PouchPromise.all([
                            this.push,
                            this.pull
                        ]).then(function (resp) {
                            var out = {
                                push: resp[0],
                                pull: resp[1]
                            };
                            self.emit('complete', out);
                            if (callback) {
                                callback(null, out);
                            }
                            self.removeAllListeners();
                            return out;
                        }, function (err) {
                            self.cancel();
                            if (callback) {
                                // if there's a callback, then the callback can receive
                                // the error event
                                callback(err);
                            } else {
                                // if there's no callback, then we're safe to emit an error
                                // event, which would otherwise throw an unhandled error
                                // due to 'error' being a special event in EventEmitters
                                self.emit('error', err);
                            }
                            self.removeAllListeners();
                            if (callback) {
                                // no sense throwing if we're already emitting an 'error' event
                                throw err;
                            }
                        });

                        this.then = function (success, err) {
                            return promise.then(success, err);
                        };

                        this["catch"] = function (err) {
                            return promise["catch"](err);
                        };
                    }

                    Sync.prototype.cancel = function () {
                        if (!this.canceled) {
                            this.canceled = true;
                            this.push.cancel();
                            this.pull.cancel();
                        }
                    };

                    function b64ToBluffer(b64, type) {
                        return binStringToBluffer(atob$1(b64), type);
                    }

//Can't find original post, but this is close
//http://stackoverflow.com/questions/6965107/ (continues on next line)
//converting-between-strings-and-arraybuffers
                    function arrayBufferToBinaryString(buffer) {
                        var binary = '';
                        var bytes = new Uint8Array(buffer);
                        var length = bytes.byteLength;
                        for (var i = 0; i < length; i++) {
                            binary += String.fromCharCode(bytes[i]);
                        }
                        return binary;
                    }

// shim for browsers that don't support it
                    function readAsBinaryString(blob, callback) {
                        if (typeof FileReader === 'undefined') {
                            // fix for Firefox in a web worker
                            // https://bugzilla.mozilla.org/show_bug.cgi?id=901097
                            return callback(arrayBufferToBinaryString(
                                new FileReaderSync().readAsArrayBuffer(blob)));
                        }

                        var reader = new FileReader();
                        var hasBinaryString = typeof reader.readAsBinaryString === 'function';
                        reader.onloadend = function (e) {
                            var result = e.target.result || '';
                            if (hasBinaryString) {
                                return callback(result);
                            }
                            callback(arrayBufferToBinaryString(result));
                        };
                        if (hasBinaryString) {
                            reader.readAsBinaryString(blob);
                        } else {
                            reader.readAsArrayBuffer(blob);
                        }
                    }

                    function blobToBase64(blobOrBuffer) {
                        return new PouchPromise(function (resolve) {
                            readAsBinaryString(blobOrBuffer, function (bin) {
                                resolve(btoa$1(bin));
                            });
                        });
                    }

                    function flatten(arrs) {
                        var res = [];
                        for (var i = 0, len = arrs.length; i < len; i++) {
                            res = res.concat(arrs[i]);
                        }
                        return res;
                    }

                    var CHANGES_BATCH_SIZE = 25;
                    var MAX_SIMULTANEOUS_REVS = 50;

                    var supportsBulkGetMap = {};

// according to http://stackoverflow.com/a/417184/680742,
// the de facto URL length limit is 2000 characters.
// but since most of our measurements don't take the full
// URL into account, we fudge it a bit.
// TODO: we could measure the full URL to enforce exactly 2000 chars
                    var MAX_URL_LENGTH = 1800;

                    var log$1 = debug('pouchdb:http');

                    function readAttachmentsAsBlobOrBuffer(row) {
                        var atts = row.doc && row.doc._attachments;
                        if (!atts) {
                            return;
                        }
                        Object.keys(atts).forEach(function (filename) {
                            var att = atts[filename];
                            att.data = b64ToBluffer(att.data, att.content_type);
                        });
                    }

                    function encodeDocId(id) {
                        if (/^_design/.test(id)) {
                            return '_design/' + encodeURIComponent(id.slice(8));
                        }
                        if (/^_local/.test(id)) {
                            return '_local/' + encodeURIComponent(id.slice(7));
                        }
                        return encodeURIComponent(id);
                    }

                    function preprocessAttachments(doc) {
                        if (!doc._attachments || !Object.keys(doc._attachments)) {
                            return PouchPromise.resolve();
                        }

                        return PouchPromise.all(Object.keys(doc._attachments).map(function (key) {
                            var attachment = doc._attachments[key];
                            if (attachment.data && typeof attachment.data !== 'string') {
                                return blobToBase64(attachment.data).then(function (b64) {
                                    attachment.data = b64;
                                });
                            }
                        }));
                    }

// Get all the information you possibly can about the URI given by name and
// return it as a suitable object.
                    function getHost(name) {
                        // Prase the URI into all its little bits
                        var uri = parseUri(name);

                        // Store the user and password as a separate auth object
                        if (uri.user || uri.password) {
                            uri.auth = { username: uri.user, password: uri.password };
                        }

                        // Split the path part of the URI into parts using '/' as the delimiter
                        // after removing any leading '/' and any trailing '/'
                        var parts = uri.path.replace(/(^\/|\/$)/g, '').split('/');

                        // Store the first part as the database name and remove it from the parts
                        // array
                        uri.db = parts.pop();
                        // Prevent double encoding of URI component
                        if (uri.db.indexOf('%') === -1) {
                            uri.db = encodeURIComponent(uri.db);
                        }

                        // Restore the path by joining all the remaining parts (all the parts
                        // except for the database name) with '/'s
                        uri.path = parts.join('/');

                        return uri;
                    }

// Generate a URL with the host data given by opts and the given path
                    function genDBUrl(opts, path) {
                        return genUrl(opts, opts.db + '/' + path);
                    }

// Generate a URL with the host data given by opts and the given path
                    function genUrl(opts, path) {
                        // If the host already has a path, then we need to have a path delimiter
                        // Otherwise, the path delimiter is the empty string
                        var pathDel = !opts.path ? '' : '/';

                        // If the host already has a path, then we need to have a path delimiter
                        // Otherwise, the path delimiter is the empty string
                        return opts.protocol + '://' + opts.host +
                            (opts.port ? (':' + opts.port) : '') +
                            '/' + opts.path + pathDel + path;
                    }

                    function paramsToStr(params) {
                        return '?' + Object.keys(params).map(function (k) {
                                return k + '=' + encodeURIComponent(params[k]);
                            }).join('&');
                    }

// Implements the PouchDB API for dealing with CouchDB instances over HTTP
                    function HttpPouch(opts, callback) {
                        // The functions that will be publicly available for HttpPouch
                        var api = this;

                        // Parse the URI given by opts.name into an easy-to-use object
                        var getHostFun = getHost;

                        // TODO: this seems to only be used by yarong for the Thali project.
                        // Verify whether or not it's still needed.
                        /* istanbul ignore if */
                        if (opts.getHost) {
                            getHostFun = opts.getHost;
                        }

                        var host = getHostFun(opts.name, opts);
                        var dbUrl = genDBUrl(host, '');

                        opts = clone(opts);
                        var ajaxOpts = opts.ajax || {};

                        api.getUrl = function () {
                            return dbUrl;
                        };
                        api.getHeaders = function () {
                            return ajaxOpts.headers || {};
                        };

                        if (opts.auth || host.auth) {
                            var nAuth = opts.auth || host.auth;
                            var str = nAuth.username + ':' + nAuth.password;
                            var token = btoa$1(unescape(encodeURIComponent(str)));
                            ajaxOpts.headers = ajaxOpts.headers || {};
                            ajaxOpts.headers.Authorization = 'Basic ' + token;
                        }

                        function ajax(userOpts, options, callback) {
                            var reqAjax = userOpts.ajax || {};
                            var reqOpts = jsExtend.extend(clone(ajaxOpts), reqAjax, options);
                            log$1(reqOpts.method + ' ' + reqOpts.url);
                            return utils.ajax(reqOpts, callback);
                        }

                        function ajaxPromise(userOpts, opts) {
                            return new PouchPromise(function (resolve, reject) {
                                ajax(userOpts, opts, function (err, res) {
                                    if (err) {
                                        return reject(err);
                                    }
                                    resolve(res);
                                });
                            });
                        }

                        function adapterFun$$(name, fun) {
                            return adapterFun(name, getArguments(function (args) {
                                setup().then(function () {
                                    return fun.apply(this, args);
                                })["catch"](function (e) {
                                    var callback = args.pop();
                                    callback(e);
                                });
                            }));
                        }

                        var setupPromise;

                        function setup() {
                            // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release
                            if (opts.skipSetup || opts.skip_setup) {
                                return PouchPromise.resolve();
                            }

                            // If there is a setup in process or previous successful setup
                            // done then we will use that
                            // If previous setups have been rejected we will try again
                            if (setupPromise) {
                                return setupPromise;
                            }

                            var checkExists = { method: 'GET', url: dbUrl };
                            setupPromise = ajaxPromise({}, checkExists)["catch"](function (err) {
                                if (err && err.status && err.status === 404) {
                                    // Doesnt exist, create it
                                    explainError(404, 'PouchDB is just detecting if the remote exists.');
                                    return ajaxPromise({}, { method: 'PUT', url: dbUrl });
                                } else {
                                    return PouchPromise.reject(err);
                                }
                            })["catch"](function (err) {
                                // If we try to create a database that already exists
                                if (err && err.status && err.status === 412) {
                                    return true;
                                }
                                return PouchPromise.reject(err);
                            });

                            setupPromise["catch"](function () {
                                setupPromise = null;
                            });

                            return setupPromise;
                        }

                        setTimeout(function () {
                            callback(null, api);
                        });

                        api.type = function () {
                            return 'http';
                        };

                        api.id = adapterFun$$('id', function (callback) {
                            ajax({}, { method: 'GET', url: genUrl(host, '') }, function (err, result) {
                                var uuid = (result && result.uuid) ?
                                    (result.uuid + host.db) : genDBUrl(host, '');
                                callback(null, uuid);
                            });
                        });

                        api.request = adapterFun$$('request', function (options, callback) {
                            options.url = genDBUrl(host, options.url);
                            ajax({}, options, callback);
                        });

                        // Sends a POST request to the host calling the couchdb _compact function
                        //    version: The version of CouchDB it is running
                        api.compact = adapterFun$$('compact', function (opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }
                            opts = clone(opts);
                            ajax(opts, {
                                url: genDBUrl(host, '_compact'),
                                method: 'POST'
                            }, function () {
                                function ping() {
                                    api.info(function (err, res) {
                                        if (res && !res.compact_running) {
                                            callback(null, { ok: true });
                                        } else {
                                            setTimeout(ping, opts.interval || 200);
                                        }
                                    });
                                }

                                // Ping the http if it's finished compaction
                                ping();
                            });
                        });

                        api.bulkGet = adapterFun('bulkGet', function (opts, callback) {
                            var self = this;

                            function doBulkGet(cb) {
                                var params = {};
                                if (opts.revs) {
                                    params.revs = true;
                                }
                                if (opts.attachments) {
                                    params.attachments = true;
                                }
                                ajax({}, {
                                    url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),
                                    method: 'POST',
                                    body: { docs: opts.docs }
                                }, cb);
                            }

                            function doBulkGetShim() {
                                // avoid "url too long error" by splitting up into multiple requests
                                var batchSize = MAX_SIMULTANEOUS_REVS;
                                var numBatches = Math.ceil(opts.docs.length / batchSize);
                                var numDone = 0;
                                var results = new Array(numBatches);

                                function onResult(batchNum) {
                                    return function (err, res) {
                                        // err is impossible because shim returns a list of errs in that case
                                        results[batchNum] = res.results;
                                        if (++numDone === numBatches) {
                                            callback(null, { results: flatten(results) });
                                        }
                                    };
                                }

                                for (var i = 0; i < numBatches; i++) {
                                    var subOpts = pick(opts, ['revs', 'attachments']);
                                    subOpts.docs = opts.docs.slice(i * batchSize,
                                        Math.min(opts.docs.length, (i + 1) * batchSize));
                                    bulkGet(self, subOpts, onResult(i));
                                }
                            }

                            // mark the whole database as either supporting or not supporting _bulk_get
                            var dbUrl = genUrl(host, '');
                            var supportsBulkGet = supportsBulkGetMap[dbUrl];

                            if (typeof supportsBulkGet !== 'boolean') {
                                // check if this database supports _bulk_get
                                doBulkGet(function (err, res) {
                                    /* istanbul ignore else */
                                    if (err) {
                                        var status = Math.floor(err.status / 100);
                                        /* istanbul ignore else */
                                        if (status === 4 || status === 5) { // 40x or 50x
                                            supportsBulkGetMap[dbUrl] = false;
                                            explainError(
                                                err.status,
                                                'PouchDB is just detecting if the remote ' +
                                                'supports the _bulk_get API.'
                                            );
                                            doBulkGetShim();
                                        } else {
                                            callback(err);
                                        }
                                    } else {
                                        supportsBulkGetMap[dbUrl] = true;
                                        callback(null, res);
                                    }
                                });
                            } else if (supportsBulkGet) {
                                /* istanbul ignore next */
                                doBulkGet(callback);
                            } else {
                                doBulkGetShim();
                            }
                        });

                        // Calls GET on the host, which gets back a JSON string containing
                        //    couchdb: A welcome string
                        //    version: The version of CouchDB it is running
                        api._info = function (callback) {
                            setup().then(function () {
                                ajax({}, {
                                    method: 'GET',
                                    url: genDBUrl(host, '')
                                }, function (err, res) {
                                    /* istanbul ignore next */
                                    if (err) {
                                        return callback(err);
                                    }
                                    res.host = genDBUrl(host, '');
                                    callback(null, res);
                                });
                            })["catch"](callback);
                        };

                        // Get the document with the given id from the database given by host.
                        // The id could be solely the _id in the database, or it may be a
                        // _design/ID or _local/ID path
                        api.get = adapterFun$$('get', function (id, opts, callback) {
                            // If no options were given, set the callback to the second parameter
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }
                            opts = clone(opts);

                            // List of parameters to add to the GET request
                            var params = {};

                            if (opts.revs) {
                                params.revs = true;
                            }

                            if (opts.revs_info) {
                                params.revs_info = true;
                            }

                            if (opts.open_revs) {
                                if (opts.open_revs !== "all") {
                                    opts.open_revs = JSON.stringify(opts.open_revs);
                                }
                                params.open_revs = opts.open_revs;
                            }

                            if (opts.rev) {
                                params.rev = opts.rev;
                            }

                            if (opts.conflicts) {
                                params.conflicts = opts.conflicts;
                            }

                            id = encodeDocId(id);

                            // Set the options for the ajax call
                            var options = {
                                method: 'GET',
                                url: genDBUrl(host, id + paramsToStr(params))
                            };

                            function fetchAttachments(doc) {
                                var atts = doc._attachments;
                                var filenames = atts && Object.keys(atts);
                                if (!atts || !filenames.length) {
                                    return;
                                }
                                // we fetch these manually in separate XHRs, because
                                // Sync Gateway would normally send it back as multipart/mixed,
                                // which we cannot parse. Also, this is more efficient than
                                // receiving attachments as base64-encoded strings.
                                return PouchPromise.all(filenames.map(function (filename) {
                                    var att = atts[filename];
                                    var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +
                                        '?rev=' + doc._rev;
                                    return ajaxPromise(opts, {
                                        method: 'GET',
                                        url: genDBUrl(host, path),
                                        binary: true
                                    }).then(function (blob) {
                                        if (opts.binary) {
                                            return blob;
                                        }
                                        return blobToBase64(blob);
                                    }).then(function (data) {
                                        delete att.stub;
                                        delete att.length;
                                        att.data = data;
                                    });
                                }));
                            }

                            function fetchAllAttachments(docOrDocs) {
                                if (Array.isArray(docOrDocs)) {
                                    return PouchPromise.all(docOrDocs.map(function (doc) {
                                        if (doc.ok) {
                                            return fetchAttachments(doc.ok);
                                        }
                                    }));
                                }
                                return fetchAttachments(docOrDocs);
                            }

                            ajaxPromise(opts, options).then(function (res) {
                                return PouchPromise.resolve().then(function () {
                                    if (opts.attachments) {
                                        return fetchAllAttachments(res);
                                    }
                                }).then(function () {
                                    callback(null, res);
                                });
                            })["catch"](callback);
                        });

                        // Delete the document given by doc from the database given by host.
                        api.remove = adapterFun$$('remove',
                            function (docOrId, optsOrRev, opts, callback) {
                                var doc;
                                if (typeof optsOrRev === 'string') {
                                    // id, rev, opts, callback style
                                    doc = {
                                        _id: docOrId,
                                        _rev: optsOrRev
                                    };
                                    if (typeof opts === 'function') {
                                        callback = opts;
                                        opts = {};
                                    }
                                } else {
                                    // doc, opts, callback style
                                    doc = docOrId;
                                    if (typeof optsOrRev === 'function') {
                                        callback = optsOrRev;
                                        opts = {};
                                    } else {
                                        callback = opts;
                                        opts = optsOrRev;
                                    }
                                }

                                var rev = (doc._rev || opts.rev);

                                // Delete the document
                                ajax(opts, {
                                    method: 'DELETE',
                                    url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev
                                }, callback);
                            });

                        function encodeAttachmentId(attachmentId) {
                            return attachmentId.split("/").map(encodeURIComponent).join("/");
                        }

                        // Get the attachment
                        api.getAttachment =
                            adapterFun$$('getAttachment', function (docId, attachmentId, opts,
                                                                    callback) {
                                if (typeof opts === 'function') {
                                    callback = opts;
                                    opts = {};
                                }
                                var params = opts.rev ? ('?rev=' + opts.rev) : '';
                                var url = genDBUrl(host, encodeDocId(docId)) + '/' +
                                    encodeAttachmentId(attachmentId) + params;
                                ajax(opts, {
                                    method: 'GET',
                                    url: url,
                                    binary: true
                                }, callback);
                            });

                        // Remove the attachment given by the id and rev
                        api.removeAttachment =
                            adapterFun$$('removeAttachment', function (docId, attachmentId, rev,
                                                                       callback) {

                                var url = genDBUrl(host, encodeDocId(docId) + '/' +
                                        encodeAttachmentId(attachmentId)) + '?rev=' + rev;

                                ajax({}, {
                                    method: 'DELETE',
                                    url: url
                                }, callback);
                            });

                        // Add the attachment given by blob and its contentType property
                        // to the document with the given id, the revision given by rev, and
                        // add it to the database given by host.
                        api.putAttachment =
                            adapterFun$$('putAttachment', function (docId, attachmentId, rev, blob,
                                                                    type, callback) {
                                if (typeof type === 'function') {
                                    callback = type;
                                    type = blob;
                                    blob = rev;
                                    rev = null;
                                }
                                var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);
                                var url = genDBUrl(host, id);
                                if (rev) {
                                    url += '?rev=' + rev;
                                }

                                if (typeof blob === 'string') {
                                    // input is assumed to be a base64 string
                                    var binary;
                                    try {
                                        binary = atob$1(blob);
                                    } catch (err) {
                                        return callback(createError(BAD_ARG,
                                            'Attachment is not a valid base64 string'));
                                    }
                                    blob = binary ? binStringToBluffer(binary, type) : '';
                                }

                                var opts = {
                                    headers: { 'Content-Type': type },
                                    method: 'PUT',
                                    url: url,
                                    processData: false,
                                    body: blob,
                                    timeout: ajaxOpts.timeout || 60000
                                };
                                // Add the attachment
                                ajax({}, opts, callback);
                            });

                        // Update/create multiple documents given by req in the database
                        // given by host.
                        api._bulkDocs = function (req, opts, callback) {
                            // If new_edits=false then it prevents the database from creating
                            // new revision numbers for the documents. Instead it just uses
                            // the old ones. This is used in database replication.
                            req.new_edits = opts.new_edits;

                            setup().then(function () {
                                return PouchPromise.all(req.docs.map(preprocessAttachments));
                            }).then(function () {
                                // Update/create the documents
                                ajax(opts, {
                                    method: 'POST',
                                    url: genDBUrl(host, '_bulk_docs'),
                                    body: req
                                }, function (err, results) {
                                    if (err) {
                                        return callback(err);
                                    }
                                    results.forEach(function (result) {
                                        result.ok = true; // smooths out cloudant not adding this
                                    });
                                    callback(null, results);
                                });
                            })["catch"](callback);
                        };

                        // Get a listing of the documents in the database given
                        // by host and ordered by increasing id.
                        api.allDocs = adapterFun$$('allDocs', function (opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }
                            opts = clone(opts);

                            // List of parameters to add to the GET request
                            var params = {};
                            var body;
                            var method = 'GET';

                            if (opts.conflicts) {
                                params.conflicts = true;
                            }

                            if (opts.descending) {
                                params.descending = true;
                            }

                            if (opts.include_docs) {
                                params.include_docs = true;
                            }

                            // added in CouchDB 1.6.0
                            if (opts.attachments) {
                                params.attachments = true;
                            }

                            if (opts.key) {
                                params.key = JSON.stringify(opts.key);
                            }

                            if (opts.start_key) {
                                opts.startkey = opts.start_key;
                            }

                            if (opts.startkey) {
                                params.startkey = JSON.stringify(opts.startkey);
                            }

                            if (opts.end_key) {
                                opts.endkey = opts.end_key;
                            }

                            if (opts.endkey) {
                                params.endkey = JSON.stringify(opts.endkey);
                            }

                            if (typeof opts.inclusive_end !== 'undefined') {
                                params.inclusive_end = !!opts.inclusive_end;
                            }

                            if (typeof opts.limit !== 'undefined') {
                                params.limit = opts.limit;
                            }

                            if (typeof opts.skip !== 'undefined') {
                                params.skip = opts.skip;
                            }

                            var paramStr = paramsToStr(params);

                            if (typeof opts.keys !== 'undefined') {

                                var keysAsString =
                                    'keys=' + encodeURIComponent(JSON.stringify(opts.keys));
                                if (keysAsString.length + paramStr.length + 1 <= MAX_URL_LENGTH) {
                                    // If the keys are short enough, do a GET. we do this to work around
                                    // Safari not understanding 304s on POSTs (see issue #1239)
                                    paramStr += '&' + keysAsString;
                                } else {
                                    // If keys are too long, issue a POST request to circumvent GET
                                    // query string limits
                                    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
                                    method = 'POST';
                                    body = { keys: opts.keys };
                                }
                            }

                            // Get the document listing
                            ajaxPromise(opts, {
                                method: method,
                                url: genDBUrl(host, '_all_docs' + paramStr),
                                body: body
                            }).then(function (res) {
                                if (opts.include_docs && opts.attachments && opts.binary) {
                                    res.rows.forEach(readAttachmentsAsBlobOrBuffer);
                                }
                                callback(null, res);
                            })["catch"](callback);
                        });

                        // Get a list of changes made to documents in the database given by host.
                        // TODO According to the README, there should be two other methods here,
                        // api.changes.addListener and api.changes.removeListener.
                        api._changes = function (opts) {

                            // We internally page the results of a changes request, this means
                            // if there is a large set of changes to be returned we can start
                            // processing them quicker instead of waiting on the entire
                            // set of changes to return and attempting to process them at once
                            var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;

                            opts = clone(opts);
                            opts.timeout = ('timeout' in opts) ? opts.timeout :
                                ('timeout' in ajaxOpts) ? ajaxOpts.timeout :
                                30 * 1000;

                            // We give a 5 second buffer for CouchDB changes to respond with
                            // an ok timeout (if a timeout it set)
                            var params = opts.timeout ? { timeout: opts.timeout - (5 * 1000) } : {};
                            var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;
                            var returnDocs;
                            if ('return_docs' in opts) {
                                returnDocs = opts.return_docs;
                            } else if ('returnDocs' in opts) {
                                // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release
                                returnDocs = opts.returnDocs;
                            } else {
                                returnDocs = true;
                            }
                            //
                            var leftToFetch = limit;

                            if (opts.style) {
                                params.style = opts.style;
                            }

                            if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {
                                params.include_docs = true;
                            }

                            if (opts.attachments) {
                                params.attachments = true;
                            }

                            if (opts.continuous) {
                                params.feed = 'longpoll';
                            }

                            if (opts.conflicts) {
                                params.conflicts = true;
                            }

                            if (opts.descending) {
                                params.descending = true;
                            }

                            if ('heartbeat' in opts) {
                                // If the heartbeat value is false, it disables the default heartbeat
                                if (opts.heartbeat) {
                                    params.heartbeat = opts.heartbeat;
                                }
                            } else {
                                // Default heartbeat to 10 seconds
                                params.heartbeat = 10000;
                            }

                            if (opts.filter && typeof opts.filter === 'string') {
                                params.filter = opts.filter;
                                if (opts.filter === '_view' &&
                                    opts.view &&
                                    typeof opts.view === 'string') {
                                    params.view = opts.view;
                                }
                            }

                            // If opts.query_params exists, pass it through to the changes request.
                            // These parameters may be used by the filter on the source database.
                            if (opts.query_params && typeof opts.query_params === 'object') {
                                for (var param_name in opts.query_params) {
                                    /* istanbul ignore else */
                                    if (opts.query_params.hasOwnProperty(param_name)) {
                                        params[param_name] = opts.query_params[param_name];
                                    }
                                }
                            }

                            var method = 'GET';
                            var body;

                            if (opts.doc_ids) {
                                // set this automagically for the user; it's annoying that couchdb
                                // requires both a "filter" and a "doc_ids" param.
                                params.filter = '_doc_ids';

                                var docIdsJson = JSON.stringify(opts.doc_ids);

                                if (docIdsJson.length < MAX_URL_LENGTH) {
                                    params.doc_ids = docIdsJson;
                                } else {
                                    // anything greater than ~2000 is unsafe for gets, so
                                    // use POST instead
                                    method = 'POST';
                                    body = { doc_ids: opts.doc_ids };
                                }
                            }

                            var xhr;
                            var lastFetchedSeq;

                            // Get all the changes starting wtih the one immediately after the
                            // sequence number given by since.
                            var fetch = function (since, callback) {
                                if (opts.aborted) {
                                    return;
                                }
                                params.since = since;
                                // "since" can be any kind of json object in Coudant/CouchDB 2.x
                                /* istanbul ignore next */
                                if (typeof params.since === "object") {
                                    params.since = JSON.stringify(params.since);
                                }

                                if (opts.descending) {
                                    if (limit) {
                                        params.limit = leftToFetch;
                                    }
                                } else {
                                    params.limit = (!limit || leftToFetch > batchSize) ?
                                        batchSize : leftToFetch;
                                }

                                // Set the options for the ajax call
                                var xhrOpts = {
                                    method: method,
                                    url: genDBUrl(host, '_changes' + paramsToStr(params)),
                                    timeout: opts.timeout,
                                    body: body
                                };
                                lastFetchedSeq = since;

                                /* istanbul ignore if */
                                if (opts.aborted) {
                                    return;
                                }

                                // Get the changes
                                setup().then(function () {
                                    xhr = ajax(opts, xhrOpts, callback);
                                })["catch"](callback);
                            };

                            // If opts.since exists, get all the changes from the sequence
                            // number given by opts.since. Otherwise, get all the changes
                            // from the sequence number 0.
                            var results = { results: [] };

                            var fetched = function (err, res) {
                                if (opts.aborted) {
                                    return;
                                }
                                var raw_results_length = 0;
                                // If the result of the ajax call (res) contains changes (res.results)
                                if (res && res.results) {
                                    raw_results_length = res.results.length;
                                    results.last_seq = res.last_seq;
                                    // For each change
                                    var req = {};
                                    req.query = opts.query_params;
                                    res.results = res.results.filter(function (c) {
                                        leftToFetch--;
                                        var ret = filterChange(opts)(c);
                                        if (ret) {
                                            if (opts.include_docs && opts.attachments && opts.binary) {
                                                readAttachmentsAsBlobOrBuffer(c);
                                            }
                                            if (returnDocs) {
                                                results.results.push(c);
                                            }
                                            opts.onChange(c);
                                        }
                                        return ret;
                                    });
                                } else if (err) {
                                    // In case of an error, stop listening for changes and call
                                    // opts.complete
                                    opts.aborted = true;
                                    opts.complete(err);
                                    return;
                                }

                                // The changes feed may have timed out with no results
                                // if so reuse last update sequence
                                if (res && res.last_seq) {
                                    lastFetchedSeq = res.last_seq;
                                }

                                var finished = (limit && leftToFetch <= 0) ||
                                    (res && raw_results_length < batchSize) ||
                                    (opts.descending);

                                if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {
                                    // Queue a call to fetch again with the newest sequence number
                                    setTimeout(function () {
                                        fetch(lastFetchedSeq, fetched);
                                    }, 0);
                                } else {
                                    // We're done, call the callback
                                    opts.complete(null, results);
                                }
                            };

                            fetch(opts.since || 0, fetched);

                            // Return a method to cancel this method from processing any more
                            return {
                                cancel: function () {
                                    opts.aborted = true;
                                    if (xhr) {
                                        xhr.abort();
                                    }
                                }
                            };
                        };

                        // Given a set of document/revision IDs (given by req), tets the subset of
                        // those that do NOT correspond to revisions stored in the database.
                        // See http://wiki.apache.org/couchdb/HttpPostRevsDiff
                        api.revsDiff = adapterFun$$('revsDiff', function (req, opts, callback) {
                            // If no options were given, set the callback to be the second parameter
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }

                            // Get the missing document/revision IDs
                            ajax(opts, {
                                method: 'POST',
                                url: genDBUrl(host, '_revs_diff'),
                                body: req
                            }, callback);
                        });

                        api._close = function (callback) {
                            callback();
                        };

                        api._destroy = function (options, callback) {
                            ajax(options, {
                                url: genDBUrl(host, ''),
                                method: 'DELETE'
                            }, function (err, resp) {
                                if (err && err.status && err.status !== 404) {
                                    return callback(err);
                                }
                                api.emit('destroyed');
                                api.constructor.emit('destroyed', opts.name);
                                callback(null, resp);
                            });
                        };
                    }

// HttpPouch is a valid adapter.
                    HttpPouch.valid = function () {
                        return true;
                    };

                    function TaskQueue$1() {
                        this.promise = new PouchPromise(function (fulfill) {
                            fulfill();
                        });
                    }

                    TaskQueue$1.prototype.add = function (promiseFactory) {
                        this.promise = this.promise["catch"](function () {
                            // just recover
                        }).then(function () {
                            return promiseFactory();
                        });
                        return this.promise;
                    };
                    TaskQueue$1.prototype.finish = function () {
                        return this.promise;
                    };

                    function md5$1(string) {
                        return Md5.hash(string);
                    }

                    function createView(opts) {
                        var sourceDB = opts.db;
                        var viewName = opts.viewName;
                        var mapFun = opts.map;
                        var reduceFun = opts.reduce;
                        var temporary = opts.temporary;

                        // the "undefined" part is for backwards compatibility
                        var viewSignature = mapFun.toString() + (reduceFun && reduceFun.toString()) +
                            'undefined';

                        if (!temporary && sourceDB._cachedViews) {
                            var cachedView = sourceDB._cachedViews[viewSignature];
                            if (cachedView) {
                                return PouchPromise.resolve(cachedView);
                            }
                        }

                        return sourceDB.info().then(function (info) {

                            var depDbName = info.db_name + '-mrview-' +
                                (temporary ? 'temp' : md5$1(viewSignature));

                            // save the view name in the source db so it can be cleaned up if necessary
                            // (e.g. when the _design doc is deleted, remove all associated view data)
                            function diffFunction(doc) {
                                doc.views = doc.views || {};
                                var fullViewName = viewName;
                                if (fullViewName.indexOf('/') === -1) {
                                    fullViewName = viewName + '/' + viewName;
                                }
                                var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};
                                /* istanbul ignore if */
                                if (depDbs[depDbName]) {
                                    return; // no update necessary
                                }
                                depDbs[depDbName] = true;
                                return doc;
                            }

                            return upsert(sourceDB, '_local/mrviews', diffFunction).then(function () {
                                return sourceDB.registerDependentDatabase(depDbName).then(function (res) {
                                    var db = res.db;
                                    db.auto_compaction = true;
                                    var view = {
                                        name: depDbName,
                                        db: db,
                                        sourceDB: sourceDB,
                                        adapter: sourceDB.adapter,
                                        mapFun: mapFun,
                                        reduceFun: reduceFun
                                    };
                                    return view.db.get('_local/lastSeq')["catch"](function (err) {
                                        /* istanbul ignore if */
                                        if (err.status !== 404) {
                                            throw err;
                                        }
                                    }).then(function (lastSeqDoc) {
                                        view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;
                                        if (!temporary) {
                                            sourceDB._cachedViews = sourceDB._cachedViews || {};
                                            sourceDB._cachedViews[viewSignature] = view;
                                            view.db.once('destroyed', function () {
                                                delete sourceDB._cachedViews[viewSignature];
                                            });
                                        }
                                        return view;
                                    });
                                });
                            });
                        });
                    }

                    function evalfunc(func, emit, sum, log, isArray, toJSON) {
                        return scopedEval(
                            "return (" + func.replace(/;\s*$/, "") + ");",
                            {
                                emit: emit,
                                sum: sum,
                                log: log,
                                isArray: isArray,
                                toJSON: toJSON
                            }
                        );
                    }

                    var promisedCallback$1 = function (promise, callback) {
                        if (callback) {
                            promise.then(function (res) {
                                process.nextTick(function () {
                                    callback(null, res);
                                });
                            }, function (reason) {
                                process.nextTick(function () {
                                    callback(reason);
                                });
                            });
                        }
                        return promise;
                    };

                    var callbackify$1 = function (fun) {
                        return getArguments(function (args) {
                            var cb = args.pop();
                            var promise = fun.apply(this, args);
                            if (typeof cb === 'function') {
                                promisedCallback$1(promise, cb);
                            }
                            return promise;
                        });
                    };

// Promise finally util similar to Q.finally
                    var fin$1 = function (promise, finalPromiseFactory) {
                        return promise.then(function (res) {
                            return finalPromiseFactory().then(function () {
                                return res;
                            });
                        }, function (reason) {
                            return finalPromiseFactory().then(function () {
                                throw reason;
                            });
                        });
                    };

                    var sequentialize$1 = function (queue, promiseFactory) {
                        return function () {
                            var args = arguments;
                            var that = this;
                            return queue.add(function () {
                                return promiseFactory.apply(that, args);
                            });
                        };
                    };

// uniq an array of strings, order not guaranteed
// similar to underscore/lodash _.uniq
                    var uniq$1 = function (arr) {
                        var map = {};

                        for (var i = 0, len = arr.length; i < len; i++) {
                            map['$' + arr[i]] = true;
                        }

                        var keys = Object.keys(map);
                        var output = new Array(keys.length);

                        for (i = 0, len = keys.length; i < len; i++) {
                            output[i] = keys[i].substring(1);
                        }
                        return output;
                    };

                    var utils$1 = {
                        uniq: uniq$1,
                        sequentialize: sequentialize$1,
                        fin: fin$1,
                        callbackify: callbackify$1,
                        promisedCallback: promisedCallback$1
                    };

                    var collate$2 = pouchCollate__default.collate;
                    var toIndexableString = pouchCollate__default.toIndexableString;
                    var normalizeKey = pouchCollate__default.normalizeKey;
                    var parseIndexableString = pouchCollate__default.parseIndexableString;
                    var log$2;
                    /* istanbul ignore else */
                    if ((typeof console !== 'undefined') && (typeof console.log === 'function')) {
                        log$2 = Function.prototype.bind.call(console.log, console);
                    } else {
                        log$2 = function () {
                        };
                    }
                    var callbackify = utils$1.callbackify;
                    var sequentialize = utils$1.sequentialize;
                    var uniq = utils$1.uniq;
                    var fin = utils$1.fin;
                    var promisedCallback = utils$1.promisedCallback;
                    var persistentQueues = {};
                    var tempViewQueue = new TaskQueue$1();
                    var CHANGES_BATCH_SIZE$1 = 50;

                    function parseViewName(name) {
                        // can be either 'ddocname/viewname' or just 'viewname'
                        // (where the ddoc name is the same)
                        return name.indexOf('/') === -1 ? [name, name] : name.split('/');
                    }

                    function isGenOne$1(changes) {
                        // only return true if the current change is 1-
                        // and there are no other leafs
                        return changes.length === 1 && /^1-/.test(changes[0].rev);
                    }

                    function emitError(db, e) {
                        try {
                            db.emit('error', e);
                        } catch (err) {
                            console.error(
                                'The user\'s map/reduce function threw an uncaught error.\n' +
                                'You can debug this error by doing:\n' +
                                'myDatabase.on(\'error\', function (err) { debugger; });\n' +
                                'Please double-check your map/reduce function.');
                            console.error(e);
                        }
                    }

                    function tryCode(db, fun, args) {
                        // emit an event if there was an error thrown by a map/reduce function.
                        // putting try/catches in a single function also avoids deoptimizations.
                        try {
                            return {
                                output: fun.apply(null, args)
                            };
                        } catch (e) {
                            emitError(db, e);
                            return { error: e };
                        }
                    }

                    function sortByKeyThenValue(x, y) {
                        var keyCompare = collate$2(x.key, y.key);
                        return keyCompare !== 0 ? keyCompare : collate$2(x.value, y.value);
                    }

                    function sliceResults(results, limit, skip) {
                        skip = skip || 0;
                        if (typeof limit === 'number') {
                            return results.slice(skip, limit + skip);
                        } else if (skip > 0) {
                            return results.slice(skip);
                        }
                        return results;
                    }

                    function rowToDocId(row) {
                        var val = row.value;
                        // Users can explicitly specify a joined doc _id, or it
                        // defaults to the doc _id that emitted the key/value.
                        var docId = (val && typeof val === 'object' && val._id) || row.id;
                        return docId;
                    }

                    function readAttachmentsAsBlobOrBuffer$1(res) {
                        res.rows.forEach(function (row) {
                            var atts = row.doc && row.doc._attachments;
                            if (!atts) {
                                return;
                            }
                            Object.keys(atts).forEach(function (filename) {
                                var att = atts[filename];
                                atts[filename].data = b64ToBluffer(att.data, att.content_type);
                            });
                        });
                    }

                    function postprocessAttachments(opts) {
                        return function (res) {
                            if (opts.include_docs && opts.attachments && opts.binary) {
                                readAttachmentsAsBlobOrBuffer$1(res);
                            }
                            return res;
                        };
                    }

                    function createBuiltInError(name) {
                        var message = 'builtin ' + name +
                            ' function requires map values to be numbers' +
                            ' or number arrays';
                        return new BuiltInError(message);
                    }

                    function sum(values) {
                        var result = 0;
                        for (var i = 0, len = values.length; i < len; i++) {
                            var num = values[i];
                            if (typeof num !== 'number') {
                                if (Array.isArray(num)) {
                                    // lists of numbers are also allowed, sum them separately
                                    result = typeof result === 'number' ? [result] : result;
                                    for (var j = 0, jLen = num.length; j < jLen; j++) {
                                        var jNum = num[j];
                                        if (typeof jNum !== 'number') {
                                            throw createBuiltInError('_sum');
                                        } else if (typeof result[j] === 'undefined') {
                                            result.push(jNum);
                                        } else {
                                            result[j] += jNum;
                                        }
                                    }
                                } else { // not array/number
                                    throw createBuiltInError('_sum');
                                }
                            } else if (typeof result === 'number') {
                                result += num;
                            } else { // add number to array
                                result[0] += num;
                            }
                        }
                        return result;
                    }

                    var builtInReduce = {
                        _sum: function (keys, values) {
                            return sum(values);
                        },

                        _count: function (keys, values) {
                            return values.length;
                        },

                        _stats: function (keys, values) {
                            // no need to implement rereduce=true, because Pouch
                            // will never call it
                            function sumsqr(values) {
                                var _sumsqr = 0;
                                for (var i = 0, len = values.length; i < len; i++) {
                                    var num = values[i];
                                    _sumsqr += (num * num);
                                }
                                return _sumsqr;
                            }

                            return {
                                sum: sum(values),
                                min: Math.min.apply(null, values),
                                max: Math.max.apply(null, values),
                                count: values.length,
                                sumsqr: sumsqr(values)
                            };
                        }
                    };

                    function addHttpParam(paramName, opts, params, asJson) {
                        // add an http param from opts to params, optionally json-encoded
                        var val = opts[paramName];
                        if (typeof val !== 'undefined') {
                            if (asJson) {
                                val = encodeURIComponent(JSON.stringify(val));
                            }
                            params.push(paramName + '=' + val);
                        }
                    }

                    function coerceInteger(integerCandidate) {
                        if (typeof integerCandidate !== 'undefined') {
                            var asNumber = Number(integerCandidate);
                            // prevents e.g. '1foo' or '1.1' being coerced to 1
                            if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {
                                return asNumber;
                            } else {
                                return integerCandidate;
                            }
                        }
                    }

                    function coerceOptions(opts) {
                        opts.group_level = coerceInteger(opts.group_level);
                        opts.limit = coerceInteger(opts.limit);
                        opts.skip = coerceInteger(opts.skip);
                        return opts;
                    }

                    function checkPositiveInteger(number) {
                        if (number) {
                            if (typeof number !== 'number') {
                                return new QueryParseError('Invalid value for integer: "' +
                                    number + '"');
                            }
                            if (number < 0) {
                                return new QueryParseError('Invalid value for positive integer: ' +
                                    '"' + number + '"');
                            }
                        }
                    }

                    function checkQueryParseError(options, fun) {
                        var startkeyName = options.descending ? 'endkey' : 'startkey';
                        var endkeyName = options.descending ? 'startkey' : 'endkey';

                        if (typeof options[startkeyName] !== 'undefined' &&
                            typeof options[endkeyName] !== 'undefined' &&
                            collate$2(options[startkeyName], options[endkeyName]) > 0) {
                            throw new QueryParseError('No rows can match your key range, ' +
                                'reverse your start_key and end_key or set {descending : true}');
                        } else if (fun.reduce && options.reduce !== false) {
                            if (options.include_docs) {
                                throw new QueryParseError('{include_docs:true} is invalid for reduce');
                            } else if (options.keys && options.keys.length > 1 && !options.group && !options.group_level) {
                                throw new QueryParseError('Multi-key fetches for reduce views must use ' +
                                    '{group: true}');
                            }
                        }
                        ['group_level', 'limit', 'skip'].forEach(function (optionName) {
                            var error = checkPositiveInteger(options[optionName]);
                            if (error) {
                                throw error;
                            }
                        });
                    }

                    function httpQuery(db, fun, opts) {
                        // List of parameters to add to the PUT request
                        var params = [];
                        var body;
                        var method = 'GET';

                        // If opts.reduce exists and is defined, then add it to the list
                        // of parameters.
                        // If reduce=false then the results are that of only the map function
                        // not the final result of map and reduce.
                        addHttpParam('reduce', opts, params);
                        addHttpParam('include_docs', opts, params);
                        addHttpParam('attachments', opts, params);
                        addHttpParam('limit', opts, params);
                        addHttpParam('descending', opts, params);
                        addHttpParam('group', opts, params);
                        addHttpParam('group_level', opts, params);
                        addHttpParam('skip', opts, params);
                        addHttpParam('stale', opts, params);
                        addHttpParam('conflicts', opts, params);
                        addHttpParam('startkey', opts, params, true);
                        addHttpParam('start_key', opts, params, true);
                        addHttpParam('endkey', opts, params, true);
                        addHttpParam('end_key', opts, params, true);
                        addHttpParam('inclusive_end', opts, params);
                        addHttpParam('key', opts, params, true);

                        // Format the list of parameters into a valid URI query string
                        params = params.join('&');
                        params = params === '' ? '' : '?' + params;

                        // If keys are supplied, issue a POST to circumvent GET query string limits
                        // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options
                        if (typeof opts.keys !== 'undefined') {
                            var MAX_URL_LENGTH = 2000;
                            // according to http://stackoverflow.com/a/417184/680742,
                            // the de facto URL length limit is 2000 characters

                            var keysAsString =
                                'keys=' + encodeURIComponent(JSON.stringify(opts.keys));
                            if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {
                                // If the keys are short enough, do a GET. we do this to work around
                                // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)
                                params += (params[0] === '?' ? '&' : '?') + keysAsString;
                            } else {
                                method = 'POST';
                                if (typeof fun === 'string') {
                                    body = { keys: opts.keys };
                                } else { // fun is {map : mapfun}, so append to this
                                    fun.keys = opts.keys;
                                }
                            }
                        }

                        // We are referencing a query defined in the design doc
                        if (typeof fun === 'string') {
                            var parts = parseViewName(fun);
                            return db.request({
                                method: method,
                                url: '_design/' + parts[0] + '/_view/' + parts[1] + params,
                                body: body
                            }).then(postprocessAttachments(opts));
                        }

                        // We are using a temporary view, terrible for performance, good for testing
                        body = body || {};
                        Object.keys(fun).forEach(function (key) {
                            if (Array.isArray(fun[key])) {
                                body[key] = fun[key];
                            } else {
                                body[key] = fun[key].toString();
                            }
                        });
                        return db.request({
                            method: 'POST',
                            url: '_temp_view' + params,
                            body: body
                        }).then(postprocessAttachments(opts));
                    }

// custom adapters can define their own api._query
// and override the default behavior
                    /* istanbul ignore next */
                    function customQuery(db, fun, opts) {
                        return new PouchPromise(function (resolve, reject) {
                            db._query(fun, opts, function (err, res) {
                                if (err) {
                                    return reject(err);
                                }
                                resolve(res);
                            });
                        });
                    }

// custom adapters can define their own api._viewCleanup
// and override the default behavior
                    /* istanbul ignore next */
                    function customViewCleanup(db) {
                        return new PouchPromise(function (resolve, reject) {
                            db._viewCleanup(function (err, res) {
                                if (err) {
                                    return reject(err);
                                }
                                resolve(res);
                            });
                        });
                    }

                    function defaultsTo(value) {
                        return function (reason) {
                            /* istanbul ignore else */
                            if (reason.status === 404) {
                                return value;
                            } else {
                                throw reason;
                            }
                        };
                    }

// returns a promise for a list of docs to update, based on the input docId.
// the order doesn't matter, because post-3.2.0, bulkDocs
// is an atomic operation in all three adapters.
                    function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {
                        var metaDocId = '_local/doc_' + docId;
                        var defaultMetaDoc = { _id: metaDocId, keys: [] };
                        var docData = docIdsToChangesAndEmits[docId];
                        var indexableKeysToKeyValues = docData.indexableKeysToKeyValues;
                        var changes = docData.changes;

                        function getMetaDoc() {
                            if (isGenOne$1(changes)) {
                                // generation 1, so we can safely assume initial state
                                // for performance reasons (avoids unnecessary GETs)
                                return PouchPromise.resolve(defaultMetaDoc);
                            }
                            return view.db.get(metaDocId)["catch"](defaultsTo(defaultMetaDoc));
                        }

                        function getKeyValueDocs(metaDoc) {
                            if (!metaDoc.keys.length) {
                                // no keys, no need for a lookup
                                return PouchPromise.resolve({ rows: [] });
                            }
                            return view.db.allDocs({
                                keys: metaDoc.keys,
                                include_docs: true
                            });
                        }

                        function processKvDocs(metaDoc, kvDocsRes) {
                            var kvDocs = [];
                            var oldKeysMap = {};

                            for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {
                                var row = kvDocsRes.rows[i];
                                var doc = row.doc;
                                if (!doc) { // deleted
                                    continue;
                                }
                                kvDocs.push(doc);
                                oldKeysMap[doc._id] = true;
                                doc._deleted = !indexableKeysToKeyValues[doc._id];
                                if (!doc._deleted) {
                                    var keyValue = indexableKeysToKeyValues[doc._id];
                                    if ('value' in keyValue) {
                                        doc.value = keyValue.value;
                                    }
                                }
                            }

                            var newKeys = Object.keys(indexableKeysToKeyValues);
                            newKeys.forEach(function (key) {
                                if (!oldKeysMap[key]) {
                                    // new doc
                                    var kvDoc = {
                                        _id: key
                                    };
                                    var keyValue = indexableKeysToKeyValues[key];
                                    if ('value' in keyValue) {
                                        kvDoc.value = keyValue.value;
                                    }
                                    kvDocs.push(kvDoc);
                                }
                            });
                            metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));
                            kvDocs.push(metaDoc);

                            return kvDocs;
                        }

                        return getMetaDoc().then(function (metaDoc) {
                            return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {
                                return processKvDocs(metaDoc, kvDocsRes);
                            });
                        });
                    }

// updates all emitted key/value docs and metaDocs in the mrview database
// for the given batch of documents from the source database
                    function saveKeyValues(view, docIdsToChangesAndEmits, seq) {
                        var seqDocId = '_local/lastSeq';
                        return view.db.get(seqDocId)[
                            "catch"](defaultsTo({ _id: seqDocId, seq: 0 }))
                            .then(function (lastSeqDoc) {
                                var docIds = Object.keys(docIdsToChangesAndEmits);
                                return PouchPromise.all(docIds.map(function (docId) {
                                    return getDocsToPersist(docId, view, docIdsToChangesAndEmits);
                                })).then(function (listOfDocsToPersist) {
                                    var docsToPersist = flatten(listOfDocsToPersist);
                                    lastSeqDoc.seq = seq;
                                    docsToPersist.push(lastSeqDoc);
                                    // write all docs in a single operation, update the seq once
                                    return view.db.bulkDocs({ docs: docsToPersist });
                                });
                            });
                    }

                    function getQueue(view) {
                        var viewName = typeof view === 'string' ? view : view.name;
                        var queue = persistentQueues[viewName];
                        if (!queue) {
                            queue = persistentQueues[viewName] = new TaskQueue$1();
                        }
                        return queue;
                    }

                    function updateView(view) {
                        return sequentialize(getQueue(view), function () {
                            return updateViewInQueue(view);
                        })();
                    }

                    function updateViewInQueue(view) {
                        // bind the emit function once
                        var mapResults;
                        var doc;

                        function emit(key, value) {
                            var output = { id: doc._id, key: normalizeKey(key) };
                            // Don't explicitly store the value unless it's defined and non-null.
                            // This saves on storage space, because often people don't use it.
                            if (typeof value !== 'undefined' && value !== null) {
                                output.value = normalizeKey(value);
                            }
                            mapResults.push(output);
                        }

                        var mapFun;
                        // for temp_views one can use emit(doc, emit), see #38
                        if (typeof view.mapFun === "function" && view.mapFun.length === 2) {
                            var origMap = view.mapFun;
                            mapFun = function (doc) {
                                return origMap(doc, emit);
                            };
                        } else {
                            mapFun = evalfunc(view.mapFun.toString(), emit, sum, log$2, Array.isArray,
                                JSON.parse);
                        }

                        var currentSeq = view.seq || 0;

                        function processChange(docIdsToChangesAndEmits, seq) {
                            return function () {
                                return saveKeyValues(view, docIdsToChangesAndEmits, seq);
                            };
                        }

                        var queue = new TaskQueue$1();
                        // TODO(neojski): https://github.com/daleharvey/pouchdb/issues/1521

                        return new PouchPromise(function (resolve, reject) {

                            function complete() {
                                queue.finish().then(function () {
                                    view.seq = currentSeq;
                                    resolve();
                                });
                            }

                            function processNextBatch() {
                                view.sourceDB.changes({
                                    conflicts: true,
                                    include_docs: true,
                                    style: 'all_docs',
                                    since: currentSeq,
                                    limit: CHANGES_BATCH_SIZE$1
                                }).on('complete', function (response) {
                                    var results = response.results;
                                    if (!results.length) {
                                        return complete();
                                    }
                                    var docIdsToChangesAndEmits = {};
                                    for (var i = 0, l = results.length; i < l; i++) {
                                        var change = results[i];
                                        if (change.doc._id[0] !== '_') {
                                            mapResults = [];
                                            doc = change.doc;

                                            if (!doc._deleted) {
                                                tryCode(view.sourceDB, mapFun, [doc]);
                                            }
                                            mapResults.sort(sortByKeyThenValue);

                                            var indexableKeysToKeyValues = {};
                                            var lastKey;
                                            for (var j = 0, jl = mapResults.length; j < jl; j++) {
                                                var obj = mapResults[j];
                                                var complexKey = [obj.key, obj.id];
                                                if (collate$2(obj.key, lastKey) === 0) {
                                                    complexKey.push(j); // dup key+id, so make it unique
                                                }
                                                var indexableKey = toIndexableString(complexKey);
                                                indexableKeysToKeyValues[indexableKey] = obj;
                                                lastKey = obj.key;
                                            }
                                            docIdsToChangesAndEmits[change.doc._id] = {
                                                indexableKeysToKeyValues: indexableKeysToKeyValues,
                                                changes: change.changes
                                            };
                                        }
                                        currentSeq = change.seq;
                                    }
                                    queue.add(processChange(docIdsToChangesAndEmits, currentSeq));
                                    if (results.length < CHANGES_BATCH_SIZE$1) {
                                        return complete();
                                    }
                                    return processNextBatch();
                                }).on('error', onError);
                                /* istanbul ignore next */
                                function onError(err) {
                                    reject(err);
                                }
                            }

                            processNextBatch();
                        });
                    }

                    function reduceView(view, results, options) {
                        if (options.group_level === 0) {
                            delete options.group_level;
                        }

                        var shouldGroup = options.group || options.group_level;

                        var reduceFun;
                        if (builtInReduce[view.reduceFun]) {
                            reduceFun = builtInReduce[view.reduceFun];
                        } else {
                            reduceFun = evalfunc(
                                view.reduceFun.toString(), null, sum, log$2, Array.isArray, JSON.parse);
                        }

                        var groups = [];
                        var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :
                            options.group_level;
                        results.forEach(function (e) {
                            var last = groups[groups.length - 1];
                            var groupKey = shouldGroup ? e.key : null;

                            // only set group_level for array keys
                            if (shouldGroup && Array.isArray(groupKey)) {
                                groupKey = groupKey.slice(0, lvl);
                            }

                            if (last && collate$2(last.groupKey, groupKey) === 0) {
                                last.keys.push([e.key, e.id]);
                                last.values.push(e.value);
                                return;
                            }
                            groups.push({
                                keys: [[e.key, e.id]],
                                values: [e.value],
                                groupKey: groupKey
                            });
                        });
                        results = [];
                        for (var i = 0, len = groups.length; i < len; i++) {
                            var e = groups[i];
                            var reduceTry = tryCode(view.sourceDB, reduceFun,
                                [e.keys, e.values, false]);
                            if (reduceTry.error && reduceTry.error instanceof BuiltInError) {
                                // CouchDB returns an error if a built-in errors out
                                throw reduceTry.error;
                            }
                            results.push({
                                // CouchDB just sets the value to null if a non-built-in errors out
                                value: reduceTry.error ? null : reduceTry.output,
                                key: e.groupKey
                            });
                        }
                        // no total_rows/offset when reducing
                        return { rows: sliceResults(results, options.limit, options.skip) };
                    }

                    function queryView(view, opts) {
                        return sequentialize(getQueue(view), function () {
                            return queryViewInQueue(view, opts);
                        })();
                    }

                    function queryViewInQueue(view, opts) {
                        var totalRows;
                        var shouldReduce = view.reduceFun && opts.reduce !== false;
                        var skip = opts.skip || 0;
                        if (typeof opts.keys !== 'undefined' && !opts.keys.length) {
                            // equivalent query
                            opts.limit = 0;
                            delete opts.keys;
                        }

                        function fetchFromView(viewOpts) {
                            viewOpts.include_docs = true;
                            return view.db.allDocs(viewOpts).then(function (res) {
                                totalRows = res.total_rows;
                                return res.rows.map(function (result) {

                                    // implicit migration - in older versions of PouchDB,
                                    // we explicitly stored the doc as {id: ..., key: ..., value: ...}
                                    // this is tested in a migration test
                                    /* istanbul ignore next */
                                    if ('value' in result.doc && typeof result.doc.value === 'object' &&
                                        result.doc.value !== null) {
                                        var keys = Object.keys(result.doc.value).sort();
                                        // this detection method is not perfect, but it's unlikely the user
                                        // emitted a value which was an object with these 3 exact keys
                                        var expectedKeys = ['id', 'key', 'value'];
                                        if (!(keys < expectedKeys || keys > expectedKeys)) {
                                            return result.doc.value;
                                        }
                                    }

                                    var parsedKeyAndDocId = parseIndexableString(result.doc._id);
                                    return {
                                        key: parsedKeyAndDocId[0],
                                        id: parsedKeyAndDocId[1],
                                        value: ('value' in result.doc ? result.doc.value : null)
                                    };
                                });
                            });
                        }

                        function onMapResultsReady(rows) {
                            var finalResults;
                            if (shouldReduce) {
                                finalResults = reduceView(view, rows, opts);
                            } else {
                                finalResults = {
                                    total_rows: totalRows,
                                    offset: skip,
                                    rows: rows
                                };
                            }
                            if (opts.include_docs) {
                                var docIds = uniq(rows.map(rowToDocId));

                                return view.sourceDB.allDocs({
                                    keys: docIds,
                                    include_docs: true,
                                    conflicts: opts.conflicts,
                                    attachments: opts.attachments,
                                    binary: opts.binary
                                }).then(function (allDocsRes) {
                                    var docIdsToDocs = {};
                                    allDocsRes.rows.forEach(function (row) {
                                        if (row.doc) {
                                            docIdsToDocs['$' + row.id] = row.doc;
                                        }
                                    });
                                    rows.forEach(function (row) {
                                        var docId = rowToDocId(row);
                                        var doc = docIdsToDocs['$' + docId];
                                        if (doc) {
                                            row.doc = doc;
                                        }
                                    });
                                    return finalResults;
                                });
                            } else {
                                return finalResults;
                            }
                        }

                        if (typeof opts.keys !== 'undefined') {
                            var keys = opts.keys;
                            var fetchPromises = keys.map(function (key) {
                                var viewOpts = {
                                    startkey: toIndexableString([key]),
                                    endkey: toIndexableString([key, {}])
                                };
                                return fetchFromView(viewOpts);
                            });
                            return PouchPromise.all(fetchPromises).then(flatten).then(onMapResultsReady);
                        } else { // normal query, no 'keys'
                            var viewOpts = {
                                descending: opts.descending
                            };
                            if (opts.start_key) {
                                opts.startkey = opts.start_key;
                            }
                            if (opts.end_key) {
                                opts.endkey = opts.end_key;
                            }
                            if (typeof opts.startkey !== 'undefined') {
                                viewOpts.startkey = opts.descending ?
                                    toIndexableString([opts.startkey, {}]) :
                                    toIndexableString([opts.startkey]);
                            }
                            if (typeof opts.endkey !== 'undefined') {
                                var inclusiveEnd = opts.inclusive_end !== false;
                                if (opts.descending) {
                                    inclusiveEnd = !inclusiveEnd;
                                }

                                viewOpts.endkey = toIndexableString(
                                    inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);
                            }
                            if (typeof opts.key !== 'undefined') {
                                var keyStart = toIndexableString([opts.key]);
                                var keyEnd = toIndexableString([opts.key, {}]);
                                if (viewOpts.descending) {
                                    viewOpts.endkey = keyStart;
                                    viewOpts.startkey = keyEnd;
                                } else {
                                    viewOpts.startkey = keyStart;
                                    viewOpts.endkey = keyEnd;
                                }
                            }
                            if (!shouldReduce) {
                                if (typeof opts.limit === 'number') {
                                    viewOpts.limit = opts.limit;
                                }
                                viewOpts.skip = skip;
                            }
                            return fetchFromView(viewOpts).then(onMapResultsReady);
                        }
                    }

                    function httpViewCleanup(db) {
                        return db.request({
                            method: 'POST',
                            url: '_view_cleanup'
                        });
                    }

                    function localViewCleanup(db) {
                        return db.get('_local/mrviews').then(function (metaDoc) {
                            var docsToViews = {};
                            Object.keys(metaDoc.views).forEach(function (fullViewName) {
                                var parts = parseViewName(fullViewName);
                                var designDocName = '_design/' + parts[0];
                                var viewName = parts[1];
                                docsToViews[designDocName] = docsToViews[designDocName] || {};
                                docsToViews[designDocName][viewName] = true;
                            });
                            var opts = {
                                keys: Object.keys(docsToViews),
                                include_docs: true
                            };
                            return db.allDocs(opts).then(function (res) {
                                var viewsToStatus = {};
                                res.rows.forEach(function (row) {
                                    var ddocName = row.key.substring(8);
                                    Object.keys(docsToViews[row.key]).forEach(function (viewName) {
                                        var fullViewName = ddocName + '/' + viewName;
                                        /* istanbul ignore if */
                                        if (!metaDoc.views[fullViewName]) {
                                            // new format, without slashes, to support PouchDB 2.2.0
                                            // migration test in pouchdb's browser.migration.js verifies this
                                            fullViewName = viewName;
                                        }
                                        var viewDBNames = Object.keys(metaDoc.views[fullViewName]);
                                        // design doc deleted, or view function nonexistent
                                        var statusIsGood = row.doc && row.doc.views &&
                                            row.doc.views[viewName];
                                        viewDBNames.forEach(function (viewDBName) {
                                            viewsToStatus[viewDBName] =
                                                viewsToStatus[viewDBName] || statusIsGood;
                                        });
                                    });
                                });
                                var dbsToDelete = Object.keys(viewsToStatus).filter(
                                    function (viewDBName) {
                                        return !viewsToStatus[viewDBName];
                                    });
                                var destroyPromises = dbsToDelete.map(function (viewDBName) {
                                    return sequentialize(getQueue(viewDBName), function () {
                                        return new db.constructor(viewDBName, db.__opts).destroy();
                                    })();
                                });
                                return PouchPromise.all(destroyPromises).then(function () {
                                    return { ok: true };
                                });
                            });
                        }, defaultsTo({ ok: true }));
                    }

                    var viewCleanup = callbackify(function () {
                        var db = this;
                        if (db._ddocCache) {
                            delete db._ddocCache;
                        }
                        if (db.type() === 'http') {
                            return httpViewCleanup(db);
                        }
                        /* istanbul ignore next */
                        if (typeof db._viewCleanup === 'function') {
                            return customViewCleanup(db);
                        }
                        return localViewCleanup(db);
                    });

                    function queryPromised(db, fun, opts) {
                        if (db.type() === 'http') {
                            return httpQuery(db, fun, opts);
                        }

                        /* istanbul ignore next */
                        if (typeof db._query === 'function') {
                            return customQuery(db, fun, opts);
                        }

                        if (typeof fun !== 'string') {
                            // temp_view
                            checkQueryParseError(opts, fun);

                            var createViewOpts = {
                                db: db,
                                viewName: 'temp_view/temp_view',
                                map: fun.map,
                                reduce: fun.reduce,
                                temporary: true
                            };
                            tempViewQueue.add(function () {
                                return createView(createViewOpts).then(function (view) {
                                    function cleanup() {
                                        return view.db.destroy();
                                    }

                                    return fin(updateView(view).then(function () {
                                        return queryView(view, opts);
                                    }), cleanup);
                                });
                            });
                            return tempViewQueue.finish();
                        } else {
                            // persistent view
                            var fullViewName = fun;
                            var parts = parseViewName(fullViewName);
                            var designDocName = parts[0];
                            var viewName = parts[1];
                            return db.getView(designDocName, viewName).then(function (fun) {
                                checkQueryParseError(opts, fun);

                                var createViewOpts = {
                                    db: db,
                                    viewName: fullViewName,
                                    map: fun.map,
                                    reduce: fun.reduce
                                };
                                return createView(createViewOpts).then(function (view) {
                                    if (opts.stale === 'ok' || opts.stale === 'update_after') {
                                        if (opts.stale === 'update_after') {
                                            process.nextTick(function () {
                                                updateView(view);
                                            });
                                        }
                                        return queryView(view, opts);
                                    } else { // stale not ok
                                        return updateView(view).then(function () {
                                            return queryView(view, opts);
                                        });
                                    }
                                });
                            });
                        }
                    }

                    var query = function (fun, opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        opts = opts ? coerceOptions(opts) : {};

                        if (typeof fun === 'function') {
                            fun = { map: fun };
                        }

                        var db = this;
                        var promise = PouchPromise.resolve().then(function () {
                            return queryPromised(db, fun, opts);
                        });
                        promisedCallback(promise, callback);
                        return promise;
                    };

                    function QueryParseError(message) {
                        this.status = 400;
                        this.name = 'query_parse_error';
                        this.message = message;
                        this.error = true;
                        try {
                            Error.captureStackTrace(this, QueryParseError);
                        } catch (e) {
                        }
                    }

                    inherits(QueryParseError, Error);

                    function BuiltInError(message) {
                        this.status = 500;
                        this.name = 'invalid_value';
                        this.message = message;
                        this.error = true;
                        try {
                            Error.captureStackTrace(this, BuiltInError);
                        } catch (e) {
                        }
                    }

                    inherits(BuiltInError, Error);

                    var mapreduce = {
                        query: query,
                        viewCleanup: viewCleanup
                    };

                    function arrayBufferToBase64(buffer) {
                        return btoa$1(arrayBufferToBinaryString(buffer));
                    }

                    function preprocessAttachments$1(docInfos, blobType, callback) {

                        if (!docInfos.length) {
                            return callback();
                        }

                        var docv = 0;

                        function parseBase64(data) {
                            try {
                                return atob$1(data);
                            } catch (e) {
                                var err = createError(BAD_ARG,
                                    'Attachment is not a valid base64 string');
                                return { error: err };
                            }
                        }

                        function preprocessAttachment(att, callback) {
                            if (att.stub) {
                                return callback();
                            }
                            if (typeof att.data === 'string') {
                                // input is assumed to be a base64 string

                                var asBinary = parseBase64(att.data);
                                if (asBinary.error) {
                                    return callback(asBinary.error);
                                }

                                att.length = asBinary.length;
                                if (blobType === 'blob') {
                                    att.data = binStringToBluffer(asBinary, att.content_type);
                                } else if (blobType === 'base64') {
                                    att.data = btoa$1(asBinary);
                                } else { // binary
                                    att.data = asBinary;
                                }
                                md5(asBinary).then(function (result) {
                                    att.digest = 'md5-' + result;
                                    callback();
                                });
                            } else { // input is a blob
                                readAsArrayBuffer(att.data, function (buff) {
                                    if (blobType === 'binary') {
                                        att.data = arrayBufferToBinaryString(buff);
                                    } else if (blobType === 'base64') {
                                        att.data = arrayBufferToBase64(buff);
                                    }
                                    md5(buff).then(function (result) {
                                        att.digest = 'md5-' + result;
                                        att.length = buff.byteLength;
                                        callback();
                                    });
                                });
                            }
                        }

                        var overallErr;

                        docInfos.forEach(function (docInfo) {
                            var attachments = docInfo.data && docInfo.data._attachments ?
                                Object.keys(docInfo.data._attachments) : [];
                            var recv = 0;

                            if (!attachments.length) {
                                return done();
                            }

                            function processedAttachment(err) {
                                overallErr = err;
                                recv++;
                                if (recv === attachments.length) {
                                    done();
                                }
                            }

                            for (var key in docInfo.data._attachments) {
                                if (docInfo.data._attachments.hasOwnProperty(key)) {
                                    preprocessAttachment(docInfo.data._attachments[key],
                                        processedAttachment);
                                }
                            }
                        });

                        function done() {
                            docv++;
                            if (docInfos.length === docv) {
                                if (overallErr) {
                                    callback(overallErr);
                                } else {
                                    callback();
                                }
                            }
                        }
                    }

                    function sortByPos$1(a, b) {
                        return a.pos - b.pos;
                    }

// classic binary search
                    function binarySearch(arr, item, comparator) {
                        var low = 0;
                        var high = arr.length;
                        var mid;
                        while (low < high) {
                            mid = (low + high) >>> 1;
                            if (comparator(arr[mid], item) < 0) {
                                low = mid + 1;
                            } else {
                                high = mid;
                            }
                        }
                        return low;
                    }

// assuming the arr is sorted, insert the item in the proper place
                    function insertSorted(arr, item, comparator) {
                        var idx = binarySearch(arr, item, comparator);
                        arr.splice(idx, 0, item);
                    }

// Turn a path as a flat array into a tree with a single branch.
// If any should be stemmed from the beginning of the array, that's passed
// in as the second argument
                    function pathToTree(path, numStemmed) {
                        var root;
                        var leaf;
                        for (var i = numStemmed, len = path.length; i < len; i++) {
                            var node = path[i];
                            var currentLeaf = [node.id, node.opts, []];
                            if (leaf) {
                                leaf[2].push(currentLeaf);
                                leaf = currentLeaf;
                            } else {
                                root = leaf = currentLeaf;
                            }
                        }
                        return root;
                    }

// compare the IDs of two trees
                    function compareTree(a, b) {
                        return a[0] < b[0] ? -1 : 1;
                    }

// Merge two trees together
// The roots of tree1 and tree2 must be the same revision
                    function mergeTree(in_tree1, in_tree2) {
                        var queue = [{ tree1: in_tree1, tree2: in_tree2 }];
                        var conflicts = false;
                        while (queue.length > 0) {
                            var item = queue.pop();
                            var tree1 = item.tree1;
                            var tree2 = item.tree2;

                            if (tree1[1].status || tree2[1].status) {
                                tree1[1].status =
                                    (tree1[1].status === 'available' ||
                                    tree2[1].status === 'available') ? 'available' : 'missing';
                            }

                            for (var i = 0; i < tree2[2].length; i++) {
                                if (!tree1[2][0]) {
                                    conflicts = 'new_leaf';
                                    tree1[2][0] = tree2[2][i];
                                    continue;
                                }

                                var merged = false;
                                for (var j = 0; j < tree1[2].length; j++) {
                                    if (tree1[2][j][0] === tree2[2][i][0]) {
                                        queue.push({ tree1: tree1[2][j], tree2: tree2[2][i] });
                                        merged = true;
                                    }
                                }
                                if (!merged) {
                                    conflicts = 'new_branch';
                                    insertSorted(tree1[2], tree2[2][i], compareTree);
                                }
                            }
                        }
                        return { conflicts: conflicts, tree: in_tree1 };
                    }

                    function doMerge(tree, path, dontExpand) {
                        var restree = [];
                        var conflicts = false;
                        var merged = false;
                        var res;

                        if (!tree.length) {
                            return { tree: [path], conflicts: 'new_leaf' };
                        }

                        for (var i = 0, len = tree.length; i < len; i++) {
                            var branch = tree[i];
                            if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {
                                // Paths start at the same position and have the same root, so they need
                                // merged
                                res = mergeTree(branch.ids, path.ids);
                                restree.push({ pos: branch.pos, ids: res.tree });
                                conflicts = conflicts || res.conflicts;
                                merged = true;
                            } else if (dontExpand !== true) {
                                // The paths start at a different position, take the earliest path and
                                // traverse up until it as at the same point from root as the path we
                                // want to merge.  If the keys match we return the longer path with the
                                // other merged After stemming we dont want to expand the trees

                                var t1 = branch.pos < path.pos ? branch : path;
                                var t2 = branch.pos < path.pos ? path : branch;
                                var diff = t2.pos - t1.pos;

                                var candidateParents = [];

                                var trees = [];
                                trees.push({ ids: t1.ids, diff: diff, parent: null, parentIdx: null });
                                while (trees.length > 0) {
                                    var item = trees.pop();
                                    if (item.diff === 0) {
                                        if (item.ids[0] === t2.ids[0]) {
                                            candidateParents.push(item);
                                        }
                                        continue;
                                    }
                                    var elements = item.ids[2];
                                    for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {
                                        trees.push({
                                            ids: elements[j],
                                            diff: item.diff - 1,
                                            parent: item.ids,
                                            parentIdx: j
                                        });
                                    }
                                }

                                var el = candidateParents[0];

                                if (!el) {
                                    restree.push(branch);
                                } else {
                                    res = mergeTree(el.ids, t2.ids);
                                    el.parent[2][el.parentIdx] = res.tree;
                                    restree.push({ pos: t1.pos, ids: t1.ids });
                                    conflicts = conflicts || res.conflicts;
                                    merged = true;
                                }
                            } else {
                                restree.push(branch);
                            }
                        }

                        // We didnt find
                        if (!merged) {
                            restree.push(path);
                        }

                        restree.sort(sortByPos$1);

                        return {
                            tree: restree,
                            conflicts: conflicts || 'internal_node'
                        };
                    }

// To ensure we dont grow the revision tree infinitely, we stem old revisions
                    function stem(tree, depth) {
                        // First we break out the tree into a complete list of root to leaf paths
                        var paths = rootToLeaf(tree);
                        var maybeStem = {};

                        var result;
                        for (var i = 0, len = paths.length; i < len; i++) {
                            // Then for each path, we cut off the start of the path based on the
                            // `depth` to stem to, and generate a new set of flat trees
                            var path = paths[i];
                            var stemmed = path.ids;
                            var numStemmed = Math.max(0, stemmed.length - depth);
                            var stemmedNode = {
                                pos: path.pos + numStemmed,
                                ids: pathToTree(stemmed, numStemmed)
                            };

                            for (var s = 0; s < numStemmed; s++) {
                                var rev = (path.pos + s) + '-' + stemmed[s].id;
                                maybeStem[rev] = true;
                            }

                            // Then we remerge all those flat trees together, ensuring that we dont
                            // connect trees that would go beyond the depth limit
                            if (result) {
                                result = doMerge(result, stemmedNode, true).tree;
                            } else {
                                result = [stemmedNode];
                            }
                        }

                        traverseRevTree(result, function (isLeaf, pos, revHash) {
                            // some revisions may have been removed in a branch but not in another
                            delete maybeStem[pos + '-' + revHash];
                        });

                        return {
                            tree: result,
                            revs: Object.keys(maybeStem)
                        };
                    }

                    function merge(tree, path, depth) {
                        var newTree = doMerge(tree, path);
                        var stemmed = stem(newTree.tree, depth);
                        return {
                            tree: stemmed.tree,
                            stemmedRevs: stemmed.revs,
                            conflicts: newTree.conflicts
                        };
                    }

// return true if a rev exists in the rev tree, false otherwise
                    function revExists(revs, rev) {
                        var toVisit = revs.slice();
                        var splitRev = rev.split('-');
                        var targetPos = parseInt(splitRev[0], 10);
                        var targetId = splitRev[1];

                        var node;
                        while ((node = toVisit.pop())) {
                            if (node.pos === targetPos && node.ids[0] === targetId) {
                                return true;
                            }
                            var branches = node.ids[2];
                            for (var i = 0, len = branches.length; i < len; i++) {
                                toVisit.push({ pos: node.pos + 1, ids: branches[i] });
                            }
                        }
                        return false;
                    }

                    function updateDoc(revLimit, prev, docInfo, results,
                                       i, cb, writeDoc, newEdits) {

                        if (revExists(prev.rev_tree, docInfo.metadata.rev)) {
                            results[i] = docInfo;
                            return cb();
                        }

                        // sometimes this is pre-calculated. historically not always
                        var previousWinningRev = prev.winningRev || winningRev(prev);
                        var previouslyDeleted = 'deleted' in prev ? prev.deleted :
                            isDeleted(prev, previousWinningRev);
                        var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :
                            isDeleted(docInfo.metadata);
                        var isRoot = /^1-/.test(docInfo.metadata.rev);

                        if (previouslyDeleted && !deleted && newEdits && isRoot) {
                            var newDoc = docInfo.data;
                            newDoc._rev = previousWinningRev;
                            newDoc._id = docInfo.metadata.id;
                            docInfo = parseDoc(newDoc, newEdits);
                        }

                        var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);

                        var inConflict = newEdits && (((previouslyDeleted && deleted) ||
                            (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||
                            (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));

                        if (inConflict) {
                            var err = createError(REV_CONFLICT);
                            results[i] = err;
                            return cb();
                        }

                        var newRev = docInfo.metadata.rev;
                        docInfo.metadata.rev_tree = merged.tree;
                        docInfo.stemmedRevs = merged.stemmedRevs || [];
                        /* istanbul ignore else */
                        if (prev.rev_map) {
                            docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb
                        }

                        // recalculate
                        var winningRev$$ = winningRev(docInfo.metadata);
                        var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$);

                        // calculate the total number of documents that were added/removed,
                        // from the perspective of total_rows/doc_count
                        var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :
                            previouslyDeleted < winningRevIsDeleted ? -1 : 1;

                        var newRevIsDeleted;
                        if (newRev === winningRev$$) {
                            // if the new rev is the same as the winning rev, we can reuse that value
                            newRevIsDeleted = winningRevIsDeleted;
                        } else {
                            // if they're not the same, then we need to recalculate
                            newRevIsDeleted = isDeleted(docInfo.metadata, newRev);
                        }

                        writeDoc(docInfo, winningRev$$, winningRevIsDeleted, newRevIsDeleted,
                            true, delta, i, cb);
                    }

                    function rootIsMissing(docInfo) {
                        return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';
                    }

                    function processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,
                                         writeDoc, opts, overallCallback) {

                        // Default to 1000 locally
                        revLimit = revLimit || 1000;

                        function insertDoc(docInfo, resultsIdx, callback) {
                            // Cant insert new deleted documents
                            var winningRev$$ = winningRev(docInfo.metadata);
                            var deleted = isDeleted(docInfo.metadata, winningRev$$);
                            if ('was_delete' in opts && deleted) {
                                results[resultsIdx] = createError(MISSING_DOC, 'deleted');
                                return callback();
                            }

                            // 4712 - detect whether a new document was inserted with a _rev
                            var inConflict = newEdits && rootIsMissing(docInfo);

                            if (inConflict) {
                                var err = createError(REV_CONFLICT);
                                results[resultsIdx] = err;
                                return callback();
                            }

                            var delta = deleted ? 0 : 1;

                            writeDoc(docInfo, winningRev$$, deleted, deleted, false,
                                delta, resultsIdx, callback);
                        }

                        var newEdits = opts.new_edits;
                        var idsToDocs = new pouchdbCollections.Map();

                        var docsDone = 0;
                        var docsToDo = docInfos.length;

                        function checkAllDocsDone() {
                            if (++docsDone === docsToDo && overallCallback) {
                                overallCallback();
                            }
                        }

                        docInfos.forEach(function (currentDoc, resultsIdx) {

                            if (currentDoc._id && isLocalId(currentDoc._id)) {
                                var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';
                                api[fun](currentDoc, { ctx: tx }, function (err, res) {
                                    results[resultsIdx] = err || res;
                                    checkAllDocsDone();
                                });
                                return;
                            }

                            var id = currentDoc.metadata.id;
                            if (idsToDocs.has(id)) {
                                docsToDo--; // duplicate
                                idsToDocs.get(id).push([currentDoc, resultsIdx]);
                            } else {
                                idsToDocs.set(id, [[currentDoc, resultsIdx]]);
                            }
                        });

                        // in the case of new_edits, the user can provide multiple docs
                        // with the same id. these need to be processed sequentially
                        idsToDocs.forEach(function (docs, id) {
                            var numDone = 0;

                            function docWritten() {
                                if (++numDone < docs.length) {
                                    nextDoc();
                                } else {
                                    checkAllDocsDone();
                                }
                            }

                            function nextDoc() {
                                var value = docs[numDone];
                                var currentDoc = value[0];
                                var resultsIdx = value[1];

                                if (fetchedDocs.has(id)) {
                                    updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,
                                        resultsIdx, docWritten, writeDoc, newEdits);
                                } else {
                                    // Ensure stemming applies to new writes as well
                                    var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);
                                    currentDoc.metadata.rev_tree = merged.tree;
                                    currentDoc.stemmedRevs = merged.stemmedRevs || [];
                                    insertDoc(currentDoc, resultsIdx, docWritten);
                                }
                            }

                            nextDoc();
                        });
                    }

// compact a tree by marking its non-leafs as missing,
// and return a list of revs to delete
                    function compactTree(metadata) {
                        var revs = [];
                        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                                     revHash, ctx, opts) {
                            if (opts.status === 'available' && !isLeaf) {
                                revs.push(pos + '-' + revHash);
                                opts.status = 'missing';
                            }
                        });
                        return revs;
                    }

// IndexedDB requires a versioned database structure, so we use the
// version here to manage migrations.
                    var ADAPTER_VERSION = 5;

// The object stores created for each database
// DOC_STORE stores the document meta data, its revision history and state
// Keyed by document id
                    var DOC_STORE = 'document-store';
// BY_SEQ_STORE stores a particular version of a document, keyed by its
// sequence id
                    var BY_SEQ_STORE = 'by-sequence';
// Where we store attachments
                    var ATTACH_STORE = 'attach-store';
// Where we store many-to-many relations
// between attachment digests and seqs
                    var ATTACH_AND_SEQ_STORE = 'attach-seq-store';

// Where we store database-wide meta data in a single record
// keyed by id: META_STORE
                    var META_STORE = 'meta-store';
// Where we store local documents
                    var LOCAL_STORE = 'local-store';
// Where we detect blob support
                    var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';

                    function slowJsonParse(str) {
                        try {
                            return JSON.parse(str);
                        } catch (e) {
                            /* istanbul ignore next */
                            return vuvuzela.parse(str);
                        }
                    }

                    function safeJsonParse(str) {
                        // try/catch is deoptimized in V8, leading to slower
                        // times than we'd like to have. Most documents are _not_
                        // huge, and do not require a slower code path just to parse them.
                        // We can be pretty sure that a document under 50000 characters
                        // will not be so deeply nested as to throw a stack overflow error
                        // (depends on the engine and available memory, though, so this is
                        // just a hunch). 50000 was chosen based on the average length
                        // of this string in our test suite, to try to find a number that covers
                        // most of our test cases (26 over this size, 26378 under it).
                        if (str.length < 50000) {
                            return JSON.parse(str);
                        }
                        return slowJsonParse(str);
                    }

                    function safeJsonStringify(json) {
                        try {
                            return JSON.stringify(json);
                        } catch (e) {
                            /* istanbul ignore next */
                            return vuvuzela.stringify(json);
                        }
                    }

                    function tryCode$1(fun, that, args, PouchDB) {
                        try {
                            fun.apply(that, args);
                        } catch (err) {
                            // Shouldn't happen, but in some odd cases
                            // IndexedDB implementations might throw a sync
                            // error, in which case this will at least log it.
                            PouchDB.emit('error', err);
                        }
                    }

                    var taskQueue = {
                        running: false,
                        queue: []
                    };

                    function applyNext(PouchDB) {
                        if (taskQueue.running || !taskQueue.queue.length) {
                            return;
                        }
                        taskQueue.running = true;
                        var item = taskQueue.queue.shift();
                        item.action(function (err, res) {
                            tryCode$1(item.callback, this, [err, res], PouchDB);
                            taskQueue.running = false;
                            process.nextTick(function () {
                                applyNext(PouchDB);
                            });
                        });
                    }

                    function idbError(callback) {
                        return function (evt) {
                            var message = 'unknown_error';
                            if (evt.target && evt.target.error) {
                                message = evt.target.error.name || evt.target.error.message;
                            }
                            callback(createError(IDB_ERROR, message, evt.type));
                        };
                    }

// Unfortunately, the metadata has to be stringified
// when it is put into the database, because otherwise
// IndexedDB can throw errors for deeply-nested objects.
// Originally we just used JSON.parse/JSON.stringify; now
// we use this custom vuvuzela library that avoids recursion.
// If we could do it all over again, we'd probably use a
// format for the revision trees other than JSON.
                    function encodeMetadata(metadata, winningRev, deleted) {
                        return {
                            data: safeJsonStringify(metadata),
                            winningRev: winningRev,
                            deletedOrLocal: deleted ? '1' : '0',
                            seq: metadata.seq, // highest seq for this doc
                            id: metadata.id
                        };
                    }

                    function decodeMetadata(storedObject) {
                        if (!storedObject) {
                            return null;
                        }
                        var metadata = safeJsonParse(storedObject.data);
                        metadata.winningRev = storedObject.winningRev;
                        metadata.deleted = storedObject.deletedOrLocal === '1';
                        metadata.seq = storedObject.seq;
                        return metadata;
                    }

// read the doc back out from the database. we don't store the
// _id or _rev because we already have _doc_id_rev.
                    function decodeDoc(doc) {
                        if (!doc) {
                            return doc;
                        }
                        var idx = doc._doc_id_rev.lastIndexOf(':');
                        doc._id = doc._doc_id_rev.substring(0, idx - 1);
                        doc._rev = doc._doc_id_rev.substring(idx + 1);
                        delete doc._doc_id_rev;
                        return doc;
                    }

// Read a blob from the database, encoding as necessary
// and translating from base64 if the IDB doesn't support
// native Blobs
                    function readBlobData(body, type, asBlob, callback) {
                        if (asBlob) {
                            if (!body) {
                                callback(createBlob([''], { type: type }));
                            } else if (typeof body !== 'string') { // we have blob support
                                callback(body);
                            } else { // no blob support
                                callback(b64ToBluffer(body, type));
                            }
                        } else { // as base64 string
                            if (!body) {
                                callback('');
                            } else if (typeof body !== 'string') { // we have blob support
                                readAsBinaryString(body, function (binary) {
                                    callback(btoa$1(binary));
                                });
                            } else { // no blob support
                                callback(body);
                            }
                        }
                    }

                    function fetchAttachmentsIfNecessary(doc, opts, txn, cb) {
                        var attachments = Object.keys(doc._attachments || {});
                        if (!attachments.length) {
                            return cb && cb();
                        }
                        var numDone = 0;

                        function checkDone() {
                            if (++numDone === attachments.length && cb) {
                                cb();
                            }
                        }

                        function fetchAttachment(doc, att) {
                            var attObj = doc._attachments[att];
                            var digest = attObj.digest;
                            var req = txn.objectStore(ATTACH_STORE).get(digest);
                            req.onsuccess = function (e) {
                                attObj.body = e.target.result.body;
                                checkDone();
                            };
                        }

                        attachments.forEach(function (att) {
                            if (opts.attachments && opts.include_docs) {
                                fetchAttachment(doc, att);
                            } else {
                                doc._attachments[att].stub = true;
                                checkDone();
                            }
                        });
                    }

// IDB-specific postprocessing necessary because
// we don't know whether we stored a true Blob or
// a base64-encoded string, and if it's a Blob it
// needs to be read outside of the transaction context
                    function postProcessAttachments(results, asBlob) {
                        return PouchPromise.all(results.map(function (row) {
                            if (row.doc && row.doc._attachments) {
                                var attNames = Object.keys(row.doc._attachments);
                                return PouchPromise.all(attNames.map(function (att) {
                                    var attObj = row.doc._attachments[att];
                                    if (!('body' in attObj)) { // already processed
                                        return;
                                    }
                                    var body = attObj.body;
                                    var type = attObj.content_type;
                                    return new PouchPromise(function (resolve) {
                                        readBlobData(body, type, asBlob, function (data) {
                                            row.doc._attachments[att] = jsExtend.extend(
                                                pick(attObj, ['digest', 'content_type']),
                                                { data: data }
                                            );
                                            resolve();
                                        });
                                    });
                                }));
                            }
                        }));
                    }

                    function compactRevs(revs, docId, txn) {

                        var possiblyOrphanedDigests = [];
                        var seqStore = txn.objectStore(BY_SEQ_STORE);
                        var attStore = txn.objectStore(ATTACH_STORE);
                        var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
                        var count = revs.length;

                        function checkDone() {
                            count--;
                            if (!count) { // done processing all revs
                                deleteOrphanedAttachments();
                            }
                        }

                        function deleteOrphanedAttachments() {
                            if (!possiblyOrphanedDigests.length) {
                                return;
                            }
                            possiblyOrphanedDigests.forEach(function (digest) {
                                var countReq = attAndSeqStore.index('digestSeq').count(
                                    IDBKeyRange.bound(
                                        digest + '::', digest + '::\uffff', false, false));
                                countReq.onsuccess = function (e) {
                                    var count = e.target.result;
                                    if (!count) {
                                        // orphaned
                                        attStore["delete"](digest);
                                    }
                                };
                            });
                        }

                        revs.forEach(function (rev) {
                            var index = seqStore.index('_doc_id_rev');
                            var key = docId + "::" + rev;
                            index.getKey(key).onsuccess = function (e) {
                                var seq = e.target.result;
                                if (typeof seq !== 'number') {
                                    return checkDone();
                                }
                                seqStore["delete"](seq);

                                var cursor = attAndSeqStore.index('seq')
                                    .openCursor(IDBKeyRange.only(seq));

                                cursor.onsuccess = function (event) {
                                    var cursor = event.target.result;
                                    if (cursor) {
                                        var digest = cursor.value.digestSeq.split('::')[0];
                                        possiblyOrphanedDigests.push(digest);
                                        attAndSeqStore["delete"](cursor.primaryKey);
                                        cursor["continue"]();
                                    } else { // done
                                        checkDone();
                                    }
                                };
                            };
                        });
                    }

                    function openTransactionSafely(idb, stores, mode) {
                        try {
                            return {
                                txn: idb.transaction(stores, mode)
                            };
                        } catch (err) {
                            return {
                                error: err
                            };
                        }
                    }

                    function idbBulkDocs(dbOpts, req, opts, api, idb, idbChanges, callback) {
                        var docInfos = req.docs;
                        var txn;
                        var docStore;
                        var bySeqStore;
                        var attachStore;
                        var attachAndSeqStore;
                        var docInfoError;
                        var docCountDelta = 0;

                        for (var i = 0, len = docInfos.length; i < len; i++) {
                            var doc = docInfos[i];
                            if (doc._id && isLocalId(doc._id)) {
                                continue;
                            }
                            doc = docInfos[i] = parseDoc(doc, opts.new_edits);
                            if (doc.error && !docInfoError) {
                                docInfoError = doc;
                            }
                        }

                        if (docInfoError) {
                            return callback(docInfoError);
                        }

                        var results = new Array(docInfos.length);
                        var fetchedDocs = new pouchdbCollections.Map();
                        var preconditionErrored = false;
                        var blobType = api._meta.blobSupport ? 'blob' : 'base64';

                        preprocessAttachments$1(docInfos, blobType, function (err) {
                            if (err) {
                                return callback(err);
                            }
                            startTransaction();
                        });

                        function startTransaction() {

                            var stores = [
                                DOC_STORE, BY_SEQ_STORE,
                                ATTACH_STORE,
                                LOCAL_STORE, ATTACH_AND_SEQ_STORE
                            ];
                            var txnResult = openTransactionSafely(idb, stores, 'readwrite');
                            if (txnResult.error) {
                                return callback(txnResult.error);
                            }
                            txn = txnResult.txn;
                            txn.onabort = idbError(callback);
                            txn.ontimeout = idbError(callback);
                            txn.oncomplete = complete;
                            docStore = txn.objectStore(DOC_STORE);
                            bySeqStore = txn.objectStore(BY_SEQ_STORE);
                            attachStore = txn.objectStore(ATTACH_STORE);
                            attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);

                            verifyAttachments(function (err) {
                                if (err) {
                                    preconditionErrored = true;
                                    return callback(err);
                                }
                                fetchExistingDocs();
                            });
                        }

                        function idbProcessDocs() {
                            processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,
                                txn, results, writeDoc, opts);
                        }

                        function fetchExistingDocs() {

                            if (!docInfos.length) {
                                return;
                            }

                            var numFetched = 0;

                            function checkDone() {
                                if (++numFetched === docInfos.length) {
                                    idbProcessDocs();
                                }
                            }

                            function readMetadata(event) {
                                var metadata = decodeMetadata(event.target.result);

                                if (metadata) {
                                    fetchedDocs.set(metadata.id, metadata);
                                }
                                checkDone();
                            }

                            for (var i = 0, len = docInfos.length; i < len; i++) {
                                var docInfo = docInfos[i];
                                if (docInfo._id && isLocalId(docInfo._id)) {
                                    checkDone(); // skip local docs
                                    continue;
                                }
                                var req = docStore.get(docInfo.metadata.id);
                                req.onsuccess = readMetadata;
                            }
                        }

                        function complete() {
                            if (preconditionErrored) {
                                return;
                            }

                            idbChanges.notify(api._meta.name);
                            api._meta.docCount += docCountDelta;
                            callback(null, results);
                        }

                        function verifyAttachment(digest, callback) {

                            var req = attachStore.get(digest);
                            req.onsuccess = function (e) {
                                if (!e.target.result) {
                                    var err = createError(MISSING_STUB,
                                        'unknown stub attachment with digest ' +
                                        digest);
                                    err.status = 412;
                                    callback(err);
                                } else {
                                    callback();
                                }
                            };
                        }

                        function verifyAttachments(finish) {


                            var digests = [];
                            docInfos.forEach(function (docInfo) {
                                if (docInfo.data && docInfo.data._attachments) {
                                    Object.keys(docInfo.data._attachments).forEach(function (filename) {
                                        var att = docInfo.data._attachments[filename];
                                        if (att.stub) {
                                            digests.push(att.digest);
                                        }
                                    });
                                }
                            });
                            if (!digests.length) {
                                return finish();
                            }
                            var numDone = 0;
                            var err;

                            function checkDone() {
                                if (++numDone === digests.length) {
                                    finish(err);
                                }
                            }

                            digests.forEach(function (digest) {
                                verifyAttachment(digest, function (attErr) {
                                    if (attErr && !err) {
                                        err = attErr;
                                    }
                                    checkDone();
                                });
                            });
                        }

                        function writeDoc(docInfo, winningRev, winningRevIsDeleted, newRevIsDeleted,
                                          isUpdate, delta, resultsIdx, callback) {

                            docCountDelta += delta;

                            docInfo.metadata.winningRev = winningRev;
                            docInfo.metadata.deleted = winningRevIsDeleted;

                            var doc = docInfo.data;
                            doc._id = docInfo.metadata.id;
                            doc._rev = docInfo.metadata.rev;

                            if (newRevIsDeleted) {
                                doc._deleted = true;
                            }

                            var hasAttachments = doc._attachments &&
                                Object.keys(doc._attachments).length;
                            if (hasAttachments) {
                                return writeAttachments(docInfo, winningRev, winningRevIsDeleted,
                                    isUpdate, resultsIdx, callback);
                            }

                            finishDoc(docInfo, winningRev, winningRevIsDeleted,
                                isUpdate, resultsIdx, callback);
                        }

                        function autoCompact(docInfo) {

                            var revsToDelete = compactTree(docInfo.metadata);
                            compactRevs(revsToDelete, docInfo.metadata.id, txn);
                        }

                        function finishDoc(docInfo, winningRev, winningRevIsDeleted,
                                           isUpdate, resultsIdx, callback) {

                            var doc = docInfo.data;
                            var metadata = docInfo.metadata;

                            doc._doc_id_rev = metadata.id + '::' + metadata.rev;
                            delete doc._id;
                            delete doc._rev;

                            function afterPutDoc(e) {
                                if (isUpdate && api.auto_compaction) {
                                    autoCompact(docInfo);
                                } else if (docInfo.stemmedRevs.length) {
                                    compactRevs(docInfo.stemmedRevs, docInfo.metadata.id, txn);
                                }

                                metadata.seq = e.target.result;
                                // Current _rev is calculated from _rev_tree on read
                                delete metadata.rev;
                                var metadataToStore = encodeMetadata(metadata, winningRev,
                                    winningRevIsDeleted);
                                var metaDataReq = docStore.put(metadataToStore);
                                metaDataReq.onsuccess = afterPutMetadata;
                            }

                            function afterPutDocError(e) {
                                // ConstraintError, need to update, not put (see #1638 for details)
                                e.preventDefault(); // avoid transaction abort
                                e.stopPropagation(); // avoid transaction onerror
                                var index = bySeqStore.index('_doc_id_rev');
                                var getKeyReq = index.getKey(doc._doc_id_rev);
                                getKeyReq.onsuccess = function (e) {
                                    var putReq = bySeqStore.put(doc, e.target.result);
                                    putReq.onsuccess = afterPutDoc;
                                };
                            }

                            function afterPutMetadata() {
                                results[resultsIdx] = {
                                    ok: true,
                                    id: metadata.id,
                                    rev: winningRev
                                };
                                fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);
                                insertAttachmentMappings(docInfo, metadata.seq, callback);
                            }

                            var putReq = bySeqStore.put(doc);

                            putReq.onsuccess = afterPutDoc;
                            putReq.onerror = afterPutDocError;
                        }

                        function writeAttachments(docInfo, winningRev, winningRevIsDeleted,
                                                  isUpdate, resultsIdx, callback) {


                            var doc = docInfo.data;

                            var numDone = 0;
                            var attachments = Object.keys(doc._attachments);

                            function collectResults() {
                                if (numDone === attachments.length) {
                                    finishDoc(docInfo, winningRev, winningRevIsDeleted,
                                        isUpdate, resultsIdx, callback);
                                }
                            }

                            function attachmentSaved() {
                                numDone++;
                                collectResults();
                            }

                            attachments.forEach(function (key) {
                                var att = docInfo.data._attachments[key];
                                if (!att.stub) {
                                    var data = att.data;
                                    delete att.data;
                                    var digest = att.digest;
                                    saveAttachment(digest, data, attachmentSaved);
                                } else {
                                    numDone++;
                                    collectResults();
                                }
                            });
                        }

                        // map seqs to attachment digests, which
                        // we will need later during compaction
                        function insertAttachmentMappings(docInfo, seq, callback) {

                            var attsAdded = 0;
                            var attsToAdd = Object.keys(docInfo.data._attachments || {});

                            if (!attsToAdd.length) {
                                return callback();
                            }

                            function checkDone() {
                                if (++attsAdded === attsToAdd.length) {
                                    callback();
                                }
                            }

                            function add(att) {
                                var digest = docInfo.data._attachments[att].digest;
                                var req = attachAndSeqStore.put({
                                    seq: seq,
                                    digestSeq: digest + '::' + seq
                                });

                                req.onsuccess = checkDone;
                                req.onerror = function (e) {
                                    // this callback is for a constaint error, which we ignore
                                    // because this docid/rev has already been associated with
                                    // the digest (e.g. when new_edits == false)
                                    e.preventDefault(); // avoid transaction abort
                                    e.stopPropagation(); // avoid transaction onerror
                                    checkDone();
                                };
                            }

                            for (var i = 0; i < attsToAdd.length; i++) {
                                add(attsToAdd[i]); // do in parallel
                            }
                        }

                        function saveAttachment(digest, data, callback) {


                            var getKeyReq = attachStore.count(digest);
                            getKeyReq.onsuccess = function (e) {
                                var count = e.target.result;
                                if (count) {
                                    return callback(); // already exists
                                }
                                var newAtt = {
                                    digest: digest,
                                    body: data
                                };
                                var putReq = attachStore.put(newAtt);
                                putReq.onsuccess = callback;
                            };
                        }
                    }

                    function createKeyRange(start, end, inclusiveEnd, key, descending) {
                        try {
                            if (start && end) {
                                if (descending) {
                                    return IDBKeyRange.bound(end, start, !inclusiveEnd, false);
                                } else {
                                    return IDBKeyRange.bound(start, end, false, !inclusiveEnd);
                                }
                            } else if (start) {
                                if (descending) {
                                    return IDBKeyRange.upperBound(start);
                                } else {
                                    return IDBKeyRange.lowerBound(start);
                                }
                            } else if (end) {
                                if (descending) {
                                    return IDBKeyRange.lowerBound(end, !inclusiveEnd);
                                } else {
                                    return IDBKeyRange.upperBound(end, !inclusiveEnd);
                                }
                            } else if (key) {
                                return IDBKeyRange.only(key);
                            }
                        } catch (e) {
                            return { error: e };
                        }
                        return null;
                    }

                    function handleKeyRangeError(api, opts, err, callback) {
                        if (err.name === "DataError" && err.code === 0) {
                            // data error, start is less than end
                            return callback(null, {
                                total_rows: api._meta.docCount,
                                offset: opts.skip,
                                rows: []
                            });
                        }
                        callback(createError(IDB_ERROR, err.name, err.message));
                    }

                    function idbAllDocs(opts, api, idb, callback) {

                        function allDocsQuery(opts, callback) {
                            var start = 'startkey' in opts ? opts.startkey : false;
                            var end = 'endkey' in opts ? opts.endkey : false;
                            var key = 'key' in opts ? opts.key : false;
                            var skip = opts.skip || 0;
                            var limit = typeof opts.limit === 'number' ? opts.limit : -1;
                            var inclusiveEnd = opts.inclusive_end !== false;
                            var descending = 'descending' in opts && opts.descending ? 'prev' : null;

                            var keyRange = createKeyRange(start, end, inclusiveEnd, key, descending);
                            if (keyRange && keyRange.error) {
                                return handleKeyRangeError(api, opts, keyRange.error, callback);
                            }

                            var stores = [DOC_STORE, BY_SEQ_STORE];

                            if (opts.attachments) {
                                stores.push(ATTACH_STORE);
                            }
                            var txnResult = openTransactionSafely(idb, stores, 'readonly');
                            if (txnResult.error) {
                                return callback(txnResult.error);
                            }
                            var txn = txnResult.txn;
                            var docStore = txn.objectStore(DOC_STORE);
                            var seqStore = txn.objectStore(BY_SEQ_STORE);
                            var cursor = descending ?
                                docStore.openCursor(keyRange, descending) :
                                docStore.openCursor(keyRange);
                            var docIdRevIndex = seqStore.index('_doc_id_rev');
                            var results = [];
                            var docCount = 0;

                            // if the user specifies include_docs=true, then we don't
                            // want to block the main cursor while we're fetching the doc
                            function fetchDocAsynchronously(metadata, row, winningRev) {
                                var key = metadata.id + "::" + winningRev;
                                docIdRevIndex.get(key).onsuccess = function onGetDoc(e) {
                                    row.doc = decodeDoc(e.target.result);
                                    if (opts.conflicts) {
                                        row.doc._conflicts = collectConflicts(metadata);
                                    }
                                    fetchAttachmentsIfNecessary(row.doc, opts, txn);
                                };
                            }

                            function allDocsInner(cursor, winningRev, metadata) {
                                var row = {
                                    id: metadata.id,
                                    key: metadata.id,
                                    value: {
                                        rev: winningRev
                                    }
                                };
                                var deleted = metadata.deleted;
                                if (opts.deleted === 'ok') {
                                    results.push(row);
                                    // deleted docs are okay with "keys" requests
                                    if (deleted) {
                                        row.value.deleted = true;
                                        row.doc = null;
                                    } else if (opts.include_docs) {
                                        fetchDocAsynchronously(metadata, row, winningRev);
                                    }
                                } else if (!deleted && skip-- <= 0) {
                                    results.push(row);
                                    if (opts.include_docs) {
                                        fetchDocAsynchronously(metadata, row, winningRev);
                                    }
                                    if (--limit === 0) {
                                        return;
                                    }
                                }
                                cursor["continue"]();
                            }

                            function onGetCursor(e) {
                                docCount = api._meta.docCount; // do this within the txn for consistency
                                var cursor = e.target.result;
                                if (!cursor) {
                                    return;
                                }
                                var metadata = decodeMetadata(cursor.value);
                                var winningRev = metadata.winningRev;

                                allDocsInner(cursor, winningRev, metadata);
                            }

                            function onResultsReady() {
                                callback(null, {
                                    total_rows: docCount,
                                    offset: opts.skip,
                                    rows: results
                                });
                            }

                            function onTxnComplete() {
                                if (opts.attachments) {
                                    postProcessAttachments(results, opts.binary).then(onResultsReady);
                                } else {
                                    onResultsReady();
                                }
                            }

                            txn.oncomplete = onTxnComplete;
                            cursor.onsuccess = onGetCursor;
                        }

                        function allDocs(opts, callback) {

                            if (opts.limit === 0) {
                                return callback(null, {
                                    total_rows: api._meta.docCount,
                                    offset: opts.skip,
                                    rows: []
                                });
                            }
                            allDocsQuery(opts, callback);
                        }

                        allDocs(opts, callback);
                    }

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
                    function checkBlobSupport(txn) {
                        return new PouchPromise(function (resolve) {
                            var blob = createBlob(['']);
                            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

                            txn.onabort = function (e) {
                                // If the transaction aborts now its due to not being able to
                                // write to the database, likely due to the disk being full
                                e.preventDefault();
                                e.stopPropagation();
                                resolve(false);
                            };

                            txn.oncomplete = function () {
                                var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
                                var matchedEdge = navigator.userAgent.match(/Edge\//);
                                // MS Edge pretends to be Chrome 42:
                                // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
                                resolve(matchedEdge || !matchedChrome ||
                                    parseInt(matchedChrome[1], 10) >= 43);
                            };
                        })["catch"](function () {
                            return false; // error, so assume unsupported
                        });
                    }

                    inherits(Changes$1, events.EventEmitter);

                    /* istanbul ignore next */
                    function attachBrowserEvents(self) {
                        if (isChromeApp()) {
                            chrome.storage.onChanged.addListener(function (e) {
                                // make sure it's event addressed to us
                                if (e.db_name != null) {
                                    //object only has oldValue, newValue members
                                    self.emit(e.dbName.newValue);
                                }
                            });
                        } else if (hasLocalStorage()) {
                            if (typeof addEventListener !== 'undefined') {
                                addEventListener("storage", function (e) {
                                    self.emit(e.key);
                                });
                            } else { // old IE
                                window.attachEvent("storage", function (e) {
                                    self.emit(e.key);
                                });
                            }
                        }
                    }

                    function Changes$1() {
                        events.EventEmitter.call(this);
                        this._listeners = {};

                        attachBrowserEvents(this);
                    }

                    Changes$1.prototype.addListener = function (dbName, id, db, opts) {
                        /* istanbul ignore if */
                        if (this._listeners[id]) {
                            return;
                        }
                        var self = this;
                        var inprogress = false;

                        function eventFunction() {
                            /* istanbul ignore if */
                            if (!self._listeners[id]) {
                                return;
                            }
                            if (inprogress) {
                                inprogress = 'waiting';
                                return;
                            }
                            inprogress = true;
                            var changesOpts = pick(opts, [
                                'style', 'include_docs', 'attachments', 'conflicts', 'filter',
                                'doc_ids', 'view', 'since', 'query_params', 'binary'
                            ]);

                            /* istanbul ignore next */
                            function onError() {
                                inprogress = false;
                            }

                            db.changes(changesOpts).on('change', function (c) {
                                if (c.seq > opts.since && !opts.cancelled) {
                                    opts.since = c.seq;
                                    opts.onChange(c);
                                }
                            }).on('complete', function () {
                                if (inprogress === 'waiting') {
                                    setTimeout(function () {
                                        eventFunction();
                                    }, 0);
                                }
                                inprogress = false;
                            }).on('error', onError);
                        }

                        this._listeners[id] = eventFunction;
                        this.on(dbName, eventFunction);
                    };

                    Changes$1.prototype.removeListener = function (dbName, id) {
                        /* istanbul ignore if */
                        if (!(id in this._listeners)) {
                            return;
                        }
                        events.EventEmitter.prototype.removeListener.call(this, dbName,
                            this._listeners[id]);
                    };


                    /* istanbul ignore next */
                    Changes$1.prototype.notifyLocalWindows = function (dbName) {
                        //do a useless change on a storage thing
                        //in order to get other windows's listeners to activate
                        if (isChromeApp()) {
                            chrome.storage.local.set({ dbName: dbName });
                        } else if (hasLocalStorage()) {
                            localStorage[dbName] = (localStorage[dbName] === "a") ? "b" : "a";
                        }
                    };

                    Changes$1.prototype.notify = function (dbName) {
                        this.emit(dbName);
                        this.notifyLocalWindows(dbName);
                    };

                    var cachedDBs = new pouchdbCollections.Map();
                    var blobSupportPromise;
                    var idbChanges = new Changes$1();
                    var openReqList = new pouchdbCollections.Map();

                    function IdbPouch(opts, callback) {
                        var api = this;

                        taskQueue.queue.push({
                            action: function (thisCallback) {
                                init(api, opts, thisCallback);
                            },
                            callback: callback
                        });
                        applyNext(api.constructor);
                    }

                    function init(api, opts, callback) {

                        var dbName = opts.name;

                        var idb = null;
                        api._meta = null;

                        // called when creating a fresh new database
                        function createSchema(db) {
                            var docStore = db.createObjectStore(DOC_STORE, { keyPath: 'id' });
                            db.createObjectStore(BY_SEQ_STORE, { autoIncrement: true })
                                .createIndex('_doc_id_rev', '_doc_id_rev', { unique: true });
                            db.createObjectStore(ATTACH_STORE, { keyPath: 'digest' });
                            db.createObjectStore(META_STORE, { keyPath: 'id', autoIncrement: false });
                            db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);

                            // added in v2
                            docStore.createIndex('deletedOrLocal', 'deletedOrLocal', { unique: false });

                            // added in v3
                            db.createObjectStore(LOCAL_STORE, { keyPath: '_id' });

                            // added in v4
                            var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
                                { autoIncrement: true });
                            attAndSeqStore.createIndex('seq', 'seq');
                            attAndSeqStore.createIndex('digestSeq', 'digestSeq', { unique: true });
                        }

                        // migration to version 2
                        // unfortunately "deletedOrLocal" is a misnomer now that we no longer
                        // store local docs in the main doc-store, but whaddyagonnado
                        function addDeletedOrLocalIndex(txn, callback) {
                            var docStore = txn.objectStore(DOC_STORE);
                            docStore.createIndex('deletedOrLocal', 'deletedOrLocal', { unique: false });

                            docStore.openCursor().onsuccess = function (event) {
                                var cursor = event.target.result;
                                if (cursor) {
                                    var metadata = cursor.value;
                                    var deleted = isDeleted(metadata);
                                    metadata.deletedOrLocal = deleted ? "1" : "0";
                                    docStore.put(metadata);
                                    cursor["continue"]();
                                } else {
                                    callback();
                                }
                            };
                        }

                        // migration to version 3 (part 1)
                        function createLocalStoreSchema(db) {
                            db.createObjectStore(LOCAL_STORE, { keyPath: '_id' })
                                .createIndex('_doc_id_rev', '_doc_id_rev', { unique: true });
                        }

                        // migration to version 3 (part 2)
                        function migrateLocalStore(txn, cb) {
                            var localStore = txn.objectStore(LOCAL_STORE);
                            var docStore = txn.objectStore(DOC_STORE);
                            var seqStore = txn.objectStore(BY_SEQ_STORE);

                            var cursor = docStore.openCursor();
                            cursor.onsuccess = function (event) {
                                var cursor = event.target.result;
                                if (cursor) {
                                    var metadata = cursor.value;
                                    var docId = metadata.id;
                                    var local = isLocalId(docId);
                                    var rev = winningRev(metadata);
                                    if (local) {
                                        var docIdRev = docId + "::" + rev;
                                        // remove all seq entries
                                        // associated with this docId
                                        var start = docId + "::";
                                        var end = docId + "::~";
                                        var index = seqStore.index('_doc_id_rev');
                                        var range = IDBKeyRange.bound(start, end, false, false);
                                        var seqCursor = index.openCursor(range);
                                        seqCursor.onsuccess = function (e) {
                                            seqCursor = e.target.result;
                                            if (!seqCursor) {
                                                // done
                                                docStore["delete"](cursor.primaryKey);
                                                cursor["continue"]();
                                            } else {
                                                var data = seqCursor.value;
                                                if (data._doc_id_rev === docIdRev) {
                                                    localStore.put(data);
                                                }
                                                seqStore["delete"](seqCursor.primaryKey);
                                                seqCursor["continue"]();
                                            }
                                        };
                                    } else {
                                        cursor["continue"]();
                                    }
                                } else if (cb) {
                                    cb();
                                }
                            };
                        }

                        // migration to version 4 (part 1)
                        function addAttachAndSeqStore(db) {
                            var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,
                                { autoIncrement: true });
                            attAndSeqStore.createIndex('seq', 'seq');
                            attAndSeqStore.createIndex('digestSeq', 'digestSeq', { unique: true });
                        }

                        // migration to version 4 (part 2)
                        function migrateAttsAndSeqs(txn, callback) {
                            var seqStore = txn.objectStore(BY_SEQ_STORE);
                            var attStore = txn.objectStore(ATTACH_STORE);
                            var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);

                            // need to actually populate the table. this is the expensive part,
                            // so as an optimization, check first that this database even
                            // contains attachments
                            var req = attStore.count();
                            req.onsuccess = function (e) {
                                var count = e.target.result;
                                if (!count) {
                                    return callback(); // done
                                }

                                seqStore.openCursor().onsuccess = function (e) {
                                    var cursor = e.target.result;
                                    if (!cursor) {
                                        return callback(); // done
                                    }
                                    var doc = cursor.value;
                                    var seq = cursor.primaryKey;
                                    var atts = Object.keys(doc._attachments || {});
                                    var digestMap = {};
                                    for (var j = 0; j < atts.length; j++) {
                                        var att = doc._attachments[atts[j]];
                                        digestMap[att.digest] = true; // uniq digests, just in case
                                    }
                                    var digests = Object.keys(digestMap);
                                    for (j = 0; j < digests.length; j++) {
                                        var digest = digests[j];
                                        attAndSeqStore.put({
                                            seq: seq,
                                            digestSeq: digest + '::' + seq
                                        });
                                    }
                                    cursor["continue"]();
                                };
                            };
                        }

                        // migration to version 5
                        // Instead of relying on on-the-fly migration of metadata,
                        // this brings the doc-store to its modern form:
                        // - metadata.winningrev
                        // - metadata.seq
                        // - stringify the metadata when storing it
                        function migrateMetadata(txn) {

                            function decodeMetadataCompat(storedObject) {
                                if (!storedObject.data) {
                                    // old format, when we didn't store it stringified
                                    storedObject.deleted = storedObject.deletedOrLocal === '1';
                                    return storedObject;
                                }
                                return decodeMetadata(storedObject);
                            }

                            // ensure that every metadata has a winningRev and seq,
                            // which was previously created on-the-fly but better to migrate
                            var bySeqStore = txn.objectStore(BY_SEQ_STORE);
                            var docStore = txn.objectStore(DOC_STORE);
                            var cursor = docStore.openCursor();
                            cursor.onsuccess = function (e) {
                                var cursor = e.target.result;
                                if (!cursor) {
                                    return; // done
                                }
                                var metadata = decodeMetadataCompat(cursor.value);

                                metadata.winningRev = metadata.winningRev ||
                                    winningRev(metadata);

                                function fetchMetadataSeq() {
                                    // metadata.seq was added post-3.2.0, so if it's missing,
                                    // we need to fetch it manually
                                    var start = metadata.id + '::';
                                    var end = metadata.id + '::\uffff';
                                    var req = bySeqStore.index('_doc_id_rev').openCursor(
                                        IDBKeyRange.bound(start, end));

                                    var metadataSeq = 0;
                                    req.onsuccess = function (e) {
                                        var cursor = e.target.result;
                                        if (!cursor) {
                                            metadata.seq = metadataSeq;
                                            return onGetMetadataSeq();
                                        }
                                        var seq = cursor.primaryKey;
                                        if (seq > metadataSeq) {
                                            metadataSeq = seq;
                                        }
                                        cursor["continue"]();
                                    };
                                }

                                function onGetMetadataSeq() {
                                    var metadataToStore = encodeMetadata(metadata,
                                        metadata.winningRev, metadata.deleted);

                                    var req = docStore.put(metadataToStore);
                                    req.onsuccess = function () {
                                        cursor["continue"]();
                                    };
                                }

                                if (metadata.seq) {
                                    return onGetMetadataSeq();
                                }

                                fetchMetadataSeq();
                            };

                        }

                        api.type = function () {
                            return 'idb';
                        };

                        api._id = toPromise(function (callback) {
                            callback(null, api._meta.instanceId);
                        });

                        api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {
                            idbBulkDocs(opts, req, reqOpts, api, idb, idbChanges, callback);
                        };

                        // First we look up the metadata in the ids database, then we fetch the
                        // current revision(s) from the by sequence store
                        api._get = function idb_get(id, opts, callback) {
                            var doc;
                            var metadata;
                            var err;
                            var txn = opts.ctx;
                            if (!txn) {
                                var txnResult = openTransactionSafely(idb,
                                    [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
                                if (txnResult.error) {
                                    return callback(txnResult.error);
                                }
                                txn = txnResult.txn;
                            }

                            function finish() {
                                callback(err, { doc: doc, metadata: metadata, ctx: txn });
                            }

                            txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {
                                metadata = decodeMetadata(e.target.result);
                                // we can determine the result here if:
                                // 1. there is no such document
                                // 2. the document is deleted and we don't ask about specific rev
                                // When we ask with opts.rev we expect the answer to be either
                                // doc (possibly with _deleted=true) or missing error
                                if (!metadata) {
                                    err = createError(MISSING_DOC, 'missing');
                                    return finish();
                                }
                                if (isDeleted(metadata) && !opts.rev) {
                                    err = createError(MISSING_DOC, "deleted");
                                    return finish();
                                }
                                var objectStore = txn.objectStore(BY_SEQ_STORE);

                                var rev = opts.rev || metadata.winningRev;
                                var key = metadata.id + '::' + rev;

                                objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {
                                    doc = e.target.result;
                                    if (doc) {
                                        doc = decodeDoc(doc);
                                    }
                                    if (!doc) {
                                        err = createError(MISSING_DOC, 'missing');
                                        return finish();
                                    }
                                    finish();
                                };
                            };
                        };

                        api._getAttachment = function (attachment, opts, callback) {
                            var txn;
                            if (opts.ctx) {
                                txn = opts.ctx;
                            } else {
                                var txnResult = openTransactionSafely(idb,
                                    [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
                                if (txnResult.error) {
                                    return callback(txnResult.error);
                                }
                                txn = txnResult.txn;
                            }
                            var digest = attachment.digest;
                            var type = attachment.content_type;

                            txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {
                                var body = e.target.result.body;
                                readBlobData(body, type, opts.binary, function (blobData) {
                                    callback(null, blobData);
                                });
                            };
                        };

                        api._info = function idb_info(callback) {

                            if (idb === null || !cachedDBs.has(dbName)) {
                                var error = new Error('db isn\'t open');
                                error.id = 'idbNull';
                                return callback(error);
                            }
                            var updateSeq;
                            var docCount;

                            var txnResult = openTransactionSafely(idb, [BY_SEQ_STORE], 'readonly');
                            if (txnResult.error) {
                                return callback(txnResult.error);
                            }
                            var txn = txnResult.txn;
                            var cursor = txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev');
                            cursor.onsuccess = function (event) {
                                var cursor = event.target.result;
                                updateSeq = cursor ? cursor.key : 0;
                                // count within the same txn for consistency
                                docCount = api._meta.docCount;
                            };

                            txn.oncomplete = function () {
                                callback(null, {
                                    doc_count: docCount,
                                    update_seq: updateSeq,
                                    // for debugging
                                    idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')
                                });
                            };
                        };

                        api._allDocs = function idb_allDocs(opts, callback) {
                            idbAllDocs(opts, api, idb, callback);
                        };

                        api._changes = function (opts) {
                            opts = clone(opts);

                            if (opts.continuous) {
                                var id = dbName + ':' + uuid();
                                idbChanges.addListener(dbName, id, api, opts);
                                idbChanges.notify(dbName);
                                return {
                                    cancel: function () {
                                        idbChanges.removeListener(dbName, id);
                                    }
                                };
                            }

                            var docIds = opts.doc_ids && new pouchdbCollections.Set(opts.doc_ids);

                            opts.since = opts.since || 0;
                            var lastSeq = opts.since;

                            var limit = 'limit' in opts ? opts.limit : -1;
                            if (limit === 0) {
                                limit = 1; // per CouchDB _changes spec
                            }
                            var returnDocs;
                            if ('return_docs' in opts) {
                                returnDocs = opts.return_docs;
                            } else if ('returnDocs' in opts) {
                                // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release
                                returnDocs = opts.returnDocs;
                            } else {
                                returnDocs = true;
                            }

                            var results = [];
                            var numResults = 0;
                            var filter = filterChange(opts);
                            var docIdsToMetadata = new pouchdbCollections.Map();

                            var txn;
                            var bySeqStore;
                            var docStore;
                            var docIdRevIndex;

                            function onGetCursor(cursor) {

                                var doc = decodeDoc(cursor.value);
                                var seq = cursor.key;

                                if (docIds && !docIds.has(doc._id)) {
                                    return cursor["continue"]();
                                }

                                var metadata;

                                function onGetMetadata() {
                                    if (metadata.seq !== seq) {
                                        // some other seq is later
                                        return cursor["continue"]();
                                    }

                                    lastSeq = seq;

                                    if (metadata.winningRev === doc._rev) {
                                        return onGetWinningDoc(doc);
                                    }

                                    fetchWinningDoc();
                                }

                                function fetchWinningDoc() {
                                    var docIdRev = doc._id + '::' + metadata.winningRev;
                                    var req = docIdRevIndex.get(docIdRev);
                                    req.onsuccess = function (e) {
                                        onGetWinningDoc(decodeDoc(e.target.result));
                                    };
                                }

                                function onGetWinningDoc(winningDoc) {

                                    var change = opts.processChange(winningDoc, metadata, opts);
                                    change.seq = metadata.seq;

                                    var filtered = filter(change);
                                    if (typeof filtered === 'object') {
                                        return opts.complete(filtered);
                                    }

                                    if (filtered) {
                                        numResults++;
                                        if (returnDocs) {
                                            results.push(change);
                                        }
                                        // process the attachment immediately
                                        // for the benefit of live listeners
                                        if (opts.attachments && opts.include_docs) {
                                            fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {
                                                postProcessAttachments([change], opts.binary).then(function () {
                                                    opts.onChange(change);
                                                });
                                            });
                                        } else {
                                            opts.onChange(change);
                                        }
                                    }
                                    if (numResults !== limit) {
                                        cursor["continue"]();
                                    }
                                }

                                metadata = docIdsToMetadata.get(doc._id);
                                if (metadata) { // cached
                                    return onGetMetadata();
                                }
                                // metadata not cached, have to go fetch it
                                docStore.get(doc._id).onsuccess = function (event) {
                                    metadata = decodeMetadata(event.target.result);
                                    docIdsToMetadata.set(doc._id, metadata);
                                    onGetMetadata();
                                };
                            }

                            function onsuccess(event) {
                                var cursor = event.target.result;

                                if (!cursor) {
                                    return;
                                }
                                onGetCursor(cursor);
                            }

                            function fetchChanges() {
                                var objectStores = [DOC_STORE, BY_SEQ_STORE];
                                if (opts.attachments) {
                                    objectStores.push(ATTACH_STORE);
                                }
                                var txnResult = openTransactionSafely(idb, objectStores, 'readonly');
                                if (txnResult.error) {
                                    return opts.complete(txnResult.error);
                                }
                                txn = txnResult.txn;
                                txn.onabort = idbError(opts.complete);
                                txn.oncomplete = onTxnComplete;

                                bySeqStore = txn.objectStore(BY_SEQ_STORE);
                                docStore = txn.objectStore(DOC_STORE);
                                docIdRevIndex = bySeqStore.index('_doc_id_rev');

                                var req;

                                if (opts.descending) {
                                    req = bySeqStore.openCursor(null, 'prev');
                                } else {
                                    req = bySeqStore.openCursor(IDBKeyRange.lowerBound(opts.since, true));
                                }

                                req.onsuccess = onsuccess;
                            }

                            fetchChanges();

                            function onTxnComplete() {

                                function finish() {
                                    opts.complete(null, {
                                        results: results,
                                        last_seq: lastSeq
                                    });
                                }

                                if (!opts.continuous && opts.attachments) {
                                    // cannot guarantee that postProcessing was already done,
                                    // so do it again
                                    postProcessAttachments(results).then(finish);
                                } else {
                                    finish();
                                }
                            }
                        };

                        api._close = function (callback) {
                            if (idb === null) {
                                return callback(createError(NOT_OPEN));
                            }

                            // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close
                            // "Returns immediately and closes the connection in a separate thread..."
                            idb.close();
                            cachedDBs["delete"](dbName);
                            idb = null;
                            callback();
                        };

                        api._getRevisionTree = function (docId, callback) {
                            var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');
                            if (txnResult.error) {
                                return callback(txnResult.error);
                            }
                            var txn = txnResult.txn;
                            var req = txn.objectStore(DOC_STORE).get(docId);
                            req.onsuccess = function (event) {
                                var doc = decodeMetadata(event.target.result);
                                if (!doc) {
                                    callback(createError(MISSING_DOC));
                                } else {
                                    callback(null, doc.rev_tree);
                                }
                            };
                        };

                        // This function removes revisions of document docId
                        // which are listed in revs and sets this document
                        // revision to to rev_tree
                        api._doCompaction = function (docId, revs, callback) {
                            var stores = [
                                DOC_STORE,
                                BY_SEQ_STORE,
                                ATTACH_STORE,
                                ATTACH_AND_SEQ_STORE
                            ];
                            var txnResult = openTransactionSafely(idb, stores, 'readwrite');
                            if (txnResult.error) {
                                return callback(txnResult.error);
                            }
                            var txn = txnResult.txn;

                            var docStore = txn.objectStore(DOC_STORE);

                            docStore.get(docId).onsuccess = function (event) {
                                var metadata = decodeMetadata(event.target.result);
                                traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                                             revHash, ctx, opts) {
                                    var rev = pos + '-' + revHash;
                                    if (revs.indexOf(rev) !== -1) {
                                        opts.status = 'missing';
                                    }
                                });
                                compactRevs(revs, docId, txn);
                                var winningRev = metadata.winningRev;
                                var deleted = metadata.deleted;
                                txn.objectStore(DOC_STORE).put(
                                    encodeMetadata(metadata, winningRev, deleted));
                            };
                            txn.onabort = idbError(callback);
                            txn.oncomplete = function () {
                                callback();
                            };
                        };


                        api._getLocal = function (id, callback) {
                            var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');
                            if (txnResult.error) {
                                return callback(txnResult.error);
                            }
                            var tx = txnResult.txn;
                            var req = tx.objectStore(LOCAL_STORE).get(id);

                            req.onerror = idbError(callback);
                            req.onsuccess = function (e) {
                                var doc = e.target.result;
                                if (!doc) {
                                    callback(createError(MISSING_DOC));
                                } else {
                                    delete doc['_doc_id_rev']; // for backwards compat
                                    callback(null, doc);
                                }
                            };
                        };

                        api._putLocal = function (doc, opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }
                            delete doc._revisions; // ignore this, trust the rev
                            var oldRev = doc._rev;
                            var id = doc._id;
                            if (!oldRev) {
                                doc._rev = '0-1';
                            } else {
                                doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
                            }

                            var tx = opts.ctx;
                            var ret;
                            if (!tx) {
                                var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
                                if (txnResult.error) {
                                    return callback(txnResult.error);
                                }
                                tx = txnResult.txn;
                                tx.onerror = idbError(callback);
                                tx.oncomplete = function () {
                                    if (ret) {
                                        callback(null, ret);
                                    }
                                };
                            }

                            var oStore = tx.objectStore(LOCAL_STORE);
                            var req;
                            if (oldRev) {
                                req = oStore.get(id);
                                req.onsuccess = function (e) {
                                    var oldDoc = e.target.result;
                                    if (!oldDoc || oldDoc._rev !== oldRev) {
                                        callback(createError(REV_CONFLICT));
                                    } else { // update
                                        var req = oStore.put(doc);
                                        req.onsuccess = function () {
                                            ret = { ok: true, id: doc._id, rev: doc._rev };
                                            if (opts.ctx) { // return immediately
                                                callback(null, ret);
                                            }
                                        };
                                    }
                                };
                            } else { // new doc
                                req = oStore.add(doc);
                                req.onerror = function (e) {
                                    // constraint error, already exists
                                    callback(createError(REV_CONFLICT));
                                    e.preventDefault(); // avoid transaction abort
                                    e.stopPropagation(); // avoid transaction onerror
                                };
                                req.onsuccess = function () {
                                    ret = { ok: true, id: doc._id, rev: doc._rev };
                                    if (opts.ctx) { // return immediately
                                        callback(null, ret);
                                    }
                                };
                            }
                        };

                        api._removeLocal = function (doc, opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }
                            var tx = opts.ctx;
                            if (!tx) {
                                var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
                                if (txnResult.error) {
                                    return callback(txnResult.error);
                                }
                                tx = txnResult.txn;
                                tx.oncomplete = function () {
                                    if (ret) {
                                        callback(null, ret);
                                    }
                                };
                            }
                            var ret;
                            var id = doc._id;
                            var oStore = tx.objectStore(LOCAL_STORE);
                            var req = oStore.get(id);

                            req.onerror = idbError(callback);
                            req.onsuccess = function (e) {
                                var oldDoc = e.target.result;
                                if (!oldDoc || oldDoc._rev !== doc._rev) {
                                    callback(createError(MISSING_DOC));
                                } else {
                                    oStore["delete"](id);
                                    ret = { ok: true, id: id, rev: '0-0' };
                                    if (opts.ctx) { // return immediately
                                        callback(null, ret);
                                    }
                                }
                            };
                        };

                        api._destroy = function (opts, callback) {
                            idbChanges.removeAllListeners(dbName);

                            //Close open request for "dbName" database to fix ie delay.
                            var openReq = openReqList.get(dbName);
                            if (openReq && openReq.result) {
                                openReq.result.close();
                                cachedDBs["delete"](dbName);
                            }
                            var req = indexedDB.deleteDatabase(dbName);

                            req.onsuccess = function () {
                                //Remove open request from the list.
                                openReqList["delete"](dbName);
                                if (hasLocalStorage() && (dbName in localStorage)) {
                                    delete localStorage[dbName];
                                }
                                callback(null, { 'ok': true });
                            };

                            req.onerror = idbError(callback);
                        };

                        var cached = cachedDBs.get(dbName);

                        if (cached) {
                            idb = cached.idb;
                            api._meta = cached.global;
                            process.nextTick(function () {
                                callback(null, api);
                            });
                            return;
                        }

                        var req;
                        if (opts.storage) {
                            req = tryStorageOption(dbName, opts.storage);
                        } else {
                            req = indexedDB.open(dbName, ADAPTER_VERSION);
                        }

                        openReqList.set(dbName, req);

                        req.onupgradeneeded = function (e) {
                            var db = e.target.result;
                            if (e.oldVersion < 1) {
                                return createSchema(db); // new db, initial schema
                            }
                            // do migrations

                            var txn = e.currentTarget.transaction;
                            // these migrations have to be done in this function, before
                            // control is returned to the event loop, because IndexedDB

                            if (e.oldVersion < 3) {
                                createLocalStoreSchema(db); // v2 -> v3
                            }
                            if (e.oldVersion < 4) {
                                addAttachAndSeqStore(db); // v3 -> v4
                            }

                            var migrations = [
                                addDeletedOrLocalIndex, // v1 -> v2
                                migrateLocalStore,      // v2 -> v3
                                migrateAttsAndSeqs,     // v3 -> v4
                                migrateMetadata         // v4 -> v5
                            ];

                            var i = e.oldVersion;

                            function next() {
                                var migration = migrations[i - 1];
                                i++;
                                if (migration) {
                                    migration(txn, next);
                                }
                            }

                            next();
                        };

                        req.onsuccess = function (e) {

                            idb = e.target.result;

                            idb.onversionchange = function () {
                                idb.close();
                                cachedDBs["delete"](dbName);
                            };

                            idb.onabort = function (e) {
                                console.error('Database has a global failure', e.target.error);
                                idb.close();
                                cachedDBs["delete"](dbName);
                            };

                            var txn = idb.transaction([
                                META_STORE,
                                DETECT_BLOB_SUPPORT_STORE,
                                DOC_STORE
                            ], 'readwrite');

                            var req = txn.objectStore(META_STORE).get(META_STORE);

                            var blobSupport = null;
                            var docCount = null;
                            var instanceId = null;

                            req.onsuccess = function (e) {

                                var checkSetupComplete = function () {
                                    if (blobSupport === null || docCount === null ||
                                        instanceId === null) {
                                        return;
                                    } else {
                                        api._meta = {
                                            name: dbName,
                                            instanceId: instanceId,
                                            blobSupport: blobSupport,
                                            docCount: docCount
                                        };

                                        cachedDBs.set(dbName, {
                                            idb: idb,
                                            global: api._meta
                                        });
                                        callback(null, api);
                                    }
                                };

                                //
                                // fetch/store the id
                                //

                                var meta = e.target.result || { id: META_STORE };
                                if (dbName + '_id' in meta) {
                                    instanceId = meta[dbName + '_id'];
                                    checkSetupComplete();
                                } else {
                                    instanceId = uuid();
                                    meta[dbName + '_id'] = instanceId;
                                    txn.objectStore(META_STORE).put(meta).onsuccess = function () {
                                        checkSetupComplete();
                                    };
                                }

                                //
                                // check blob support
                                //

                                if (!blobSupportPromise) {
                                    // make sure blob support is only checked once
                                    blobSupportPromise = checkBlobSupport(txn);
                                }

                                blobSupportPromise.then(function (val) {
                                    blobSupport = val;
                                    checkSetupComplete();
                                });

                                //
                                // count docs
                                //

                                var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');
                                index.count(IDBKeyRange.only('0')).onsuccess = function (e) {
                                    docCount = e.target.result;
                                    checkSetupComplete();
                                };

                            };
                        };

                        req.onerror = function () {
                            var msg = 'Failed to open indexedDB, are you in private browsing mode?';
                            console.error(msg);
                            callback(createError(IDB_ERROR, msg));
                        };
                    }

                    IdbPouch.valid = function () {

                        // Issue #2533, we finally gave up on doing bug
                        // detection instead of browser sniffing. Safari brought us
                        // to our knees.
                        var isSafari = typeof openDatabase !== 'undefined' &&
                            /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

                        // some outdated implementations of IDB that appear on Samsung
                        // and HTC Android devices <4.4 are missing IDBKeyRange
                        var supportsIDB = !isSafari && typeof indexedDB !== 'undefined' &&
                            typeof IDBKeyRange !== 'undefined';

                        var isNotDevice = window.cordova === false;
                        if (!supportsIDB && isNotDevice && window.require !== undefined) {
                            return true;
                        }

                        return supportsIDB;
                    };

                    function tryStorageOption(dbName, storage) {
                        try { // option only available in Firefox 26+
                            return indexedDB.open(dbName, {
                                version: ADAPTER_VERSION,
                                storage: storage
                            });
                        } catch (err) {
                            return indexedDB.open(dbName, ADAPTER_VERSION);
                        }
                    }

//
// Parsing hex strings. Yeah.
//
// So basically we need this because of a bug in WebSQL:
// https://code.google.com/p/chromium/issues/detail?id=422690
// https://bugs.webkit.org/show_bug.cgi?id=137637
//
// UTF-8 and UTF-16 are provided as separate functions
// for meager performance improvements
//

                    function decodeUtf8(str) {
                        return decodeURIComponent(window.escape(str));
                    }

                    function hexToInt(charCode) {
                        // '0'-'9' is 48-57
                        // 'A'-'F' is 65-70
                        // SQLite will only give us uppercase hex
                        return charCode < 65 ? (charCode - 48) : (charCode - 55);
                    }


// Example:
// pragma encoding=utf8;
// select hex('A');
// returns '41'
                    function parseHexUtf8(str, start, end) {
                        var result = '';
                        while (start < end) {
                            result += String.fromCharCode(
                                (hexToInt(str.charCodeAt(start++)) << 4) |
                                hexToInt(str.charCodeAt(start++)));
                        }
                        return result;
                    }

// Example:
// pragma encoding=utf16;
// select hex('A');
// returns '4100'
// notice that the 00 comes after the 41 (i.e. it's swizzled)
                    function parseHexUtf16(str, start, end) {
                        var result = '';
                        while (start < end) {
                            // UTF-16, so swizzle the bytes
                            result += String.fromCharCode(
                                (hexToInt(str.charCodeAt(start + 2)) << 12) |
                                (hexToInt(str.charCodeAt(start + 3)) << 8) |
                                (hexToInt(str.charCodeAt(start)) << 4) |
                                hexToInt(str.charCodeAt(start + 1)));
                            start += 4;
                        }
                        return result;
                    }

                    function parseHexString(str, encoding) {
                        if (encoding === 'UTF-8') {
                            return decodeUtf8(parseHexUtf8(str, 0, str.length));
                        } else {
                            return parseHexUtf16(str, 0, str.length);
                        }
                    }

                    function quote(str) {
                        return "'" + str + "'";
                    }

                    var ADAPTER_VERSION$1 = 7; // used to manage migrations

// The object stores created for each database
// DOC_STORE stores the document meta data, its revision history and state
                    var DOC_STORE$1 = quote('document-store');
// BY_SEQ_STORE stores a particular version of a document, keyed by its
// sequence id
                    var BY_SEQ_STORE$1 = quote('by-sequence');
// Where we store attachments
                    var ATTACH_STORE$1 = quote('attach-store');
                    var LOCAL_STORE$1 = quote('local-store');
                    var META_STORE$1 = quote('metadata-store');
// where we store many-to-many relations between attachment
// digests and seqs
                    var ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');

                    function createOpenDBFunction() {
                        if (typeof sqlitePlugin !== 'undefined') {
                            // The SQLite Plugin started deviating pretty heavily from the
                            // standard openDatabase() function, as they started adding more features.
                            // It's better to just use their "new" format and pass in a big ol'
                            // options object.
                            return sqlitePlugin.openDatabase.bind(sqlitePlugin);
                        }

                        if (typeof openDatabase !== 'undefined') {
                            return function openDB(opts) {
                                // Traditional WebSQL API
                                return openDatabase(opts.name, opts.version, opts.description, opts.size);
                            };
                        }
                    }

                    function valid() {
                        // SQLitePlugin leaks this global object, which we can use
                        // to detect if it's installed or not. The benefit is that it's
                        // declared immediately, before the 'deviceready' event has fired.
                        return typeof openDatabase !== 'undefined' ||
                            typeof SQLitePlugin !== 'undefined';
                    }

// escapeBlob and unescapeBlob are workarounds for a websql bug:
// https://code.google.com/p/chromium/issues/detail?id=422690
// https://bugs.webkit.org/show_bug.cgi?id=137637
// The goal is to never actually insert the \u0000 character
// in the database.
                    function escapeBlob(str) {
                        return str
                            .replace(/\u0002/g, '\u0002\u0002')
                            .replace(/\u0001/g, '\u0001\u0002')
                            .replace(/\u0000/g, '\u0001\u0001');
                    }

                    function unescapeBlob(str) {
                        return str
                            .replace(/\u0001\u0001/g, '\u0000')
                            .replace(/\u0001\u0002/g, '\u0001')
                            .replace(/\u0002\u0002/g, '\u0002');
                    }

                    function stringifyDoc(doc) {
                        // don't bother storing the id/rev. it uses lots of space,
                        // in persistent map/reduce especially
                        delete doc._id;
                        delete doc._rev;
                        return JSON.stringify(doc);
                    }

                    function unstringifyDoc(doc, id, rev) {
                        doc = JSON.parse(doc);
                        doc._id = id;
                        doc._rev = rev;
                        return doc;
                    }

                    // question mark groups IN queries, e.g. 3 -> '(?,?,?)'
                    function qMarks(num) {
                        var s = '(';
                        while (num--) {
                            s += '?';
                            if (num) {
                                s += ',';
                            }
                        }
                        return s + ')';
                    }

                    function select(selector, table, joiner, where, orderBy) {
                        return 'SELECT ' + selector + ' FROM ' +
                            (typeof table === 'string' ? table : table.join(' JOIN ')) +
                            (joiner ? (' ON ' + joiner) : '') +
                            (where ? (' WHERE ' +
                            (typeof where === 'string' ? where : where.join(' AND '))) : '') +
                            (orderBy ? (' ORDER BY ' + orderBy) : '');
                    }

                    function compactRevs$1(revs, docId, tx) {

                        if (!revs.length) {
                            return;
                        }

                        var numDone = 0;
                        var seqs = [];

                        function checkDone() {
                            if (++numDone === revs.length) { // done
                                deleteOrphans();
                            }
                        }

                        function deleteOrphans() {
                            // find orphaned attachment digests

                            if (!seqs.length) {
                                return;
                            }

                            var sql = 'SELECT DISTINCT digest AS digest FROM ' +
                                ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);

                            tx.executeSql(sql, seqs, function (tx, res) {

                                var digestsToCheck = [];
                                for (var i = 0; i < res.rows.length; i++) {
                                    digestsToCheck.push(res.rows.item(i).digest);
                                }
                                if (!digestsToCheck.length) {
                                    return;
                                }

                                var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +
                                    ' WHERE seq IN (' +
                                    seqs.map(function () {
                                        return '?';
                                    }).join(',') +
                                    ')';
                                tx.executeSql(sql, seqs, function (tx) {

                                    var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +
                                        ' WHERE digest IN (' +
                                        digestsToCheck.map(function () {
                                            return '?';
                                        }).join(',') +
                                        ')';
                                    tx.executeSql(sql, digestsToCheck, function (tx, res) {
                                        var nonOrphanedDigests = new pouchdbCollections.Set();
                                        for (var i = 0; i < res.rows.length; i++) {
                                            nonOrphanedDigests.add(res.rows.item(i).digest);
                                        }
                                        digestsToCheck.forEach(function (digest) {
                                            if (nonOrphanedDigests.has(digest)) {
                                                return;
                                            }
                                            tx.executeSql(
                                                'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',
                                                [digest]);
                                            tx.executeSql(
                                                'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);
                                        });
                                    });
                                });
                            });
                        }

                        // update by-seq and attach stores in parallel
                        revs.forEach(function (rev) {
                            var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +
                                ' WHERE doc_id=? AND rev=?';

                            tx.executeSql(sql, [docId, rev], function (tx, res) {
                                if (!res.rows.length) { // already deleted
                                    return checkDone();
                                }
                                var seq = res.rows.item(0).seq;
                                seqs.push(seq);

                                tx.executeSql(
                                    'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);
                            });
                        });
                    }

                    function websqlError(callback) {
                        return function (event) {
                            console.error('WebSQL threw an error', event);
                            // event may actually be a SQLError object, so report is as such
                            var errorNameMatch = event && event.constructor.toString()
                                    .match(/function ([^\(]+)/);
                            var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;
                            var errorReason = event.target || event.message;
                            callback(createError(WSQ_ERROR, errorReason, errorName));
                        };
                    }

                    function getSize(opts) {
                        if ('size' in opts) {
                            // triggers immediate popup in iOS, fixes #2347
                            // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,
                            return opts.size * 1000000;
                        }
                        // In iOS, doesn't matter as long as it's <= 5000000.
                        // Except that if you request too much, our tests fail
                        // because of the native "do you accept?" popup.
                        // In Android <=4.3, this value is actually used as an
                        // honest-to-god ceiling for data, so we need to
                        // set it to a decently high number.
                        var isAndroid = typeof navigator !== 'undefined' &&
                            /Android/.test(navigator.userAgent);
                        return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash
                    }

                    function openDBSafely(openDBFunction, opts) {
                        try {
                            return {
                                db: openDBFunction(opts)
                            };
                        } catch (err) {
                            return {
                                error: err
                            };
                        }
                    }

                    var cachedDatabases = new pouchdbCollections.Map();

                    function openDB(opts) {
                        var cachedResult = cachedDatabases.get(opts.name);
                        if (!cachedResult) {
                            var openDBFun = createOpenDBFunction();
                            cachedResult = openDBSafely(openDBFun, opts);
                            cachedDatabases.set(opts.name, cachedResult);
                            if (cachedResult.db) {
                                cachedResult.db._sqlitePlugin = typeof sqlitePlugin !== 'undefined';
                            }
                        }
                        return cachedResult;
                    }

                    function websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {
                        var newEdits = opts.new_edits;
                        var userDocs = req.docs;

                        // Parse the docs, give them a sequence number for the result
                        var docInfos = userDocs.map(function (doc) {
                            if (doc._id && isLocalId(doc._id)) {
                                return doc;
                            }
                            var newDoc = parseDoc(doc, newEdits);
                            return newDoc;
                        });

                        var docInfoErrors = docInfos.filter(function (docInfo) {
                            return docInfo.error;
                        });
                        if (docInfoErrors.length) {
                            return callback(docInfoErrors[0]);
                        }

                        var tx;
                        var results = new Array(docInfos.length);
                        var fetchedDocs = new pouchdbCollections.Map();

                        var preconditionErrored;

                        function complete() {
                            if (preconditionErrored) {
                                return callback(preconditionErrored);
                            }
                            websqlChanges.notify(api._name);
                            api._docCount = -1; // invalidate
                            callback(null, results);
                        }

                        function verifyAttachment(digest, callback) {
                            var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +
                                ' WHERE digest=?';
                            tx.executeSql(sql, [digest], function (tx, result) {
                                if (result.rows.item(0).cnt === 0) {
                                    var err = createError(MISSING_STUB,
                                        'unknown stub attachment with digest ' +
                                        digest);
                                    callback(err);
                                } else {
                                    callback();
                                }
                            });
                        }

                        function verifyAttachments(finish) {
                            var digests = [];
                            docInfos.forEach(function (docInfo) {
                                if (docInfo.data && docInfo.data._attachments) {
                                    Object.keys(docInfo.data._attachments).forEach(function (filename) {
                                        var att = docInfo.data._attachments[filename];
                                        if (att.stub) {
                                            digests.push(att.digest);
                                        }
                                    });
                                }
                            });
                            if (!digests.length) {
                                return finish();
                            }
                            var numDone = 0;
                            var err;

                            function checkDone() {
                                if (++numDone === digests.length) {
                                    finish(err);
                                }
                            }

                            digests.forEach(function (digest) {
                                verifyAttachment(digest, function (attErr) {
                                    if (attErr && !err) {
                                        err = attErr;
                                    }
                                    checkDone();
                                });
                            });
                        }

                        function writeDoc(docInfo, winningRev, winningRevIsDeleted, newRevIsDeleted,
                                          isUpdate, delta, resultsIdx, callback) {

                            function finish() {
                                var data = docInfo.data;
                                var deletedInt = newRevIsDeleted ? 1 : 0;

                                var id = data._id;
                                var rev = data._rev;
                                var json = stringifyDoc(data);
                                var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +
                                    ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';
                                var sqlArgs = [id, rev, json, deletedInt];

                                // map seqs to attachment digests, which
                                // we will need later during compaction
                                function insertAttachmentMappings(seq, callback) {
                                    var attsAdded = 0;
                                    var attsToAdd = Object.keys(data._attachments || {});

                                    if (!attsToAdd.length) {
                                        return callback();
                                    }
                                    function checkDone() {
                                        if (++attsAdded === attsToAdd.length) {
                                            callback();
                                        }
                                        return false; // ack handling a constraint error
                                    }

                                    function add(att) {
                                        var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +
                                            ' (digest, seq) VALUES (?,?)';
                                        var sqlArgs = [data._attachments[att].digest, seq];
                                        tx.executeSql(sql, sqlArgs, checkDone, checkDone);
                                        // second callback is for a constaint error, which we ignore
                                        // because this docid/rev has already been associated with
                                        // the digest (e.g. when new_edits == false)
                                    }

                                    for (var i = 0; i < attsToAdd.length; i++) {
                                        add(attsToAdd[i]); // do in parallel
                                    }
                                }

                                tx.executeSql(sql, sqlArgs, function (tx, result) {
                                    var seq = result.insertId;
                                    insertAttachmentMappings(seq, function () {
                                        dataWritten(tx, seq);
                                    });
                                }, function () {
                                    // constraint error, recover by updating instead (see #1638)
                                    var fetchSql = select('seq', BY_SEQ_STORE$1, null,
                                        'doc_id=? AND rev=?');
                                    tx.executeSql(fetchSql, [id, rev], function (tx, res) {
                                        var seq = res.rows.item(0).seq;
                                        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +
                                            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';
                                        var sqlArgs = [json, deletedInt, id, rev];
                                        tx.executeSql(sql, sqlArgs, function (tx) {
                                            insertAttachmentMappings(seq, function () {
                                                dataWritten(tx, seq);
                                            });
                                        });
                                    });
                                    return false; // ack that we've handled the error
                                });
                            }

                            function collectResults(attachmentErr) {
                                if (!err) {
                                    if (attachmentErr) {
                                        err = attachmentErr;
                                        callback(err);
                                    } else if (recv === attachments.length) {
                                        finish();
                                    }
                                }
                            }

                            var err = null;
                            var recv = 0;

                            docInfo.data._id = docInfo.metadata.id;
                            docInfo.data._rev = docInfo.metadata.rev;
                            var attachments = Object.keys(docInfo.data._attachments || {});

                            if (newRevIsDeleted) {
                                docInfo.data._deleted = true;
                            }

                            function attachmentSaved(err) {
                                recv++;
                                collectResults(err);
                            }

                            attachments.forEach(function (key) {
                                var att = docInfo.data._attachments[key];
                                if (!att.stub) {
                                    var data = att.data;
                                    delete att.data;
                                    var digest = att.digest;
                                    saveAttachment(digest, data, attachmentSaved);
                                } else {
                                    recv++;
                                    collectResults();
                                }
                            });

                            if (!attachments.length) {
                                finish();
                            }

                            function dataWritten(tx, seq) {
                                var id = docInfo.metadata.id;
                                if (isUpdate && api.auto_compaction) {
                                    compactRevs$1(compactTree(docInfo.metadata), id, tx);
                                } else if (docInfo.stemmedRevs.length) {
                                    compactRevs$1(docInfo.stemmedRevs, id, tx);
                                }

                                docInfo.metadata.seq = seq;
                                delete docInfo.metadata.rev;

                                var sql = isUpdate ?
                                'UPDATE ' + DOC_STORE$1 +
                                ' SET json=?, max_seq=?, winningseq=' +
                                '(SELECT seq FROM ' + BY_SEQ_STORE$1 +
                                ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'
                                    : 'INSERT INTO ' + DOC_STORE$1 +
                                ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';
                                var metadataStr = safeJsonStringify(docInfo.metadata);
                                var params = isUpdate ?
                                    [metadataStr, seq, winningRev, id] :
                                    [id, seq, seq, metadataStr];
                                tx.executeSql(sql, params, function () {
                                    results[resultsIdx] = {
                                        ok: true,
                                        id: docInfo.metadata.id,
                                        rev: winningRev
                                    };
                                    fetchedDocs.set(id, docInfo.metadata);
                                    callback();
                                });
                            }
                        }

                        function websqlProcessDocs() {
                            processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,
                                results, writeDoc, opts);
                        }

                        function fetchExistingDocs(callback) {
                            if (!docInfos.length) {
                                return callback();
                            }

                            var numFetched = 0;

                            function checkDone() {
                                if (++numFetched === docInfos.length) {
                                    callback();
                                }
                            }

                            docInfos.forEach(function (docInfo) {
                                if (docInfo._id && isLocalId(docInfo._id)) {
                                    return checkDone(); // skip local docs
                                }
                                var id = docInfo.metadata.id;
                                tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +
                                    ' WHERE id = ?', [id], function (tx, result) {
                                    if (result.rows.length) {
                                        var metadata = safeJsonParse(result.rows.item(0).json);
                                        fetchedDocs.set(id, metadata);
                                    }
                                    checkDone();
                                });
                            });
                        }

                        function saveAttachment(digest, data, callback) {
                            var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';
                            tx.executeSql(sql, [digest], function (tx, result) {
                                if (result.rows.length) { // attachment already exists
                                    return callback();
                                }
                                // we could just insert before selecting and catch the error,
                                // but my hunch is that it's cheaper not to serialize the blob
                                // from JS to C if we don't have to (TODO: confirm this)
                                sql = 'INSERT INTO ' + ATTACH_STORE$1 +
                                    ' (digest, body, escaped) VALUES (?,?,1)';
                                tx.executeSql(sql, [digest, escapeBlob(data)], function () {
                                    callback();
                                }, function () {
                                    // ignore constaint errors, means it already exists
                                    callback();
                                    return false; // ack we handled the error
                                });
                            });
                        }

                        preprocessAttachments$1(docInfos, 'binary', function (err) {
                            if (err) {
                                return callback(err);
                            }
                            db.transaction(function (txn) {
                                tx = txn;
                                verifyAttachments(function (err) {
                                    if (err) {
                                        preconditionErrored = err;
                                    } else {
                                        fetchExistingDocs(websqlProcessDocs);
                                    }
                                });
                            }, websqlError(callback), complete);
                        });
                    }

                    var websqlChanges = new Changes$1();

                    function fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {
                        var attachments = Object.keys(doc._attachments || {});
                        if (!attachments.length) {
                            return cb && cb();
                        }
                        var numDone = 0;

                        function checkDone() {
                            if (++numDone === attachments.length && cb) {
                                cb();
                            }
                        }

                        function fetchAttachment(doc, att) {
                            var attObj = doc._attachments[att];
                            var attOpts = { binary: opts.binary, ctx: txn };
                            api._getAttachment(attObj, attOpts, function (_, data) {
                                doc._attachments[att] = jsExtend.extend(
                                    pick(attObj, ['digest', 'content_type']),
                                    { data: data }
                                );
                                checkDone();
                            });
                        }

                        attachments.forEach(function (att) {
                            if (opts.attachments && opts.include_docs) {
                                fetchAttachment(doc, att);
                            } else {
                                doc._attachments[att].stub = true;
                                checkDone();
                            }
                        });
                    }

                    var POUCH_VERSION = 1;

                    // these indexes cover the ground for most allDocs queries
                    var BY_SEQ_STORE_DELETED_INDEX_SQL =
                        'CREATE INDEX IF NOT EXISTS \'by-seq-deleted-idx\' ON ' +
                        BY_SEQ_STORE$1 + ' (seq, deleted)';
                    var BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =
                        'CREATE UNIQUE INDEX IF NOT EXISTS \'by-seq-doc-id-rev\' ON ' +
                        BY_SEQ_STORE$1 + ' (doc_id, rev)';
                    var DOC_STORE_WINNINGSEQ_INDEX_SQL =
                        'CREATE INDEX IF NOT EXISTS \'doc-winningseq-idx\' ON ' +
                        DOC_STORE$1 + ' (winningseq)';
                    var ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =
                        'CREATE INDEX IF NOT EXISTS \'attach-seq-seq-idx\' ON ' +
                        ATTACH_AND_SEQ_STORE$1 + ' (seq)';
                    var ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =
                        'CREATE UNIQUE INDEX IF NOT EXISTS \'attach-seq-digest-idx\' ON ' +
                        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';

                    var DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +
                        '.seq = ' + DOC_STORE$1 + '.winningseq';

                    var SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +
                        BY_SEQ_STORE$1 + '.deleted AS deleted, ' +
                        BY_SEQ_STORE$1 + '.json AS data, ' +
                        BY_SEQ_STORE$1 + '.rev AS rev, ' +
                        DOC_STORE$1 + '.json AS metadata';

                    function WebSqlPouch(opts, callback) {
                        var api = this;
                        var instanceId = null;
                        var size = getSize(opts);
                        var idRequests = [];
                        var encoding;

                        api._docCount = -1; // cache sqlite count(*) for performance
                        api._name = opts.name;

                        var openDBResult = openDB({
                            name: api._name,
                            version: POUCH_VERSION,
                            description: api._name,
                            size: size,
                            location: opts.location,
                            createFromLocation: opts.createFromLocation,
                            androidDatabaseImplementation: opts.androidDatabaseImplementation
                        });
                        if (openDBResult.error) {
                            return websqlError(callback)(openDBResult.error);
                        }
                        var db = openDBResult.db;
                        if (typeof db.readTransaction !== 'function') {
                            // doesn't exist in sqlite plugin
                            db.readTransaction = db.transaction;
                        }

                        function dbCreated() {
                            // note the db name in case the browser upgrades to idb
                            if (hasLocalStorage()) {
                                window.localStorage['_pouch__websqldb_' + api._name] = true;
                            }
                            callback(null, api);
                        }

                        // In this migration, we added the 'deleted' and 'local' columns to the
                        // by-seq and doc store tables.
                        // To preserve existing user data, we re-process all the existing JSON
                        // and add these values.
                        // Called migration2 because it corresponds to adapter version (db_version) #2
                        function runMigration2(tx, callback) {
                            // index used for the join in the allDocs query
                            tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);

                            tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +
                                ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {
                                tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);
                                tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +
                                    ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {
                                    tx.executeSql('CREATE INDEX IF NOT EXISTS \'doc-store-local-idx\' ON ' +
                                        DOC_STORE$1 + ' (local, id)');

                                    var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +
                                        '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +
                                        ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';

                                    tx.executeSql(sql, [], function (tx, result) {

                                        var deleted = [];
                                        var local = [];

                                        for (var i = 0; i < result.rows.length; i++) {
                                            var item = result.rows.item(i);
                                            var seq = item.seq;
                                            var metadata = JSON.parse(item.metadata);
                                            if (isDeleted(metadata)) {
                                                deleted.push(seq);
                                            }
                                            if (isLocalId(metadata.id)) {
                                                local.push(metadata.id);
                                            }
                                        }
                                        tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +
                                            qMarks(local.length), local, function () {
                                            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +
                                                ' SET deleted = 1 WHERE seq IN ' +
                                                qMarks(deleted.length), deleted, callback);
                                        });
                                    });
                                });
                            });
                        }

                        // in this migration, we make all the local docs unversioned
                        function runMigration3(tx, callback) {
                            var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +
                                ' (id UNIQUE, rev, json)';
                            tx.executeSql(local, [], function () {
                                var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +
                                    BY_SEQ_STORE$1 + '.json AS data ' +
                                    'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +
                                    DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +
                                    DOC_STORE$1 + '.winningseq WHERE local = 1';
                                tx.executeSql(sql, [], function (tx, res) {
                                    var rows = [];
                                    for (var i = 0; i < res.rows.length; i++) {
                                        rows.push(res.rows.item(i));
                                    }
                                    function doNext() {
                                        if (!rows.length) {
                                            return callback(tx);
                                        }
                                        var row = rows.shift();
                                        var rev = JSON.parse(row.data)._rev;
                                        tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +
                                            ' (id, rev, json) VALUES (?,?,?)',
                                            [row.id, rev, row.data], function (tx) {
                                                tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',
                                                    [row.id], function (tx) {
                                                        tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',
                                                            [row.seq], function () {
                                                                doNext();
                                                            });
                                                    });
                                            });
                                    }

                                    doNext();
                                });
                            });
                        }

                        // in this migration, we remove doc_id_rev and just use rev
                        function runMigration4(tx, callback) {

                            function updateRows(rows) {
                                function doNext() {
                                    if (!rows.length) {
                                        return callback(tx);
                                    }
                                    var row = rows.shift();
                                    var doc_id_rev = parseHexString(row.hex, encoding);
                                    var idx = doc_id_rev.lastIndexOf('::');
                                    var doc_id = doc_id_rev.substring(0, idx);
                                    var rev = doc_id_rev.substring(idx + 2);
                                    var sql = 'UPDATE ' + BY_SEQ_STORE$1 +
                                        ' SET doc_id=?, rev=? WHERE doc_id_rev=?';
                                    tx.executeSql(sql, [doc_id, rev, doc_id_rev], function () {
                                        doNext();
                                    });
                                }

                                doNext();
                            }

                            var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';
                            tx.executeSql(sql, [], function (tx) {
                                var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';
                                tx.executeSql(sql, [], function (tx) {
                                    tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {
                                        var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;
                                        tx.executeSql(sql, [], function (tx, res) {
                                            var rows = [];
                                            for (var i = 0; i < res.rows.length; i++) {
                                                rows.push(res.rows.item(i));
                                            }
                                            updateRows(rows);
                                        });
                                    });
                                });
                            });
                        }

                        // in this migration, we add the attach_and_seq table
                        // for issue #2818
                        function runMigration5(tx, callback) {

                            function migrateAttsAndSeqs(tx) {
                                // need to actually populate the table. this is the expensive part,
                                // so as an optimization, check first that this database even
                                // contains attachments
                                var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;
                                tx.executeSql(sql, [], function (tx, res) {
                                    var count = res.rows.item(0).cnt;
                                    if (!count) {
                                        return callback(tx);
                                    }

                                    var offset = 0;
                                    var pageSize = 10;

                                    function nextPage() {
                                        var sql = select(
                                            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',
                                            [DOC_STORE$1, BY_SEQ_STORE$1],
                                            DOC_STORE_AND_BY_SEQ_JOINER,
                                            null,
                                            DOC_STORE$1 + '.id '
                                        );
                                        sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;
                                        offset += pageSize;
                                        tx.executeSql(sql, [], function (tx, res) {
                                            if (!res.rows.length) {
                                                return callback(tx);
                                            }
                                            var digestSeqs = {};

                                            function addDigestSeq(digest, seq) {
                                                // uniq digest/seq pairs, just in case there are dups
                                                var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);
                                                if (seqs.indexOf(seq) === -1) {
                                                    seqs.push(seq);
                                                }
                                            }

                                            for (var i = 0; i < res.rows.length; i++) {
                                                var row = res.rows.item(i);
                                                var doc = unstringifyDoc(row.data, row.id, row.rev);
                                                var atts = Object.keys(doc._attachments || {});
                                                for (var j = 0; j < atts.length; j++) {
                                                    var att = doc._attachments[atts[j]];
                                                    addDigestSeq(att.digest, row.seq);
                                                }
                                            }
                                            var digestSeqPairs = [];
                                            Object.keys(digestSeqs).forEach(function (digest) {
                                                var seqs = digestSeqs[digest];
                                                seqs.forEach(function (seq) {
                                                    digestSeqPairs.push([digest, seq]);
                                                });
                                            });
                                            if (!digestSeqPairs.length) {
                                                return nextPage();
                                            }
                                            var numDone = 0;
                                            digestSeqPairs.forEach(function (pair) {
                                                var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +
                                                    ' (digest, seq) VALUES (?,?)';
                                                tx.executeSql(sql, pair, function () {
                                                    if (++numDone === digestSeqPairs.length) {
                                                        nextPage();
                                                    }
                                                });
                                            });
                                        });
                                    }

                                    nextPage();
                                });
                            }

                            var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +
                                ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';
                            tx.executeSql(attachAndRev, [], function (tx) {
                                tx.executeSql(
                                    ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {
                                        tx.executeSql(
                                            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],
                                            migrateAttsAndSeqs);
                                    });
                            });
                        }

                        // in this migration, we use escapeBlob() and unescapeBlob()
                        // instead of reading out the binary as HEX, which is slow
                        function runMigration6(tx, callback) {
                            var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +
                                ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';
                            tx.executeSql(sql, [], callback);
                        }

                        // issue #3136, in this migration we need a "latest seq" as well
                        // as the "winning seq" in the doc store
                        function runMigration7(tx, callback) {
                            var sql = 'ALTER TABLE ' + DOC_STORE$1 +
                                ' ADD COLUMN max_seq INTEGER';
                            tx.executeSql(sql, [], function (tx) {
                                var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +
                                    BY_SEQ_STORE$1 + ' WHERE doc_id=id)';
                                tx.executeSql(sql, [], function (tx) {
                                    // add unique index after filling, else we'll get a constraint
                                    // error when we do the ALTER TABLE
                                    var sql =
                                        'CREATE UNIQUE INDEX IF NOT EXISTS \'doc-max-seq-idx\' ON ' +
                                        DOC_STORE$1 + ' (max_seq)';
                                    tx.executeSql(sql, [], callback);
                                });
                            });
                        }

                        function checkEncoding(tx, cb) {
                            // UTF-8 on chrome/android, UTF-16 on safari < 7.1
                            tx.executeSql('SELECT HEX("a") AS hex', [], function (tx, res) {
                                    var hex = res.rows.item(0).hex;
                                    encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';
                                    cb();
                                }
                            );
                        }

                        function onGetInstanceId() {
                            while (idRequests.length > 0) {
                                var idCallback = idRequests.pop();
                                idCallback(null, instanceId);
                            }
                        }

                        function onGetVersion(tx, dbVersion) {
                            if (dbVersion === 0) {
                                // initial schema

                                var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +
                                    ' (dbid, db_version INTEGER)';
                                var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +
                                    ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';
                                var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +
                                    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';
                                // TODO: migrate winningseq to INTEGER
                                var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +
                                    ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';
                                var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +
                                    ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +
                                    'json, deleted TINYINT(1), doc_id, rev)';
                                var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +
                                    ' (id UNIQUE, rev, json)';

                                // creates
                                tx.executeSql(attach);
                                tx.executeSql(local);
                                tx.executeSql(attachAndRev, [], function () {
                                    tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);
                                    tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);
                                });
                                tx.executeSql(doc, [], function () {
                                    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);
                                    tx.executeSql(seq, [], function () {
                                        tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);
                                        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);
                                        tx.executeSql(meta, [], function () {
                                            // mark the db version, and new dbid
                                            var initSeq = 'INSERT INTO ' + META_STORE$1 +
                                                ' (db_version, dbid) VALUES (?,?)';
                                            instanceId = uuid();
                                            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];
                                            tx.executeSql(initSeq, initSeqArgs, function () {
                                                onGetInstanceId();
                                            });
                                        });
                                    });
                                });
                            } else { // version > 0

                                var setupDone = function () {
                                    var migrated = dbVersion < ADAPTER_VERSION$1;
                                    if (migrated) {
                                        // update the db version within this transaction
                                        tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +
                                            ADAPTER_VERSION$1);
                                    }
                                    // notify db.id() callers
                                    var sql = 'SELECT dbid FROM ' + META_STORE$1;
                                    tx.executeSql(sql, [], function (tx, result) {
                                        instanceId = result.rows.item(0).dbid;
                                        onGetInstanceId();
                                    });
                                };

                                // would love to use promises here, but then websql
                                // ends the transaction early
                                var tasks = [
                                    runMigration2,
                                    runMigration3,
                                    runMigration4,
                                    runMigration5,
                                    runMigration6,
                                    runMigration7,
                                    setupDone
                                ];

                                // run each migration sequentially
                                var i = dbVersion;
                                var nextMigration = function (tx) {
                                    tasks[i - 1](tx, nextMigration);
                                    i++;
                                };
                                nextMigration(tx);
                            }
                        }

                        function setup() {
                            db.transaction(function (tx) {
                                // first check the encoding
                                checkEncoding(tx, function () {
                                    // then get the version
                                    fetchVersion(tx);
                                });
                            }, websqlError(callback), dbCreated);
                        }

                        function fetchVersion(tx) {
                            var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;
                            tx.executeSql(sql, [], function (tx, result) {
                                if (!result.rows.length) {
                                    // database hasn't even been created yet (version 0)
                                    onGetVersion(tx, 0);
                                } else if (!/db_version/.test(result.rows.item(0).sql)) {
                                    // table was created, but without the new db_version column,
                                    // so add it.
                                    tx.executeSql('ALTER TABLE ' + META_STORE$1 +
                                        ' ADD COLUMN db_version INTEGER', [], function () {
                                        // before version 2, this column didn't even exist
                                        onGetVersion(tx, 1);
                                    });
                                } else { // column exists, we can safely get it
                                    tx.executeSql('SELECT db_version FROM ' + META_STORE$1,
                                        [], function (tx, result) {
                                            var dbVersion = result.rows.item(0).db_version;
                                            onGetVersion(tx, dbVersion);
                                        });
                                }
                            });
                        }

                        setup();

                        api.type = function () {
                            return 'websql';
                        };

                        api._id = toPromise(function (callback) {
                            callback(null, instanceId);
                        });

                        api._info = function (callback) {
                            db.readTransaction(function (tx) {
                                countDocs(tx, function (docCount) {
                                    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;
                                    tx.executeSql(sql, [], function (tx, res) {
                                        var updateSeq = res.rows.item(0).seq || 0;
                                        callback(null, {
                                            doc_count: docCount,
                                            update_seq: updateSeq,
                                            // for debugging
                                            sqlite_plugin: db._sqlitePlugin,
                                            websql_encoding: encoding
                                        });
                                    });
                                });
                            }, websqlError(callback));
                        };

                        api._bulkDocs = function (req, reqOpts, callback) {
                            websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);
                        };

                        api._get = function (id, opts, callback) {
                            var doc;
                            var metadata;
                            var err;
                            var tx = opts.ctx;
                            if (!tx) {
                                return db.readTransaction(function (txn) {
                                    api._get(id, jsExtend.extend({ ctx: txn }, opts), callback);
                                });
                            }

                            function finish() {
                                callback(err, { doc: doc, metadata: metadata, ctx: tx });
                            }

                            var sql;
                            var sqlArgs;
                            if (opts.rev) {
                                sql = select(
                                    SELECT_DOCS,
                                    [DOC_STORE$1, BY_SEQ_STORE$1],
                                    DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',
                                    [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);
                                sqlArgs = [id, opts.rev];
                            } else {
                                sql = select(
                                    SELECT_DOCS,
                                    [DOC_STORE$1, BY_SEQ_STORE$1],
                                    DOC_STORE_AND_BY_SEQ_JOINER,
                                    DOC_STORE$1 + '.id=?');
                                sqlArgs = [id];
                            }
                            tx.executeSql(sql, sqlArgs, function (a, results) {
                                if (!results.rows.length) {
                                    err = createError(MISSING_DOC, 'missing');
                                    return finish();
                                }
                                var item = results.rows.item(0);
                                metadata = safeJsonParse(item.metadata);
                                if (item.deleted && !opts.rev) {
                                    err = createError(MISSING_DOC, 'deleted');
                                    return finish();
                                }
                                doc = unstringifyDoc(item.data, metadata.id, item.rev);
                                finish();
                            });
                        };

                        function countDocs(tx, callback) {

                            if (api._docCount !== -1) {
                                return callback(api._docCount);
                            }

                            // count the total rows
                            var sql = select(
                                'COUNT(' + DOC_STORE$1 + '.id) AS \'num\'',
                                [DOC_STORE$1, BY_SEQ_STORE$1],
                                DOC_STORE_AND_BY_SEQ_JOINER,
                                BY_SEQ_STORE$1 + '.deleted=0');

                            tx.executeSql(sql, [], function (tx, result) {
                                api._docCount = result.rows.item(0).num;
                                callback(api._docCount);
                            });
                        }

                        api._allDocs = function (opts, callback) {
                            var results = [];
                            var totalRows;

                            var start = 'startkey' in opts ? opts.startkey : false;
                            var end = 'endkey' in opts ? opts.endkey : false;
                            var key = 'key' in opts ? opts.key : false;
                            var descending = 'descending' in opts ? opts.descending : false;
                            var limit = 'limit' in opts ? opts.limit : -1;
                            var offset = 'skip' in opts ? opts.skip : 0;
                            var inclusiveEnd = opts.inclusive_end !== false;

                            var sqlArgs = [];
                            var criteria = [];

                            if (key !== false) {
                                criteria.push(DOC_STORE$1 + '.id = ?');
                                sqlArgs.push(key);
                            } else if (start !== false || end !== false) {
                                if (start !== false) {
                                    criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');
                                    sqlArgs.push(start);
                                }
                                if (end !== false) {
                                    var comparator = descending ? '>' : '<';
                                    if (inclusiveEnd) {
                                        comparator += '=';
                                    }
                                    criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');
                                    sqlArgs.push(end);
                                }
                                if (key !== false) {
                                    criteria.push(DOC_STORE$1 + '.id = ?');
                                    sqlArgs.push(key);
                                }
                            }

                            if (opts.deleted !== 'ok') {
                                // report deleted if keys are specified
                                criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');
                            }

                            db.readTransaction(function (tx) {

                                // first count up the total rows
                                countDocs(tx, function (count) {
                                    totalRows = count;

                                    if (limit === 0) {
                                        return;
                                    }

                                    // then actually fetch the documents
                                    var sql = select(
                                        SELECT_DOCS,
                                        [DOC_STORE$1, BY_SEQ_STORE$1],
                                        DOC_STORE_AND_BY_SEQ_JOINER,
                                        criteria,
                                        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')
                                    );
                                    sql += ' LIMIT ' + limit + ' OFFSET ' + offset;

                                    tx.executeSql(sql, sqlArgs, function (tx, result) {
                                        for (var i = 0, l = result.rows.length; i < l; i++) {
                                            var item = result.rows.item(i);
                                            var metadata = safeJsonParse(item.metadata);
                                            var id = metadata.id;
                                            var data = unstringifyDoc(item.data, id, item.rev);
                                            var winningRev = data._rev;
                                            var doc = {
                                                id: id,
                                                key: id,
                                                value: { rev: winningRev }
                                            };
                                            if (opts.include_docs) {
                                                doc.doc = data;
                                                doc.doc._rev = winningRev;
                                                if (opts.conflicts) {
                                                    doc.doc._conflicts = collectConflicts(metadata);
                                                }
                                                fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);
                                            }
                                            if (item.deleted) {
                                                if (opts.deleted === 'ok') {
                                                    doc.value.deleted = true;
                                                    doc.doc = null;
                                                } else {
                                                    continue;
                                                }
                                            }
                                            results.push(doc);
                                        }
                                    });
                                });
                            }, websqlError(callback), function () {
                                callback(null, {
                                    total_rows: totalRows,
                                    offset: opts.skip,
                                    rows: results
                                });
                            });
                        };

                        api._changes = function (opts) {
                            opts = clone(opts);

                            if (opts.continuous) {
                                var id = api._name + ':' + uuid();
                                websqlChanges.addListener(api._name, id, api, opts);
                                websqlChanges.notify(api._name);
                                return {
                                    cancel: function () {
                                        websqlChanges.removeListener(api._name, id);
                                    }
                                };
                            }

                            var descending = opts.descending;

                            // Ignore the `since` parameter when `descending` is true
                            opts.since = opts.since && !descending ? opts.since : 0;

                            var limit = 'limit' in opts ? opts.limit : -1;
                            if (limit === 0) {
                                limit = 1; // per CouchDB _changes spec
                            }

                            var returnDocs;
                            if ('return_docs' in opts) {
                                returnDocs = opts.return_docs;
                            } else if ('returnDocs' in opts) {
                                // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release
                                returnDocs = opts.returnDocs;
                            } else {
                                returnDocs = true;
                            }
                            var results = [];
                            var numResults = 0;

                            function fetchChanges() {

                                var selectStmt =
                                    DOC_STORE$1 + '.json AS metadata, ' +
                                    DOC_STORE$1 + '.max_seq AS maxSeq, ' +
                                    BY_SEQ_STORE$1 + '.json AS winningDoc, ' +
                                    BY_SEQ_STORE$1 + '.rev AS winningRev ';

                                var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;

                                var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +
                                    ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';

                                var criteria = ['maxSeq > ?'];
                                var sqlArgs = [opts.since];

                                if (opts.doc_ids) {
                                    criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));
                                    sqlArgs = sqlArgs.concat(opts.doc_ids);
                                }

                                var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');

                                var sql = select(selectStmt, from, joiner, criteria, orderBy);

                                var filter = filterChange(opts);
                                if (!opts.view && !opts.filter) {
                                    // we can just limit in the query
                                    sql += ' LIMIT ' + limit;
                                }

                                var lastSeq = opts.since || 0;
                                db.readTransaction(function (tx) {
                                    tx.executeSql(sql, sqlArgs, function (tx, result) {
                                        function reportChange(change) {
                                            return function () {
                                                opts.onChange(change);
                                            };
                                        }

                                        for (var i = 0, l = result.rows.length; i < l; i++) {
                                            var item = result.rows.item(i);
                                            var metadata = safeJsonParse(item.metadata);
                                            lastSeq = item.maxSeq;

                                            var doc = unstringifyDoc(item.winningDoc, metadata.id,
                                                item.winningRev);
                                            var change = opts.processChange(doc, metadata, opts);
                                            change.seq = item.maxSeq;

                                            var filtered = filter(change);
                                            if (typeof filtered === 'object') {
                                                return opts.complete(filtered);
                                            }

                                            if (filtered) {
                                                numResults++;
                                                if (returnDocs) {
                                                    results.push(change);
                                                }
                                                // process the attachment immediately
                                                // for the benefit of live listeners
                                                if (opts.attachments && opts.include_docs) {
                                                    fetchAttachmentsIfNecessary$1(doc, opts, api, tx,
                                                        reportChange(change));
                                                } else {
                                                    reportChange(change)();
                                                }
                                            }
                                            if (numResults === limit) {
                                                break;
                                            }
                                        }
                                    });
                                }, websqlError(opts.complete), function () {
                                    if (!opts.continuous) {
                                        opts.complete(null, {
                                            results: results,
                                            last_seq: lastSeq
                                        });
                                    }
                                });
                            }

                            fetchChanges();
                        };

                        api._close = function (callback) {
                            //WebSQL databases do not need to be closed
                            callback();
                        };

                        api._getAttachment = function (attachment, opts, callback) {
                            var res;
                            var tx = opts.ctx;
                            var digest = attachment.digest;
                            var type = attachment.content_type;
                            var sql = 'SELECT escaped, ' +
                                'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +
                                ATTACH_STORE$1 + ' WHERE digest=?';
                            tx.executeSql(sql, [digest], function (tx, result) {
                                // websql has a bug where \u0000 causes early truncation in strings
                                // and blobs. to work around this, we used to use the hex() function,
                                // but that's not performant. after migration 6, we remove \u0000
                                // and add it back in afterwards
                                var item = result.rows.item(0);
                                var data = item.escaped ? unescapeBlob(item.body) :
                                    parseHexString(item.body, encoding);
                                if (opts.binary) {
                                    res = binStringToBluffer(data, type);
                                } else {
                                    res = btoa$1(data);
                                }
                                callback(null, res);
                            });
                        };

                        api._getRevisionTree = function (docId, callback) {
                            db.readTransaction(function (tx) {
                                var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';
                                tx.executeSql(sql, [docId], function (tx, result) {
                                    if (!result.rows.length) {
                                        callback(createError(MISSING_DOC));
                                    } else {
                                        var data = safeJsonParse(result.rows.item(0).metadata);
                                        callback(null, data.rev_tree);
                                    }
                                });
                            });
                        };

                        api._doCompaction = function (docId, revs, callback) {
                            if (!revs.length) {
                                return callback();
                            }
                            db.transaction(function (tx) {

                                // update doc store
                                var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';
                                tx.executeSql(sql, [docId], function (tx, result) {
                                    var metadata = safeJsonParse(result.rows.item(0).metadata);
                                    traverseRevTree(metadata.rev_tree, function (isLeaf, pos,
                                                                                 revHash, ctx, opts) {
                                        var rev = pos + '-' + revHash;
                                        if (revs.indexOf(rev) !== -1) {
                                            opts.status = 'missing';
                                        }
                                    });

                                    var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';
                                    tx.executeSql(sql, [safeJsonStringify(metadata), docId]);
                                });

                                compactRevs$1(revs, docId, tx);
                            }, websqlError(callback), function () {
                                callback();
                            });
                        };

                        api._getLocal = function (id, callback) {
                            db.readTransaction(function (tx) {
                                var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';
                                tx.executeSql(sql, [id], function (tx, res) {
                                    if (res.rows.length) {
                                        var item = res.rows.item(0);
                                        var doc = unstringifyDoc(item.json, id, item.rev);
                                        callback(null, doc);
                                    } else {
                                        callback(createError(MISSING_DOC));
                                    }
                                });
                            });
                        };

                        api._putLocal = function (doc, opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }
                            delete doc._revisions; // ignore this, trust the rev
                            var oldRev = doc._rev;
                            var id = doc._id;
                            var newRev;
                            if (!oldRev) {
                                newRev = doc._rev = '0-1';
                            } else {
                                newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
                            }
                            var json = stringifyDoc(doc);

                            var ret;

                            function putLocal(tx) {
                                var sql;
                                var values;
                                if (oldRev) {
                                    sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +
                                        'WHERE id=? AND rev=?';
                                    values = [newRev, json, id, oldRev];
                                } else {
                                    sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';
                                    values = [id, newRev, json];
                                }
                                tx.executeSql(sql, values, function (tx, res) {
                                    if (res.rowsAffected) {
                                        ret = { ok: true, id: id, rev: newRev };
                                        if (opts.ctx) { // return immediately
                                            callback(null, ret);
                                        }
                                    } else {
                                        callback(createError(REV_CONFLICT));
                                    }
                                }, function () {
                                    callback(createError(REV_CONFLICT));
                                    return false; // ack that we handled the error
                                });
                            }

                            if (opts.ctx) {
                                putLocal(opts.ctx);
                            } else {
                                db.transaction(putLocal, websqlError(callback), function () {
                                    if (ret) {
                                        callback(null, ret);
                                    }
                                });
                            }
                        };

                        api._removeLocal = function (doc, opts, callback) {
                            if (typeof opts === 'function') {
                                callback = opts;
                                opts = {};
                            }
                            var ret;

                            function removeLocal(tx) {
                                var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';
                                var params = [doc._id, doc._rev];
                                tx.executeSql(sql, params, function (tx, res) {
                                    if (!res.rowsAffected) {
                                        return callback(createError(MISSING_DOC));
                                    }
                                    ret = { ok: true, id: doc._id, rev: '0-0' };
                                    if (opts.ctx) { // return immediately
                                        callback(null, ret);
                                    }
                                });
                            }

                            if (opts.ctx) {
                                removeLocal(opts.ctx);
                            } else {
                                db.transaction(removeLocal, websqlError(callback), function () {
                                    if (ret) {
                                        callback(null, ret);
                                    }
                                });
                            }
                        };

                        api._destroy = function (opts, callback) {
                            websqlChanges.removeAllListeners(api._name);
                            db.transaction(function (tx) {
                                var stores = [
                                    DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,
                                    LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1
                                ];
                                stores.forEach(function (store) {
                                    tx.executeSql('DROP TABLE IF EXISTS ' + store, []);
                                });
                            }, websqlError(callback), function () {
                                if (hasLocalStorage()) {
                                    delete window.localStorage['_pouch__websqldb_' + api._name];
                                    delete window.localStorage[api._name];
                                }
                                callback(null, { 'ok': true });
                            });
                        };
                    }

                    // in the browser, use a prefix. in Node, don't bother having one
                    WebSqlPouch.use_prefix = !!(typeof process === 'undefined' || process.browser);

                    WebSqlPouch.valid = valid;

                    var adapters = {
                        idb: IdbPouch,
                        websql: WebSqlPouch
                    };

                    PouchDB.ajax = ajax;
                    PouchDB.utils = utils;
                    PouchDB.Errors = allErrors;
                    PouchDB.replicate = replication.replicate;
                    PouchDB.sync = sync;
                    PouchDB.version = '5.3.1'; // will be automatically supplied by build.sh
                    PouchDB.adapter('http', HttpPouch);
                    PouchDB.adapter('https', HttpPouch);

                    PouchDB.plugin(mapreduce);

                    Object.keys(adapters).forEach(function (adapterName) {
                        PouchDB.adapter(adapterName, adapters[adapterName], true);
                    });

                    module.exports = PouchDB;
                }).call(this, _dereq_(13), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
            }, { "1": 1, "10": 10, "12": 12, "13": 13, "14": 14, "15": 15, "16": 16, "2": 2, "4": 4, "6": 6, "7": 7, "8": 8 }
        ]
    }, {}, [17])(17)
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.pouchdbFind = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
    'use strict';

    var upsert = _dereq_(4);
    var utils = _dereq_(5);
    var Promise = utils.Promise;

    function stringify(input) {
        if (!input) {
            return 'undefined'; // backwards compat for empty reduce
        }
        // for backwards compat with mapreduce, functions/strings are stringified
        // as-is. everything else is JSON-stringified.
        switch (typeof input) {
            case 'function':
                // e.g. a mapreduce map
                return input.toString();
            case 'string':
                // e.g. a mapreduce built-in _reduce function
                return input.toString();
            default:
                // e.g. a JSON object in the case of mango queries
                return JSON.stringify(input);
        }
    }

    module.exports = function (opts) {
        var sourceDB = opts.db;
        var viewName = opts.viewName;
        var mapFun = opts.map;
        var reduceFun = opts.reduce;
        var temporary = opts.temporary;
        var pluginName = opts.pluginName;

        // the "undefined" part is for backwards compatibility
        var viewSignature = stringify(mapFun) + stringify(reduceFun) +
            'undefined';

        if (!temporary && sourceDB._cachedViews) {
            var cachedView = sourceDB._cachedViews[viewSignature];
            if (cachedView) {
                return Promise.resolve(cachedView);
            }
        }

        return sourceDB.info().then(function (info) {

            var depDbName = info.db_name + '-mrview-' +
                (temporary ? 'temp' : utils.MD5(viewSignature));

            // save the view name in the source PouchDB so it can be cleaned up if necessary
            // (e.g. when the _design doc is deleted, remove all associated view data)
            function diffFunction(doc) {
                doc.views = doc.views || {};
                var fullViewName = viewName;
                if (fullViewName.indexOf('/') === -1) {
                    fullViewName = viewName + '/' + viewName;
                }
                var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};
                /* istanbul ignore if */
                if (depDbs[depDbName]) {
                    return; // no update necessary
                }
                depDbs[depDbName] = true;
                return doc;
            }
            return upsert(sourceDB, '_local/' + pluginName, diffFunction).then(function () {
                return sourceDB.registerDependentDatabase(depDbName).then(function (res) {
                    var db = res.db;
                    db.auto_compaction = true;
                    var view = {
                        name: depDbName,
                        db: db,
                        sourceDB: sourceDB,
                        adapter: sourceDB.adapter,
                        mapFun: mapFun,
                        reduceFun: reduceFun
                    };
                    return view.db.get('_local/lastSeq')["catch"](function (err) {
                        /* istanbul ignore if */
                        if (err.status !== 404) {
                            throw err;
                        }
                    }).then(function (lastSeqDoc) {
                        view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;
                        if (!temporary) {
                            sourceDB._cachedViews = sourceDB._cachedViews || {};
                            sourceDB._cachedViews[viewSignature] = view;
                            view.db.on('destroyed', function () {
                                delete sourceDB._cachedViews[viewSignature];
                            });
                        }
                        return view;
                    });
                });
            });
        });
    };

},{"4":4,"5":5}],2:[function(_dereq_,module,exports){
    (function (process){
        'use strict';

        var pouchCollate = _dereq_(26);
        var TaskQueue = _dereq_(3);
        var collate = pouchCollate.collate;
        var toIndexableString = pouchCollate.toIndexableString;
        var normalizeKey = pouchCollate.normalizeKey;
        var createView = _dereq_(1);
        var log;
        /* istanbul ignore else */
        if ((typeof console !== 'undefined') && (typeof console.log === 'function')) {
            log = Function.prototype.bind.call(console.log, console);
        } else {
            log = function () {};
        }
        var utils = _dereq_(5);
        var Promise = utils.Promise;
        var persistentQueues = {};
        var tempViewQueue = new TaskQueue();
        var CHANGES_BATCH_SIZE = 50;

        function QueryParseError(message) {
            this.status = 400;
            this.name = 'query_parse_error';
            this.message = message;
            this.error = true;
            try {
                Error.captureStackTrace(this, QueryParseError);
            } catch (e) {}
        }

        utils.inherits(QueryParseError, Error);

        function NotFoundError(message) {
            this.status = 404;
            this.name = 'not_found';
            this.message = message;
            this.error = true;
            try {
                Error.captureStackTrace(this, NotFoundError);
            } catch (e) {}
        }

        utils.inherits(NotFoundError, Error);

        function parseViewName(name) {
            // can be either 'ddocname/viewname' or just 'viewname'
            // (where the ddoc name is the same)
            return name.indexOf('/') === -1 ? [name, name] : name.split('/');
        }

        function isGenOne(changes) {
            // only return true if the current change is 1-
            // and there are no other leafs
            return changes.length === 1 && /^1-/.test(changes[0].rev);
        }

        function sortByKeyThenValue(x, y) {
            var keyCompare = collate(x.key, y.key);
            return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);
        }

        function sliceResults(results, limit, skip) {
            skip = skip || 0;
            if (typeof limit === 'number') {
                return results.slice(skip, limit + skip);
            } else if (skip > 0) {
                return results.slice(skip);
            }
            return results;
        }

        function rowToDocId(row) {
            var val = row.value;
            // Users can explicitly specify a joined doc _id, or it
            // defaults to the doc _id that emitted the key/value.
            var docId = (val && typeof val === 'object' && val._id) || row.id;
            return docId;
        }

        function emitError(db, e) {
            try {
                db.emit('error', e);
            } catch (err) {
                console.error(
                    'The user\'s map/reduce function threw an uncaught error.\n' +
                    'You can debug this error by doing:\n' +
                    'myDatabase.on(\'error\', function (err) { debugger; });\n' +
                    'Please double-check your map/reduce function.');
                console.error(e);
            }
        }

        function tryCode(db, fun, args) {
            // emit an event if there was an error thrown by a map/reduce function.
            // putting try/catches in a single function also avoids deoptimizations.
            try {
                return {
                    output : fun.apply(null, args)
                };
            } catch (e) {
                emitError(db, e);
                return {error: e};
            }
        }

        function checkQueryParseError(options, fun) {
            var startkeyName = options.descending ? 'endkey' : 'startkey';
            var endkeyName = options.descending ? 'startkey' : 'endkey';

            if (typeof options[startkeyName] !== 'undefined' &&
                typeof options[endkeyName] !== 'undefined' &&
                collate(options[startkeyName], options[endkeyName]) > 0) {
                throw new QueryParseError('No rows can match your key range, reverse your ' +
                    'start_key and end_key or set {descending : true}');
            } else if (fun.reduce && options.reduce !== false) {
                if (options.include_docs) {
                    throw new QueryParseError('{include_docs:true} is invalid for reduce');
                } else if (options.keys && options.keys.length > 1 &&
                    !options.group && !options.group_level) {
                    throw new QueryParseError('Multi-key fetches for reduce views must use {group: true}');
                }
            }
            if (options.group_level) {
                if (typeof options.group_level !== 'number') {
                    throw new QueryParseError('Invalid value for integer: "' + options.group_level + '"');
                }
                if (options.group_level < 0) {
                    throw new QueryParseError('Invalid value for positive integer: ' +
                        '"' + options.group_level + '"');
                }
            }
        }

        function defaultsTo(value) {
            return function (reason) {
                /* istanbul ignore else */
                if (reason.status === 404) {
                    return value;
                } else {
                    throw reason;
                }
            };
        }

        function createIndexer(def) {

            var pluginName = def.name;
            var mapper = def.mapper;
            var reducer = def.reducer;
            var ddocValidator = def.ddocValidator;


            // returns a promise for a list of docs to update, based on the input docId.
            // the order doesn't matter, because post-3.2.0, bulkDocs
            // is an atomic operation in all three adapters.
            function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {
                var metaDocId = '_local/doc_' + docId;
                var defaultMetaDoc = {_id: metaDocId, keys: []};
                var docData = docIdsToChangesAndEmits[docId];
                var indexableKeysToKeyValues = docData.indexableKeysToKeyValues;
                var changes = docData.changes;

                function getMetaDoc() {
                    if (isGenOne(changes)) {
                        // generation 1, so we can safely assume initial state
                        // for performance reasons (avoids unnecessary GETs)
                        return Promise.resolve(defaultMetaDoc);
                    }
                    return view.db.get(metaDocId)["catch"](defaultsTo(defaultMetaDoc));
                }

                function getKeyValueDocs(metaDoc) {
                    if (!metaDoc.keys.length) {
                        // no keys, no need for a lookup
                        return Promise.resolve({rows: []});
                    }
                    return view.db.allDocs({
                        keys: metaDoc.keys,
                        include_docs: true
                    });
                }

                function processKvDocs(metaDoc, kvDocsRes) {
                    var kvDocs = [];
                    var oldKeysMap = {};

                    for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {
                        var row = kvDocsRes.rows[i];
                        var doc = row.doc;
                        if (!doc) { // deleted
                            continue;
                        }
                        kvDocs.push(doc);
                        oldKeysMap[doc._id] = true;
                        doc._deleted = !indexableKeysToKeyValues[doc._id];
                        if (!doc._deleted) {
                            var keyValue = indexableKeysToKeyValues[doc._id];
                            if ('value' in keyValue) {
                                doc.value = keyValue.value;
                            }
                        }
                    }

                    var newKeys = Object.keys(indexableKeysToKeyValues);
                    newKeys.forEach(function (key) {
                        if (!oldKeysMap[key]) {
                            // new doc
                            var kvDoc = {
                                _id: key
                            };
                            var keyValue = indexableKeysToKeyValues[key];
                            if ('value' in keyValue) {
                                kvDoc.value = keyValue.value;
                            }
                            kvDocs.push(kvDoc);
                        }
                    });
                    metaDoc.keys = utils.uniq(newKeys.concat(metaDoc.keys));
                    kvDocs.push(metaDoc);

                    return kvDocs;
                }

                return getMetaDoc().then(function (metaDoc) {
                    return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {
                        return processKvDocs(metaDoc, kvDocsRes);
                    });
                });
            }

            // updates all emitted key/value docs and metaDocs in the mrview database
            // for the given batch of documents from the source database
            function saveKeyValues(view, docIdsToChangesAndEmits, seq) {
                var seqDocId = '_local/lastSeq';
                return view.db.get(seqDocId)[
                    "catch"](defaultsTo({_id: seqDocId, seq: 0}))
                    .then(function (lastSeqDoc) {
                        var docIds = Object.keys(docIdsToChangesAndEmits);
                        return Promise.all(docIds.map(function (docId) {
                            return getDocsToPersist(docId, view, docIdsToChangesAndEmits);
                        })).then(function (listOfDocsToPersist) {
                            var docsToPersist = utils.flatten(listOfDocsToPersist);
                            lastSeqDoc.seq = seq;
                            docsToPersist.push(lastSeqDoc);
                            // write all docs in a single operation, update the seq once
                            return view.db.bulkDocs({docs : docsToPersist});
                        });
                    });
            }

            function getQueue(view) {
                var viewName = typeof view === 'string' ? view : view.name;
                var queue = persistentQueues[viewName];
                if (!queue) {
                    queue = persistentQueues[viewName] = new TaskQueue();
                }
                return queue;
            }

            function updateView(view) {
                return utils.sequentialize(getQueue(view), function () {
                    return updateViewInQueue(view);
                })();
            }

            function updateViewInQueue(view) {
                // bind the emit function once
                var mapResults;
                var doc;

                function emit(key, value) {
                    var output = {id: doc._id, key: normalizeKey(key)};
                    // Don't explicitly store the value unless it's defined and non-null.
                    // This saves on storage space, because often people don't use it.
                    if (typeof value !== 'undefined' && value !== null) {
                        output.value = normalizeKey(value);
                    }
                    mapResults.push(output);
                }

                var mapFun = mapper(view.mapFun, emit);

                var currentSeq = view.seq || 0;

                function processChange(docIdsToChangesAndEmits, seq) {
                    return function () {
                        return saveKeyValues(view, docIdsToChangesAndEmits, seq);
                    };
                }

                var queue = new TaskQueue();

                return new Promise(function (resolve, reject) {

                    function complete() {
                        queue.finish().then(function () {
                            view.seq = currentSeq;
                            resolve();
                        });
                    }

                    function processNextBatch() {
                        view.sourceDB.changes({
                            conflicts: true,
                            include_docs: true,
                            style: 'all_docs',
                            since: currentSeq,
                            limit: CHANGES_BATCH_SIZE
                        }).on('complete', function (response) {
                            var results = response.results;
                            if (!results.length) {
                                return complete();
                            }
                            var docIdsToChangesAndEmits = {};
                            for (var i = 0, l = results.length; i < l; i++) {
                                var change = results[i];
                                if (change.doc._id[0] !== '_') {
                                    mapResults = [];
                                    doc = change.doc;

                                    if (!doc._deleted) {
                                        tryCode(view.sourceDB, mapFun, [doc]);
                                    }
                                    mapResults.sort(sortByKeyThenValue);

                                    var indexableKeysToKeyValues = {};
                                    var lastKey;
                                    for (var j = 0, jl = mapResults.length; j < jl; j++) {
                                        var obj = mapResults[j];
                                        var complexKey = [obj.key, obj.id];
                                        if (collate(obj.key, lastKey) === 0) {
                                            complexKey.push(j); // dup key+id, so make it unique
                                        }
                                        var indexableKey = toIndexableString(complexKey);
                                        indexableKeysToKeyValues[indexableKey] = obj;
                                        lastKey = obj.key;
                                    }
                                    docIdsToChangesAndEmits[change.doc._id] = {
                                        indexableKeysToKeyValues: indexableKeysToKeyValues,
                                        changes: change.changes
                                    };
                                }
                                currentSeq = change.seq;
                            }
                            queue.add(processChange(docIdsToChangesAndEmits, currentSeq));
                            if (results.length < CHANGES_BATCH_SIZE) {
                                return complete();
                            }
                            return processNextBatch();
                        }).on('error', onError);
                        /* istanbul ignore next */
                        function onError(err) {
                            reject(err);
                        }
                    }

                    processNextBatch();
                });
            }

            function reduceView(view, results, options) {
                if (options.group_level === 0) {
                    delete options.group_level;
                }

                var shouldGroup = options.group || options.group_level;

                var reduceFun = reducer(view.reduceFun);

                var groups = [];
                var lvl = options.group_level;
                results.forEach(function (e) {
                    var last = groups[groups.length - 1];
                    var key = shouldGroup ? e.key : null;

                    // only set group_level for array keys
                    if (shouldGroup && Array.isArray(key) && typeof lvl === 'number') {
                        key = key.length > lvl ? key.slice(0, lvl) : key;
                    }

                    if (last && collate(last.key[0][0], key) === 0) {
                        last.key.push([key, e.id]);
                        last.value.push(e.value);
                        return;
                    }
                    groups.push({key: [
                        [key, e.id]
                    ], value: [e.value]});
                });
                for (var i = 0, len = groups.length; i < len; i++) {
                    var e = groups[i];
                    var reduceTry = tryCode(view.sourceDB, reduceFun, [e.key, e.value, false]);
                    // TODO: can't do instanceof BuiltInError because this class is buried
                    // in mapreduce.js
                    if (reduceTry.error && /BuiltInError/.test(reduceTry.error.constructor)) {
                        // CouchDB returns an error if a built-in errors out
                        throw reduceTry.error;
                    }
                    // CouchDB just sets the value to null if a non-built-in errors out
                    e.value = reduceTry.error ? null : reduceTry.output;
                    e.key = e.key[0][0];
                }
                // no total_rows/offset when reducing
                return {rows: sliceResults(groups, options.limit, options.skip)};
            }

            function queryView(view, opts) {
                return utils.sequentialize(getQueue(view), function () {
                    return queryViewInQueue(view, opts);
                })();
            }

            function queryViewInQueue(view, opts) {
                var totalRows;
                var shouldReduce = view.reduceFun && opts.reduce !== false;
                var skip = opts.skip || 0;
                if (typeof opts.keys !== 'undefined' && !opts.keys.length) {
                    // equivalent query
                    opts.limit = 0;
                    delete opts.keys;
                }

                function fetchFromView(viewOpts) {
                    viewOpts.include_docs = true;
                    return view.db.allDocs(viewOpts).then(function (res) {
                        totalRows = res.total_rows;
                        return res.rows.map(function (result) {

                            // implicit migration - in older versions of PouchDB,
                            // we explicitly stored the doc as {id: ..., key: ..., value: ...}
                            // this is tested in a migration test
                            /* istanbul ignore next */
                            if ('value' in result.doc && typeof result.doc.value === 'object' &&
                                result.doc.value !== null) {
                                var keys = Object.keys(result.doc.value).sort();
                                // this detection method is not perfect, but it's unlikely the user
                                // emitted a value which was an object with these 3 exact keys
                                var expectedKeys = ['id', 'key', 'value'];
                                if (!(keys < expectedKeys || keys > expectedKeys)) {
                                    return result.doc.value;
                                }
                            }

                            var parsedKeyAndDocId = pouchCollate.parseIndexableString(result.doc._id);
                            return {
                                key: parsedKeyAndDocId[0],
                                id: parsedKeyAndDocId[1],
                                value: ('value' in result.doc ? result.doc.value : null)
                            };
                        });
                    });
                }

                function onMapResultsReady(rows) {
                    var finalResults;
                    if (shouldReduce) {
                        finalResults = reduceView(view, rows, opts);
                    } else {
                        finalResults = {
                            total_rows: totalRows,
                            offset: skip,
                            rows: rows
                        };
                    }
                    if (opts.include_docs) {
                        var docIds = utils.uniq(rows.map(rowToDocId));

                        return view.sourceDB.allDocs({
                            keys: docIds,
                            include_docs: true,
                            conflicts: opts.conflicts,
                            attachments: opts.attachments,
                            binary: opts.binary
                        }).then(function (allDocsRes) {
                            var docIdsToDocs = {};
                            allDocsRes.rows.forEach(function (row) {
                                if (row.doc) {
                                    docIdsToDocs['$' + row.id] = row.doc;
                                }
                            });
                            rows.forEach(function (row) {
                                var docId = rowToDocId(row);
                                var doc = docIdsToDocs['$' + docId];
                                if (doc) {
                                    row.doc = doc;
                                }
                            });
                            return finalResults;
                        });
                    } else {
                        return finalResults;
                    }
                }

                var flatten = function (array) {
                    return array.reduce(function (prev, cur) {
                        return prev.concat(cur);
                    });
                };

                if (typeof opts.keys !== 'undefined') {
                    var keys = opts.keys;
                    var fetchPromises = keys.map(function (key) {
                        var viewOpts = {
                            startkey : toIndexableString([key]),
                            endkey   : toIndexableString([key, {}])
                        };
                        return fetchFromView(viewOpts);
                    });
                    return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);
                } else { // normal query, no 'keys'
                    var viewOpts = {
                        descending : opts.descending
                    };
                    if (typeof opts.startkey !== 'undefined') {
                        viewOpts.startkey = opts.descending ?
                            toIndexableString([opts.startkey, {}]) :
                            toIndexableString([opts.startkey]);
                    }
                    if (typeof opts.endkey !== 'undefined') {
                        var inclusiveEnd = opts.inclusive_end !== false;
                        if (opts.descending) {
                            inclusiveEnd = !inclusiveEnd;
                        }

                        viewOpts.endkey = toIndexableString(inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);
                    }
                    if (typeof opts.key !== 'undefined') {
                        var keyStart = toIndexableString([opts.key]);
                        var keyEnd = toIndexableString([opts.key, {}]);
                        if (viewOpts.descending) {
                            viewOpts.endkey = keyStart;
                            viewOpts.startkey = keyEnd;
                        } else {
                            viewOpts.startkey = keyStart;
                            viewOpts.endkey = keyEnd;
                        }
                    }
                    if (!shouldReduce) {
                        if (typeof opts.limit === 'number') {
                            viewOpts.limit = opts.limit;
                        }
                        viewOpts.skip = skip;
                    }
                    return fetchFromView(viewOpts).then(onMapResultsReady);
                }
            }

            function localViewCleanup(db) {
                return db.get('_local/' + pluginName).then(function (metaDoc) {
                    var docsToViews = {};
                    Object.keys(metaDoc.views).forEach(function (fullViewName) {
                        var parts = parseViewName(fullViewName);
                        var designDocName = '_design/' + parts[0];
                        var viewName = parts[1];
                        docsToViews[designDocName] = docsToViews[designDocName] || {};
                        docsToViews[designDocName][viewName] = true;
                    });
                    var opts = {
                        keys : Object.keys(docsToViews),
                        include_docs : true
                    };
                    return db.allDocs(opts).then(function (res) {
                        var viewsToStatus = {};
                        res.rows.forEach(function (row) {
                            var ddocName = row.key.substring(8);
                            Object.keys(docsToViews[row.key]).forEach(function (viewName) {
                                var fullViewName = ddocName + '/' + viewName;
                                /* istanbul ignore if */
                                if (!metaDoc.views[fullViewName]) {
                                    // new format, without slashes, to support PouchDB 2.2.0
                                    // migration test in pouchdb's browser.migration.js verifies this
                                    fullViewName = viewName;
                                }
                                var viewDBNames = Object.keys(metaDoc.views[fullViewName]);
                                // design doc deleted, or view function nonexistent
                                var statusIsGood = row.doc && row.doc.views && row.doc.views[viewName];
                                viewDBNames.forEach(function (viewDBName) {
                                    viewsToStatus[viewDBName] = viewsToStatus[viewDBName] || statusIsGood;
                                });
                            });
                        });
                        var dbsToDelete = Object.keys(viewsToStatus).filter(function (viewDBName) {
                            return !viewsToStatus[viewDBName];
                        });
                        var destroyPromises = dbsToDelete.map(function (viewDBName) {
                            return utils.sequentialize(getQueue(viewDBName), function () {
                                return new db.constructor(viewDBName, db.__opts).destroy();
                            })();
                        });
                        return Promise.all(destroyPromises).then(function () {
                            return {ok: true};
                        });
                    });
                }, defaultsTo({ok: true}));
            }

            function queryPromised(db, fun, opts) {
                if (typeof fun !== 'string') {
                    // temp_view
                    checkQueryParseError(opts, fun);

                    var createViewOpts = {
                        db : db,
                        viewName : 'temp_view/temp_view',
                        map : fun.map,
                        reduce : fun.reduce,
                        temporary : true,
                        pluginName: pluginName
                    };
                    tempViewQueue.add(function () {
                        return createView(createViewOpts).then(function (view) {
                            function cleanup() {
                                return view.db.destroy();
                            }
                            return utils.fin(updateView(view).then(function () {
                                return queryView(view, opts);
                            }), cleanup);
                        });
                    });
                    return tempViewQueue.finish();
                } else {
                    // persistent view
                    var fullViewName = fun;
                    var parts = parseViewName(fullViewName);
                    var designDocName = parts[0];
                    var viewName = parts[1];
                    return db.get('_design/' + designDocName).then(function (doc) {
                        var fun = doc.views && doc.views[viewName];

                        if (!fun) {
                            // basic validator; it's assumed that every subclass would want this
                            throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +
                                viewName);
                        }

                        ddocValidator(doc, viewName);
                        checkQueryParseError(opts, fun);

                        var createViewOpts = {
                            db : db,
                            viewName : fullViewName,
                            map : fun.map,
                            reduce : fun.reduce,
                            pluginName: pluginName
                        };
                        return createView(createViewOpts).then(function (view) {
                            if (opts.stale === 'ok' || opts.stale === 'update_after') {
                                if (opts.stale === 'update_after') {
                                    process.nextTick(function () {
                                        updateView(view);
                                    });
                                }
                                return queryView(view, opts);
                            } else { // stale not ok
                                return updateView(view).then(function () {
                                    return queryView(view, opts);
                                });
                            }
                        });
                    });
                }
            }

            var query = function (fun, opts, callback) {
                var db = this;
                if (typeof opts === 'function') {
                    callback = opts;
                    opts = {};
                }
                opts = utils.extend(true, {}, opts);

                if (typeof fun === 'function') {
                    fun = {map : fun};
                }

                var promise = Promise.resolve().then(function () {
                    return queryPromised(db, fun, opts);
                });
                utils.promisedCallback(promise, callback);
                return promise;
            };

            var viewCleanup = utils.callbackify(function () {
                var db = this;
                return localViewCleanup(db);
            });

            return {
                query: query,
                viewCleanup: viewCleanup
            };
        }

        module.exports = createIndexer;

    }).call(this,_dereq_(34))
},{"1":1,"26":26,"3":3,"34":34,"5":5}],3:[function(_dereq_,module,exports){
    'use strict';
    /*
     * Simple task queue to sequentialize actions. Assumes callbacks will eventually fire (once).
     */

    var Promise = _dereq_(5).Promise;

    function TaskQueue() {
        this.promise = new Promise(function (fulfill) {fulfill(); });
    }
    TaskQueue.prototype.add = function (promiseFactory) {
        this.promise = this.promise["catch"](function () {
            // just recover
        }).then(function () {
            return promiseFactory();
        });
        return this.promise;
    };
    TaskQueue.prototype.finish = function () {
        return this.promise;
    };

    module.exports = TaskQueue;

},{"5":5}],4:[function(_dereq_,module,exports){
    'use strict';

    var upsert = _dereq_(31).upsert;

    module.exports = function (db, doc, diffFun) {
        return upsert.apply(db, [doc, diffFun]);
    };
},{"31":31}],5:[function(_dereq_,module,exports){
    (function (process){
        'use strict';
        /* istanbul ignore if */
        exports.Promise = _dereq_(29);

        exports.inherits = _dereq_(23);
        exports.extend = _dereq_(28);
        var argsarray = _dereq_(18);

        /* istanbul ignore next */
        exports.promisedCallback = function (promise, callback) {
            if (callback) {
                promise.then(function (res) {
                    process.nextTick(function () {
                        callback(null, res);
                    });
                }, function (reason) {
                    process.nextTick(function () {
                        callback(reason);
                    });
                });
            }
            return promise;
        };

        /* istanbul ignore next */
        exports.callbackify = function (fun) {
            return argsarray(function (args) {
                var cb = args.pop();
                var promise = fun.apply(this, args);
                if (typeof cb === 'function') {
                    exports.promisedCallback(promise, cb);
                }
                return promise;
            });
        };

// Promise finally util similar to Q.finally
        /* istanbul ignore next */
        exports.fin = function (promise, cb) {
            return promise.then(function (res) {
                var promise2 = cb();
                if (typeof promise2.then === 'function') {
                    return promise2.then(function () {
                        return res;
                    });
                }
                return res;
            }, function (reason) {
                var promise2 = cb();
                if (typeof promise2.then === 'function') {
                    return promise2.then(function () {
                        throw reason;
                    });
                }
                throw reason;
            });
        };

        exports.sequentialize = function (queue, promiseFactory) {
            return function () {
                var args = arguments;
                var that = this;
                return queue.add(function () {
                    return promiseFactory.apply(that, args);
                });
            };
        };

        exports.flatten = function (arrs) {
            var res = [];
            for (var i = 0, len = arrs.length; i < len; i++) {
                res = res.concat(arrs[i]);
            }
            return res;
        };

// uniq an array of strings, order not guaranteed
// similar to underscore/lodash _.uniq
        exports.uniq = function (arr) {
            var map = {};

            for (var i = 0, len = arr.length; i < len; i++) {
                map['$' + arr[i]] = true;
            }

            var keys = Object.keys(map);
            var output = new Array(keys.length);

            for (i = 0, len = keys.length; i < len; i++) {
                output[i] = keys[i].substring(1);
            }
            return output;
        };

        var crypto = _dereq_(19);
        var Md5 = _dereq_(35);

        exports.MD5 = function (string) {
            /* istanbul ignore else */
            if (!process.browser) {
                return crypto.createHash('md5').update(string).digest('hex');
            } else {
                return Md5.hash(string);
            }
        };
    }).call(this,_dereq_(34))
},{"18":18,"19":19,"23":23,"28":28,"29":29,"34":34,"35":35}],6:[function(_dereq_,module,exports){
    'use strict';

    var massageCreateIndexRequest = _dereq_(16);

    function createIndex(db, requestDef, callback) {
        requestDef = massageCreateIndexRequest(requestDef);

        db.request({
            method: 'POST',
            url: '_index',
            body: requestDef
        }, callback);
    }

    function find(db, requestDef, callback) {
        db.request({
            method: 'POST',
            url: '_find',
            body: requestDef
        }, callback);
    }

    function getIndexes(db, callback) {
        db.request({
            method: 'GET',
            url: '_index'
        }, callback);
    }

    function deleteIndex(db, indexDef, callback) {


        var ddoc = indexDef.ddoc;
        var type = indexDef.type || 'json';
        var name = indexDef.name;

        if (!ddoc) {
            return callback(new Error('you must provide an index\'s ddoc'));
        }

        if (!name) {
            return callback(new Error('you must provide an index\'s name'));
        }

        var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');

        db.request({
            method: 'DELETE',
            url: url
        }, callback);
    }

    exports.createIndex = createIndex;
    exports.find = find;
    exports.getIndexes = getIndexes;
    exports.deleteIndex = deleteIndex;
},{"16":16}],7:[function(_dereq_,module,exports){
    'use strict';

    var localUtils = _dereq_(15);
    var abstractMapReduce = _dereq_(2);
    var parseField = localUtils.parseField;

//
// One thing about these mappers:
//
// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),
// what you want to do in this case is optimize for the smallest possible
// function, since that's the thing that gets run over and over again.
//
// This code would be a lot simpler if all the if/elses were inside
// the function, but it would also be a lot less performant.
//


    function createDeepMultiMapper(fields, emit) {
        return function (doc) {
            var toEmit = [];
            for (var i = 0, iLen = fields.length; i < iLen; i++) {
                var parsedField = parseField(fields[i]);
                var value = doc;
                for (var j = 0, jLen = parsedField.length; j < jLen; j++) {
                    var key = parsedField[j];
                    value = value[key];
                    if (!value) {
                        break;
                    }
                }
                toEmit.push(value);
            }
            emit(toEmit);
        };
    }

    function createDeepSingleMapper(field, emit) {
        var parsedField = parseField(field);
        return function (doc) {
            var value = doc;
            for (var i = 0, len = parsedField.length; i < len; i++) {
                var key = parsedField[i];
                value = value[key];
                if (!value) {
                    return; // do nothing
                }
            }
            emit(value);
        };
    }

    function createShallowSingleMapper(field, emit) {
        return function (doc) {
            emit(doc[field]);
        };
    }

    function createShallowMultiMapper(fields, emit) {
        return function (doc) {
            var toEmit = [];
            for (var i = 0, len = fields.length; i < len; i++) {
                toEmit.push(doc[fields[i]]);
            }
            emit(toEmit);
        };
    }

    function checkShallow(fields) {
        for (var i = 0, len = fields.length; i < len; i++) {
            var field = fields[i];
            if (field.indexOf('.') !== -1) {
                return false;
            }
        }
        return true;
    }

    function createMapper(fields, emit) {
        var isShallow = checkShallow(fields);
        var isSingle = fields.length === 1;

        // notice we try to optimize for the most common case,
        // i.e. single shallow indexes
        if (isShallow) {
            if (isSingle) {
                return createShallowSingleMapper(fields[0], emit);
            } else { // multi
                return createShallowMultiMapper(fields, emit);
            }
        } else { // deep
            if (isSingle) {
                return createDeepSingleMapper(fields[0], emit);
            } else { // multi
                return createDeepMultiMapper(fields, emit);
            }
        }
    }

    function mapper(mapFunDef, emit) {
        // mapFunDef is a list of fields

        var fields = Object.keys(mapFunDef.fields);

        return createMapper(fields, emit);
    }

    /* istanbul ignore next */
    function reducer(/*reduceFunDef*/) {
        throw new Error('reduce not supported');
    }

    function ddocValidator(ddoc, viewName) {
        var view = ddoc.views[viewName];
        // This doesn't actually need to be here apparently, but
        // I feel safer keeping it.
        /* istanbul ignore if */
        if (!view.map || !view.map.fields) {
            throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +
                ' doesn\'t have map.fields defined. ' +
                'maybe it wasn\'t created by this plugin?');
        }
    }

    var abstractMapper = abstractMapReduce({
        name: 'indexes',
        mapper: mapper,
        reducer: reducer,
        ddocValidator: ddocValidator
    });

    module.exports = abstractMapper;
},{"15":15,"2":2}],8:[function(_dereq_,module,exports){
    'use strict';

    var utils = _dereq_(17);
    var log = utils.log;

    var pouchUpsert = _dereq_(31);
    var abstractMapper = _dereq_(7);
    var localUtils = _dereq_(15);
    var validateIndex = localUtils.validateIndex;
    var massageIndexDef = localUtils.massageIndexDef;
    var massageCreateIndexRequest = _dereq_(16);

    function upsert(db, docId, diffFun) {
        return pouchUpsert.upsert.call(db, docId, diffFun);
    }

    function createIndex(db, requestDef) {
        requestDef = massageCreateIndexRequest(requestDef);
        var originalIndexDef = utils.clone(requestDef.index);
        requestDef.index = massageIndexDef(requestDef.index);

        validateIndex(requestDef.index);

        var md5 = utils.MD5(JSON.stringify(requestDef));

        var viewName = requestDef.name || ('idx-' + md5);

        var ddocName = requestDef.ddoc || ('idx-' + md5);
        var ddocId = '_design/' + ddocName;

        var hasInvalidLanguage = false;
        var viewExists = false;

        function updateDdoc(doc) {
            if (doc._rev && doc.language !== 'query') {
                hasInvalidLanguage = true;
            }
            doc.language = 'query';
            doc.views = doc.views || {};

            viewExists = !!doc.views[viewName];

            if (viewExists) {
                return false;
            }

            doc.views[viewName] = {
                map: {
                    fields: utils.mergeObjects(requestDef.index.fields)
                },
                reduce: '_count',
                options: {
                    def: originalIndexDef
                }
            };

            return doc;
        }

        log('creating index', ddocId);

        return upsert(db, ddocId, updateDdoc).then(function () {
            if (hasInvalidLanguage) {
                throw new Error('invalid language for ddoc with id "' +
                    ddocId +
                    '" (should be "query")');
            }
        }).then(function () {
            // kick off a build
            // TODO: abstract-pouchdb-mapreduce should support auto-updating
            // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me
            var signature = ddocName + '/' + viewName;
            return abstractMapper.query.call(db, signature, {
                limit: 0,
                reduce: false
            }).then(function () {
                return {
                    id: ddocId,
                    name: viewName,
                    result: viewExists ? 'exists' : 'created'
                };
            });
        });
    }

    module.exports = createIndex;

},{"15":15,"16":16,"17":17,"31":31,"7":7}],9:[function(_dereq_,module,exports){
    'use strict';

    var abstractMapper = _dereq_(7);
    var upsert = _dereq_(4);

    function deleteIndex(db, index) {

        if (!index.ddoc) {
            throw new Error('you must supply an index.ddoc when deleting');
        }

        if (!index.name) {
            throw new Error('you must supply an index.name when deleting');
        }

        var docId = index.ddoc;
        var viewName = index.name;

        function deltaFun (doc) {
            if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {
                // only one view in this ddoc, delete the whole ddoc
                return {_id: docId, _deleted: true};
            }
            // more than one view here, just remove the view
            delete doc.views[viewName];
            return doc;
        }

        return upsert(db, docId, deltaFun).then(function () {
            return abstractMapper.viewCleanup.apply(db);
        }).then(function () {
            return {ok: true};
        });
    }

    module.exports = deleteIndex;
},{"4":4,"7":7}],10:[function(_dereq_,module,exports){
    'use strict';

//
// Do an in-memory filtering of rows that aren't covered by the index.
// E.g. if the user is asking for foo=1 and bar=2, but the index
// only covers "foo", then this in-memory filter would take care of
// "bar".
//

    var isArray = _dereq_(24);
    var collate = _dereq_(26).collate;
    var localUtils = _dereq_(15);
    var isCombinationalField = localUtils.isCombinationalField;
    var getKey = localUtils.getKey;
    var getValue = localUtils.getValue;
    var parseField = localUtils.parseField;
    var utils = _dereq_(17);
    var getFieldFromDoc = utils.getFieldFromDoc;

// create a comparator based on the sort object
    function createFieldSorter(sort) {

        function getFieldValuesAsArray(doc) {
            return sort.map(function (sorting) {
                var fieldName = getKey(sorting);
                var parsedField = parseField(fieldName);
                var docFieldValue = getFieldFromDoc(doc, parsedField);
                return docFieldValue;
            });
        }

        return function (aRow, bRow) {
            var aFieldValues = getFieldValuesAsArray(aRow.doc);
            var bFieldValues = getFieldValuesAsArray(bRow.doc);
            var collation = collate(aFieldValues, bFieldValues);
            if (collation !== 0) {
                return collation;
            }
            // this is what mango seems to do
            return utils.compare(aRow.doc._id, bRow.doc._id);
        };
    }

    function filterInMemoryFields (rows, requestDef, inMemoryFields) {
        rows = rows.filter(function (row) {
            return rowFilter(row.doc, requestDef.selector, inMemoryFields);
        });

        if (requestDef.sort) {
            // in-memory sort
            var fieldSorter = createFieldSorter(requestDef.sort);
            rows = rows.sort(fieldSorter);
            if (typeof requestDef.sort[0] !== 'string' &&
                getValue(requestDef.sort[0]) === 'desc') {
                rows = rows.reverse();
            }
        }

        if ('limit' in requestDef || 'skip' in requestDef) {
            // have to do the limit in-memory
            var skip = requestDef.skip || 0;
            var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;
            rows = rows.slice(skip, limit);
        }
        return rows;
    }

    function rowFilter (doc, selector, inMemoryFields) {
        return inMemoryFields.every(function (field) {
            var matcher = selector[field];
            var parsedField = parseField(field);
            var docFieldValue = getFieldFromDoc(doc, parsedField);
            if (isCombinationalField(field)) {
                return matchCominationalSelector(field, matcher, doc);
            }

            return matchSelector(matcher, doc, parsedField, docFieldValue);
        });
    }

    function matchSelector (matcher, doc, parsedField, docFieldValue) {
        if (!matcher) {
            // no filtering necessary; this field is just needed for sorting
            return true;
        }

        return Object.keys(matcher).every(function (userOperator) {
            var userValue = matcher[userOperator];
            return match(userOperator, doc, userValue, parsedField, docFieldValue);
        });
    }

    function matchCominationalSelector (field, matcher, doc) {

        if (field === '$or') {
            return matcher.some(function (orMatchers) {
                return rowFilter(doc, orMatchers, Object.keys(orMatchers));
            });
        }

        if (field === '$not') {
            return !rowFilter(doc, matcher, Object.keys(matcher));
        }

        //`$nor`
        return !matcher.find(function (orMatchers) {
            return rowFilter(doc, orMatchers, Object.keys(orMatchers));
        });

    }

    function match(userOperator, doc, userValue, parsedField, docFieldValue) {
        if (!matchers[userOperator]) {
            throw new Error('unknown operator "' + userOperator +
                '" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +
                '$nin, $size, $mod, $regex, $elemMatch, $type or $all');
        }
        return matchers[userOperator](doc, userValue, parsedField, docFieldValue);
    }

    function fieldExists(docFieldValue) {
        return typeof docFieldValue !== 'undefined' && docFieldValue !== null;
    }

    function fieldIsNotUndefined(docFieldValue) {
        return typeof docFieldValue !== 'undefined';
    }

    function modField (docFieldValue, userValue) {
        var divisor = userValue[0];
        var mod = userValue[1];
        if (divisor === 0) {
            throw new Error('Bad divisor, cannot divide by zero');
        }

        if (parseInt(divisor, 10) !== divisor ) {
            throw new Error('Divisor is not an integer');
        }

        if (parseInt(mod, 10) !== mod ) {
            throw new Error('Modulus is not an integer');
        }

        if (parseInt(docFieldValue, 10) !== docFieldValue) {
            return false;
        }

        return docFieldValue % divisor === mod;
    }

    function arrayContainsValue (docFieldValue, userValue) {
        return userValue.some(function (val) {
            if (docFieldValue instanceof Array) {
                return docFieldValue.indexOf(val) > -1;
            }

            return docFieldValue === val;
        });
    }

    function arrayContainsAllValues (docFieldValue, userValue) {
        return userValue.every(function (val) {
            return docFieldValue.indexOf(val) > -1;
        });
    }

    function arraySize (docFieldValue, userValue) {
        return docFieldValue.length === userValue;
    }

    function regexMatch(docFieldValue, userValue) {
        var re = new RegExp(userValue);

        return re.test(docFieldValue);
    }

    function typeMatch(docFieldValue, userValue) {

        switch (userValue) {
            case 'null':
                return docFieldValue === null;
            case 'boolean':
                return typeof(docFieldValue) === 'boolean';
            case 'number':
                return typeof(docFieldValue) === 'number';
            case 'string':
                return typeof(docFieldValue) === 'string';
            case 'array':
                return docFieldValue instanceof Array;
            case 'object':
                return ({}).toString.call(docFieldValue) === '[object Object]';
        }

        throw new Error(userValue + ' not supported as a type.' +
            'Please use one of object, string, array, number, boolean or null.');

    }

    var matchers = {

        '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {
            if (!isArray(docFieldValue)) {
                return false;
            }

            if (docFieldValue.length === 0) {
                return false;
            }

            if (typeof docFieldValue[0] === 'object') {
                return docFieldValue.some(function (val) {
                    return rowFilter(val, userValue, Object.keys(userValue));
                });
            }

            return docFieldValue.some(function (val) {
                return matchSelector(userValue, doc, parsedField, val);
            });
        },

        '$eq': function (doc, userValue, parsedField, docFieldValue) {
            return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;
        },

        '$gte': function (doc, userValue, parsedField, docFieldValue) {
            return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;
        },

        '$gt': function (doc, userValue, parsedField, docFieldValue) {
            return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;
        },

        '$lte': function (doc, userValue, parsedField, docFieldValue) {
            return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;
        },

        '$lt': function (doc, userValue, parsedField, docFieldValue) {
            return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;
        },

        '$exists': function (doc, userValue, parsedField, docFieldValue) {
            //a field that is null is still considered to exist
            if (userValue) {
                return fieldIsNotUndefined(docFieldValue);
            }

            return !fieldIsNotUndefined(docFieldValue);
        },

        '$mod': function (doc, userValue, parsedField, docFieldValue) {
            return fieldExists(docFieldValue) && modField(docFieldValue, userValue);
        },

        '$ne': function (doc, userValue, parsedField, docFieldValue) {
            return userValue.every(function (neValue) {
                return collate(docFieldValue, neValue) !== 0;
            });
        },
        '$in': function (doc, userValue, parsedField, docFieldValue) {
            return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);
        },

        '$nin': function (doc, userValue, parsedField, docFieldValue) {
            return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);
        },

        '$size': function (doc, userValue, parsedField, docFieldValue) {
            return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);
        },

        '$all': function (doc, userValue, parsedField, docFieldValue) {
            return isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);
        },

        '$regex': function (doc, userValue, parsedField, docFieldValue) {
            return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);
        },

        '$type': function (doc, userValue, parsedField, docFieldValue) {
            return typeMatch(docFieldValue, userValue);
        }
    };

    module.exports = filterInMemoryFields;

},{"15":15,"17":17,"24":24,"26":26}],11:[function(_dereq_,module,exports){
    'use strict';

    var utils = _dereq_(17);
    var clone = utils.clone;
    var getIndexes = _dereq_(13);
    var collate = _dereq_(26).collate;
    var abstractMapper = _dereq_(7);
    var planQuery = _dereq_(12);
    var localUtils = _dereq_(15);
    var filterInMemoryFields = _dereq_(10);
    var massageSelector = localUtils.massageSelector;
    var massageSort = localUtils.massageSort;
    var getValue = localUtils.getValue;
    var validateFindRequest = localUtils.validateFindRequest;
    var validateSort = localUtils.validateSort;
    var reverseOptions = localUtils.reverseOptions;
    var filterInclusiveStart = localUtils.filterInclusiveStart;
    var Promise = utils.Promise;

    function indexToSignature(index) {
        // remove '_design/'
        return index.ddoc.substring(8) + '/' + index.name;
    }

    function doAllDocs(db, originalOpts) {
        var opts = clone(originalOpts);

        // CouchDB responds in weird ways when you provide a non-string to _id;
        // we mimic the behavior for consistency. See issue66 tests for details.

        if (opts.descending) {
            if ('endkey' in opts && typeof opts.endkey !== 'string') {
                opts.endkey = '';
            }
            if ('startkey' in opts && typeof opts.startkey !== 'string') {
                opts.limit = 0;
            }
        } else {
            if ('startkey' in opts && typeof opts.startkey !== 'string') {
                opts.startkey = '';
            }
            if ('endkey' in opts && typeof opts.endkey !== 'string') {
                opts.limit = 0;
            }
        }
        if ('key' in opts && typeof opts.key !== 'string') {
            opts.limit = 0;
        }

        return db.allDocs(opts);
    }

    function find(db, requestDef) {

        if (requestDef.selector) {
            requestDef.selector = massageSelector(requestDef.selector);
        }
        if (requestDef.sort) {
            requestDef.sort = massageSort(requestDef.sort);
        }

        validateFindRequest(requestDef);

        return getIndexes(db).then(function (getIndexesRes) {

            var queryPlan = planQuery(requestDef, getIndexesRes.indexes);

            var indexToUse = queryPlan.index;

            validateSort(requestDef, indexToUse);

            var opts = utils.extend(true, {
                include_docs: true,
                reduce: false
            }, queryPlan.queryOpts);

            if ('startkey' in opts && 'endkey' in opts &&
                collate(opts.startkey, opts.endkey) > 0) {
                // can't possibly return any results, startkey > endkey
                return {docs: []};
            }

            var isDescending = requestDef.sort &&
                typeof requestDef.sort[0] !== 'string' &&
                getValue(requestDef.sort[0]) === 'desc';

            if (isDescending) {
                // either all descending or all ascending
                opts.descending = true;
                opts = reverseOptions(opts);
            }

            if (!queryPlan.inMemoryFields.length) {
                // no in-memory filtering necessary, so we can let the
                // database do the limit/skip for us
                if ('limit' in requestDef) {
                    opts.limit = requestDef.limit;
                }
                if ('skip' in requestDef) {
                    opts.skip = requestDef.skip;
                }
            }

            return Promise.resolve().then(function () {
                if (indexToUse.name === '_all_docs') {
                    return doAllDocs(db, opts);
                } else {
                    var signature = indexToSignature(indexToUse);
                    return abstractMapper.query.call(db, signature, opts);
                }
            }).then(function (res) {

                if (opts.inclusive_start === false) {
                    // may have to manually filter the first one,
                    // since couchdb has no true inclusive_start option
                    res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);
                }

                if (queryPlan.inMemoryFields.length) {
                    // need to filter some stuff in-memory
                    res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);
                }

                var resp = {
                    docs: res.rows.map(function (row) {
                        var doc = row.doc;
                        if (requestDef.fields) {
                            return utils.pick(doc, requestDef.fields);
                        }
                        return doc;
                    })
                };

                if (indexToUse.defaultUsed) {
                    resp.warning = 'no matching index found, create an index to optimize query time';
                }

                return resp;
            });
        });
    }

    module.exports = find;

},{"10":10,"12":12,"13":13,"15":15,"17":17,"26":26,"7":7}],12:[function(_dereq_,module,exports){
    'use strict';

    var utils = _dereq_(17);
    var log = utils.log;
    var localUtils = _dereq_(15);
    var getKey = localUtils.getKey;
    var getUserFields = localUtils.getUserFields;

// couchdb lowest collation value
    var COLLATE_LO = null;

// couchdb highest collation value (TODO: well not really, but close enough amirite)
    var COLLATE_HI = {"\uffff": {}};

// couchdb second-lowest collation value

    function checkFieldInIndex(index, field) {
        var indexFields = index.def.fields.map(getKey);
        for (var i = 0, len = indexFields.length; i < len; i++) {
            var indexField = indexFields[i];
            if (field === indexField) {
                return true;
            }
        }
        return false;
    }

// so when you do e.g. $eq/$eq, we can do it entirely in the database.
// but when you do e.g. $gt/$eq, the first part can be done
// in the database, but the second part has to be done in-memory,
// because $gt has forced us to lose precision.
// so that's what this determines
    function userOperatorLosesPrecision(selector, field) {
        var matcher = selector[field];
        var userOperator = getKey(matcher);

        return userOperator !== '$eq';
    }

// sort the user fields by their position in the index,
// if they're in the index
    function sortFieldsByIndex(userFields, index) {
        var indexFields = index.def.fields.map(getKey);

        return userFields.slice().sort(function (a, b) {
            var aIdx = indexFields.indexOf(a);
            var bIdx = indexFields.indexOf(b);
            if (aIdx === -1) {
                aIdx = Number.MAX_VALUE;
            }
            if (bIdx === -1) {
                bIdx = Number.MAX_VALUE;
            }
            return utils.compare(aIdx, bIdx);
        });
    }

// first pass to try to find fields that will need to be sorted in-memory
    function getBasicInMemoryFields(index, selector, userFields) {

        userFields = sortFieldsByIndex(userFields, index);

        // check if any of the user selectors lose precision
        var needToFilterInMemory = false;
        for (var i = 0, len = userFields.length; i < len; i++) {
            var field = userFields[i];
            if (needToFilterInMemory || !checkFieldInIndex(index, field)) {
                return userFields.slice(i);
            }
            if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {
                needToFilterInMemory = true;
            }
        }
        return [];
    }

    function getInMemoryFieldsFromNe(selector) {
        var fields = [];
        Object.keys(selector).forEach(function (field) {
            var matcher = selector[field];
            Object.keys(matcher).forEach(function (operator) {
                if (operator === '$ne') {
                    fields.push(field);
                }
            });
        });
        return fields;
    }

    function getInMemoryFields(coreInMemoryFields, index, selector, userFields) {
        var result = utils.flatten(
            // in-memory fields reported as necessary by the query planner
            coreInMemoryFields,
            // combine with another pass that checks for any we may have missed
            getBasicInMemoryFields(index, selector, userFields),
            // combine with another pass that checks for $ne's
            getInMemoryFieldsFromNe(selector)
        );

        return sortFieldsByIndex(utils.uniq(result), index);
    }

// check that at least one field in the user's query is represented
// in the index. order matters in the case of sorts
    function checkIndexFieldsMatch(indexFields, sortOrder, fields) {
        if (sortOrder) {
            // array has to be a strict subarray of index array. furthermore,
            // the sortOrder fields need to all be represented in the index
            var sortMatches = utils.oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);
            var selectorMatches = utils.oneArrayIsSubArrayOfOther(fields, indexFields);

            return sortMatches && selectorMatches;
        }

        // all of the user's specified fields still need to be
        // on the left side of the index array, although the order
        // doesn't matter
        return utils.oneSetIsSubArrayOfOther(fields, indexFields);
    }

    var logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];
    function isNonLogicalMatcher (matcher) {
        return logicalMatchers.indexOf(matcher) === -1;
    }

// check all the index fields for usages of '$ne'
// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},
// then we can neither use an index on ['foo'] nor an index on
// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']
    function checkFieldsLogicallySound(indexFields, selector) {
        var firstField = indexFields[0];
        var matcher = selector[firstField];

        var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {
            return !(isNonLogicalMatcher(matcherKey));
        });

        if (!hasLogicalOperator) {
            return false;
        }

        var isInvalidNe = Object.keys(matcher).length === 1 &&
            getKey(matcher) === '$ne';

        return !isInvalidNe;
    }

    function checkIndexMatches(index, sortOrder, fields, selector) {

        var indexFields = index.def.fields.map(getKey);

        var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);

        if (!fieldsMatch) {
            return false;
        }

        return checkFieldsLogicallySound(indexFields, selector);
    }

//
// the algorithm is very simple:
// take all the fields the user supplies, and if those fields
// are a strict subset of the fields in some index,
// then use that index
//
//
    function findMatchingIndexes(selector, userFields, sortOrder, indexes) {

        return indexes.reduce(function (res, index) {
            var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);
            if (indexMatches) {
                res.push(index);
            }
            return res;
        }, []);
    }

// find the best index, i.e. the one that matches the most fields
// in the user's query
    function findBestMatchingIndex(selector, userFields, sortOrder, indexes) {

        var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);

        if (matchingIndexes.length === 0) {
            //return `all_docs` as a default index;
            //I'm assuming that _all_docs is always first
            var defaultIndex = indexes[0];
            defaultIndex.defaultUsed = true;
            return defaultIndex;
        }
        if (matchingIndexes.length === 1) {
            return matchingIndexes[0];
        }

        var userFieldsMap = utils.arrayToObject(userFields);

        function scoreIndex(index) {
            var indexFields = index.def.fields.map(getKey);
            var score = 0;
            for (var i = 0, len = indexFields.length; i < len; i++) {
                var indexField = indexFields[i];
                if (userFieldsMap[indexField]) {
                    score++;
                }
            }
            return score;
        }

        return utils.max(matchingIndexes, scoreIndex);
    }

    function getSingleFieldQueryOptsFor(userOperator, userValue) {
        switch (userOperator) {
            case '$eq':
                return {key: userValue};
            case '$lte':
                return {endkey: userValue};
            case '$gte':
                return {startkey: userValue};
            case '$lt':
                return {
                    endkey: userValue,
                    inclusive_end: false
                };
            case '$gt':
                return {
                    startkey: userValue,
                    inclusive_start: false
                };
        }
    }

    function getSingleFieldCoreQueryPlan(selector, index) {
        var field = getKey(index.def.fields[0]);
        var matcher = selector[field];
        var inMemoryFields = [];

        var userOperators = Object.keys(matcher);

        var combinedOpts;

        userOperators.forEach(function (userOperator) {

            if (isNonLogicalMatcher(userOperator)) {
                inMemoryFields.push(field);
                return;
            }

            var userValue = matcher[userOperator];

            var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);

            if (combinedOpts) {
                combinedOpts = utils.mergeObjects([combinedOpts, newQueryOpts]);
            } else {
                combinedOpts = newQueryOpts;
            }
        });

        return {
            queryOpts: combinedOpts,
            inMemoryFields: inMemoryFields
        };
    }

    function getMultiFieldCoreQueryPlan(userOperator, userValue) {
        switch (userOperator) {
            case '$eq':
                return {
                    startkey: userValue,
                    endkey: userValue
                };
            case '$lte':
                return {
                    endkey: userValue
                };
            case '$gte':
                return {
                    startkey: userValue
                };
            case '$lt':
                return {
                    endkey: userValue,
                    inclusive_end: false
                };
            case '$gt':
                return {
                    startkey: userValue,
                    inclusive_start: false
                };
        }
    }

    function getMultiFieldQueryOpts(selector, index) {

        var indexFields = index.def.fields.map(getKey);

        var inMemoryFields = [];
        var startkey = [];
        var endkey = [];
        var inclusiveStart;
        var inclusiveEnd;


        function finish(i) {

            if (inclusiveStart !== false) {
                startkey.push(COLLATE_LO);
            }
            if (inclusiveEnd !== false) {
                endkey.push(COLLATE_HI);
            }
            // keep track of the fields where we lost specificity,
            // and therefore need to filter in-memory
            inMemoryFields = indexFields.slice(i);
        }

        for (var i = 0, len = indexFields.length; i < len; i++) {
            var indexField = indexFields[i];

            var matcher = selector[indexField];

            if (!matcher) { // fewer fields in user query than in index
                finish(i);
                break;
            } else if (i > 0) {
                if ('$ne' in matcher) { // unusable $ne index
                    finish(i);
                    break;
                }
                var usingGtlt = (
                '$gt' in matcher || '$gte' in matcher ||
                '$lt' in matcher || '$lte' in matcher);
                var previousKeys = Object.keys(selector[indexFields[i - 1]]);
                var previousWasEq = utils.arrayEquals(previousKeys, ['$eq']);
                var previousWasSame = utils.arrayEquals(previousKeys, Object.keys(matcher));
                var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;
                if (gtltLostSpecificity) {
                    finish(i);
                    break;
                }
            }

            var userOperators = Object.keys(matcher);

            var combinedOpts = null;

            for (var j = 0; j < userOperators.length; j++) {
                var userOperator = userOperators[j];
                var userValue = matcher[userOperator];

                var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);

                if (combinedOpts) {
                    combinedOpts = utils.mergeObjects([combinedOpts, newOpts]);
                } else {
                    combinedOpts = newOpts;
                }
            }

            startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);
            endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);
            if ('inclusive_start' in combinedOpts) {
                inclusiveStart = combinedOpts.inclusive_start;
            }
            if ('inclusive_end' in combinedOpts) {
                inclusiveEnd = combinedOpts.inclusive_end;
            }
        }

        var res = {
            startkey: startkey,
            endkey: endkey
        };

        if (typeof inclusiveStart !== 'undefined') {
            res.inclusive_start = inclusiveStart;
        }
        if (typeof inclusiveEnd !== 'undefined') {
            res.inclusive_end = inclusiveEnd;
        }

        return {
            queryOpts: res,
            inMemoryFields: inMemoryFields
        };
    }

    function getDefaultQueryPlan () {
        return {
            queryOpts: {startkey: null},
            //getInMemoryFields will do the work here later
            inMemoryFields: []
        };
    }

    function getCoreQueryPlan(selector, index) {
        if (index.defaultUsed) {
            return getDefaultQueryPlan(selector, index);
        }

        if (index.def.fields.length === 1) {
            // one field in index, so the value was indexed as a singleton
            return getSingleFieldCoreQueryPlan(selector, index);
        }
        // else index has multiple fields, so the value was indexed as an array
        return getMultiFieldQueryOpts(selector, index);
    }

    function planQuery(request, indexes) {

        log('planning query', request);

        var selector = request.selector;
        var sort = request.sort;

        var userFieldsRes = getUserFields(selector, sort);

        var userFields = userFieldsRes.fields;
        var sortOrder = userFieldsRes.sortOrder;
        var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes);

        var coreQueryPlan = getCoreQueryPlan(selector, index);
        var queryOpts = coreQueryPlan.queryOpts;
        var coreInMemoryFields = coreQueryPlan.inMemoryFields;

        var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);

        var res = {
            queryOpts: queryOpts,
            index: index,
            inMemoryFields: inMemoryFields
        };
        log('query plan', res);
        return res;
    }

    module.exports = planQuery;

},{"15":15,"17":17}],13:[function(_dereq_,module,exports){
    'use strict';

    var utils = _dereq_(17);

    var localUtils = _dereq_(15);
    var massageIndexDef = localUtils.massageIndexDef;

    function getIndexes(db) {
        // just search through all the design docs and filter in-memory.
        // hopefully there aren't that many ddocs.
        return db.allDocs({
            startkey: '_design/',
            endkey: '_design/\uffff',
            include_docs: true
        }).then(function (allDocsRes) {
            var res = {
                indexes: [{
                    ddoc: null,
                    name: '_all_docs',
                    type: 'special',
                    def: {
                        fields: [{_id: 'asc'}]
                    }
                }]
            };

            res.indexes = utils.flatten(res.indexes, allDocsRes.rows.filter(function (row) {
                return row.doc.language === 'query';
            }).map(function (row) {
                var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];

                return viewNames.map(function (viewName) {
                    var view = row.doc.views[viewName];
                    return {
                        ddoc: row.id,
                        name: viewName,
                        type: 'json',
                        def: massageIndexDef(view.options.def)
                    };
                });
            }));

            // these are sorted by view name for some reason
            res.indexes.sort(function (left, right) {
                return utils.compare(left.name, right.name);
            });
            res.total_rows = res.indexes.length;
            return res;
        });
    }

    module.exports = getIndexes;

},{"15":15,"17":17}],14:[function(_dereq_,module,exports){
    'use strict';

    var utils = _dereq_(17);
    var callbackify = utils.callbackify;

    exports.createIndex = callbackify(_dereq_(8));
    exports.find = callbackify(_dereq_(11));
    exports.getIndexes = callbackify(_dereq_(13));
    exports.deleteIndex = callbackify(_dereq_(9));
},{"11":11,"13":13,"17":17,"8":8,"9":9}],15:[function(_dereq_,module,exports){
    'use strict';

    var utils = _dereq_(17);
    var collate = _dereq_(26);

    function getKey(obj) {
        return Object.keys(obj)[0];
    }

    function getValue(obj) {
        return obj[getKey(obj)];
    }

// normalize the "sort" value
    function massageSort(sort) {
        if (!Array.isArray(sort)) {
            throw new Error('invalid sort json - should be an array');
        }
        return sort.map(function (sorting) {
            if (typeof sorting === 'string') {
                var obj = {};
                obj[sorting] = 'asc';
                return obj;
            } else {
                return sorting;
            }
        });
    }

    var combinationFields = ['$or', '$nor', '$not'];
    function isCombinationalField (field) {
        return combinationFields.indexOf(field) > -1;
    }

// collapse logically equivalent gt/gte values
    function mergeGtGte(operator, value, fieldMatchers) {
        if (typeof fieldMatchers.$eq !== 'undefined') {
            return; // do nothing
        }
        if (typeof fieldMatchers.$gte !== 'undefined') {
            if (operator === '$gte') {
                if (value > fieldMatchers.$gte) { // more specificity
                    fieldMatchers.$gte = value;
                }
            } else { // operator === '$gt'
                if (value >= fieldMatchers.$gte) { // more specificity
                    delete fieldMatchers.$gte;
                    fieldMatchers.$gt = value;
                }
            }
        } else if (typeof fieldMatchers.$gt !== 'undefined') {
            if (operator === '$gte') {
                if (value > fieldMatchers.$gt) { // more specificity
                    delete fieldMatchers.$gt;
                    fieldMatchers.$gte = value;
                }
            } else { // operator === '$gt'
                if (value > fieldMatchers.$gt) { // more specificity
                    fieldMatchers.$gt = value;
                }
            }
        } else {
            fieldMatchers[operator] = value;
        }
    }

// collapse logically equivalent lt/lte values
    function mergeLtLte(operator, value, fieldMatchers) {
        if (typeof fieldMatchers.$eq !== 'undefined') {
            return; // do nothing
        }
        if (typeof fieldMatchers.$lte !== 'undefined') {
            if (operator === '$lte') {
                if (value < fieldMatchers.$lte) { // more specificity
                    fieldMatchers.$lte = value;
                }
            } else { // operator === '$gt'
                if (value <= fieldMatchers.$lte) { // more specificity
                    delete fieldMatchers.$lte;
                    fieldMatchers.$lt = value;
                }
            }
        } else if (typeof fieldMatchers.$lt !== 'undefined') {
            if (operator === '$lte') {
                if (value < fieldMatchers.$lt) { // more specificity
                    delete fieldMatchers.$lt;
                    fieldMatchers.$lte = value;
                }
            } else { // operator === '$gt'
                if (value < fieldMatchers.$lt) { // more specificity
                    fieldMatchers.$lt = value;
                }
            }
        } else {
            fieldMatchers[operator] = value;
        }
    }

// combine $ne values into one array
    function mergeNe(value, fieldMatchers) {
        if ('$ne' in fieldMatchers) {
            // there are many things this could "not" be
            fieldMatchers.$ne.push(value);
        } else { // doesn't exist yet
            fieldMatchers.$ne = [value];
        }
    }

// add $eq into the mix
    function mergeEq(value, fieldMatchers) {
        // these all have less specificity than the $eq
        // TODO: check for user errors here
        delete fieldMatchers.$gt;
        delete fieldMatchers.$gte;
        delete fieldMatchers.$lt;
        delete fieldMatchers.$lte;
        delete fieldMatchers.$ne;
        fieldMatchers.$eq = value;
    }

// flatten an array of selectors joined by an $and operator
    function mergeAndedSelectors(selectors) {

        // sort to ensure that e.g. if the user specified
        // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into
        // just {$gt: 'b'}
        var res = {};

        selectors.forEach(function (selector) {
            Object.keys(selector).forEach(function (field) {
                var matcher = selector[field];
                if (typeof matcher !== 'object') {
                    matcher = {$eq: matcher};
                }

                if (isCombinationalField(field)) {
                    if (matcher instanceof Array) {
                        res[field] = matcher.map(function (m) {
                            return mergeAndedSelectors([m]);
                        });
                    } else {
                        res[field] = mergeAndedSelectors([matcher]);
                    }
                } else {
                    var fieldMatchers = res[field] = res[field] || {};
                    Object.keys(matcher).forEach(function (operator) {
                        var value = matcher[operator];

                        if (operator === '$gt' || operator === '$gte') {
                            return mergeGtGte(operator, value, fieldMatchers);
                        } else if (operator === '$lt' || operator === '$lte') {
                            return mergeLtLte(operator, value, fieldMatchers);
                        } else if (operator === '$ne') {
                            return mergeNe(value, fieldMatchers);
                        } else if (operator === '$eq') {
                            return mergeEq(value, fieldMatchers);
                        }
                        fieldMatchers[operator] = value;
                    });
                }
            });
        });

        return res;
    }

//
// normalize the selector
//
    function massageSelector(input) {
        var result = utils.clone(input);
        var wasAnded = false;
        if ('$and' in result) {
            result = mergeAndedSelectors(result['$and']);
            wasAnded = true;
        }

        ['$or', '$nor'].forEach(function (orOrNor) {
            if (orOrNor in result) {
                // message each individual selector
                // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}
                result[orOrNor].forEach(function (subSelector) {
                    var fields = Object.keys(subSelector);
                    for (var i = 0; i < fields.length; i++) {
                        var field = fields[i];
                        var matcher = subSelector[field];
                        if (typeof matcher !== 'object' || matcher === null) {
                            subSelector[field] = {$eq: matcher};
                        }
                    }
                });
            }
        });

        if ('$not' in result) {
            //This feels a little like forcing, but it will work for now,
            //I would like to come back to this and make the merging of selectors a little more generic
            result['$not'] = mergeAndedSelectors([result['$not']]);
        }

        var fields = Object.keys(result);

        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var matcher = result[field];

            if (typeof matcher !== 'object' || matcher === null) {
                matcher = {$eq: matcher};
            } else if ('$ne' in matcher && !wasAnded) {
                // I put these in an array, since there may be more than one
                // but in the "mergeAnded" operation, I already take care of that
                matcher.$ne = [matcher.$ne];
            }
            result[field] = matcher;
        }

        return result;
    }


    function massageIndexDef(indexDef) {
        indexDef.fields = indexDef.fields.map(function (field) {
            if (typeof field === 'string') {
                var obj = {};
                obj[field] = 'asc';
                return obj;
            }
            return field;
        });
        return indexDef;
    }

    function getKeyFromDoc(doc, index) {
        var res = [];
        for (var i = 0; i < index.def.fields.length; i++) {
            var field = getKey(index.def.fields[i]);
            res.push(doc[field]);
        }
        return res;
    }

// have to do this manually because REASONS. I don't know why
// CouchDB didn't implement inclusive_start
    function filterInclusiveStart(rows, targetValue, index) {
        var indexFields = index.def.fields;
        for (var i = 0, len = rows.length; i < len; i++) {
            var row = rows[i];

            // shave off any docs at the beginning that are <= the
            // target value

            var docKey = getKeyFromDoc(row.doc, index);
            if (indexFields.length === 1) {
                docKey = docKey[0]; // only one field, not multi-field
            } else { // more than one field in index
                // in the case where e.g. the user is searching {$gt: {a: 1}}
                // but the index is [a, b], then we need to shorten the doc key
                while (docKey.length > targetValue.length) {
                    docKey.pop();
                }
            }
            //ABS as we just looking for values that don't match
            if (Math.abs(collate.collate(docKey, targetValue)) > 0) {
                // no need to filter any further; we're past the key
                break;
            }
        }
        return i > 0 ? rows.slice(i) : rows;
    }

    function reverseOptions(opts) {
        var newOpts = utils.clone(opts);
        delete newOpts.startkey;
        delete newOpts.endkey;
        delete newOpts.inclusive_start;
        delete newOpts.inclusive_end;

        if ('endkey' in opts) {
            newOpts.startkey = opts.endkey;
        }
        if ('startkey' in opts) {
            newOpts.endkey = opts.startkey;
        }
        if ('inclusive_start' in opts) {
            newOpts.inclusive_end = opts.inclusive_start;
        }
        if ('inclusive_end' in opts) {
            newOpts.inclusive_start = opts.inclusive_end;
        }
        return newOpts;
    }

    function validateIndex(index) {
        var ascFields = index.fields.filter(function (field) {
            return getValue(field) === 'asc';
        });
        if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {
            throw new Error('unsupported mixed sorting');
        }
    }

    function validateSort (requestDef, index) {
        if (index.defaultUsed && requestDef.sort) {
            var noneIdSorts = requestDef.sort.filter(function (sortItem) {
                return Object.keys(sortItem)[0] !== '_id';
            }).map(function (sortItem) {
                return Object.keys(sortItem)[0];
            });

            if (noneIdSorts.length > 0) {
                throw new Error('Cannot sort on field(s) "' + noneIdSorts.join(',') +
                    '" when using the default index');
            }
        }

        if (index.defaultUsed) {
            return;
        }
    }

    function validateFindRequest(requestDef) {
        if (typeof requestDef.selector !== 'object') {
            throw new Error('you must provide a selector when you find()');
        }

        /*var selectors = requestDef.selector['$and'] || [requestDef.selector];
         for (var i = 0; i < selectors.length; i++) {
         var selector = selectors[i];
         var keys = Object.keys(selector);
         if (keys.length === 0) {
         throw new Error('invalid empty selector');
         }
         //var selection = selector[keys[0]];
         /*if (Object.keys(selection).length !== 1) {
         throw new Error('invalid selector: ' + JSON.stringify(selection) +
         ' - it must have exactly one key/value');
         }
         }*/
    }

// determine the maximum number of fields
// we're going to need to query, e.g. if the user
// has selection ['a'] and sorting ['a', 'b'], then we
// need to use the longer of the two: ['a', 'b']
    function getUserFields(selector, sort) {
        var selectorFields = Object.keys(selector);
        var sortFields = sort? sort.map(getKey) : [];
        var userFields;
        if (selectorFields.length >= sortFields.length) {
            userFields = selectorFields;
        } else {
            userFields = sortFields;
        }

        if (sortFields.length === 0) {
            return {
                fields: userFields
            };
        }

        // sort according to the user's preferred sorting
        userFields = userFields.sort(function (left, right) {
            var leftIdx = sortFields.indexOf(left);
            if (leftIdx === -1) {
                leftIdx = Number.MAX_VALUE;
            }
            var rightIdx = sortFields.indexOf(right);
            if (rightIdx === -1) {
                rightIdx = Number.MAX_VALUE;
            }
            return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;
        });

        return {
            fields: userFields,
            sortOrder: sort.map(getKey)
        };
    }

    module.exports = {
        getKey: getKey,
        getValue: getValue,
        massageSort: massageSort,
        massageSelector: massageSelector,
        validateIndex: validateIndex,
        validateFindRequest: validateFindRequest,
        validateSort: validateSort,
        reverseOptions: reverseOptions,
        filterInclusiveStart: filterInclusiveStart,
        massageIndexDef: massageIndexDef,
        parseField: utils.parseField,
        getUserFields: getUserFields,
        isCombinationalField: isCombinationalField
    };

},{"17":17,"26":26}],16:[function(_dereq_,module,exports){
    'use strict';

    var utils = _dereq_(17);
    var clone = utils.clone;

// we restucture the supplied JSON considerably, because the official
// Mango API is very particular about a lot of this stuff, but we like
// to be liberal with what we accept in order to prevent mental
// breakdowns in our users
    module.exports = function (requestDef) {
        requestDef = clone(requestDef);

        if (!requestDef.index) {
            requestDef.index = {};
        }

        ['type', 'name', 'ddoc'].forEach(function (key) {
            if (requestDef.index[key]) {
                requestDef[key] = requestDef.index[key];
                delete requestDef.index[key];
            }
        });

        if (requestDef.fields) {
            requestDef.index.fields = requestDef.fields;
            delete requestDef.fields;
        }

        if (!requestDef.type) {
            requestDef.type = 'json';
        }
        return requestDef;
    };
},{"17":17}],17:[function(_dereq_,module,exports){
    (function (process){
        'use strict';

        var Promise = _dereq_(29);

        /* istanbul ignore next */
        exports.once = function (fun) {
            var called = false;
            return exports.getArguments(function (args) {
                if (called) {
                    console.trace();
                    throw new Error('once called  more than once');
                } else {
                    called = true;
                    fun.apply(this, args);
                }
            });
        };
        /* istanbul ignore next */
        exports.getArguments = function (fun) {
            return function () {
                var len = arguments.length;
                var args = new Array(len);
                var i = -1;
                while (++i < len) {
                    args[i] = arguments[i];
                }
                return fun.call(this, args);
            };
        };
        /* istanbul ignore next */
        exports.toPromise = function (func) {
            //create the function we will be returning
            return exports.getArguments(function (args) {
                var self = this;
                var tempCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;
                // if the last argument is a function, assume its a callback
                var usedCB;
                if (tempCB) {
                    // if it was a callback, create a new callback which calls it,
                    // but do so async so we don't trap any errors
                    usedCB = function (err, resp) {
                        process.nextTick(function () {
                            tempCB(err, resp);
                        });
                    };
                }
                var promise = new Promise(function (fulfill, reject) {
                    try {
                        var callback = exports.once(function (err, mesg) {
                            if (err) {
                                reject(err);
                            } else {
                                fulfill(mesg);
                            }
                        });
                        // create a callback for this invocation
                        // apply the function in the orig context
                        args.push(callback);
                        func.apply(self, args);
                    } catch (e) {
                        reject(e);
                    }
                });
                // if there is a callback, call it back
                if (usedCB) {
                    promise.then(function (result) {
                        usedCB(null, result);
                    }, usedCB);
                }
                promise.cancel = function () {
                    return this;
                };
                return promise;
            });
        };

        exports.inherits = _dereq_(23);
        exports.Promise = Promise;

        exports.clone = function (obj) {
            return exports.extend(true, {}, obj);
        };

        exports.extend = _dereq_(28);

        exports.callbackify = function (fun) {
            return exports.getArguments(function (args) {
                var cb = args.pop();
                var promise = fun.apply(this, args);
                exports.promisedCallback(promise, cb);
                return promise;
            });
        };

        exports.promisedCallback = function (promise, callback) {
            promise.then(function (res) {
                process.nextTick(function () {
                    callback(null, res);
                });
            }, function (reason) {
                process.nextTick(function () {
                    callback(reason);
                });
            });
            return promise;
        };

        var crypto = _dereq_(19);
        var Md5 = _dereq_(35);

        exports.MD5 = function (string) {
            /* istanbul ignore else */
            if (!process.browser) {
                return crypto.createHash('md5').update(string).digest('hex');
            } else {
                return Md5.hash(string);
            }
        };

        exports.flatten = exports.getArguments(function (args) {
            var res = [];
            for (var i = 0, len = args.length; i < len; i++) {
                var subArr = args[i];
                if (Array.isArray(subArr)) {
                    res = res.concat(exports.flatten.apply(null, subArr));
                } else {
                    res.push(subArr);
                }
            }
            return res;
        });

        exports.mergeObjects = function (arr) {
            var res = {};
            for (var i = 0, len = arr.length; i < len; i++) {
                res = exports.extend(true, res, arr[i]);
            }
            return res;
        };

// this would just be "return doc[field]", but fields
// can be "deep" due to dot notation
        exports.getFieldFromDoc = function (doc, parsedField) {
            var value = doc;
            for (var i = 0, len = parsedField.length; i < len; i++) {
                var key = parsedField[i];
                value = value[key];
                if (!value) {
                    break;
                }
            }
            return value;
        };

        exports.setFieldInDoc = function (doc, parsedField, value) {
            for (var i = 0, len = parsedField.length; i < len-1; i++) {
                var elem = parsedField[i];
                doc = doc[elem] = {};
            }
            doc[parsedField[len-1]] = value;
        };

// Converts a string in dot notation to an array of its components, with backslash escaping
        exports.parseField = function (fieldName) {
            // fields may be deep (e.g. "foo.bar.baz"), so parse
            var fields = [];
            var current = '';
            for (var i = 0, len = fieldName.length; i < len; i++) {
                var ch = fieldName[i];
                if (ch === '.') {
                    if (i > 0 && fieldName[i - 1] === '\\') { // escaped delimiter
                        current = current.substring(0, current.length - 1) + '.';
                    } else { // not escaped, so delimiter
                        fields.push(current);
                        current = '';
                    }
                } else { // normal character
                    current += ch;
                }
            }
            fields.push(current);
            return fields;
        };

// Selects a list of fields defined in dot notation from one doc
// and copies them to a new doc. Like underscore _.pick but supports nesting.
        exports.pick = function (obj, arr) {
            var res = {};
            for (var i = 0, len = arr.length; i < len; i++) {
                var parsedField = exports.parseField(arr[i]);
                var value = exports.getFieldFromDoc(obj, parsedField);
                if(typeof value !== 'undefined') {
                    exports.setFieldInDoc(res, parsedField, value);
                }
            }
            return res;
        };

// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false
        exports.oneArrayIsSubArrayOfOther = function (left, right) {

            for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {
                if (left[i] !== right[i]) {
                    return false;
                }
            }
            return true;
        };

// e.g.['a', 'b', 'c'], ['a', 'b'] is false
        exports.oneArrayIsStrictSubArrayOfOther = function (left, right) {

            if (left.length > right.length) {
                return false;
            }

            return exports.oneArrayIsSubArrayOfOther(left, right);
        };

// same as above, but treat the left array as an unordered set
// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false
        exports.oneSetIsSubArrayOfOther = function (left, right) {
            left = left.slice();
            for (var i = 0, len = right.length; i < len; i++) {
                var field = right[i];
                if (!left.length) {
                    break;
                }
                var leftIdx = left.indexOf(field);
                if (leftIdx === -1) {
                    return false;
                } else {
                    left.splice(leftIdx, 1);
                }
            }
            return true;
        };

        exports.compare = function (left, right) {
            return left < right ? -1 : left > right ? 1 : 0;
        };

        exports.arrayToObject = function (arr) {
            var res = {};
            for (var i = 0, len = arr.length; i < len; i++) {
                res[arr[i]] = true;
            }
            return res;
        };

        exports.max = function (arr, fun) {
            var max = null;
            var maxScore = -1;
            for (var i = 0, len = arr.length; i < len; i++) {
                var element = arr[i];
                var score = fun(element);
                if (score > maxScore) {
                    maxScore = score;
                    max = element;
                }
            }
            return max;
        };

        exports.arrayEquals = function (arr1, arr2) {
            if (arr1.length !== arr2.length) {
                return false;
            }
            for (var i = 0, len = arr1.length; i < len; i++) {
                if (arr1[i] !== arr2[i]) {
                    return false;
                }
            }
            return true;
        };

        exports.uniq = function(arr) {
            var obj = {};
            for (var i = 0; i < arr.length; i++) {
                obj['$' + arr[i]] = true;
            }
            return Object.keys(obj).map(function (key) {
                return key.substring(1);
            });
        };

        exports.log = _dereq_(20)('pouchdb:find');

    }).call(this,_dereq_(34))
},{"19":19,"20":20,"23":23,"28":28,"29":29,"34":34,"35":35}],18:[function(_dereq_,module,exports){
    'use strict';

    module.exports = argsArray;

    function argsArray(fun) {
        return function () {
            var len = arguments.length;
            if (len) {
                var args = [];
                var i = -1;
                while (++i < len) {
                    args[i] = arguments[i];
                }
                return fun.call(this, args);
            } else {
                return fun.call(this, []);
            }
        };
    }
},{}],19:[function(_dereq_,module,exports){

},{}],20:[function(_dereq_,module,exports){

    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = _dereq_(21);
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome
    && 'undefined' != typeof chrome.storage
        ? chrome.storage.local
        : localstorage();

    /**
     * Colors.
     */

    exports.colors = [
        'lightseagreen',
        'forestgreen',
        'goldenrod',
        'dodgerblue',
        'darkorchid',
        'crimson'
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
        // is webkit? http://stackoverflow.com/a/16459606/376773
        return ('WebkitAppearance' in document.documentElement.style) ||
            // is firebug? http://stackoverflow.com/a/398120/376773
            (window.console && (console.firebug || (console.exception && console.table))) ||
            // is firefox >= v31?
            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
            (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
    }

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    exports.formatters.j = function(v) {
        return JSON.stringify(v);
    };


    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs() {
        var args = arguments;
        var useColors = this.useColors;

        args[0] = (useColors ? '%c' : '')
            + this.namespace
            + (useColors ? ' %c' : ' ')
            + args[0]
            + (useColors ? '%c ' : ' ')
            + '+' + exports.humanize(this.diff);

        if (!useColors) return args;

        var c = 'color: ' + this.color;
        args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

        // the final "%c" is somewhat tricky, because there could be other
        // arguments passed either before or after the %c, so we need to
        // figure out the correct index to insert the CSS into
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-z%]/g, function(match) {
            if ('%%' === match) return;
            index++;
            if ('%c' === match) {
                // we only are interested in the *last* %c
                // (the user may have provided their own)
                lastC = index;
            }
        });

        args.splice(lastC, 0, c);
        return args;
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
        // this hackery is required for IE8/9, where
        // the `console.log` function doesn't have 'apply'
        return 'object' === typeof console
            && console.log
            && Function.prototype.apply.call(console.log, console, arguments);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
        try {
            if (null == namespaces) {
                exports.storage.removeItem('debug');
            } else {
                exports.storage.debug = namespaces;
            }
        } catch(e) {}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
        var r;
        try {
            r = exports.storage.debug;
        } catch(e) {}
        return r;
    }

    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

    exports.enable(load());

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage(){
        try {
            return window.localStorage;
        } catch (e) {}
    }

},{"21":21}],21:[function(_dereq_,module,exports){

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = _dereq_(25);

    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];

    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lowercased letter, i.e. "n".
     */

    exports.formatters = {};

    /**
     * Previously assigned color.
     */

    var prevColor = 0;

    /**
     * Previous log timestamp.
     */

    var prevTime;

    /**
     * Select a color.
     *
     * @return {Number}
     * @api private
     */

    function selectColor() {
        return exports.colors[prevColor++ % exports.colors.length];
    }

    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

    function debug(namespace) {

        // define the `disabled` version
        function disabled() {
        }
        disabled.enabled = false;

        // define the `enabled` version
        function enabled() {

            var self = enabled;

            // set `diff` timestamp
            var curr = +new Date();
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;

            // add the `color` if not set
            if (null == self.useColors) self.useColors = exports.useColors();
            if (null == self.color && self.useColors) self.color = selectColor();

            var args = Array.prototype.slice.call(arguments);

            args[0] = exports.coerce(args[0]);

            if ('string' !== typeof args[0]) {
                // anything else let's inspect with %o
                args = ['%o'].concat(args);
            }

            // apply any `formatters` transformations
            var index = 0;
            args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
                // if we encounter an escaped % then don't increase the array index
                if (match === '%%') return match;
                index++;
                var formatter = exports.formatters[format];
                if ('function' === typeof formatter) {
                    var val = args[index];
                    match = formatter.call(self, val);

                    // now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });

            if ('function' === typeof exports.formatArgs) {
                args = exports.formatArgs.apply(self, args);
            }
            var logFn = enabled.log || exports.log || console.log.bind(console);
            logFn.apply(self, args);
        }
        enabled.enabled = true;

        var fn = exports.enabled(namespace) ? enabled : disabled;

        fn.namespace = namespace;

        return fn;
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

    function enable(namespaces) {
        exports.save(namespaces);

        var split = (namespaces || '').split(/[\s,]+/);
        var len = split.length;

        for (var i = 0; i < len; i++) {
            if (!split[i]) continue; // ignore empty strings
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
                exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
            } else {
                exports.names.push(new RegExp('^' + namespaces + '$'));
            }
        }
    }

    /**
     * Disable debug output.
     *
     * @api public
     */

    function disable() {
        exports.enable('');
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
        var i, len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
            if (exports.skips[i].test(name)) {
                return false;
            }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
            if (exports.names[i].test(name)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
    }

},{"25":25}],22:[function(_dereq_,module,exports){
    (function (global){
        'use strict';
        var Mutation = global.MutationObserver || global.WebKitMutationObserver;

        var scheduleDrain;

        {
            if (Mutation) {
                var called = 0;
                var observer = new Mutation(nextTick);
                var element = global.document.createTextNode('');
                observer.observe(element, {
                    characterData: true
                });
                scheduleDrain = function () {
                    element.data = (called = ++called % 2);
                };
            } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
                var channel = new global.MessageChannel();
                channel.port1.onmessage = nextTick;
                scheduleDrain = function () {
                    channel.port2.postMessage(0);
                };
            } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
                scheduleDrain = function () {

                    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                    var scriptEl = global.document.createElement('script');
                    scriptEl.onreadystatechange = function () {
                        nextTick();

                        scriptEl.onreadystatechange = null;
                        scriptEl.parentNode.removeChild(scriptEl);
                        scriptEl = null;
                    };
                    global.document.documentElement.appendChild(scriptEl);
                };
            } else {
                scheduleDrain = function () {
                    setTimeout(nextTick, 0);
                };
            }
        }

        var draining;
        var queue = [];
//named nextTick for less confusing stack traces
        function nextTick() {
            draining = true;
            var i, oldQueue;
            var len = queue.length;
            while (len) {
                oldQueue = queue;
                queue = [];
                i = -1;
                while (++i < len) {
                    oldQueue[i]();
                }
                len = queue.length;
            }
            draining = false;
        }

        module.exports = immediate;
        function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
                scheduleDrain();
            }
        }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],23:[function(_dereq_,module,exports){
    if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function () {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
        }
    }

},{}],24:[function(_dereq_,module,exports){

    /**
     * isArray
     */

    var isArray = Array.isArray;

    /**
     * toString
     */

    var str = Object.prototype.toString;

    /**
     * Whether or not the given `val`
     * is an array.
     *
     * example:
     *
     *        isArray([]);
     *        // > true
     *        isArray(arguments);
     *        // > false
     *        isArray('');
     *        // > false
     *
     * @param {mixed} val
     * @return {bool}
     */

    module.exports = isArray || function (val) {
            return !! val && '[object Array]' == str.call(val);
        };

},{}],25:[function(_dereq_,module,exports){
    /**
     * Helpers.
     */

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */

    module.exports = function(val, options){
        options = options || {};
        if ('string' == typeof val) return parse(val);
        return options["long"]
            ? long(val)
            : short(val);
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse(str) {
        str = '' + str;
        if (str.length > 10000) return;
        var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
        if (!match) return;
        var n = parseFloat(match[1]);
        var type = (match[2] || 'ms').toLowerCase();
        switch (type) {
            case 'years':
            case 'year':
            case 'yrs':
            case 'yr':
            case 'y':
                return n * y;
            case 'days':
            case 'day':
            case 'd':
                return n * d;
            case 'hours':
            case 'hour':
            case 'hrs':
            case 'hr':
            case 'h':
                return n * h;
            case 'minutes':
            case 'minute':
            case 'mins':
            case 'min':
            case 'm':
                return n * m;
            case 'seconds':
            case 'second':
            case 'secs':
            case 'sec':
            case 's':
                return n * s;
            case 'milliseconds':
            case 'millisecond':
            case 'msecs':
            case 'msec':
            case 'ms':
                return n;
        }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function short(ms) {
        if (ms >= d) return Math.round(ms / d) + 'd';
        if (ms >= h) return Math.round(ms / h) + 'h';
        if (ms >= m) return Math.round(ms / m) + 'm';
        if (ms >= s) return Math.round(ms / s) + 's';
        return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function long(ms) {
        return plural(ms, d, 'day')
            || plural(ms, h, 'hour')
            || plural(ms, m, 'minute')
            || plural(ms, s, 'second')
            || ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, n, name) {
        if (ms < n) return;
        if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
        return Math.ceil(ms / n) + ' ' + name + 's';
    }

},{}],26:[function(_dereq_,module,exports){
    'use strict';

    var MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE
    var MAGNITUDE_DIGITS = 3; // ditto
    var SEP = ''; // set to '_' for easier debugging

    var utils = _dereq_(27);

    exports.collate = function (a, b) {

        if (a === b) {
            return 0;
        }

        a = exports.normalizeKey(a);
        b = exports.normalizeKey(b);

        var ai = collationIndex(a);
        var bi = collationIndex(b);
        if ((ai - bi) !== 0) {
            return ai - bi;
        }
        if (a === null) {
            return 0;
        }
        switch (typeof a) {
            case 'number':
                return a - b;
            case 'boolean':
                return a === b ? 0 : (a < b ? -1 : 1);
            case 'string':
                return stringCollate(a, b);
        }
        return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);
    };

// couch considers null/NaN/Infinity/-Infinity === undefined,
// for the purposes of mapreduce indexes. also, dates get stringified.
    exports.normalizeKey = function (key) {
        switch (typeof key) {
            case 'undefined':
                return null;
            case 'number':
                if (key === Infinity || key === -Infinity || isNaN(key)) {
                    return null;
                }
                return key;
            case 'object':
                var origKey = key;
                if (Array.isArray(key)) {
                    var len = key.length;
                    key = new Array(len);
                    for (var i = 0; i < len; i++) {
                        key[i] = exports.normalizeKey(origKey[i]);
                    }
                } else if (key instanceof Date) {
                    return key.toJSON();
                } else if (key !== null) { // generic object
                    key = {};
                    for (var k in origKey) {
                        if (origKey.hasOwnProperty(k)) {
                            var val = origKey[k];
                            if (typeof val !== 'undefined') {
                                key[k] = exports.normalizeKey(val);
                            }
                        }
                    }
                }
        }
        return key;
    };

    function indexify(key) {
        if (key !== null) {
            switch (typeof key) {
                case 'boolean':
                    return key ? 1 : 0;
                case 'number':
                    return numToIndexableString(key);
                case 'string':
                    // We've to be sure that key does not contain \u0000
                    // Do order-preserving replacements:
                    // 0 -> 1, 1
                    // 1 -> 1, 2
                    // 2 -> 2, 2
                    return key
                        .replace(/\u0002/g, '\u0002\u0002')
                        .replace(/\u0001/g, '\u0001\u0002')
                        .replace(/\u0000/g, '\u0001\u0001');
                case 'object':
                    var isArray = Array.isArray(key);
                    var arr = isArray ? key : Object.keys(key);
                    var i = -1;
                    var len = arr.length;
                    var result = '';
                    if (isArray) {
                        while (++i < len) {
                            result += exports.toIndexableString(arr[i]);
                        }
                    } else {
                        while (++i < len) {
                            var objKey = arr[i];
                            result += exports.toIndexableString(objKey) +
                                exports.toIndexableString(key[objKey]);
                        }
                    }
                    return result;
            }
        }
        return '';
    }

// convert the given key to a string that would be appropriate
// for lexical sorting, e.g. within a database, where the
// sorting is the same given by the collate() function.
    exports.toIndexableString = function (key) {
        var zero = '\u0000';
        key = exports.normalizeKey(key);
        return collationIndex(key) + SEP + indexify(key) + zero;
    };

    function parseNumber(str, i) {
        var originalIdx = i;
        var num;
        var zero = str[i] === '1';
        if (zero) {
            num = 0;
            i++;
        } else {
            var neg = str[i] === '0';
            i++;
            var numAsString = '';
            var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);
            var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;
            if (neg) {
                magnitude = -magnitude;
            }
            i += MAGNITUDE_DIGITS;
            while (true) {
                var ch = str[i];
                if (ch === '\u0000') {
                    break;
                } else {
                    numAsString += ch;
                }
                i++;
            }
            numAsString = numAsString.split('.');
            if (numAsString.length === 1) {
                num = parseInt(numAsString, 10);
            } else {
                num = parseFloat(numAsString[0] + '.' + numAsString[1]);
            }
            if (neg) {
                num = num - 10;
            }
            if (magnitude !== 0) {
                // parseFloat is more reliable than pow due to rounding errors
                // e.g. Number.MAX_VALUE would return Infinity if we did
                // num * Math.pow(10, magnitude);
                num = parseFloat(num + 'e' + magnitude);
            }
        }
        return {num: num, length : i - originalIdx};
    }

// move up the stack while parsing
// this function moved outside of parseIndexableString for performance
    function pop(stack, metaStack) {
        var obj = stack.pop();

        if (metaStack.length) {
            var lastMetaElement = metaStack[metaStack.length - 1];
            if (obj === lastMetaElement.element) {
                // popping a meta-element, e.g. an object whose value is another object
                metaStack.pop();
                lastMetaElement = metaStack[metaStack.length - 1];
            }
            var element = lastMetaElement.element;
            var lastElementIndex = lastMetaElement.index;
            if (Array.isArray(element)) {
                element.push(obj);
            } else if (lastElementIndex === stack.length - 2) { // obj with key+value
                var key = stack.pop();
                element[key] = obj;
            } else {
                stack.push(obj); // obj with key only
            }
        }
    }

    exports.parseIndexableString = function (str) {
        var stack = [];
        var metaStack = []; // stack for arrays and objects
        var i = 0;

        while (true) {
            var collationIndex = str[i++];
            if (collationIndex === '\u0000') {
                if (stack.length === 1) {
                    return stack.pop();
                } else {
                    pop(stack, metaStack);
                    continue;
                }
            }
            switch (collationIndex) {
                case '1':
                    stack.push(null);
                    break;
                case '2':
                    stack.push(str[i] === '1');
                    i++;
                    break;
                case '3':
                    var parsedNum = parseNumber(str, i);
                    stack.push(parsedNum.num);
                    i += parsedNum.length;
                    break;
                case '4':
                    var parsedStr = '';
                    while (true) {
                        var ch = str[i];
                        if (ch === '\u0000') {
                            break;
                        }
                        parsedStr += ch;
                        i++;
                    }
                    // perform the reverse of the order-preserving replacement
                    // algorithm (see above)
                    parsedStr = parsedStr.replace(/\u0001\u0001/g, '\u0000')
                        .replace(/\u0001\u0002/g, '\u0001')
                        .replace(/\u0002\u0002/g, '\u0002');
                    stack.push(parsedStr);
                    break;
                case '5':
                    var arrayElement = { element: [], index: stack.length };
                    stack.push(arrayElement.element);
                    metaStack.push(arrayElement);
                    break;
                case '6':
                    var objElement = { element: {}, index: stack.length };
                    stack.push(objElement.element);
                    metaStack.push(objElement);
                    break;
                default:
                    throw new Error(
                        'bad collationIndex or unexpectedly reached end of input: ' + collationIndex);
            }
        }
    };

    function arrayCollate(a, b) {
        var len = Math.min(a.length, b.length);
        for (var i = 0; i < len; i++) {
            var sort = exports.collate(a[i], b[i]);
            if (sort !== 0) {
                return sort;
            }
        }
        return (a.length === b.length) ? 0 :
            (a.length > b.length) ? 1 : -1;
    }
    function stringCollate(a, b) {
        // See: https://github.com/daleharvey/pouchdb/issues/40
        // This is incompatible with the CouchDB implementation, but its the
        // best we can do for now
        return (a === b) ? 0 : ((a > b) ? 1 : -1);
    }
    function objectCollate(a, b) {
        var ak = Object.keys(a), bk = Object.keys(b);
        var len = Math.min(ak.length, bk.length);
        for (var i = 0; i < len; i++) {
            // First sort the keys
            var sort = exports.collate(ak[i], bk[i]);
            if (sort !== 0) {
                return sort;
            }
            // if the keys are equal sort the values
            sort = exports.collate(a[ak[i]], b[bk[i]]);
            if (sort !== 0) {
                return sort;
            }

        }
        return (ak.length === bk.length) ? 0 :
            (ak.length > bk.length) ? 1 : -1;
    }
// The collation is defined by erlangs ordered terms
// the atoms null, true, false come first, then numbers, strings,
// arrays, then objects
// null/undefined/NaN/Infinity/-Infinity are all considered null
    function collationIndex(x) {
        var id = ['boolean', 'number', 'string', 'object'];
        var idx = id.indexOf(typeof x);
        //false if -1 otherwise true, but fast!!!!1
        if (~idx) {
            if (x === null) {
                return 1;
            }
            if (Array.isArray(x)) {
                return 5;
            }
            return idx < 3 ? (idx + 2) : (idx + 3);
        }
        if (Array.isArray(x)) {
            return 5;
        }
    }

// conversion:
// x yyy zz...zz
// x = 0 for negative, 1 for 0, 2 for positive
// y = exponent (for negative numbers negated) moved so that it's >= 0
// z = mantisse
    function numToIndexableString(num) {

        if (num === 0) {
            return '1';
        }

        // convert number to exponential format for easier and
        // more succinct string sorting
        var expFormat = num.toExponential().split(/e\+?/);
        var magnitude = parseInt(expFormat[1], 10);

        var neg = num < 0;

        var result = neg ? '0' : '2';

        // first sort by magnitude
        // it's easier if all magnitudes are positive
        var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);
        var magString = utils.padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);

        result += SEP + magString;

        // then sort by the factor
        var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)
        if (neg) { // for negative reverse ordering
            factor = 10 - factor;
        }

        var factorStr = factor.toFixed(20);

        // strip zeros from the end
        factorStr = factorStr.replace(/\.?0+$/, '');

        result += SEP + factorStr;

        return result;
    }

},{"27":27}],27:[function(_dereq_,module,exports){
    'use strict';

    function pad(str, padWith, upToLength) {
        var padding = '';
        var targetLength = upToLength - str.length;
        while (padding.length < targetLength) {
            padding += padWith;
        }
        return padding;
    }

    exports.padLeft = function (str, padWith, upToLength) {
        var padding = pad(str, padWith, upToLength);
        return padding + str;
    };

    exports.padRight = function (str, padWith, upToLength) {
        var padding = pad(str, padWith, upToLength);
        return str + padding;
    };

    exports.stringLexCompare = function (a, b) {

        var aLen = a.length;
        var bLen = b.length;

        var i;
        for (i = 0; i < aLen; i++) {
            if (i === bLen) {
                // b is shorter substring of a
                return 1;
            }
            var aChar = a.charAt(i);
            var bChar = b.charAt(i);
            if (aChar !== bChar) {
                return aChar < bChar ? -1 : 1;
            }
        }

        if (aLen < bLen) {
            // a is shorter substring of b
            return -1;
        }

        return 0;
    };

    /*
     * returns the decimal form for the given integer, i.e. writes
     * out all the digits (in base-10) instead of using scientific notation
     */
    exports.intToDecimalForm = function (int) {

        var isNeg = int < 0;
        var result = '';

        do {
            var remainder = isNeg ? -Math.ceil(int % 10) : Math.floor(int % 10);

            result = remainder + result;
            int = isNeg ? Math.ceil(int / 10) : Math.floor(int / 10);
        } while (int);


        if (isNeg && result !== '0') {
            result = '-' + result;
        }

        return result;
    };
},{}],28:[function(_dereq_,module,exports){
    "use strict";

// Extends method
// (taken from http://code.jquery.com/jquery-1.9.0.js)
// Populate the class2type map
    var class2type = {};

    var types = [
        "Boolean", "Number", "String", "Function", "Array",
        "Date", "RegExp", "Object", "Error"
    ];
    for (var i = 0; i < types.length; i++) {
        var typename = types[i];
        class2type["[object " + typename + "]"] = typename.toLowerCase();
    }

    var core_toString = class2type.toString;
    var core_hasOwn = class2type.hasOwnProperty;

    function type(obj) {
        if (obj === null) {
            return String(obj);
        }
        return typeof obj === "object" || typeof obj === "function" ?
            class2type[core_toString.call(obj)] || "object" :
            typeof obj;
    }

    function isWindow(obj) {
        return obj !== null && obj === obj.window;
    }

    function isPlainObject(obj) {
        // Must be an Object.
        // Because of IE, we also have to check the presence of
        // the constructor property.
        // Make sure that DOM nodes and window objects don't pass through, as well
        if (!obj || type(obj) !== "object" || obj.nodeType || isWindow(obj)) {
            return false;
        }

        try {
            // Not own constructor property must be Object
            if (obj.constructor &&
                !core_hasOwn.call(obj, "constructor") &&
                !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
            }
        } catch ( e ) {
            // IE8,9 Will throw exceptions on certain host objects #9897
            return false;
        }

        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.
        var key;
        for (key in obj) {}

        return key === undefined || core_hasOwn.call(obj, key);
    }


    function isFunction(obj) {
        return type(obj) === "function";
    }

    var isArray = Array.isArray || function (obj) {
            return type(obj) === "array";
        };

    function extend() {
        // originally extend() was recursive, but this ended up giving us
        // "call stack exceeded", so it's been unrolled to use a literal stack
        // (see https://github.com/pouchdb/pouchdb/issues/2543)
        var stack = [];
        var i = -1;
        var len = arguments.length;
        var args = new Array(len);
        while (++i < len) {
            args[i] = arguments[i];
        }
        var container = {};
        stack.push({args: args, result: {container: container, key: 'key'}});
        var next;
        while ((next = stack.pop())) {
            extendInner(stack, next.args, next.result);
        }
        return container.key;
    }

    function extendInner(stack, args, result) {
        var options, name, src, copy, copyIsArray, clone,
            target = args[0] || {},
            i = 1,
            length = args.length,
            deep = false,
            numericStringRegex = /\d+/,
            optionsIsArray;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            target = args[1] || {};
            // skip the boolean and the target
            i = 2;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !isFunction(target)) {
            target = {};
        }

        // extend jQuery itself if only one argument is passed
        if (length === i) {
            /* jshint validthis: true */
            target = this;
            --i;
        }

        for (; i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = args[i]) != null) {
                optionsIsArray = isArray(options);
                // Extend the base object
                for (name in options) {
                    //if (options.hasOwnProperty(name)) {
                    if (!(name in Object.prototype)) {
                        if (optionsIsArray && !numericStringRegex.test(name)) {
                            continue;
                        }

                        src = target[name];
                        copy = options[name];

                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && (isPlainObject(copy) ||
                            (copyIsArray = isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && isArray(src) ? src : [];

                            } else {
                                clone = src && isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            stack.push({
                                args: [deep, clone, copy],
                                result: {
                                    container: target,
                                    key: name
                                }
                            });

                            // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            if (!(isArray(options) && isFunction(copy))) {
                                target[name] = copy;
                            }
                        }
                    }
                }
            }
        }

        // "Return" the modified object by setting the key
        // on the given container
        result.container[result.key] = target;
    }


    module.exports = extend;



},{}],29:[function(_dereq_,module,exports){
    'use strict';

    function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

    var lie = _interopDefault(_dereq_(30));

    /* istanbul ignore next */
    var PouchPromise = typeof Promise === 'function' ? Promise : lie;

    module.exports = PouchPromise;
},{"30":30}],30:[function(_dereq_,module,exports){
    'use strict';
    var immediate = _dereq_(22);

    /* istanbul ignore next */
    function INTERNAL() {}

    var handlers = {};

    var REJECTED = ['REJECTED'];
    var FULFILLED = ['FULFILLED'];
    var PENDING = ['PENDING'];

    module.exports = Promise;

    function Promise(resolver) {
        if (typeof resolver !== 'function') {
            throw new TypeError('resolver must be a function');
        }
        this.state = PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
        }
    }

    Promise.prototype["catch"] = function (onRejected) {
        return this.then(null, onRejected);
    };
    Promise.prototype.then = function (onFulfilled, onRejected) {
        if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
            typeof onRejected !== 'function' && this.state === REJECTED) {
            return this;
        }
        var promise = new this.constructor(INTERNAL);
        if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
        } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }

        return promise;
    };
    function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;
        if (typeof onFulfilled === 'function') {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === 'function') {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
        }
    }
    QueueItem.prototype.callFulfilled = function (value) {
        handlers.resolve(this.promise, value);
    };
    QueueItem.prototype.otherCallFulfilled = function (value) {
        unwrap(this.promise, this.onFulfilled, value);
    };
    QueueItem.prototype.callRejected = function (value) {
        handlers.reject(this.promise, value);
    };
    QueueItem.prototype.otherCallRejected = function (value) {
        unwrap(this.promise, this.onRejected, value);
    };

    function unwrap(promise, func, value) {
        immediate(function () {
            var returnValue;
            try {
                returnValue = func(value);
            } catch (e) {
                return handlers.reject(promise, e);
            }
            if (returnValue === promise) {
                handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
            } else {
                handlers.resolve(promise, returnValue);
            }
        });
    }

    handlers.resolve = function (self, value) {
        var result = tryCatch(getThen, value);
        if (result.status === 'error') {
            return handlers.reject(self, result.value);
        }
        var thenable = result.value;

        if (thenable) {
            safelyResolveThenable(self, thenable);
        } else {
            self.state = FULFILLED;
            self.outcome = value;
            var i = -1;
            var len = self.queue.length;
            while (++i < len) {
                self.queue[i].callFulfilled(value);
            }
        }
        return self;
    };
    handlers.reject = function (self, error) {
        self.state = REJECTED;
        self.outcome = error;
        var i = -1;
        var len = self.queue.length;
        while (++i < len) {
            self.queue[i].callRejected(error);
        }
        return self;
    };

    function getThen(obj) {
        // Make sure we only access the accessor once as required by the spec
        var then = obj && obj.then;
        if (obj && typeof obj === 'object' && typeof then === 'function') {
            return function appyThen() {
                then.apply(obj, arguments);
            };
        }
    }

    function safelyResolveThenable(self, thenable) {
        // Either fulfill, reject or reject with error
        var called = false;
        function onError(value) {
            if (called) {
                return;
            }
            called = true;
            handlers.reject(self, value);
        }

        function onSuccess(value) {
            if (called) {
                return;
            }
            called = true;
            handlers.resolve(self, value);
        }

        function tryToUnwrap() {
            thenable(onSuccess, onError);
        }

        var result = tryCatch(tryToUnwrap);
        if (result.status === 'error') {
            onError(result.value);
        }
    }

    function tryCatch(func, value) {
        var out = {};
        try {
            out.value = func(value);
            out.status = 'success';
        } catch (e) {
            out.status = 'error';
            out.value = e;
        }
        return out;
    }

    Promise.resolve = resolve;
    function resolve(value) {
        if (value instanceof this) {
            return value;
        }
        return handlers.resolve(new this(INTERNAL), value);
    }

    Promise.reject = reject;
    function reject(reason) {
        var promise = new this(INTERNAL);
        return handlers.reject(promise, reason);
    }

    Promise.all = all;
    function all(iterable) {
        var self = this;
        if (Object.prototype.toString.call(iterable) !== '[object Array]') {
            return this.reject(new TypeError('must be an array'));
        }

        var len = iterable.length;
        var called = false;
        if (!len) {
            return this.resolve([]);
        }

        var values = new Array(len);
        var resolved = 0;
        var i = -1;
        var promise = new this(INTERNAL);

        while (++i < len) {
            allResolver(iterable[i], i);
        }
        return promise;
        function allResolver(value, i) {
            self.resolve(value).then(resolveFromAll, function (error) {
                if (!called) {
                    called = true;
                    handlers.reject(promise, error);
                }
            });
            function resolveFromAll(outValue) {
                values[i] = outValue;
                if (++resolved === len && !called) {
                    called = true;
                    handlers.resolve(promise, values);
                }
            }
        }
    }

    Promise.race = race;
    function race(iterable) {
        var self = this;
        if (Object.prototype.toString.call(iterable) !== '[object Array]') {
            return this.reject(new TypeError('must be an array'));
        }

        var len = iterable.length;
        var called = false;
        if (!len) {
            return this.resolve([]);
        }

        var i = -1;
        var promise = new this(INTERNAL);

        while (++i < len) {
            resolver(iterable[i]);
        }
        return promise;
        function resolver(value) {
            self.resolve(value).then(function (response) {
                if (!called) {
                    called = true;
                    handlers.resolve(promise, response);
                }
            }, function (error) {
                if (!called) {
                    called = true;
                    handlers.reject(promise, error);
                }
            });
        }
    }

},{"22":22}],31:[function(_dereq_,module,exports){
    'use strict';

    var PouchPromise = _dereq_(33);

// this is essentially the "update sugar" function from daleharvey/pouchdb#1388
// the diffFun tells us what delta to apply to the doc.  it either returns
// the doc, or false if it doesn't need to do an update after all
    function upsertInner(db, docId, diffFun) {
        if (typeof docId !== 'string') {
            return PouchPromise.reject(new Error('doc id is required'));
        }

        return db.get(docId)["catch"](function (err) {
            /* istanbul ignore next */
            if (err.status !== 404) {
                throw err;
            }
            return {};
        }).then(function (doc) {
            // the user might change the _rev, so save it for posterity
            var docRev = doc._rev;
            var newDoc = diffFun(doc);

            if (!newDoc) {
                // if the diffFun returns falsy, we short-circuit as
                // an optimization
                return { updated: false, rev: docRev };
            }

            // users aren't allowed to modify these values,
            // so reset them here
            newDoc._id = docId;
            newDoc._rev = docRev;
            return tryAndPut(db, newDoc, diffFun);
        });
    }

    function tryAndPut(db, doc, diffFun) {
        return db.put(doc).then(function (res) {
            return {
                updated: true,
                rev: res.rev
            };
        }, function (err) {
            /* istanbul ignore next */
            if (err.status !== 409) {
                throw err;
            }
            return upsertInner(db, doc._id, diffFun);
        });
    }

    exports.upsert = function upsert(docId, diffFun, cb) {
        var db = this;
        var promise = upsertInner(db, docId, diffFun);
        if (typeof cb !== 'function') {
            return promise;
        }
        promise.then(function (resp) {
            cb(null, resp);
        }, cb);
    };

    exports.putIfNotExists = function putIfNotExists(docId, doc, cb) {
        var db = this;

        if (typeof docId !== 'string') {
            cb = doc;
            doc = docId;
            docId = doc._id;
        }

        var diffFun = function (existingDoc) {
            if (existingDoc._rev) {
                return false; // do nothing
            }
            return doc;
        };

        var promise = upsertInner(db, docId, diffFun);
        if (typeof cb !== 'function') {
            return promise;
        }
        promise.then(function (resp) {
            cb(null, resp);
        }, cb);
    };


    /* istanbul ignore next */
    if (typeof window !== 'undefined' && window.PouchDB) {
        window.PouchDB.plugin(exports);
    }

},{"33":33}],32:[function(_dereq_,module,exports){
    arguments[4][30][0].apply(exports,arguments)
},{"22":22,"30":30}],33:[function(_dereq_,module,exports){
    arguments[4][29][0].apply(exports,arguments)
},{"29":29,"32":32}],34:[function(_dereq_,module,exports){
// shim for using process in browser

    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            setTimeout(drainQueue, 0);
        }
    };

// v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };

},{}],35:[function(_dereq_,module,exports){
    /*jshint bitwise:false*/
    /*global unescape*/

    (function (factory) {
        if (typeof exports === 'object') {
            // Node/CommonJS
            module.exports = factory();
        } else if (typeof define === 'function' && define.amd) {
            // AMD
            define(factory);
        } else {
            // Browser globals (with support for web workers)
            var glob;
            try {
                glob = window;
            } catch (e) {
                glob = self;
            }

            glob.SparkMD5 = factory();
        }
    }(function (undefined) {

        'use strict';

        ////////////////////////////////////////////////////////////////////////////

        /*
         * Fastest md5 implementation around (JKM md5)
         * Credits: Joseph Myers
         *
         * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
         * @see http://jsperf.com/md5-shootout/7
         */

        /* this function is much faster,
         so if possible we use it. Some IEs
         are the only ones I know of that
         need the idiotic second function,
         generated by an if clause.  */
        var add32 = function (a, b) {
                return (a + b) & 0xFFFFFFFF;
            },

            cmn = function (q, a, b, x, s, t) {
                a = add32(add32(a, q), add32(x, t));
                return add32((a << s) | (a >>> (32 - s)), b);
            },

            ff = function (a, b, c, d, x, s, t) {
                return cmn((b & c) | ((~b) & d), a, b, x, s, t);
            },

            gg = function (a, b, c, d, x, s, t) {
                return cmn((b & d) | (c & (~d)), a, b, x, s, t);
            },

            hh = function (a, b, c, d, x, s, t) {
                return cmn(b ^ c ^ d, a, b, x, s, t);
            },

            ii = function (a, b, c, d, x, s, t) {
                return cmn(c ^ (b | (~d)), a, b, x, s, t);
            },

            md5cycle = function (x, k) {
                var a = x[0],
                    b = x[1],
                    c = x[2],
                    d = x[3];

                a = ff(a, b, c, d, k[0], 7, -680876936);
                d = ff(d, a, b, c, k[1], 12, -389564586);
                c = ff(c, d, a, b, k[2], 17, 606105819);
                b = ff(b, c, d, a, k[3], 22, -1044525330);
                a = ff(a, b, c, d, k[4], 7, -176418897);
                d = ff(d, a, b, c, k[5], 12, 1200080426);
                c = ff(c, d, a, b, k[6], 17, -1473231341);
                b = ff(b, c, d, a, k[7], 22, -45705983);
                a = ff(a, b, c, d, k[8], 7, 1770035416);
                d = ff(d, a, b, c, k[9], 12, -1958414417);
                c = ff(c, d, a, b, k[10], 17, -42063);
                b = ff(b, c, d, a, k[11], 22, -1990404162);
                a = ff(a, b, c, d, k[12], 7, 1804603682);
                d = ff(d, a, b, c, k[13], 12, -40341101);
                c = ff(c, d, a, b, k[14], 17, -1502002290);
                b = ff(b, c, d, a, k[15], 22, 1236535329);

                a = gg(a, b, c, d, k[1], 5, -165796510);
                d = gg(d, a, b, c, k[6], 9, -1069501632);
                c = gg(c, d, a, b, k[11], 14, 643717713);
                b = gg(b, c, d, a, k[0], 20, -373897302);
                a = gg(a, b, c, d, k[5], 5, -701558691);
                d = gg(d, a, b, c, k[10], 9, 38016083);
                c = gg(c, d, a, b, k[15], 14, -660478335);
                b = gg(b, c, d, a, k[4], 20, -405537848);
                a = gg(a, b, c, d, k[9], 5, 568446438);
                d = gg(d, a, b, c, k[14], 9, -1019803690);
                c = gg(c, d, a, b, k[3], 14, -187363961);
                b = gg(b, c, d, a, k[8], 20, 1163531501);
                a = gg(a, b, c, d, k[13], 5, -1444681467);
                d = gg(d, a, b, c, k[2], 9, -51403784);
                c = gg(c, d, a, b, k[7], 14, 1735328473);
                b = gg(b, c, d, a, k[12], 20, -1926607734);

                a = hh(a, b, c, d, k[5], 4, -378558);
                d = hh(d, a, b, c, k[8], 11, -2022574463);
                c = hh(c, d, a, b, k[11], 16, 1839030562);
                b = hh(b, c, d, a, k[14], 23, -35309556);
                a = hh(a, b, c, d, k[1], 4, -1530992060);
                d = hh(d, a, b, c, k[4], 11, 1272893353);
                c = hh(c, d, a, b, k[7], 16, -155497632);
                b = hh(b, c, d, a, k[10], 23, -1094730640);
                a = hh(a, b, c, d, k[13], 4, 681279174);
                d = hh(d, a, b, c, k[0], 11, -358537222);
                c = hh(c, d, a, b, k[3], 16, -722521979);
                b = hh(b, c, d, a, k[6], 23, 76029189);
                a = hh(a, b, c, d, k[9], 4, -640364487);
                d = hh(d, a, b, c, k[12], 11, -421815835);
                c = hh(c, d, a, b, k[15], 16, 530742520);
                b = hh(b, c, d, a, k[2], 23, -995338651);

                a = ii(a, b, c, d, k[0], 6, -198630844);
                d = ii(d, a, b, c, k[7], 10, 1126891415);
                c = ii(c, d, a, b, k[14], 15, -1416354905);
                b = ii(b, c, d, a, k[5], 21, -57434055);
                a = ii(a, b, c, d, k[12], 6, 1700485571);
                d = ii(d, a, b, c, k[3], 10, -1894986606);
                c = ii(c, d, a, b, k[10], 15, -1051523);
                b = ii(b, c, d, a, k[1], 21, -2054922799);
                a = ii(a, b, c, d, k[8], 6, 1873313359);
                d = ii(d, a, b, c, k[15], 10, -30611744);
                c = ii(c, d, a, b, k[6], 15, -1560198380);
                b = ii(b, c, d, a, k[13], 21, 1309151649);
                a = ii(a, b, c, d, k[4], 6, -145523070);
                d = ii(d, a, b, c, k[11], 10, -1120210379);
                c = ii(c, d, a, b, k[2], 15, 718787259);
                b = ii(b, c, d, a, k[9], 21, -343485551);

                x[0] = add32(a, x[0]);
                x[1] = add32(b, x[1]);
                x[2] = add32(c, x[2]);
                x[3] = add32(d, x[3]);
            },

            /* there needs to be support for Unicode here,
             * unless we pretend that we can redefine the MD-5
             * algorithm for multi-byte characters (perhaps
             * by adding every four 16-bit characters and
             * shortening the sum to 32 bits). Otherwise
             * I suggest performing MD-5 as if every character
             * was two bytes--e.g., 0040 0025 = @%--but then
             * how will an ordinary MD-5 sum be matched?
             * There is no way to standardize text to something
             * like UTF-8 before transformation; speed cost is
             * utterly prohibitive. The JavaScript standard
             * itself needs to look at this: it should start
             * providing access to strings as preformed UTF-8
             * 8-bit unsigned value arrays.
             */
            md5blk = function (s) {
                var md5blks = [],
                    i; /* Andy King said do it this way. */

                for (i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
                }
                return md5blks;
            },

            md5blk_array = function (a) {
                var md5blks = [],
                    i; /* Andy King said do it this way. */

                for (i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
                }
                return md5blks;
            },

            md51 = function (s) {
                var n = s.length,
                    state = [1732584193, -271733879, -1732584194, 271733878],
                    i,
                    length,
                    tail,
                    tmp,
                    lo,
                    hi;

                for (i = 64; i <= n; i += 64) {
                    md5cycle(state, md5blk(s.substring(i - 64, i)));
                }
                s = s.substring(i - 64);
                length = s.length;
                tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                for (i = 0; i < length; i += 1) {
                    tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
                }
                tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                if (i > 55) {
                    md5cycle(state, tail);
                    for (i = 0; i < 16; i += 1) {
                        tail[i] = 0;
                    }
                }

                // Beware that the final length might not fit in 32 bits so we take care of that
                tmp = n * 8;
                tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
                lo = parseInt(tmp[2], 16);
                hi = parseInt(tmp[1], 16) || 0;

                tail[14] = lo;
                tail[15] = hi;

                md5cycle(state, tail);
                return state;
            },

            md51_array = function (a) {
                var n = a.length,
                    state = [1732584193, -271733879, -1732584194, 271733878],
                    i,
                    length,
                    tail,
                    tmp,
                    lo,
                    hi;

                for (i = 64; i <= n; i += 64) {
                    md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
                }

                // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
                // containing the last element of the parent array if the sub array specified starts
                // beyond the length of the parent array - weird.
                // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
                a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

                length = a.length;
                tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                for (i = 0; i < length; i += 1) {
                    tail[i >> 2] |= a[i] << ((i % 4) << 3);
                }

                tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                if (i > 55) {
                    md5cycle(state, tail);
                    for (i = 0; i < 16; i += 1) {
                        tail[i] = 0;
                    }
                }

                // Beware that the final length might not fit in 32 bits so we take care of that
                tmp = n * 8;
                tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
                lo = parseInt(tmp[2], 16);
                hi = parseInt(tmp[1], 16) || 0;

                tail[14] = lo;
                tail[15] = hi;

                md5cycle(state, tail);

                return state;
            },

            hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'],

            rhex = function (n) {
                var s = '',
                    j;
                for (j = 0; j < 4; j += 1) {
                    s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
                }
                return s;
            },

            hex = function (x) {
                var i;
                for (i = 0; i < x.length; i += 1) {
                    x[i] = rhex(x[i]);
                }
                return x.join('');
            },

            md5 = function (s) {
                return hex(md51(s));
            },



            ////////////////////////////////////////////////////////////////////////////

            /**
             * SparkMD5 OOP implementation.
             *
             * Use this class to perform an incremental md5, otherwise use the
             * static methods instead.
             */
            SparkMD5 = function () {
                // call reset to init the instance
                this.reset();
            };


        // In some cases the fast add32 function cannot be used..
        if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {
            add32 = function (x, y) {
                var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                    msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                return (msw << 16) | (lsw & 0xFFFF);
            };
        }


        /**
         * Appends a string.
         * A conversion will be applied if an utf8 string is detected.
         *
         * @param {String} str The string to be appended
         *
         * @return {SparkMD5} The instance itself
         */
        SparkMD5.prototype.append = function (str) {
            // converts the string to utf8 bytes if necessary
            if (/[\u0080-\uFFFF]/.test(str)) {
                str = unescape(encodeURIComponent(str));
            }

            // then append as binary
            this.appendBinary(str);

            return this;
        };

        /**
         * Appends a binary string.
         *
         * @param {String} contents The binary string to be appended
         *
         * @return {SparkMD5} The instance itself
         */
        SparkMD5.prototype.appendBinary = function (contents) {
            this._buff += contents;
            this._length += contents.length;

            var length = this._buff.length,
                i;

            for (i = 64; i <= length; i += 64) {
                md5cycle(this._state, md5blk(this._buff.substring(i - 64, i)));
            }

            this._buff = this._buff.substr(i - 64);

            return this;
        };

        /**
         * Finishes the incremental computation, reseting the internal state and
         * returning the result.
         * Use the raw parameter to obtain the raw result instead of the hex one.
         *
         * @param {Boolean} raw True to get the raw result, false to get the hex result
         *
         * @return {String|Array} The result
         */
        SparkMD5.prototype.end = function (raw) {
            var buff = this._buff,
                length = buff.length,
                i,
                tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ret;

            for (i = 0; i < length; i += 1) {
                tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
            }

            this._finish(tail, length);
            ret = !!raw ? this._state : hex(this._state);

            this.reset();

            return ret;
        };

        /**
         * Finish the final calculation based on the tail.
         *
         * @param {Array}  tail   The tail (will be modified)
         * @param {Number} length The length of the remaining buffer
         */
        SparkMD5.prototype._finish = function (tail, length) {
            var i = length,
                tmp,
                lo,
                hi;

            tail[i >> 2] |= 0x80 << ((i % 4) << 3);
            if (i > 55) {
                md5cycle(this._state, tail);
                for (i = 0; i < 16; i += 1) {
                    tail[i] = 0;
                }
            }

            // Do the final computation based on the tail and length
            // Beware that the final length may not fit in 32 bits so we take care of that
            tmp = this._length * 8;
            tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
            lo = parseInt(tmp[2], 16);
            hi = parseInt(tmp[1], 16) || 0;

            tail[14] = lo;
            tail[15] = hi;
            md5cycle(this._state, tail);
        };

        /**
         * Resets the internal state of the computation.
         *
         * @return {SparkMD5} The instance itself
         */
        SparkMD5.prototype.reset = function () {
            this._buff = "";
            this._length = 0;
            this._state = [1732584193, -271733879, -1732584194, 271733878];

            return this;
        };

        /**
         * Releases memory used by the incremental buffer and other aditional
         * resources. If you plan to use the instance again, use reset instead.
         */
        SparkMD5.prototype.destroy = function () {
            delete this._state;
            delete this._buff;
            delete this._length;
        };


        /**
         * Performs the md5 hash on a string.
         * A conversion will be applied if utf8 string is detected.
         *
         * @param {String}  str The string
         * @param {Boolean} raw True to get the raw result, false to get the hex result
         *
         * @return {String|Array} The result
         */
        SparkMD5.hash = function (str, raw) {
            // converts the string to utf8 bytes if necessary
            if (/[\u0080-\uFFFF]/.test(str)) {
                str = unescape(encodeURIComponent(str));
            }

            var hash = md51(str);

            return !!raw ? hash : hex(hash);
        };

        /**
         * Performs the md5 hash on a binary string.
         *
         * @param {String}  content The binary string
         * @param {Boolean} raw     True to get the raw result, false to get the hex result
         *
         * @return {String|Array} The result
         */
        SparkMD5.hashBinary = function (content, raw) {
            var hash = md51(content);

            return !!raw ? hash : hex(hash);
        };

        /**
         * SparkMD5 OOP implementation for array buffers.
         *
         * Use this class to perform an incremental md5 ONLY for array buffers.
         */
        SparkMD5.ArrayBuffer = function () {
            // call reset to init the instance
            this.reset();
        };

        ////////////////////////////////////////////////////////////////////////////

        /**
         * Appends an array buffer.
         *
         * @param {ArrayBuffer} arr The array to be appended
         *
         * @return {SparkMD5.ArrayBuffer} The instance itself
         */
        SparkMD5.ArrayBuffer.prototype.append = function (arr) {
            // TODO: we could avoid the concatenation here but the algorithm would be more complex
            //       if you find yourself needing extra performance, please make a PR.
            var buff = this._concatArrayBuffer(this._buff, arr),
                length = buff.length,
                i;

            this._length += arr.byteLength;

            for (i = 64; i <= length; i += 64) {
                md5cycle(this._state, md5blk_array(buff.subarray(i - 64, i)));
            }

            // Avoids IE10 weirdness (documented above)
            this._buff = (i - 64) < length ? buff.subarray(i - 64) : new Uint8Array(0);

            return this;
        };

        /**
         * Finishes the incremental computation, reseting the internal state and
         * returning the result.
         * Use the raw parameter to obtain the raw result instead of the hex one.
         *
         * @param {Boolean} raw True to get the raw result, false to get the hex result
         *
         * @return {String|Array} The result
         */
        SparkMD5.ArrayBuffer.prototype.end = function (raw) {
            var buff = this._buff,
                length = buff.length,
                tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                i,
                ret;

            for (i = 0; i < length; i += 1) {
                tail[i >> 2] |= buff[i] << ((i % 4) << 3);
            }

            this._finish(tail, length);
            ret = !!raw ? this._state : hex(this._state);

            this.reset();

            return ret;
        };

        SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

        /**
         * Resets the internal state of the computation.
         *
         * @return {SparkMD5.ArrayBuffer} The instance itself
         */
        SparkMD5.ArrayBuffer.prototype.reset = function () {
            this._buff = new Uint8Array(0);
            this._length = 0;
            this._state = [1732584193, -271733879, -1732584194, 271733878];

            return this;
        };

        /**
         * Releases memory used by the incremental buffer and other aditional
         * resources. If you plan to use the instance again, use reset instead.
         */
        SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

        /**
         * Concats two array buffers, returning a new one.
         *
         * @param  {ArrayBuffer} first  The first array buffer
         * @param  {ArrayBuffer} second The second array buffer
         *
         * @return {ArrayBuffer} The new array buffer
         */
        SparkMD5.ArrayBuffer.prototype._concatArrayBuffer = function (first, second) {
            var firstLength = first.length,
                result = new Uint8Array(firstLength + second.byteLength);

            result.set(first);
            result.set(new Uint8Array(second), firstLength);

            return result;
        };

        /**
         * Performs the md5 hash on an array buffer.
         *
         * @param {ArrayBuffer} arr The array buffer
         * @param {Boolean}     raw True to get the raw result, false to get the hex result
         *
         * @return {String|Array} The result
         */
        SparkMD5.ArrayBuffer.hash = function (arr, raw) {
            var hash = md51_array(new Uint8Array(arr));

            return !!raw ? hash : hex(hash);
        };

        return SparkMD5;
    }));

},{}],36:[function(_dereq_,module,exports){
    'use strict';

    var utils = _dereq_(17);

    var httpIndexes = _dereq_(6);
    var localIndexes = _dereq_(14);

    var plugin = {};
    plugin.createIndex = utils.toPromise(function (requestDef, callback) {

        if (typeof requestDef !== 'object') {
            return callback(new Error('you must provide an index to create'));
        }

        var adapter = this.type() === 'http' ? httpIndexes : localIndexes;

        adapter.createIndex(this, requestDef, callback);
    });

    plugin.find = utils.toPromise(function (requestDef, callback) {

        if (typeof callback === 'undefined') {
            callback = requestDef;
            requestDef = undefined;
        }

        if (typeof requestDef !== 'object') {
            return callback(new Error('you must provide search parameters to find()'));
        }

        var adapter = this.type() === 'http' ? httpIndexes : localIndexes;

        adapter.find(this, requestDef, callback);
    });

    plugin.getIndexes = utils.toPromise(function (callback) {

        var adapter = this.type() === 'http' ? httpIndexes : localIndexes;

        adapter.getIndexes(this, callback);
    });

    plugin.deleteIndex = utils.toPromise(function (indexDef, callback) {

        if (typeof indexDef !== 'object') {
            return callback(new Error('you must provide an index to delete'));
        }

        var adapter = this.type() === 'http' ? httpIndexes : localIndexes;

        adapter.deleteIndex(this, indexDef, callback);
    });

    module.exports = plugin;

    /* istanbul ignore next */
    if (typeof window !== 'undefined' && window.PouchDB) {
        window.PouchDB.plugin(plugin);
    }

},{"14":14,"17":17,"6":6}]},{},[36])(36)
});

!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var o;"undefined"!=typeof window?o=window:"undefined"!=typeof global?o=global:"undefined"!=typeof self&&(o=self),o.cryptoPouch=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
    var util = require('util/');

    var pSlice = Array.prototype.slice;
    var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

    var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

    assert.AssertionError = function AssertionError(options) {
        this.name = 'AssertionError';
        this.actual = options.actual;
        this.expected = options.expected;
        this.operator = options.operator;
        if (options.message) {
            this.message = options.message;
            this.generatedMessage = false;
        } else {
            this.message = getMessage(this);
            this.generatedMessage = true;
        }
        var stackStartFunction = options.stackStartFunction || fail;

        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, stackStartFunction);
        }
        else {
            // non v8 browsers so we can have a stacktrace
            var err = new Error();
            if (err.stack) {
                var out = err.stack;

                // try to strip useless frames
                var fn_name = stackStartFunction.name;
                var idx = out.indexOf('\n' + fn_name);
                if (idx >= 0) {
                    // once we have located the function frame
                    // we need to strip out everything before it (and its line)
                    var next_line = out.indexOf('\n', idx + 1);
                    out = out.substring(next_line + 1);
                }

                this.stack = out;
            }
        }
    };

// assert.AssertionError instanceof Error
    util.inherits(assert.AssertionError, Error);

    function replacer(key, value) {
        if (util.isUndefined(value)) {
            return '' + value;
        }
        if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
            return value.toString();
        }
        if (util.isFunction(value) || util.isRegExp(value)) {
            return value.toString();
        }
        return value;
    }

    function truncate(s, n) {
        if (util.isString(s)) {
            return s.length < n ? s : s.slice(0, n);
        } else {
            return s;
        }
    }

    function getMessage(self) {
        return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
            self.operator + ' ' +
            truncate(JSON.stringify(self.expected, replacer), 128);
    }

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

    function fail(actual, expected, message, operator, stackStartFunction) {
        throw new assert.AssertionError({
            message: message,
            actual: actual,
            expected: expected,
            operator: operator,
            stackStartFunction: stackStartFunction
        });
    }

// EXTENSION! allows for well behaved errors defined elsewhere.
    assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

    function ok(value, message) {
        if (!value) fail(value, true, message, '==', assert.ok);
    }
    assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

    assert.equal = function equal(actual, expected, message) {
        if (actual != expected) fail(actual, expected, message, '==', assert.equal);
    };

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

    assert.notEqual = function notEqual(actual, expected, message) {
        if (actual == expected) {
            fail(actual, expected, message, '!=', assert.notEqual);
        }
    };

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

    assert.deepEqual = function deepEqual(actual, expected, message) {
        if (!_deepEqual(actual, expected)) {
            fail(actual, expected, message, 'deepEqual', assert.deepEqual);
        }
    };

    function _deepEqual(actual, expected) {
        // 7.1. All identical values are equivalent, as determined by ===.
        if (actual === expected) {
            return true;

        } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
            if (actual.length != expected.length) return false;

            for (var i = 0; i < actual.length; i++) {
                if (actual[i] !== expected[i]) return false;
            }

            return true;

            // 7.2. If the expected value is a Date object, the actual value is
            // equivalent if it is also a Date object that refers to the same time.
        } else if (util.isDate(actual) && util.isDate(expected)) {
            return actual.getTime() === expected.getTime();

            // 7.3 If the expected value is a RegExp object, the actual value is
            // equivalent if it is also a RegExp object with the same source and
            // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
        } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
            return actual.source === expected.source &&
                actual.global === expected.global &&
                actual.multiline === expected.multiline &&
                actual.lastIndex === expected.lastIndex &&
                actual.ignoreCase === expected.ignoreCase;

            // 7.4. Other pairs that do not both pass typeof value == 'object',
            // equivalence is determined by ==.
        } else if (!util.isObject(actual) && !util.isObject(expected)) {
            return actual == expected;

            // 7.5 For all other Object pairs, including Array objects, equivalence is
            // determined by having the same number of owned properties (as verified
            // with Object.prototype.hasOwnProperty.call), the same set of keys
            // (although not necessarily the same order), equivalent values for every
            // corresponding key, and an identical 'prototype' property. Note: this
            // accounts for both named and indexed properties on Arrays.
        } else {
            return objEquiv(actual, expected);
        }
    }

    function isArguments(object) {
        return Object.prototype.toString.call(object) == '[object Arguments]';
    }

    function objEquiv(a, b) {
        if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
            return false;
        // an identical 'prototype' property.
        if (a.prototype !== b.prototype) return false;
        //~~~I've managed to break Object.keys through screwy arguments passing.
        //   Converting to array solves the problem.
        if (isArguments(a)) {
            if (!isArguments(b)) {
                return false;
            }
            a = pSlice.call(a);
            b = pSlice.call(b);
            return _deepEqual(a, b);
        }
        try {
            var ka = objectKeys(a),
                kb = objectKeys(b),
                key, i;
        } catch (e) {//happens when one is a string literal and the other isn't
            return false;
        }
        // having the same number of owned properties (keys incorporates
        // hasOwnProperty)
        if (ka.length != kb.length)
            return false;
        //the same set of keys (although not necessarily the same order),
        ka.sort();
        kb.sort();
        //~~~cheap key test
        for (i = ka.length - 1; i >= 0; i--) {
            if (ka[i] != kb[i])
                return false;
        }
        //equivalent values for every corresponding key, and
        //~~~possibly expensive deep test
        for (i = ka.length - 1; i >= 0; i--) {
            key = ka[i];
            if (!_deepEqual(a[key], b[key])) return false;
        }
        return true;
    }

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
        if (_deepEqual(actual, expected)) {
            fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
        }
    };

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

    assert.strictEqual = function strictEqual(actual, expected, message) {
        if (actual !== expected) {
            fail(actual, expected, message, '===', assert.strictEqual);
        }
    };

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
        if (actual === expected) {
            fail(actual, expected, message, '!==', assert.notStrictEqual);
        }
    };

    function expectedException(actual, expected) {
        if (!actual || !expected) {
            return false;
        }

        if (Object.prototype.toString.call(expected) == '[object RegExp]') {
            return expected.test(actual);
        } else if (actual instanceof expected) {
            return true;
        } else if (expected.call({}, actual) === true) {
            return true;
        }

        return false;
    }

    function _throws(shouldThrow, block, expected, message) {
        var actual;

        if (util.isString(expected)) {
            message = expected;
            expected = null;
        }

        try {
            block();
        } catch (e) {
            actual = e;
        }

        message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

        if (shouldThrow && !actual) {
            fail(actual, expected, 'Missing expected exception' + message);
        }

        if (!shouldThrow && expectedException(actual, expected)) {
            fail(actual, expected, 'Got unwanted exception' + message);
        }

        if ((shouldThrow && actual && expected &&
            !expectedException(actual, expected)) || (!shouldThrow && actual)) {
            throw actual;
        }
    }

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

    assert.throws = function(block, /*optional*/error, /*optional*/message) {
        _throws.apply(this, [true].concat(pSlice.call(arguments)));
    };

// EXTENSION! This is annoying to write outside this module.
    assert.doesNotThrow = function(block, /*optional*/message) {
        _throws.apply(this, [false].concat(pSlice.call(arguments)));
    };

    assert.ifError = function(err) { if (err) {throw err;}};

    var objectKeys = Object.keys || function (obj) {
            var keys = [];
            for (var key in obj) {
                if (hasOwn.call(obj, key)) keys.push(key);
            }
            return keys;
        };

},{"util/":166}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */

    var base64 = require('base64-js')
    var ieee754 = require('ieee754')
    var isArray = require('is-array')

    exports.Buffer = Buffer
    exports.SlowBuffer = SlowBuffer
    exports.INSPECT_MAX_BYTES = 50
    Buffer.poolSize = 8192 // not used by this implementation

    var kMaxLength = 0x3fffffff
    var rootParent = {}

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Note:
     *
     * - Implementation must support adding new properties to `Uint8Array` instances.
     *   Firefox 4-29 lacked support, fixed in Firefox 30+.
     *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *    incorrect length in some situations.
     *
     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
     * get the Object implementation, which is slower but will work correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = (function () {
        try {
            var buf = new ArrayBuffer(0)
            var arr = new Uint8Array(buf)
            arr.foo = function () { return 42 }
            return 42 === arr.foo() && // typed array instances can be augmented
                typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
        } catch (e) {
            return false
        }
    })()

    /**
     * Class: Buffer
     * =============
     *
     * The Buffer constructor returns instances of `Uint8Array` that are augmented
     * with function properties for all the node `Buffer` API functions. We use
     * `Uint8Array` so that square bracket notation works as expected -- it returns
     * a single octet.
     *
     * By augmenting the instances, we can avoid modifying the `Uint8Array`
     * prototype.
     */
    function Buffer (subject, encoding, noZero) {
        if (!(this instanceof Buffer))
            return new Buffer(subject, encoding, noZero)

        var type = typeof subject

        // Find the length
        var length
        if (type === 'number')
            length = subject > 0 ? subject >>> 0 : 0
        else if (type === 'string') {
            length = Buffer.byteLength(subject, encoding)
        } else if (type === 'object' && subject !== null) { // assume object is array-like
            if (subject.type === 'Buffer' && isArray(subject.data))
                subject = subject.data
            length = +subject.length > 0 ? Math.floor(+subject.length) : 0
        } else
            throw new TypeError('must start with number, buffer, array or string')

        if (length > kMaxLength)
            throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                'size: 0x' + kMaxLength.toString(16) + ' bytes')

        var buf
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            // Preferred: Return an augmented `Uint8Array` instance for best performance
            buf = Buffer._augment(new Uint8Array(length))
        } else {
            // Fallback: Return THIS instance of Buffer (created by `new`)
            buf = this
            buf.length = length
            buf._isBuffer = true
        }

        var i
        if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
            // Speed optimization -- use set if we're copying from a typed array
            buf._set(subject)
        } else if (isArrayish(subject)) {
            // Treat array-ish objects as a byte array
            if (Buffer.isBuffer(subject)) {
                for (i = 0; i < length; i++)
                    buf[i] = subject.readUInt8(i)
            } else {
                for (i = 0; i < length; i++)
                    buf[i] = ((subject[i] % 256) + 256) % 256
            }
        } else if (type === 'string') {
            buf.write(subject, 0, encoding)
        } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
            for (i = 0; i < length; i++) {
                buf[i] = 0
            }
        }

        if (length > 0 && length <= Buffer.poolSize)
            buf.parent = rootParent

        return buf
    }

    function SlowBuffer(subject, encoding, noZero) {
        if (!(this instanceof SlowBuffer))
            return new SlowBuffer(subject, encoding, noZero)

        var buf = new Buffer(subject, encoding, noZero)
        delete buf.parent
        return buf
    }

    Buffer.isBuffer = function (b) {
        return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function (a, b) {
        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
            throw new TypeError('Arguments must be Buffers')

        var x = a.length
        var y = b.length
        for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
        if (i !== len) {
            x = a[i]
            y = b[i]
        }
        if (x < y) return -1
        if (y < x) return 1
        return 0
    }

    Buffer.isEncoding = function (encoding) {
        switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'binary':
            case 'base64':
            case 'raw':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return true
            default:
                return false
        }
    }

    Buffer.concat = function (list, totalLength) {
        if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

        if (list.length === 0) {
            return new Buffer(0)
        } else if (list.length === 1) {
            return list[0]
        }

        var i
        if (totalLength === undefined) {
            totalLength = 0
            for (i = 0; i < list.length; i++) {
                totalLength += list[i].length
            }
        }

        var buf = new Buffer(totalLength)
        var pos = 0
        for (i = 0; i < list.length; i++) {
            var item = list[i]
            item.copy(buf, pos)
            pos += item.length
        }
        return buf
    }

    Buffer.byteLength = function (str, encoding) {
        var ret
        str = str + ''
        switch (encoding || 'utf8') {
            case 'ascii':
            case 'binary':
            case 'raw':
                ret = str.length
                break
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                ret = str.length * 2
                break
            case 'hex':
                ret = str.length >>> 1
                break
            case 'utf8':
            case 'utf-8':
                ret = utf8ToBytes(str).length
                break
            case 'base64':
                ret = base64ToBytes(str).length
                break
            default:
                ret = str.length
        }
        return ret
    }

// pre-set for values that may exist in the future
    Buffer.prototype.length = undefined
    Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
    Buffer.prototype.toString = function (encoding, start, end) {
        var loweredCase = false

        start = start >>> 0
        end = end === undefined || end === Infinity ? this.length : end >>> 0

        if (!encoding) encoding = 'utf8'
        if (start < 0) start = 0
        if (end > this.length) end = this.length
        if (end <= start) return ''

        while (true) {
            switch (encoding) {
                case 'hex':
                    return hexSlice(this, start, end)

                case 'utf8':
                case 'utf-8':
                    return utf8Slice(this, start, end)

                case 'ascii':
                    return asciiSlice(this, start, end)

                case 'binary':
                    return binarySlice(this, start, end)

                case 'base64':
                    return base64Slice(this, start, end)

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                    return utf16leSlice(this, start, end)

                default:
                    if (loweredCase)
                        throw new TypeError('Unknown encoding: ' + encoding)
                    encoding = (encoding + '').toLowerCase()
                    loweredCase = true
            }
        }
    }

    Buffer.prototype.equals = function (b) {
        if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
        return Buffer.compare(this, b) === 0
    }

    Buffer.prototype.inspect = function () {
        var str = ''
        var max = exports.INSPECT_MAX_BYTES
        if (this.length > 0) {
            str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
            if (this.length > max)
                str += ' ... '
        }
        return '<Buffer ' + str + '>'
    }

    Buffer.prototype.compare = function (b) {
        if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
        return Buffer.compare(this, b)
    }

// `get` will be removed in Node 0.13+
    Buffer.prototype.get = function (offset) {
        console.log('.get() is deprecated. Access using array indexes instead.')
        return this.readUInt8(offset)
    }

// `set` will be removed in Node 0.13+
    Buffer.prototype.set = function (v, offset) {
        console.log('.set() is deprecated. Access using array indexes instead.')
        return this.writeUInt8(v, offset)
    }

    function hexWrite (buf, string, offset, length) {
        offset = Number(offset) || 0
        var remaining = buf.length - offset
        if (!length) {
            length = remaining
        } else {
            length = Number(length)
            if (length > remaining) {
                length = remaining
            }
        }

        // must be an even number of digits
        var strLen = string.length
        if (strLen % 2 !== 0) throw new Error('Invalid hex string')

        if (length > strLen / 2) {
            length = strLen / 2
        }
        for (var i = 0; i < length; i++) {
            var byte = parseInt(string.substr(i * 2, 2), 16)
            if (isNaN(byte)) throw new Error('Invalid hex string')
            buf[offset + i] = byte
        }
        return i
    }

    function utf8Write (buf, string, offset, length) {
        var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
        return charsWritten
    }

    function asciiWrite (buf, string, offset, length) {
        var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
        return charsWritten
    }

    function binaryWrite (buf, string, offset, length) {
        return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
        var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
        return charsWritten
    }

    function utf16leWrite (buf, string, offset, length) {
        var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length, 2)
        return charsWritten
    }

    Buffer.prototype.write = function (string, offset, length, encoding) {
        // Support both (string, offset, length, encoding)
        // and the legacy (string, encoding, offset, length)
        if (isFinite(offset)) {
            if (!isFinite(length)) {
                encoding = length
                length = undefined
            }
        } else {  // legacy
            var swap = encoding
            encoding = offset
            offset = length
            length = swap
        }

        offset = Number(offset) || 0

        if (length < 0 || offset < 0 || offset > this.length)
            throw new RangeError('attempt to write outside buffer bounds');

        var remaining = this.length - offset
        if (!length) {
            length = remaining
        } else {
            length = Number(length)
            if (length > remaining) {
                length = remaining
            }
        }
        encoding = String(encoding || 'utf8').toLowerCase()

        var ret
        switch (encoding) {
            case 'hex':
                ret = hexWrite(this, string, offset, length)
                break
            case 'utf8':
            case 'utf-8':
                ret = utf8Write(this, string, offset, length)
                break
            case 'ascii':
                ret = asciiWrite(this, string, offset, length)
                break
            case 'binary':
                ret = binaryWrite(this, string, offset, length)
                break
            case 'base64':
                ret = base64Write(this, string, offset, length)
                break
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                ret = utf16leWrite(this, string, offset, length)
                break
            default:
                throw new TypeError('Unknown encoding: ' + encoding)
        }
        return ret
    }

    Buffer.prototype.toJSON = function () {
        return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }

    function base64Slice (buf, start, end) {
        if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf)
        } else {
            return base64.fromByteArray(buf.slice(start, end))
        }
    }

    function utf8Slice (buf, start, end) {
        var res = ''
        var tmp = ''
        end = Math.min(buf.length, end)

        for (var i = start; i < end; i++) {
            if (buf[i] <= 0x7F) {
                res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
                tmp = ''
            } else {
                tmp += '%' + buf[i].toString(16)
            }
        }

        return res + decodeUtf8Char(tmp)
    }

    function asciiSlice (buf, start, end) {
        var ret = ''
        end = Math.min(buf.length, end)

        for (var i = start; i < end; i++) {
            ret += String.fromCharCode(buf[i] & 0x7F)
        }
        return ret
    }

    function binarySlice (buf, start, end) {
        var ret = ''
        end = Math.min(buf.length, end)

        for (var i = start; i < end; i++) {
            ret += String.fromCharCode(buf[i])
        }
        return ret
    }

    function hexSlice (buf, start, end) {
        var len = buf.length

        if (!start || start < 0) start = 0
        if (!end || end < 0 || end > len) end = len

        var out = ''
        for (var i = start; i < end; i++) {
            out += toHex(buf[i])
        }
        return out
    }

    function utf16leSlice (buf, start, end) {
        var bytes = buf.slice(start, end)
        var res = ''
        for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
        }
        return res
    }

    Buffer.prototype.slice = function (start, end) {
        var len = this.length
        start = ~~start
        end = end === undefined ? len : ~~end

        if (start < 0) {
            start += len;
            if (start < 0)
                start = 0
        } else if (start > len) {
            start = len
        }

        if (end < 0) {
            end += len
            if (end < 0)
                end = 0
        } else if (end > len) {
            end = len
        }

        if (end < start)
            end = start

        var newBuf
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            newBuf = Buffer._augment(this.subarray(start, end))
        } else {
            var sliceLen = end - start
            newBuf = new Buffer(sliceLen, undefined, true)
            for (var i = 0; i < sliceLen; i++) {
                newBuf[i] = this[i + start]
            }
        }

        if (newBuf.length)
            newBuf.parent = this.parent || this

        return newBuf
    }

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
        if ((offset % 1) !== 0 || offset < 0)
            throw new RangeError('offset is not uint')
        if (offset + ext > length)
            throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function (offset, byteLength, noAssert) {
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert)
            checkOffset(offset, byteLength, this.length)

        var val = this[offset]
        var mul = 1
        var i = 0
        while (++i < byteLength && (mul *= 0x100))
            val += this[offset + i] * mul

        return val
    }

    Buffer.prototype.readUIntBE = function (offset, byteLength, noAssert) {
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert)
            checkOffset(offset, byteLength, this.length)

        var val = this[offset + --byteLength]
        var mul = 1
        while (byteLength > 0 && (mul *= 0x100))
            val += this[offset + --byteLength] * mul;

        return val
    }

    Buffer.prototype.readUInt8 = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 1, this.length)
        return this[offset]
    }

    Buffer.prototype.readUInt16LE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 2, this.length)
        return this[offset] | (this[offset + 1] << 8)
    }

    Buffer.prototype.readUInt16BE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 2, this.length)
        return (this[offset] << 8) | this[offset + 1]
    }

    Buffer.prototype.readUInt32LE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 4, this.length)

        return ((this[offset]) |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16)) +
            (this[offset + 3] * 0x1000000)
    }

    Buffer.prototype.readUInt32BE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 4, this.length)

        return (this[offset] * 0x1000000) +
            ((this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            this[offset + 3])
    }

    Buffer.prototype.readIntLE = function (offset, byteLength, noAssert) {
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert)
            checkOffset(offset, byteLength, this.length)

        var val = this[offset]
        var mul = 1
        var i = 0
        while (++i < byteLength && (mul *= 0x100))
            val += this[offset + i] * mul
        mul *= 0x80

        if (val >= mul)
            val -= Math.pow(2, 8 * byteLength)

        return val
    }

    Buffer.prototype.readIntBE = function (offset, byteLength, noAssert) {
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert)
            checkOffset(offset, byteLength, this.length)

        var i = byteLength
        var mul = 1
        var val = this[offset + --i]
        while (i > 0 && (mul *= 0x100))
            val += this[offset + --i] * mul
        mul *= 0x80

        if (val >= mul)
            val -= Math.pow(2, 8 * byteLength)

        return val
    }

    Buffer.prototype.readInt8 = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 1, this.length)
        if (!(this[offset] & 0x80))
            return (this[offset])
        return ((0xff - this[offset] + 1) * -1)
    }

    Buffer.prototype.readInt16LE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 2, this.length)
        var val = this[offset] | (this[offset + 1] << 8)
        return (val & 0x8000) ? val | 0xFFFF0000 : val
    }

    Buffer.prototype.readInt16BE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 2, this.length)
        var val = this[offset + 1] | (this[offset] << 8)
        return (val & 0x8000) ? val | 0xFFFF0000 : val
    }

    Buffer.prototype.readInt32LE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 4, this.length)

        return (this[offset]) |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16) |
            (this[offset + 3] << 24)
    }

    Buffer.prototype.readInt32BE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 4, this.length)

        return (this[offset] << 24) |
            (this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            (this[offset + 3])
    }

    Buffer.prototype.readFloatLE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 4, this.length)
        return ieee754.read(this, offset, true, 23, 4)
    }

    Buffer.prototype.readFloatBE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 4, this.length)
        return ieee754.read(this, offset, false, 23, 4)
    }

    Buffer.prototype.readDoubleLE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 8, this.length)
        return ieee754.read(this, offset, true, 52, 8)
    }

    Buffer.prototype.readDoubleBE = function (offset, noAssert) {
        if (!noAssert)
            checkOffset(offset, 8, this.length)
        return ieee754.read(this, offset, false, 52, 8)
    }

    function checkInt (buf, value, offset, ext, max, min) {
        if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
        if (value > max || value < min) throw new RangeError('value is out of bounds')
        if (offset + ext > buf.length) throw new RangeError('index out of range')
    }

    Buffer.prototype.writeUIntLE = function (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert)
            checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

        var mul = 1
        var i = 0
        this[offset] = value & 0xFF
        while (++i < byteLength && (mul *= 0x100))
            this[offset + i] = (value / mul) >>> 0 & 0xFF

        return offset + byteLength
    }

    Buffer.prototype.writeUIntBE = function (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset >>> 0
        byteLength = byteLength >>> 0
        if (!noAssert)
            checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

        var i = byteLength - 1
        var mul = 1
        this[offset + i] = value & 0xFF
        while (--i >= 0 && (mul *= 0x100))
            this[offset + i] = (value / mul) >>> 0 & 0xFF

        return offset + byteLength
    }

    Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert)
            checkInt(this, value, offset, 1, 0xff, 0)
        if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
        this[offset] = value
        return offset + 1
    }

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
        if (value < 0) value = 0xffff + value + 1
        for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
            buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                (littleEndian ? i : 1 - i) * 8
        }
    }

    Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert)
            checkInt(this, value, offset, 2, 0xffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value
            this[offset + 1] = (value >>> 8)
        } else objectWriteUInt16(this, value, offset, true)
        return offset + 2
    }

    Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert)
            checkInt(this, value, offset, 2, 0xffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = (value >>> 8)
            this[offset + 1] = value
        } else objectWriteUInt16(this, value, offset, false)
        return offset + 2
    }

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
        if (value < 0) value = 0xffffffff + value + 1
        for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
            buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
        }
    }

    Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert)
            checkInt(this, value, offset, 4, 0xffffffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = (value >>> 24)
            this[offset + 2] = (value >>> 16)
            this[offset + 1] = (value >>> 8)
            this[offset] = value
        } else objectWriteUInt32(this, value, offset, true)
        return offset + 4
    }

    Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert)
            checkInt(this, value, offset, 4, 0xffffffff, 0)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = (value >>> 24)
            this[offset + 1] = (value >>> 16)
            this[offset + 2] = (value >>> 8)
            this[offset + 3] = value
        } else objectWriteUInt32(this, value, offset, false)
        return offset + 4
    }

    Buffer.prototype.writeIntLE = function (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) {
            checkInt(this,
                value,
                offset,
                byteLength,
                Math.pow(2, 8 * byteLength - 1) - 1,
                -Math.pow(2, 8 * byteLength - 1))
        }

        var i = 0
        var mul = 1
        var sub = value < 0 ? 1 : 0
        this[offset] = value & 0xFF
        while (++i < byteLength && (mul *= 0x100))
            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF

        return offset + byteLength
    }

    Buffer.prototype.writeIntBE = function (value, offset, byteLength, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert) {
            checkInt(this,
                value,
                offset,
                byteLength,
                Math.pow(2, 8 * byteLength - 1) - 1,
                -Math.pow(2, 8 * byteLength - 1))
        }

        var i = byteLength - 1
        var mul = 1
        var sub = value < 0 ? 1 : 0
        this[offset + i] = value & 0xFF
        while (--i >= 0 && (mul *= 0x100))
            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF

        return offset + byteLength
    }

    Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert)
            checkInt(this, value, offset, 1, 0x7f, -0x80)
        if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
        if (value < 0) value = 0xff + value + 1
        this[offset] = value
        return offset + 1
    }

    Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert)
            checkInt(this, value, offset, 2, 0x7fff, -0x8000)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value
            this[offset + 1] = (value >>> 8)
        } else objectWriteUInt16(this, value, offset, true)
        return offset + 2
    }

    Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert)
            checkInt(this, value, offset, 2, 0x7fff, -0x8000)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = (value >>> 8)
            this[offset + 1] = value
        } else objectWriteUInt16(this, value, offset, false)
        return offset + 2
    }

    Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value
            this[offset + 1] = (value >>> 8)
            this[offset + 2] = (value >>> 16)
            this[offset + 3] = (value >>> 24)
        } else objectWriteUInt32(this, value, offset, true)
        return offset + 4
    }

    Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
        value = +value
        offset = offset >>> 0
        if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
        if (value < 0) value = 0xffffffff + value + 1
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = (value >>> 24)
            this[offset + 1] = (value >>> 16)
            this[offset + 2] = (value >>> 8)
            this[offset + 3] = value
        } else objectWriteUInt32(this, value, offset, false)
        return offset + 4
    }

    function checkIEEE754 (buf, value, offset, ext, max, min) {
        if (value > max || value < min) throw new RangeError('value is out of bounds')
        if (offset + ext > buf.length) throw new RangeError('index out of range')
        if (offset < 0) throw new RangeError('index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
        if (!noAssert)
            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
        ieee754.write(buf, value, offset, littleEndian, 23, 4)
        return offset + 4
    }

    Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert)
    }

    Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert)
    }

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
        if (!noAssert)
            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
        ieee754.write(buf, value, offset, littleEndian, 52, 8)
        return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert)
    }

    Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert)
    }

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function (target, target_start, start, end) {
        var source = this

        if (!start) start = 0
        if (!end && end !== 0) end = this.length
        if (target_start >= target.length) target_start = target.length
        if (!target_start) target_start = 0
        if (end > 0 && end < start) end = start

        // Copy 0 bytes; we're done
        if (end === start) return 0
        if (target.length === 0 || source.length === 0) return 0

        // Fatal error conditions
        if (target_start < 0)
            throw new RangeError('targetStart out of bounds')
        if (start < 0 || start >= source.length) throw new RangeError('sourceStart out of bounds')
        if (end < 0) throw new RangeError('sourceEnd out of bounds')

        // Are we oob?
        if (end > this.length)
            end = this.length
        if (target.length - target_start < end - start)
            end = target.length - target_start + start

        var len = end - start

        if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < len; i++) {
                target[i + target_start] = this[i + start]
            }
        } else {
            target._set(this.subarray(start, start + len), target_start)
        }

        return len
    }

// fill(value, start=0, end=buffer.length)
    Buffer.prototype.fill = function (value, start, end) {
        if (!value) value = 0
        if (!start) start = 0
        if (!end) end = this.length

        if (end < start) throw new RangeError('end < start')

        // Fill 0 bytes; we're done
        if (end === start) return
        if (this.length === 0) return

        if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
        if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

        var i
        if (typeof value === 'number') {
            for (i = start; i < end; i++) {
                this[i] = value
            }
        } else {
            var bytes = utf8ToBytes(value.toString())
            var len = bytes.length
            for (i = start; i < end; i++) {
                this[i] = bytes[i % len]
            }
        }

        return this
    }

    /**
     * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
     * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
     */
    Buffer.prototype.toArrayBuffer = function () {
        if (typeof Uint8Array !== 'undefined') {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                return (new Buffer(this)).buffer
            } else {
                var buf = new Uint8Array(this.length)
                for (var i = 0, len = buf.length; i < len; i += 1) {
                    buf[i] = this[i]
                }
                return buf.buffer
            }
        } else {
            throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
        }
    }

// HELPER FUNCTIONS
// ================

    var BP = Buffer.prototype

    /**
     * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
     */
    Buffer._augment = function (arr) {
        arr.constructor = Buffer
        arr._isBuffer = true

        // save reference to original Uint8Array get/set methods before overwriting
        arr._get = arr.get
        arr._set = arr.set

        // deprecated, will be removed in node 0.13+
        arr.get = BP.get
        arr.set = BP.set

        arr.write = BP.write
        arr.toString = BP.toString
        arr.toLocaleString = BP.toString
        arr.toJSON = BP.toJSON
        arr.equals = BP.equals
        arr.compare = BP.compare
        arr.copy = BP.copy
        arr.slice = BP.slice
        arr.readUIntLE = BP.readUIntLE
        arr.readUIntBE = BP.readUIntBE
        arr.readUInt8 = BP.readUInt8
        arr.readUInt16LE = BP.readUInt16LE
        arr.readUInt16BE = BP.readUInt16BE
        arr.readUInt32LE = BP.readUInt32LE
        arr.readUInt32BE = BP.readUInt32BE
        arr.readIntLE = BP.readIntLE
        arr.readIntBE = BP.readIntBE
        arr.readInt8 = BP.readInt8
        arr.readInt16LE = BP.readInt16LE
        arr.readInt16BE = BP.readInt16BE
        arr.readInt32LE = BP.readInt32LE
        arr.readInt32BE = BP.readInt32BE
        arr.readFloatLE = BP.readFloatLE
        arr.readFloatBE = BP.readFloatBE
        arr.readDoubleLE = BP.readDoubleLE
        arr.readDoubleBE = BP.readDoubleBE
        arr.writeUInt8 = BP.writeUInt8
        arr.writeUIntLE = BP.writeUIntLE
        arr.writeUIntBE = BP.writeUIntBE
        arr.writeUInt16LE = BP.writeUInt16LE
        arr.writeUInt16BE = BP.writeUInt16BE
        arr.writeUInt32LE = BP.writeUInt32LE
        arr.writeUInt32BE = BP.writeUInt32BE
        arr.writeIntLE = BP.writeIntLE
        arr.writeIntBE = BP.writeIntBE
        arr.writeInt8 = BP.writeInt8
        arr.writeInt16LE = BP.writeInt16LE
        arr.writeInt16BE = BP.writeInt16BE
        arr.writeInt32LE = BP.writeInt32LE
        arr.writeInt32BE = BP.writeInt32BE
        arr.writeFloatLE = BP.writeFloatLE
        arr.writeFloatBE = BP.writeFloatBE
        arr.writeDoubleLE = BP.writeDoubleLE
        arr.writeDoubleBE = BP.writeDoubleBE
        arr.fill = BP.fill
        arr.inspect = BP.inspect
        arr.toArrayBuffer = BP.toArrayBuffer

        return arr
    }

    var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

    function base64clean (str) {
        // Node strips out invalid characters like \n and \t from the string, base64-js does not
        str = stringtrim(str).replace(INVALID_BASE64_RE, '')
        // Node converts strings with length < 2 to ''
        if (str.length < 2) return ''
        // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
        while (str.length % 4 !== 0) {
            str = str + '='
        }
        return str
    }

    function stringtrim (str) {
        if (str.trim) return str.trim()
        return str.replace(/^\s+|\s+$/g, '')
    }

    function isArrayish (subject) {
        return isArray(subject) || Buffer.isBuffer(subject) ||
            subject && typeof subject === 'object' &&
            typeof subject.length === 'number'
    }

    function toHex (n) {
        if (n < 16) return '0' + n.toString(16)
        return n.toString(16)
    }

    function utf8ToBytes(string, units) {
        var codePoint, length = string.length
        var leadSurrogate = null
        units = units || Infinity
        var bytes = []
        var i = 0

        for (; i<length; i++) {
            codePoint = string.charCodeAt(i)

            // is surrogate component
            if (codePoint > 0xD7FF && codePoint < 0xE000) {

                // last char was a lead
                if (leadSurrogate) {

                    // 2 leads in a row
                    if (codePoint < 0xDC00) {
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                        leadSurrogate = codePoint
                        continue
                    }

                    // valid surrogate pair
                    else {
                        codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
                        leadSurrogate = null
                    }
                }

                // no lead yet
                else {

                    // unexpected trail
                    if (codePoint > 0xDBFF) {
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                        continue
                    }

                    // unpaired lead
                    else if (i + 1 === length) {
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                        continue
                    }

                    // valid lead
                    else {
                        leadSurrogate = codePoint
                        continue
                    }
                }
            }

            // valid bmp char, but last char was a lead
            else if (leadSurrogate) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                leadSurrogate = null
            }

            // encode utf8
            if (codePoint < 0x80) {
                if ((units -= 1) < 0) break
                bytes.push(codePoint)
            }
            else if (codePoint < 0x800) {
                if ((units -= 2) < 0) break
                bytes.push(
                    codePoint >> 0x6 | 0xC0,
                    codePoint & 0x3F | 0x80
                );
            }
            else if (codePoint < 0x10000) {
                if ((units -= 3) < 0) break
                bytes.push(
                    codePoint >> 0xC | 0xE0,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                );
            }
            else if (codePoint < 0x200000) {
                if ((units -= 4) < 0) break
                bytes.push(
                    codePoint >> 0x12 | 0xF0,
                    codePoint >> 0xC & 0x3F | 0x80,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                );
            }
            else {
                throw new Error('Invalid code point')
            }
        }

        return bytes
    }

    function asciiToBytes (str) {
        var byteArray = []
        for (var i = 0; i < str.length; i++) {
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xFF)
        }
        return byteArray
    }

    function utf16leToBytes (str, units) {
        var c, hi, lo
        var byteArray = []
        for (var i = 0; i < str.length; i++) {

            if ((units -= 2) < 0) break

            c = str.charCodeAt(i)
            hi = c >> 8
            lo = c % 256
            byteArray.push(lo)
            byteArray.push(hi)
        }

        return byteArray
    }

    function base64ToBytes (str) {
        return base64.toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length, unitSize) {
        if (unitSize) length -= length % unitSize;
        for (var i = 0; i < length; i++) {
            if ((i + offset >= dst.length) || (i >= src.length))
                break
            dst[i + offset] = src[i]
        }
        return i
    }

    function decodeUtf8Char (str) {
        try {
            return decodeURIComponent(str)
        } catch (err) {
            return String.fromCharCode(0xFFFD) // UTF 8 invalid char
        }
    }

},{"base64-js":4,"ieee754":5,"is-array":6}],4:[function(require,module,exports){
    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    ;(function (exports) {
        

        var Arr = (typeof Uint8Array !== 'undefined')
            ? Uint8Array
            : Array

        var PLUS   = '+'.charCodeAt(0)
        var SLASH  = '/'.charCodeAt(0)
        var NUMBER = '0'.charCodeAt(0)
        var LOWER  = 'a'.charCodeAt(0)
        var UPPER  = 'A'.charCodeAt(0)
        var PLUS_URL_SAFE = '-'.charCodeAt(0)
        var SLASH_URL_SAFE = '_'.charCodeAt(0)

        function decode (elt) {
            var code = elt.charCodeAt(0)
            if (code === PLUS ||
                code === PLUS_URL_SAFE)
                return 62 // '+'
            if (code === SLASH ||
                code === SLASH_URL_SAFE)
                return 63 // '/'
            if (code < NUMBER)
                return -1 //no match
            if (code < NUMBER + 10)
                return code - NUMBER + 26 + 26
            if (code < UPPER + 26)
                return code - UPPER
            if (code < LOWER + 26)
                return code - LOWER + 26
        }

        function b64ToByteArray (b64) {
            var i, j, l, tmp, placeHolders, arr

            if (b64.length % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
            }

            // the number of equal signs (place holders)
            // if there are two placeholders, than the two characters before it
            // represent one byte
            // if there is only one, then the three characters before it represent 2 bytes
            // this is just a cheap hack to not do indexOf twice
            var len = b64.length
            placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

            // base64 is 4/3 + up to two characters of the original data
            arr = new Arr(b64.length * 3 / 4 - placeHolders)

            // if there are placeholders, only get up to the last complete 4 chars
            l = placeHolders > 0 ? b64.length - 4 : b64.length

            var L = 0

            function push (v) {
                arr[L++] = v
            }

            for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
                push((tmp & 0xFF0000) >> 16)
                push((tmp & 0xFF00) >> 8)
                push(tmp & 0xFF)
            }

            if (placeHolders === 2) {
                tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
                push(tmp & 0xFF)
            } else if (placeHolders === 1) {
                tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
                push((tmp >> 8) & 0xFF)
                push(tmp & 0xFF)
            }

            return arr
        }

        function uint8ToBase64 (uint8) {
            var i,
                extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
                output = "",
                temp, length

            function encode (num) {
                return lookup.charAt(num)
            }

            function tripletToBase64 (num) {
                return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
            }

            // go through the array every three bytes, we'll deal with trailing stuff later
            for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
                output += tripletToBase64(temp)
            }

            // pad the end with zeros, but make sure to not forget the extra bytes
            switch (extraBytes) {
                case 1:
                    temp = uint8[uint8.length - 1]
                    output += encode(temp >> 2)
                    output += encode((temp << 4) & 0x3F)
                    output += '=='
                    break
                case 2:
                    temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
                    output += encode(temp >> 10)
                    output += encode((temp >> 4) & 0x3F)
                    output += encode((temp << 2) & 0x3F)
                    output += '='
                    break
            }

            return output
        }

        exports.toByteArray = b64ToByteArray
        exports.fromByteArray = uint8ToBase64
    }(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],5:[function(require,module,exports){
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = -7,
            i = isLE ? (nBytes - 1) : 0,
            d = isLE ? -1 : 1,
            s = buffer[offset + i];

        i += d;

        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };

    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
            i = isLE ? 0 : (nBytes - 1),
            d = isLE ? 1 : -1,
            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

        buffer[offset + i - d] |= s * 128;
    };

},{}],6:[function(require,module,exports){

    /**
     * isArray
     */

    var isArray = Array.isArray;

    /**
     * toString
     */

    var str = Object.prototype.toString;

    /**
     * Whether or not the given `val`
     * is an array.
     *
     * example:
     *
     *        isArray([]);
     *        // > true
     *        isArray(arguments);
     *        // > false
     *        isArray('');
     *        // > false
     *
     * @param {mixed} val
     * @return {bool}
     */

    module.exports = isArray || function (val) {
            return !! val && '[object Array]' == str.call(val);
        };

},{}],7:[function(require,module,exports){
    (function (Buffer){
        
        var createHash = require('sha.js')

        var md5 = require('./md5')
        var rmd160 = require('ripemd160')
        var Transform = require('stream').Transform;
        var inherits = require('util').inherits

        module.exports = function (alg) {
            if('md5' === alg) return new HashNoConstructor(md5)
            if('rmd160' === alg) return new HashNoConstructor(rmd160)
            return new Hash(createHash(alg))
        }
        inherits(HashNoConstructor, Transform)

        function HashNoConstructor(hash) {
            Transform.call(this);
            this._hash = hash
            this.buffers = []
        }

        HashNoConstructor.prototype._transform = function (data, _, done) {
            this.buffers.push(data)
            done()
        }
        HashNoConstructor.prototype._flush = function (done) {
            var buf = Buffer.concat(this.buffers)
            var r = this._hash(buf)
            this.buffers = null
            this.push(r)
            done()
        }
        HashNoConstructor.prototype.update = function (data, enc) {
            this.write(data, enc)
            return this
        }

        HashNoConstructor.prototype.digest = function (enc) {
            this.end()
            var outData = new Buffer('')
            var chunk
            while ((chunk = this.read())) {
                outData = Buffer.concat([outData, chunk])
            }
            if (enc) {
                outData = outData.toString(enc)
            }
            return outData
        }

        inherits(Hash, Transform)

        function Hash(hash) {
            Transform.call(this);
            this._hash = hash
        }

        Hash.prototype._transform = function (data, _, done) {
            this._hash.update(data)
            done()
        }
        Hash.prototype._flush = function (done) {
            this.push(this._hash.digest())
            this._hash = null
            done()
        }
        Hash.prototype.update = function (data, enc) {
            this.write(data, enc)
            return this
        }

        Hash.prototype.digest = function (enc) {
            this.end()
            var outData = new Buffer('')
            var chunk
            while ((chunk = this.read())) {
                outData = Buffer.concat([outData, chunk])
            }
            if (enc) {
                outData = outData.toString(enc)
            }
            return outData
        }

    }).call(this,require("buffer").Buffer)
},{"./md5":11,"buffer":3,"ripemd160":137,"sha.js":139,"stream":163,"util":166}],8:[function(require,module,exports){
    (function (Buffer){
        
        var createHash = require('./create-hash')
        var Transform = require('stream').Transform;
        var inherits = require('util').inherits
        var zeroBuffer = new Buffer(128)
        zeroBuffer.fill(0)

        module.exports = Hmac
        inherits(Hmac, Transform)
        function Hmac (alg, key) {
            if(!(this instanceof Hmac)) return new Hmac(alg, key)

            Transform.call(this)
            this._opad = opad
            this._alg = alg

            var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

            key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key

            if(key.length > blocksize) {
                key = createHash(alg).update(key).digest()
            } else if(key.length < blocksize) {
                key = Buffer.concat([key, zeroBuffer], blocksize)
            }

            var ipad = this._ipad = new Buffer(blocksize)
            var opad = this._opad = new Buffer(blocksize)

            for(var i = 0; i < blocksize; i++) {
                ipad[i] = key[i] ^ 0x36
                opad[i] = key[i] ^ 0x5C
            }

            this._hash = createHash(alg).update(ipad)
        }

        Hmac.prototype.update = function (data, enc) {
            this.write(data, enc)
            return this
        }

        Hmac.prototype._transform = function (data, _, next) {
            this._hash.update(data)
            next()
        }

        Hmac.prototype._flush = function (next) {
            var h = this._hash.digest()
            this.push(createHash(this._alg).update(this._opad).update(h).digest())
            next()
        }

        Hmac.prototype.digest = function (enc) {
            this.end()
            var outData = new Buffer('')
            var chunk
            while ((chunk = this.read())) {
                outData = Buffer.concat([outData, chunk])
            }
            if (enc) {
                outData = outData.toString(enc)
            }
            return outData
        }


    }).call(this,require("buffer").Buffer)
},{"./create-hash":7,"buffer":3,"stream":163,"util":166}],9:[function(require,module,exports){
    (function (Buffer){
        
        var intSize = 4;
        var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
        var chrsz = 8;

        function toArray(buf, bigEndian) {
            if ((buf.length % intSize) !== 0) {
                var len = buf.length + (intSize - (buf.length % intSize));
                buf = Buffer.concat([buf, zeroBuffer], len);
            }

            var arr = [];
            var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
            for (var i = 0; i < buf.length; i += intSize) {
                arr.push(fn.call(buf, i));
            }
            return arr;
        }

        function toBuffer(arr, size, bigEndian) {
            var buf = new Buffer(size);
            var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
            for (var i = 0; i < arr.length; i++) {
                fn.call(buf, arr[i], i * 4, true);
            }
            return buf;
        }

        function hash(buf, fn, hashSize, bigEndian) {
            if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
            var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
            return toBuffer(arr, hashSize, bigEndian);
        }

        module.exports = { hash: hash };

    }).call(this,require("buffer").Buffer)
},{"buffer":3}],10:[function(require,module,exports){
    
    var rng = exports.rng = require('./rng')
    var prng = exports.prng = require('./prng');

    function error () {
        var m = [].slice.call(arguments).join(' ')
        throw new Error([
            m,
            'we accept pull requests',
            'http://github.com/dominictarr/crypto-browserify'
        ].join('\n'))
    }

    exports.createHash = exports.Hash = require('./create-hash')

    exports.createHmac = exports.Hmac = require('./create-hmac')

    exports.randomBytes = function(size, callback) {
        if (callback && callback.call) {
            try {
                callback.call(this, undefined, rng(size))
            } catch (err) { callback(err) }
        } else {
            return rng(size)
        }
    }
    exports.pseudoRandomBytes = function(size, callback) {
        if (callback && callback.call) {
            try {
                callback.call(this, undefined, prng(size))
            } catch (err) { callback(err) }
        } else {
            return prng(size)
        }
    }

    function each(a, f) {
        for(var i in a)
            f(a[i], i)
    }
    var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(require('browserify-sign/algos')))
    exports.getHashes = function () {
        return hashes;
    }

    var p = require('./pbkdf2')(exports)
    exports.pbkdf2 = p.pbkdf2
    exports.pbkdf2Sync = p.pbkdf2Sync
    require('browserify-aes/inject')(exports, module.exports);
    require('browserify-sign/inject')(module.exports, exports);
    require('diffie-hellman/inject')(exports, module.exports);
    require('create-ecdh/inject')(module.exports, exports);
    require('public-encrypt/inject')(module.exports, exports);

// the least I can do is make error messages for the rest of the node.js/crypto api.
    each([
        'createCredentials'
    ], function (name) {
        exports[name] = function () {
            error('sorry,', name, 'is not implemented yet')
        }
    })

},{"./create-hash":7,"./create-hmac":8,"./pbkdf2":145,"./prng":146,"./rng":147,"browserify-aes/inject":19,"browserify-sign/algos":30,"browserify-sign/inject":31,"create-ecdh/inject":78,"diffie-hellman/inject":102,"public-encrypt/inject":109}],11:[function(require,module,exports){
    
    /*
     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
     * Digest Algorithm, as defined in RFC 1321.
     * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for more info.
     */

    var helpers = require('./helpers');

    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length
     */
    function core_md5(x, len)
    {
        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var a =  1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d =  271733878;

        for(var i = 0; i < x.length; i += 16)
        {
            var olda = a;
            var oldb = b;
            var oldc = c;
            var oldd = d;

            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return Array(a, b, c, d);

    }

    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    function md5_cmn(q, a, b, x, s, t)
    {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
    }
    function md5_ff(a, b, c, d, x, s, t)
    {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t)
    {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t)
    {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t)
    {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    }

    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    function safe_add(x, y)
    {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    function bit_rol(num, cnt)
    {
        return (num << cnt) | (num >>> (32 - cnt));
    }

    module.exports = function md5(buf) {
        return helpers.hash(buf, core_md5, 16);
    };

},{"./helpers":9}],12:[function(require,module,exports){
    (function (Buffer){

        module.exports = function (crypto, password, keyLen, ivLen) {
            keyLen = keyLen/8;
            ivLen = ivLen || 0;
            var ki = 0;
            var ii = 0;
            var key = new Buffer(keyLen);
            var iv = new Buffer(ivLen);
            var addmd = 0;
            var md, md_buf;
            var i;
            while (true) {
                md = crypto.createHash('md5');
                if(addmd++ > 0) {
                    md.update(md_buf);
                }
                md.update(password);
                md_buf = md.digest();
                i = 0;
                if(keyLen > 0) {
                    while(true) {
                        if(keyLen === 0) {
                            break;
                        }
                        if(i === md_buf.length) {
                            break;
                        }
                        key[ki++] = md_buf[i];
                        keyLen--;
                        i++;
                    }
                }
                if(ivLen > 0 && i !== md_buf.length) {
                    while(true) {
                        if(ivLen === 0) {
                            break;
                        }
                        if(i === md_buf.length) {
                            break;
                        }
                        iv[ii++] = md_buf[i];
                        ivLen--;
                        i++;
                    }
                }
                if(keyLen === 0 && ivLen === 0) {
                    break;
                }
            }
            for(i=0;i<md_buf.length;i++) {
                md_buf[i] = 0;
            }
            return {
                key: key,
                iv: iv
            };
        };
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],13:[function(require,module,exports){
    (function (Buffer){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

        var uint_max = Math.pow(2, 32);
        function fixup_uint32(x) {
            var ret, x_pos;
            ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
            return ret;
        }
        function scrub_vec(v) {
            var i, _i, _ref;
            for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                v[i] = 0;
            }
            return false;
        }

        function Global() {
            var i;
            this.SBOX = [];
            this.INV_SBOX = [];
            this.SUB_MIX = (function() {
                var _i, _results;
                _results = [];
                for (i = _i = 0; _i < 4; i = ++_i) {
                    _results.push([]);
                }
                return _results;
            })();
            this.INV_SUB_MIX = (function() {
                var _i, _results;
                _results = [];
                for (i = _i = 0; _i < 4; i = ++_i) {
                    _results.push([]);
                }
                return _results;
            })();
            this.init();
            this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
        }

        Global.prototype.init = function() {
            var d, i, sx, t, x, x2, x4, x8, xi, _i;
            d = (function() {
                var _i, _results;
                _results = [];
                for (i = _i = 0; _i < 256; i = ++_i) {
                    if (i < 128) {
                        _results.push(i << 1);
                    } else {
                        _results.push((i << 1) ^ 0x11b);
                    }
                }
                return _results;
            })();
            x = 0;
            xi = 0;
            for (i = _i = 0; _i < 256; i = ++_i) {
                sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
                sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
                this.SBOX[x] = sx;
                this.INV_SBOX[sx] = x;
                x2 = d[x];
                x4 = d[x2];
                x8 = d[x4];
                t = (d[sx] * 0x101) ^ (sx * 0x1010100);
                this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);
                this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);
                this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);
                this.SUB_MIX[3][x] = t;
                t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
                this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
                this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
                this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
                this.INV_SUB_MIX[3][sx] = t;
                if (x === 0) {
                    x = xi = 1;
                } else {
                    x = x2 ^ d[d[d[x8 ^ x2]]];
                    xi ^= d[d[xi]];
                }
            }
            return true;
        };

        var G = new Global();


        AES.blockSize = 4 * 4;

        AES.prototype.blockSize = AES.blockSize;

        AES.keySize = 256 / 8;

        AES.prototype.keySize = AES.keySize;

        function bufferToArray(buf) {
            var len = buf.length/4;
            var out = new Array(len);
            var i = -1;
            while (++i < len) {
                out[i] = buf.readUInt32BE(i * 4);
            }
            return out;
        }
        function AES(key) {
            this._key = bufferToArray(key);
            this._doReset();
        }

        AES.prototype._doReset = function() {
            var invKsRow, keySize, keyWords, ksRow, ksRows, t, _i, _j;
            keyWords = this._key;
            keySize = keyWords.length;
            this._nRounds = keySize + 6;
            ksRows = (this._nRounds + 1) * 4;
            this._keySchedule = [];
            for (ksRow = _i = 0; 0 <= ksRows ? _i < ksRows : _i > ksRows; ksRow = 0 <= ksRows ? ++_i : --_i) {
                this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);
            }
            this._invKeySchedule = [];
            for (invKsRow = _j = 0; 0 <= ksRows ? _j < ksRows : _j > ksRows; invKsRow = 0 <= ksRows ? ++_j : --_j) {
                ksRow = ksRows - invKsRow;
                t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
                this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]];
            }
            return true;
        };

        AES.prototype.encryptBlock = function(M) {
            M = bufferToArray(new Buffer(M));
            var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX);
            var buf = new Buffer(16);
            buf.writeUInt32BE(out[0], 0);
            buf.writeUInt32BE(out[1], 4);
            buf.writeUInt32BE(out[2], 8);
            buf.writeUInt32BE(out[3], 12);
            return buf;
        };

        AES.prototype.decryptBlock = function(M) {
            M = bufferToArray(new Buffer(M));
            var temp = [M[3], M[1]];
            M[1] = temp[0];
            M[3] = temp[1];
            var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);
            var buf = new Buffer(16);
            buf.writeUInt32BE(out[0], 0);
            buf.writeUInt32BE(out[3], 4);
            buf.writeUInt32BE(out[2], 8);
            buf.writeUInt32BE(out[1], 12);
            return buf;
        };

        AES.prototype.scrub = function() {
            scrub_vec(this._keySchedule);
            scrub_vec(this._invKeySchedule);
            scrub_vec(this._key);
        };

        AES.prototype._doCryptBlock = function(M, keySchedule, SUB_MIX, SBOX) {
            var ksRow, round, s0, s1, s2, s3, t0, t1, t2, t3, _i, _ref;

            s0 = M[0] ^ keySchedule[0];
            s1 = M[1] ^ keySchedule[1];
            s2 = M[2] ^ keySchedule[2];
            s3 = M[3] ^ keySchedule[3];
            ksRow = 4;
            for (round = _i = 1, _ref = this._nRounds; 1 <= _ref ? _i < _ref : _i > _ref; round = 1 <= _ref ? ++_i : --_i) {
                t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];
                t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];
                t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];
                t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
            }
            t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
            t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
            t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
            t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
            return [
                fixup_uint32(t0),
                fixup_uint32(t1),
                fixup_uint32(t2),
                fixup_uint32(t3)
            ];

        };




        exports.AES = AES;
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],14:[function(require,module,exports){
    (function (Buffer){
        var aes = require('./aes');
        var Transform = require('./cipherBase');
        var inherits = require('inherits');
        var GHASH = require('./ghash');
        var xor = require('./xor');
        inherits(StreamCipher, Transform);
        module.exports = StreamCipher;

        function StreamCipher(mode, key, iv, decrypt) {
            if (!(this instanceof StreamCipher)) {
                return new StreamCipher(mode, key, iv);
            }
            Transform.call(this);
            this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])]);
            iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])]);
            this._cipher = new aes.AES(key);
            this._prev = new Buffer(iv.length);
            this._cache = new Buffer('');
            this._secCache = new Buffer('');
            this._decrypt = decrypt;
            this._alen = 0;
            this._len = 0;
            iv.copy(this._prev);
            this._mode = mode;
            var h = new Buffer(4);
            h.fill(0);
            this._ghash = new GHASH(this._cipher.encryptBlock(h));
            this._authTag = null;
            this._called = false;
        }
        StreamCipher.prototype._update = function (chunk) {
            if (!this._called && this._alen) {
                var rump = 16 - (this._alen % 16);
                if (rump <16) {
                    rump = new Buffer(rump);
                    rump.fill(0);
                    this._ghash.update(rump);
                }
            }
            this._called = true;
            var out = this._mode.encrypt(this, chunk);
            if (this._decrypt) {
                this._ghash.update(chunk);
            } else {
                this._ghash.update(out);
            }
            this._len += chunk.length;
            return out;
        };
        StreamCipher.prototype._final = function () {
            if (this._decrypt && !this._authTag) {
                throw new Error('Unsupported state or unable to authenticate data');
            }
            var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
            if (this._decrypt) {
                if (xorTest(tag, this._authTag)) {
                    throw new Error('Unsupported state or unable to authenticate data');
                }
            } else {
                this._authTag = tag;
            }
            this._cipher.scrub();
        };
        StreamCipher.prototype.getAuthTag = function getAuthTag () {
            if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
                return this._authTag;
            } else {
                throw new Error('Attempting to get auth tag in unsupported state');
            }
        };
        StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
            if (this._decrypt) {
                this._authTag = tag;
            } else {
                throw new Error('Attempting to set auth tag in unsupported state');
            }
        };
        StreamCipher.prototype.setAAD = function setAAD (buf) {
            if (!this._called) {
                this._ghash.update(buf);
                this._alen += buf.length;
            } else {
                throw new Error('Attempting to set AAD in unsupported state');
            }
        };
        function xorTest(a, b) {
            var out = 0;
            if (a.length !== b.length) {
                out++;
            }
            var len = Math.min(a.length, b.length);
            var i = -1;
            while (++i < len) {
                out += (a[i] ^ b[i]);
            }
            return out;
        }



    }).call(this,require("buffer").Buffer)
},{"./aes":13,"./cipherBase":15,"./ghash":18,"./xor":29,"buffer":3,"inherits":149}],15:[function(require,module,exports){
    (function (Buffer){
        var Transform = require('stream').Transform;
        var inherits = require('inherits');

        module.exports = CipherBase;
        inherits(CipherBase, Transform);
        function CipherBase() {
            Transform.call(this);
        }
        CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
            if (typeof data === 'string') {
                data = new Buffer(data, inputEnc);
            }
            var outData = this._update(data);
            if (outputEnc) {
                outData = outData.toString(outputEnc);
            }
            return outData;
        };
        CipherBase.prototype._transform = function (data, _, next) {
            this.push(this._update(data));
            next();
        };
        CipherBase.prototype._flush = function (next) {
            try {
                this.push(this._final());
            } catch(e) {
                return next(e);
            }
            next();
        };
        CipherBase.prototype.final = function (outputEnc) {
            var outData = this._final() || new Buffer('');
            if (outputEnc) {
                outData = outData.toString(outputEnc);
            }
            return outData;
        };
    }).call(this,require("buffer").Buffer)
},{"buffer":3,"inherits":149,"stream":163}],16:[function(require,module,exports){
    (function (Buffer){
        var aes = require('./aes');
        var Transform = require('./cipherBase');
        var inherits = require('inherits');
        var modes = require('./modes');
        var StreamCipher = require('./streamCipher');
        var AuthCipher = require('./authCipher');
        var ebtk = require('./EVP_BytesToKey');

        inherits(Decipher, Transform);
        function Decipher(mode, key, iv) {
            if (!(this instanceof Decipher)) {
                return new Decipher(mode, key, iv);
            }
            Transform.call(this);
            this._cache = new Splitter();
            this._last = void 0;
            this._cipher = new aes.AES(key);
            this._prev = new Buffer(iv.length);
            iv.copy(this._prev);
            this._mode = mode;
            this._autopadding = true;
        }
        Decipher.prototype._update = function (data) {
            this._cache.add(data);
            var chunk;
            var thing;
            var out = [];
            while ((chunk = this._cache.get(this._autopadding))) {
                thing = this._mode.decrypt(this, chunk);
                out.push(thing);
            }
            return Buffer.concat(out);
        };
        Decipher.prototype._final = function () {
            var chunk = this._cache.flush();
            if (this._autopadding) {
                return unpad(this._mode.decrypt(this, chunk));
            } else if (chunk) {
                throw new Error('data not multiple of block length');
            }
        };
        Decipher.prototype.setAutoPadding = function (setTo) {
            this._autopadding = !!setTo;
        };
        function Splitter() {
            if (!(this instanceof Splitter)) {
                return new Splitter();
            }
            this.cache = new Buffer('');
        }
        Splitter.prototype.add = function (data) {
            this.cache = Buffer.concat([this.cache, data]);
        };

        Splitter.prototype.get = function (autoPadding) {
            var out;
            if (autoPadding) {
                if (this.cache.length > 16) {
                    out = this.cache.slice(0, 16);
                    this.cache = this.cache.slice(16);
                    return out;
                }
            } else {
                if (this.cache.length >= 16) {
                    out = this.cache.slice(0, 16);
                    this.cache = this.cache.slice(16);
                    return out;
                }
            }
            return null;
        };
        Splitter.prototype.flush = function () {
            if (this.cache.length) {
                return this.cache;
            }
        };
        function unpad(last) {
            var padded = last[15];
            var i = -1;
            while (++i < padded) {
                if (last[(i + (16 - padded))] !== padded) {
                    throw new Error('unable to decrypt data');
                }
            }
            if (padded === 16) {
                return;
            }
            return last.slice(0, 16 - padded);
        }

        var modelist = {
            ECB: require('./modes/ecb'),
            CBC: require('./modes/cbc'),
            CFB: require('./modes/cfb'),
            CFB8: require('./modes/cfb8'),
            CFB1: require('./modes/cfb1'),
            OFB: require('./modes/ofb'),
            CTR: require('./modes/ctr'),
            GCM: require('./modes/ctr')
        };

        module.exports = function (crypto) {
            function createDecipheriv(suite, password, iv) {
                var config = modes[suite.toLowerCase()];
                if (!config) {
                    throw new TypeError('invalid suite type');
                }
                if (typeof iv === 'string') {
                    iv = new Buffer(iv);
                }
                if (typeof password === 'string') {
                    password = new Buffer(password);
                }
                if (password.length !== config.key/8) {
                    throw new TypeError('invalid key length ' + password.length);
                }
                if (iv.length !== config.iv) {
                    throw new TypeError('invalid iv length ' + iv.length);
                }
                if (config.type === 'stream') {
                    return new StreamCipher(modelist[config.mode], password, iv, true);
                } else if (config.type === 'auth') {
                    return new AuthCipher(modelist[config.mode], password, iv, true);
                }
                return new Decipher(modelist[config.mode], password, iv);
            }

            function createDecipher (suite, password) {
                var config = modes[suite.toLowerCase()];
                if (!config) {
                    throw new TypeError('invalid suite type');
                }
                var keys = ebtk(crypto, password, config.key, config.iv);
                return createDecipheriv(suite, keys.key, keys.iv);
            }
            return {
                createDecipher: createDecipher,
                createDecipheriv: createDecipheriv
            };
        };

    }).call(this,require("buffer").Buffer)
},{"./EVP_BytesToKey":12,"./aes":13,"./authCipher":14,"./cipherBase":15,"./modes":20,"./modes/cbc":21,"./modes/cfb":22,"./modes/cfb1":23,"./modes/cfb8":24,"./modes/ctr":25,"./modes/ecb":26,"./modes/ofb":27,"./streamCipher":28,"buffer":3,"inherits":149}],17:[function(require,module,exports){
    (function (Buffer){
        var aes = require('./aes');
        var Transform = require('./cipherBase');
        var inherits = require('inherits');
        var modes = require('./modes');
        var ebtk = require('./EVP_BytesToKey');
        var StreamCipher = require('./streamCipher');
        var AuthCipher = require('./authCipher');
        inherits(Cipher, Transform);
        function Cipher(mode, key, iv) {
            if (!(this instanceof Cipher)) {
                return new Cipher(mode, key, iv);
            }
            Transform.call(this);
            this._cache = new Splitter();
            this._cipher = new aes.AES(key);
            this._prev = new Buffer(iv.length);
            iv.copy(this._prev);
            this._mode = mode;
            this._autopadding = true;
        }
        Cipher.prototype._update = function (data) {
            this._cache.add(data);
            var chunk;
            var thing;
            var out = [];
            while ((chunk = this._cache.get())) {
                thing = this._mode.encrypt(this, chunk);
                out.push(thing);
            }
            return Buffer.concat(out);
        };
        Cipher.prototype._final = function () {
            var chunk = this._cache.flush();
            if (this._autopadding) {
                chunk = this._mode.encrypt(this, chunk);
                this._cipher.scrub();
                return chunk;
            } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
                this._cipher.scrub();
                throw new Error('data not multiple of block length');
            }
        };
        Cipher.prototype.setAutoPadding = function (setTo) {
            this._autopadding = !!setTo;
        };

        function Splitter() {
            if (!(this instanceof Splitter)) {
                return new Splitter();
            }
            this.cache = new Buffer('');
        }
        Splitter.prototype.add = function (data) {
            this.cache = Buffer.concat([this.cache, data]);
        };

        Splitter.prototype.get = function () {
            if (this.cache.length > 15) {
                var out = this.cache.slice(0, 16);
                this.cache = this.cache.slice(16);
                return out;
            }
            return null;
        };
        Splitter.prototype.flush = function () {
            var len = 16 - this.cache.length;
            var padBuff = new Buffer(len);

            var i = -1;
            while (++i < len) {
                padBuff.writeUInt8(len, i);
            }
            var out = Buffer.concat([this.cache, padBuff]);
            return out;
        };
        var modelist = {
            ECB: require('./modes/ecb'),
            CBC: require('./modes/cbc'),
            CFB: require('./modes/cfb'),
            CFB8: require('./modes/cfb8'),
            CFB1: require('./modes/cfb1'),
            OFB: require('./modes/ofb'),
            CTR: require('./modes/ctr'),
            GCM: require('./modes/ctr')
        };
        module.exports = function (crypto) {
            function createCipheriv(suite, password, iv) {
                var config = modes[suite.toLowerCase()];
                if (!config) {
                    throw new TypeError('invalid suite type');
                }
                if (typeof iv === 'string') {
                    iv = new Buffer(iv);
                }
                if (typeof password === 'string') {
                    password = new Buffer(password);
                }
                if (password.length !== config.key/8) {
                    throw new TypeError('invalid key length ' + password.length);
                }
                if (iv.length !== config.iv) {
                    throw new TypeError('invalid iv length ' + iv.length);
                }
                if (config.type === 'stream') {
                    return new StreamCipher(modelist[config.mode], password, iv);
                } else if (config.type === 'auth') {
                    return new AuthCipher(modelist[config.mode], password, iv);
                }
                return new Cipher(modelist[config.mode], password, iv);
            }
            function createCipher (suite, password) {
                var config = modes[suite.toLowerCase()];
                if (!config) {
                    throw new TypeError('invalid suite type');
                }
                var keys = ebtk(crypto, password, config.key, config.iv);
                return createCipheriv(suite, keys.key, keys.iv);
            }
            return {
                createCipher: createCipher,
                createCipheriv: createCipheriv
            };
        };

    }).call(this,require("buffer").Buffer)
},{"./EVP_BytesToKey":12,"./aes":13,"./authCipher":14,"./cipherBase":15,"./modes":20,"./modes/cbc":21,"./modes/cfb":22,"./modes/cfb1":23,"./modes/cfb8":24,"./modes/ctr":25,"./modes/ecb":26,"./modes/ofb":27,"./streamCipher":28,"buffer":3,"inherits":149}],18:[function(require,module,exports){
    (function (Buffer){
        var zeros = new Buffer(16);
        zeros.fill(0);
        module.exports = GHASH;
        function GHASH(key){
            this.h = key;
            this.state = new Buffer(16);
            this.state.fill(0);
            this.cache = new Buffer('');
        }
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
        GHASH.prototype.ghash = function (block) {
            var i = -1;
            while (++i < block.length) {
                this.state[i] ^= block[i];
            }
            this._multiply();
        };

        GHASH.prototype._multiply = function () {
            var Vi = toArray(this.h);
            var Zi = [0, 0, 0, 0];
            var j, xi, lsb_Vi;
            var i = -1;
            while (++i < 128) {
                xi = (this.state[~~(i/8)] & (1 << (7-i%8))) !== 0;
                if (xi) {
                    // Z_i+1 = Z_i ^ V_i
                    Zi = xor(Zi, Vi);
                }

                // Store the value of LSB(V_i)
                lsb_Vi = (Vi[3] & 1) !== 0;

                // V_i+1 = V_i >> 1
                for (j=3; j>0; j--) {
                    Vi[j] = (Vi[j] >>> 1) | ((Vi[j-1]&1) << 31);
                }
                Vi[0] = Vi[0] >>> 1;

                // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
                if (lsb_Vi) {
                    Vi[0] = Vi[0] ^ (0xe1 << 24);
                }
            }
            this.state = fromArray(Zi);
        };
        GHASH.prototype.update = function (buf) {
            this.cache = Buffer.concat([this.cache, buf]);
            var chunk;
            while (this.cache.length >= 16) {
                chunk = this.cache.slice(0, 16);
                this.cache = this.cache.slice(16);
                this.ghash(chunk);
            }
        };
        GHASH.prototype.final = function (abl, bl) {
            if (this.cache.length) {
                this.ghash(Buffer.concat([this.cache, zeros], 16));
            }
            this.ghash(fromArray([
                0, abl,
                0, bl
            ]));
            return this.state;
        };

        function toArray(buf) {
            return [
                buf.readUInt32BE(0),
                buf.readUInt32BE(4),
                buf.readUInt32BE(8),
                buf.readUInt32BE(12)
            ];
        }
        function fromArray(out) {
            out = out.map(fixup_uint32);
            var buf = new Buffer(16);
            buf.writeUInt32BE(out[0], 0);
            buf.writeUInt32BE(out[1], 4);
            buf.writeUInt32BE(out[2], 8);
            buf.writeUInt32BE(out[3], 12);
            return buf;
        }
        var uint_max = Math.pow(2, 32);
        function fixup_uint32(x) {
            var ret, x_pos;
            ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
            return ret;
        }
        function xor(a, b) {
            return [
                a[0] ^ b[0],
                a[1] ^ b[1],
                a[2] ^ b[2],
                a[3] ^ b[3],
            ];
        }
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],19:[function(require,module,exports){
    module.exports = function (crypto, exports) {
        exports = exports || {};
        var ciphers = require('./encrypter')(crypto);
        exports.createCipher = exports.Cipher = ciphers.createCipher;
        exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
        var deciphers = require('./decrypter')(crypto);
        exports.createDecipher = exports.Decipher = deciphers.createDecipher;
        exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
        var modes = require('./modes');
        function getCiphers () {
            return Object.keys(modes);
        }
        exports.listCiphers = exports.getCiphers = getCiphers;
    };

},{"./decrypter":16,"./encrypter":17,"./modes":20}],20:[function(require,module,exports){
    exports['aes-128-ecb'] = {
        cipher: 'AES',
        key: 128,
        iv: 0,
        mode: 'ECB',
        type: 'block'
    };
    exports['aes-192-ecb'] = {
        cipher: 'AES',
        key: 192,
        iv: 0,
        mode: 'ECB',
        type: 'block'
    };
    exports['aes-256-ecb'] = {
        cipher: 'AES',
        key: 256,
        iv: 0,
        mode: 'ECB',
        type: 'block'
    };
    exports['aes-128-cbc'] = {
        cipher: 'AES',
        key: 128,
        iv: 16,
        mode: 'CBC',
        type: 'block'
    };
    exports['aes-192-cbc'] = {
        cipher: 'AES',
        key: 192,
        iv: 16,
        mode: 'CBC',
        type: 'block'
    };
    exports['aes-256-cbc'] = {
        cipher: 'AES',
        key: 256,
        iv: 16,
        mode: 'CBC',
        type: 'block'
    };
    exports['aes128'] = exports['aes-128-cbc'];
    exports['aes192'] = exports['aes-192-cbc'];
    exports['aes256'] = exports['aes-256-cbc'];
    exports['aes-128-cfb'] = {
        cipher: 'AES',
        key: 128,
        iv: 16,
        mode: 'CFB',
        type: 'stream'
    };
    exports['aes-192-cfb'] = {
        cipher: 'AES',
        key: 192,
        iv: 16,
        mode: 'CFB',
        type: 'stream'
    };
    exports['aes-256-cfb'] = {
        cipher: 'AES',
        key: 256,
        iv: 16,
        mode: 'CFB',
        type: 'stream'
    };
    exports['aes-128-cfb8'] = {
        cipher: 'AES',
        key: 128,
        iv: 16,
        mode: 'CFB8',
        type: 'stream'
    };
    exports['aes-192-cfb8'] = {
        cipher: 'AES',
        key: 192,
        iv: 16,
        mode: 'CFB8',
        type: 'stream'
    };
    exports['aes-256-cfb8'] = {
        cipher: 'AES',
        key: 256,
        iv: 16,
        mode: 'CFB8',
        type: 'stream'
    };
    exports['aes-128-cfb1'] = {
        cipher: 'AES',
        key: 128,
        iv: 16,
        mode: 'CFB1',
        type: 'stream'
    };
    exports['aes-192-cfb1'] = {
        cipher: 'AES',
        key: 192,
        iv: 16,
        mode: 'CFB1',
        type: 'stream'
    };
    exports['aes-256-cfb1'] = {
        cipher: 'AES',
        key: 256,
        iv: 16,
        mode: 'CFB1',
        type: 'stream'
    };
    exports['aes-128-ofb'] = {
        cipher: 'AES',
        key: 128,
        iv: 16,
        mode: 'OFB',
        type: 'stream'
    };
    exports['aes-192-ofb'] = {
        cipher: 'AES',
        key: 192,
        iv: 16,
        mode: 'OFB',
        type: 'stream'
    };
    exports['aes-256-ofb'] = {
        cipher: 'AES',
        key: 256,
        iv: 16,
        mode: 'OFB',
        type: 'stream'
    };
    exports['aes-128-ctr'] = {
        cipher: 'AES',
        key: 128,
        iv: 16,
        mode: 'CTR',
        type: 'stream'
    };
    exports['aes-192-ctr'] = {
        cipher: 'AES',
        key: 192,
        iv: 16,
        mode: 'CTR',
        type: 'stream'
    };
    exports['aes-256-ctr'] = {
        cipher: 'AES',
        key: 256,
        iv: 16,
        mode: 'CTR',
        type: 'stream'
    };
    exports['aes-128-gcm'] = {
        cipher: 'AES',
        key: 128,
        iv: 12,
        mode: 'GCM',
        type: 'auth'
    };
    exports['aes-192-gcm'] = {
        cipher: 'AES',
        key: 192,
        iv: 12,
        mode: 'GCM',
        type: 'auth'
    };
    exports['aes-256-gcm'] = {
        cipher: 'AES',
        key: 256,
        iv: 12,
        mode: 'GCM',
        type: 'auth'
    };
},{}],21:[function(require,module,exports){
    var xor = require('../xor');
    exports.encrypt = function (self, block) {
        var data = xor(block, self._prev);
        self._prev = self._cipher.encryptBlock(data);
        return self._prev;
    };
    exports.decrypt = function (self, block) {
        var pad = self._prev;
        self._prev = block;
        var out = self._cipher.decryptBlock(block);
        return xor(out, pad);
    };
},{"../xor":29}],22:[function(require,module,exports){
    (function (Buffer){
        var xor = require('../xor');
        exports.encrypt = function (self, data, decrypt) {
            var out = new Buffer('');
            var len;
            while (data.length) {
                if (self._cache.length === 0) {
                    self._cache = self._cipher.encryptBlock(self._prev);
                    self._prev = new Buffer('');
                }
                if (self._cache.length <= data.length) {
                    len = self._cache.length;
                    out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
                    data = data.slice(len);
                } else {
                    out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
                    break;
                }
            }
            return out;
        };
        function encryptStart(self, data, decrypt) {
            var len = data.length;
            var out = xor(data, self._cache);
            self._cache = self._cache.slice(len);
            self._prev = Buffer.concat([self._prev, decrypt?data:out]);
            return out;
        }
    }).call(this,require("buffer").Buffer)
},{"../xor":29,"buffer":3}],23:[function(require,module,exports){
    (function (Buffer){

        function encryptByte(self, byte, decrypt) {
            var pad;
            var i = -1;
            var len = 8;
            var out = 0;
            var bit, value;
            while (++i < len) {
                pad = self._cipher.encryptBlock(self._prev);
                bit = (byte & (1 << (7-i))) ? 0x80:0;
                value = pad[0] ^ bit;
                out += ((value&0x80) >> (i%8));
                self._prev = shiftIn(self._prev, decrypt?bit:value);
            }
            return out;
        }
        exports.encrypt = function (self, chunk, decrypt) {
            var len = chunk.length;
            var out = new Buffer(len);
            var i = -1;
            while (++i < len) {
                out[i] = encryptByte(self, chunk[i], decrypt);
            }
            return out;
        };
        function shiftIn(buffer, value) {
            var len = buffer.length;
            var i = -1;
            var out = new Buffer(buffer.length);
            buffer = Buffer.concat([buffer, new Buffer([value])]);
            while(++i < len) {
                out[i] = buffer[i]<<1 | buffer[i+1]>>(7);
            }
            return out;
        }
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],24:[function(require,module,exports){
    (function (Buffer){
        function encryptByte(self, byte, decrypt) {
            var pad = self._cipher.encryptBlock(self._prev);
            var out = pad[0] ^ byte;
            self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt?byte:out])]);
            return out;
        }
        exports.encrypt = function (self, chunk, decrypt) {
            var len = chunk.length;
            var out = new Buffer(len);
            var i = -1;
            while (++i < len) {
                out[i] = encryptByte(self, chunk[i], decrypt);
            }
            return out;
        };
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],25:[function(require,module,exports){
    (function (Buffer){
        var xor = require('../xor');
        function getBlock(self) {
            var out = self._cipher.encryptBlock(self._prev);
            incr32(self._prev);
            return out;
        }
        exports.encrypt = function (self, chunk) {
            while (self._cache.length < chunk.length) {
                self._cache = Buffer.concat([self._cache, getBlock(self)]);
            }
            var pad = self._cache.slice(0, chunk.length);
            self._cache = self._cache.slice(chunk.length);
            return xor(chunk, pad);
        };
        function incr32(iv) {
            var len = iv.length;
            var item;
            while (len--) {
                item = iv.readUInt8(len);
                if (item === 255) {
                    iv.writeUInt8(0, len);
                } else {
                    item++;
                    iv.writeUInt8(item, len);
                    break;
                }
            }
        }
    }).call(this,require("buffer").Buffer)
},{"../xor":29,"buffer":3}],26:[function(require,module,exports){
    exports.encrypt = function (self, block) {
        return self._cipher.encryptBlock(block);
    };
    exports.decrypt = function (self, block) {
        return self._cipher.decryptBlock(block);
    };
},{}],27:[function(require,module,exports){
    (function (Buffer){
        var xor = require('../xor');
        function getBlock(self) {
            self._prev = self._cipher.encryptBlock(self._prev);
            return self._prev;
        }
        exports.encrypt = function (self, chunk) {
            while (self._cache.length < chunk.length) {
                self._cache = Buffer.concat([self._cache, getBlock(self)]);
            }
            var pad = self._cache.slice(0, chunk.length);
            self._cache = self._cache.slice(chunk.length);
            return xor(chunk, pad);
        };
    }).call(this,require("buffer").Buffer)
},{"../xor":29,"buffer":3}],28:[function(require,module,exports){
    (function (Buffer){
        var aes = require('./aes');
        var Transform = require('./cipherBase');
        var inherits = require('inherits');

        inherits(StreamCipher, Transform);
        module.exports = StreamCipher;
        function StreamCipher(mode, key, iv, decrypt) {
            if (!(this instanceof StreamCipher)) {
                return new StreamCipher(mode, key, iv);
            }
            Transform.call(this);
            this._cipher = new aes.AES(key);
            this._prev = new Buffer(iv.length);
            this._cache = new Buffer('');
            this._secCache = new Buffer('');
            this._decrypt = decrypt;
            iv.copy(this._prev);
            this._mode = mode;
        }
        StreamCipher.prototype._update = function (chunk) {
            return this._mode.encrypt(this, chunk, this._decrypt);
        };
        StreamCipher.prototype._final = function () {
            this._cipher.scrub();
        };
    }).call(this,require("buffer").Buffer)
},{"./aes":13,"./cipherBase":15,"buffer":3,"inherits":149}],29:[function(require,module,exports){
    (function (Buffer){
        module.exports = xor;
        function xor(a, b) {
            var len = Math.min(a.length, b.length);
            var out = new Buffer(len);
            var i = -1;
            while (++i < len) {
                out.writeUInt8(a[i] ^ b[i], i);
            }
            return out;
        }
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],30:[function(require,module,exports){
    (function (Buffer){
        exports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {
            sign: 'rsa',
            hash: 'sha224',
            id: new Buffer('302d300d06096086480165030402040500041c', 'hex')
        };
        exports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {
            sign: 'rsa',
            hash: 'sha256',
            id: new Buffer('3031300d060960864801650304020105000420', 'hex')
        };
        exports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {
            sign: 'rsa',
            hash: 'sha384',
            id: new Buffer('3041300d060960864801650304020205000430', 'hex')
        };
        exports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {
            sign: 'rsa',
            hash: 'sha512',
            id: new Buffer('3051300d060960864801650304020305000440', 'hex')
        };
        exports['RSA-SHA1'] = {
            sign: 'rsa',
            hash: 'sha1',
            id: new Buffer('3021300906052b0e03021a05000414', 'hex')
        };
        exports['ecdsa-with-SHA1'] = {
            sign: 'ecdsa',
            hash: 'sha1',
            id: new Buffer('', 'hex')
        };
        exports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {
            sign: 'dsa',
            hash: 'sha1',
            id: new Buffer('', 'hex')
        };
        exports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {
            sign: 'rsa',
            hash: 'rmd160',
            id: new Buffer('3021300906052b2403020105000414', 'hex')
        };
        exports['RSA-MD5'] = exports.md5WithRSAEncryption = {
            sign: 'rsa',
            hash: 'md5',
            id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')
        };
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],31:[function(require,module,exports){
    (function (Buffer){
        var sign = require('./sign');
        var verify = require('./verify');
        var stream = require('stream');
        var inherits = require('inherits');
        var algos = require('./algos');
        
        module.exports = function (exports, crypto) {
            exports.createSign = exports.Sign = createSign;
            function createSign(algorithm) {

                return new Sign(algorithm, crypto);
            }
            exports.createVerify = exports.Verify = createVerify;
            function createVerify(algorithm) {
                return new Verify(algorithm, crypto);
            }
        };
        inherits(Sign, stream.Writable);
        function Sign(algorithm, crypto) {
            stream.Writable.call(this);
            var data = algos[algorithm];
            if (!data) {
                throw new Error('Unknown message digest');
            }
            this._hash = crypto.createHash(data.hash);
            this._tag = data.id;
            this._crypto = crypto;
        }
        Sign.prototype._write = function _write(data, _, done) {
            this._hash.update(data);
            done();
        };
        Sign.prototype.update = function update(data) {
            this.write(data);
            return this;
        };

        Sign.prototype.sign = function signMethod(key, enc) {
            this.end();
            var hash = this._hash.digest();
            var sig = sign(Buffer.concat([this._tag, hash]), key, this._crypto);
            if (enc) {
                sig = sig.toString(enc);
            }
            return sig;
        };

        inherits(Verify, stream.Writable);
        function Verify(algorithm, crypto) {
            stream.Writable.call(this);
            var data = algos[algorithm];
            if (!data) {
                throw new Error('Unknown message digest');
            }
            this._hash = crypto.createHash(data.hash);
            this._tag = data.id;
        }
        Verify.prototype._write = function _write(data, _, done) {
            this._hash.update(data);
            done();
        };
        Verify.prototype.update = function update(data) {
            this.write(data);
            return this;
        };

        Verify.prototype.verify = function verifyMethod(key, sig, enc) {
            this.end();
            var hash = this._hash.digest();
            if (!Buffer.isBuffer(sig)) {
                sig = new Buffer(sig, enc);
            }
            return verify(sig, Buffer.concat([this._tag, hash]), key);
        };
    }).call(this,require("buffer").Buffer)
},{"./algos":30,"./sign":75,"./verify":76,"buffer":3,"inherits":149,"stream":163}],32:[function(require,module,exports){
// Utils

    function assert(val, msg) {
        if (!val)
            throw new Error(msg || 'Assertion failed');
    }

    function assertEqual(l, r, msg) {
        if (l != r)
            throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
    }

// Could use `inherits` module, but don't want to move from single file
// architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor
        var TempCtor = function () {}
        TempCtor.prototype = superCtor.prototype
        ctor.prototype = new TempCtor()
        ctor.prototype.constructor = ctor
    }

// BN

    function BN(number, base, endian) {
        // May be `new BN(bn)` ?
        if (number !== null &&
            typeof number === 'object' &&
            Array.isArray(number.words)) {
            return number;
        }

        this.sign = false;
        this.words = null;
        this.length = 0;

        // Reduction context
        this.red = null;

        if (base === 'le' || base === 'be') {
            endian = base;
            base = 10;
        }

        if (number !== null)
            this._init(number || 0, base || 10, endian || 'be');
    }
    if (typeof module === 'object')
        module.exports = BN;

    BN.BN = BN;
    BN.wordSize = 26;

    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === 'number') {
            if (number < 0) {
                this.sign = true;
                number = -number;
            }
            if (number < 0x4000000) {
                this.words = [ number & 0x3ffffff ];
                this.length = 1;
            } else {
                this.words = [
                    number & 0x3ffffff,
                    (number / 0x4000000) & 0x3ffffff
                ];
                this.length = 2;
            }
            return;
        } else if (typeof number === 'object') {
            return this._initArray(number, base, endian);
        }
        if (base === 'hex')
            base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);

        number = number.toString().replace(/\s+/g, '');
        var start = 0;
        if (number[0] === '-')
            start++;

        if (base === 16)
            this._parseHex(number, start);
        else
            this._parseBase(number, base, start);

        if (number[0] === '-')
            this.sign = true;

        this.strip();
    };

    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === 'number');
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++)
            this.words[i] = 0;

        var off = 0;
        if (endian === 'be') {
            for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
                var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
                this.words[j] |= (w << off) & 0x3ffffff;
                this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
                off += 24;
                if (off >= 26) {
                    off -= 26;
                    j++;
                }
            }
        } else if (endian === 'le') {
            for (var i = 0, j = 0; i < number.length; i += 3) {
                var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
                this.words[j] |= (w << off) & 0x3ffffff;
                this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
                off += 24;
                if (off >= 26) {
                    off -= 26;
                    j++;
                }
            }
        }
        return this.strip();
    };

    BN.prototype._parseHex = function parseHex(number, start) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++)
            this.words[i] = 0;

        // Scan 24-bit chunks and add them to the number
        var off = 0;
        for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
            var w = parseInt(number.slice(i, i + 6), 16);
            this.words[j] |= (w << off) & 0x3ffffff;
            this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        if (i + 6 !== start) {
            var w = parseInt(number.slice(start, i + 6), 16);
            this.words[j] |= (w << off) & 0x3ffffff;
            this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
        }
        this.strip();
    };

    BN.prototype._parseBase = function parseBase(number, base, start) {
        // Initialize as zero
        this.words = [ 0 ];
        this.length = 1;

        var word = 0;
        var q = 1;
        var p = 0;
        var bigQ = null;
        for (var i = start; i < number.length; i++) {
            var digit;
            var ch = number[i];
            if (base === 10 || ch <= '9')
                digit = ch | 0;
            else if (ch >= 'a')
                digit = ch.charCodeAt(0) - 97 + 10;
            else
                digit = ch.charCodeAt(0) - 65 + 10;
            word *= base;
            word += digit;
            q *= base;
            p++;

            if (q > 0xfffff) {
                assert(q <= 0x3ffffff);
                if (!bigQ)
                    bigQ = new BN(q);
                this.mul(bigQ).copy(this);
                this.iadd(new BN(word));
                word = 0;
                q = 1;
                p = 0;
            }
        }
        if (p !== 0) {
            this.mul(new BN(q)).copy(this);
            this.iadd(new BN(word));
        }
    };

    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++)
            dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.sign = this.sign;
        dest.red = this.red;
    };

    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };

// Remove leading `0` from `this`
    BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
            this.length--;
        return this._normSign();
    };

    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0)
            this.sign = false;
        return this;
    };

    BN.prototype.inspect = function inspect() {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    };

    /*

     var zeros = [];
     var groupSizes = [];
     var groupBases = [];

     var s = '';
     var i = -1;
     while (++i < BN.wordSize) {
     zeros[i] = s;
     s += '0';
     }
     groupSizes[0] = 0;
     groupSizes[1] = 0;
     groupBases[0] = 0;
     groupBases[1] = 0;
     var base = 2 - 1;
     while (++base < 36 + 1) {
     var groupSize = 0;
     var groupBase = 1;
     // TODO: <=
     while (groupBase < (1 << BN.wordSize) / base) {
     groupBase *= base;
     groupSize += 1;
     }
     groupSizes[base] = groupSize;
     groupBases[base] = groupBase;
     }

     */

    var zeros = [
        '',
        '0',
        '00',
        '000',
        '0000',
        '00000',
        '000000',
        '0000000',
        '00000000',
        '000000000',
        '0000000000',
        '00000000000',
        '000000000000',
        '0000000000000',
        '00000000000000',
        '000000000000000',
        '0000000000000000',
        '00000000000000000',
        '000000000000000000',
        '0000000000000000000',
        '00000000000000000000',
        '000000000000000000000',
        '0000000000000000000000',
        '00000000000000000000000',
        '000000000000000000000000',
        '0000000000000000000000000'
    ];

    var groupSizes = [
        0, 0,
        25, 16, 12, 11, 10, 9, 8,
        8, 7, 7, 7, 7, 6, 6,
        6, 6, 6, 6, 6, 5, 5,
        5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5
    ];

    var groupBases = [
        0, 0,
        33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
        43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
        16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
        6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
        24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
    ];

    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        if (base === 16 || base === 'hex') {
            var out = '';
            var off = 0;
            var padding = padding | 0 || 1;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
                var w = this.words[i];
                var word = (((w << off) | carry) & 0xffffff).toString(16);
                carry = (w >>> (24 - off)) & 0xffffff;
                if (carry !== 0 || i !== this.length - 1)
                    out = zeros[6 - word.length] + word + out;
                else
                    out = word + out;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
            }
            if (carry !== 0)
                out = carry.toString(16) + out;
            while (out.length % padding !== 0)
                out = '0' + out;
            if (this.sign)
                out = '-' + out;
            return out;
        } else if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            var out = '';
            var c = this.clone();
            c.sign = false;
            while (c.cmpn(0) !== 0) {
                var r = c.modn(groupBase).toString(base);
                c = c.idivn(groupBase);

                if (c.cmpn(0) !== 0)
                    out = zeros[groupSize - r.length] + r + out;
                else
                    out = r + out;
            }
            if (this.cmpn(0) === 0)
                out = '0' + out;
            if (this.sign)
                out = '-' + out;
            return out;
        } else {
            assert(false, 'Base should be between 2 and 36');
        }
    };

    BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
    };

    BN.prototype.toArray = function toArray() {
        this.strip();
        var res = new Array(this.byteLength());
        res[0] = 0;

        var q = this.clone();
        for (var i = 0; q.cmpn(0) !== 0; i++) {
            var b = q.andln(0xff);
            q.ishrn(8);

            // Assume big-endian
            res[res.length - i - 1] = b;
        }

        return res;
    };

    /*
     function genCountBits(bits) {
     var arr = [];

     for (var i = bits - 1; i >= 0; i--) {
     var bit = '0x' + (1 << i).toString(16);
     arr.push('w >= ' + bit + ' ? ' + (i + 1));
     }

     return new Function('w', 'return ' + arr.join(' :\n') + ' :\n0;');
     };

     BN.prototype._countBits = genCountBits(26);
     */

// Sadly chrome apps could not contain `new Function()` calls
    BN.prototype._countBits = function _countBits(w) {
        return w >= 0x2000000 ? 26 :
            w >= 0x1000000 ? 25 :
                w >= 0x800000 ? 24 :
                    w >= 0x400000 ? 23 :
                        w >= 0x200000 ? 22 :
                            w >= 0x100000 ? 21 :
                                w >= 0x80000 ? 20 :
                                    w >= 0x40000 ? 19 :
                                        w >= 0x20000 ? 18 :
                                            w >= 0x10000 ? 17 :
                                                w >= 0x8000 ? 16 :
                                                    w >= 0x4000 ? 15 :
                                                        w >= 0x2000 ? 14 :
                                                            w >= 0x1000 ? 13 :
                                                                w >= 0x800 ? 12 :
                                                                    w >= 0x400 ? 11 :
                                                                        w >= 0x200 ? 10 :
                                                                            w >= 0x100 ? 9 :
                                                                                w >= 0x80 ? 8 :
                                                                                    w >= 0x40 ? 7 :
                                                                                        w >= 0x20 ? 6 :
                                                                                            w >= 0x10 ? 5 :
                                                                                                w >= 0x8 ? 4 :
                                                                                                    w >= 0x4 ? 3 :
                                                                                                        w >= 0x2 ? 2 :
                                                                                                            w >= 0x1 ? 1 :
                                                                                                                0;
    };

// Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var hi = 0;
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };

    BN.prototype.byteLength = function byteLength() {
        var hi = 0;
        var w = this.words[this.length - 1];
        return Math.ceil(this.bitLength() / 8);
    };

// Return negative clone of `this`
    BN.prototype.neg = function neg() {
        if (this.cmpn(0) === 0)
            return this.clone();

        var r = this.clone();
        r.sign = !this.sign;
        return r;
    };

// Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        // negative + positive
        if (this.sign && !num.sign) {
            this.sign = false;
            var r = this.isub(num);
            this.sign = !this.sign;
            return this._normSign();

            // positive + negative
        } else if (!this.sign && num.sign) {
            num.sign = false;
            var r = this.isub(num);
            num.sign = true;
            return r._normSign();
        }

        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }

        var carry = 0;
        for (var i = 0; i < b.length; i++) {
            var r = a.words[i] + b.words[i] + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
            var r = a.words[i] + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }

        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
            // Copy the rest of the words
        } else if (a !== this) {
            for (; i < a.length; i++)
                this.words[i] = a.words[i];
        }

        return this;
    };

// Add `num` to `this`
    BN.prototype.add = function add(num) {
        if (num.sign && !this.sign) {
            num.sign = false;
            var res = this.sub(num);
            num.sign = true;
            return res;
        } else if (!num.sign && this.sign) {
            this.sign = false;
            var res = num.sub(this);
            this.sign = true;
            return res;
        }

        if (this.length > num.length)
            return this.clone().iadd(num);
        else
            return num.clone().iadd(this);
    };

// Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.sign) {
            num.sign = false;
            var r = this.iadd(num);
            num.sign = true;
            return r._normSign();

            // -this - num = -(this + num)
        } else if (this.sign) {
            this.sign = false;
            this.iadd(num);
            this.sign = true;
            return this._normSign();
        }

        // At this point both numbers are positive
        var cmp = this.cmp(num);

        // Optimization - zeroify
        if (cmp === 0) {
            this.sign = false;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }

        // a > b
        if (cmp > 0) {
            var a = this;
            var b = num;
        } else {
            var a = num;
            var b = this;
        }

        var carry = 0;
        for (var i = 0; i < b.length; i++) {
            var r = a.words[i] - b.words[i] - carry;
            if (r < 0) {
                r += 0x4000000;
                carry = 1;
            } else {
                carry = 0;
            }
            this.words[i] = r;
        }
        for (; carry !== 0 && i < a.length; i++) {
            var r = a.words[i] - carry;
            if (r < 0) {
                r += 0x4000000;
                carry = 1;
            } else {
                carry = 0;
            }
            this.words[i] = r;
        }

        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this)
            for (; i < a.length; i++)
                this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);

        if (a !== this)
            this.sign = true;

        return this.strip();
    };

// Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };

    /*
     // NOTE: This could be potentionally used to generate loop-less multiplications
     function _genCombMulTo(alen, blen) {
     var len = alen + blen - 1;
     var src = [
     'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
     'mask = 0x3ffffff, shift = 0x4000000;',
     'out.length = ' + len + ';'
     ];
     for (var k = 0; k < len; k++) {
     var minJ = Math.max(0, k - alen + 1);
     var maxJ = Math.min(k, blen - 1);

     for (var j = minJ; j <= maxJ; j++) {
     var i = k - j;
     var mul = 'a[' + i + '] * b[' + j + ']';

     if (j === minJ) {
     src.push('w = ' + mul + ' + c;');
     src.push('c = (w / shift) | 0;');
     } else {
     src.push('w += ' + mul + ';');
     src.push('c += (w / shift) | 0;');
     }
     src.push('w &= mask;');
     }
     src.push('o[' + k + '] = w;');
     }
     src.push('if (c !== 0) {',
     '  o[' + k + '] = c;',
     '  out.length++;',
     '}',
     'return out;');

     return src.join('\n');
     }
     */

    BN.prototype._smallMulTo = function _smallMulTo(num, out) {
        out.sign = num.sign !== this.sign;
        out.length = this.length + num.length;

        var carry = 0;
        for (var k = 0; k < out.length - 1; k++) {
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                var i = k - j;
                var a = this.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;

                var lo = r & 0x3ffffff;
                ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
                lo = (lo + rword) | 0;
                rword = lo & 0x3ffffff;
                ncarry = (ncarry + (lo >>> 26)) | 0;
            }
            out.words[k] = rword;
            carry = ncarry;
        }
        if (carry !== 0) {
            out.words[k] = carry;
        } else {
            out.length--;
        }

        return out.strip();
    };

    BN.prototype._bigMulTo = function _bigMulTo(num, out) {
        out.sign = num.sign !== this.sign;
        out.length = this.length + num.length;

        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                var i = k - j;
                var a = this.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;

                var lo = r & 0x3ffffff;
                ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
                lo = (lo + rword) | 0;
                rword = lo & 0x3ffffff;
                ncarry = (ncarry + (lo >>> 26)) | 0;

                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) {
            out.words[k] = carry;
        } else {
            out.length--;
        }

        return out.strip();
    };

    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        if (this.length + num.length < 63)
            res = this._smallMulTo(num, out);
        else
            res = this._bigMulTo(num, out);
        return res;
    };

// Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };

// In-place Multiplication
    BN.prototype.imul = function imul(num) {
        if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
            this.words[0] = 0;
            this.length = 1;
            return this;
        }

        var tlen = this.length;
        var nlen = num.length;

        this.sign = num.sign !== this.sign;
        this.length = this.length + num.length;
        this.words[this.length - 1] = 0;

        var lastCarry = 0;
        for (var k = this.length - 2; k >= 0; k--) {
            // Sum all words with the same `i + j = k` and accumulate `carry`,
            // note that carry could be >= 0x3ffffff
            var carry = 0;
            var rword = 0;
            var maxJ = Math.min(k, nlen - 1);
            for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
                var i = k - j;
                var a = this.words[i];
                var b = num.words[j];
                var r = a * b;

                var lo = r & 0x3ffffff;
                carry += (r / 0x4000000) | 0;
                lo += rword;
                rword = lo & 0x3ffffff;
                carry += lo >>> 26;
            }
            this.words[k] = rword;
            this.words[k + 1] += carry;
            carry = 0;
        }

        // Propagate overflows
        var carry = 0;
        for (var i = 1; i < this.length; i++) {
            var w = this.words[i] + carry;
            this.words[i] = w & 0x3ffffff;
            carry = w >>> 26;
        }

        return this.strip();
    };

// `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };

// `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.mul(this);
    };

// Shift-left in-place
    BN.prototype.ishln = function ishln(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

        var o = this.clone();
        if (r !== 0) {
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] - newCarry) << r;
                this.words[i] = c | carry;
                carry = newCarry >>> (26 - r);
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }

        if (s !== 0) {
            for (var i = this.length - 1; i >= 0; i--)
                this.words[i + s] = this.words[i];
            for (var i = 0; i < s; i++)
                this.words[i] = 0;
            this.length += s;
        }

        return this.strip();
    };

// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is true - { lo: ..., hi: } object will be returned
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(typeof bits === 'number' && bits >= 0);
        if (hint)
            hint = (hint - (hint % 26)) / 26;
        else
            hint = 0;

        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
        var maskedWords = extended;

        hint -= s;
        hint = Math.max(0, hint);

        // Extended mode, copy masked part
        if (maskedWords) {
            for (var i = 0; i < s; i++)
                maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }

        if (s === 0) {
            // No-op, we should not move anything at all
        } else if (this.length > s) {
            this.length -= s;
            for (var i = 0; i < this.length; i++)
                this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }

        var carry = 0;
        for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= hint); i--) {
            var word = this.words[i];
            this.words[i] = (carry << (26 - r)) | (word >>> r);
            carry = word & mask;
        }

        // Push carried bits as a mask
        if (maskedWords && carry !== 0)
            maskedWords.words[maskedWords.length++] = carry;

        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }

        this.strip();
        if (extended)
            return { hi: this, lo: maskedWords };

        return this;
    };

// Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };

// Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };

// Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === 'number' && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;

        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            return false;
        }

        // Check bit and return
        var w = this.words[s];

        return !!(w & q);
    };

// Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;

        assert(!this.sign, 'imaskn works only with positive numbers');

        if (r !== 0)
            s++;
        this.length = Math.min(s, this.length);

        if (r !== 0) {
            var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
            this.words[this.length - 1] &= mask;
        }

        return this.strip();
    };

// Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };

// Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === 'number');
        if (num < 0)
            return this.isubn(-num);

        // Possible sign change
        if (this.sign) {
            if (this.length === 1 && this.words[0] < num) {
                this.words[0] = num - this.words[0];
                this.sign = false;
                return this;
            }

            this.sign = false;
            this.isubn(num);
            this.sign = true;
            return this;
        }
        this.words[0] += num;

        // Carry
        for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
            this.words[i] -= 0x4000000;
            if (i === this.length - 1)
                this.words[i + 1] = 1;
            else
                this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);

        return this;
    };

// Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === 'number');
        if (num < 0)
            return this.iaddn(-num);

        if (this.sign) {
            this.sign = false;
            this.iaddn(num);
            this.sign = true;
            return this;
        }

        this.words[0] -= num;

        // Carry
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }

        return this.strip();
    };

    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };

    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };

    BN.prototype.iabs = function iabs() {
        this.sign = false;

        return this
    };

    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };

    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;

        var a = this.clone();
        var b = num;

        var q = mode !== 'mod' && new BN(0);
        var sign = false;

        // Approximate quotient at each step
        while (a.length > b.length) {
            // NOTE: a.length is always >= 2, because of the condition .div()
            var hi = a.words[a.length - 1] * 0x4000000 + a.words[a.length - 2];
            var sq = (hi / b.words[b.length - 1]);
            var sqhi = (sq / 0x4000000) | 0;
            var sqlo = sq & 0x3ffffff;
            sq = new BN(null);
            sq.words = [ sqlo, sqhi ];
            sq.length = 2;

            // Collect quotient
            var shift = (a.length - b.length - 1) * 26;
            if (q) {
                var t = sq.shln(shift);
                if (a.sign)
                    q.isub(t);
                else
                    q.iadd(t);
            }

            sq = sq.mul(b).ishln(shift);
            if (a.sign)
                a.iadd(sq)
            else
                a.isub(sq);
        }
        // At this point a.length <= b.length
        while (a.ucmp(b) >= 0) {
            // NOTE: a.length is always >= 2, because of the condition above
            var hi = a.words[a.length - 1];
            var sq = new BN((hi / b.words[b.length - 1]) | 0);
            var shift = (a.length - b.length) * 26;

            if (q) {
                var t = sq.shln(shift);
                if (a.sign)
                    q.isub(t);
                else
                    q.iadd(t);
            }

            sq = sq.mul(b).ishln(shift);

            if (a.sign)
                a.iadd(sq);
            else
                a.isub(sq);
        }

        if (a.sign) {
            if (q)
                q.isubn(1);
            a.iadd(b);
        }
        return { div: q ? q : null, mod: a };
    };

    BN.prototype.divmod = function divmod(num, mode) {
        assert(num.cmpn(0) !== 0);

        if (this.sign && !num.sign) {
            var res = this.neg().divmod(num, mode);
            var div;
            var mod;
            if (mode !== 'mod')
                div = res.div.neg();
            if (mode !== 'div')
                mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
            return {
                div: div,
                mod: mod
            };
        } else if (!this.sign && num.sign) {
            var res = this.divmod(num.neg(), mode);
            var div;
            if (mode !== 'mod')
                div = res.div.neg();
            return { div: div, mod: res.mod };
        } else if (this.sign && num.sign) {
            return this.neg().divmod(num.neg(), mode);
        }

        // Both numbers are positive at this point

        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0)
            return { div: new BN(0), mod: this };

        // Very short reduction
        if (num.length === 1) {
            if (mode === 'div')
                return { div: this.divn(num.words[0]), mod: null };
            else if (mode === 'mod')
                return { div: null, mod: new BN(this.modn(num.words[0])) };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modn(num.words[0]))
            };
        }

        return this._wordDiv(num, mode);
    };

// Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, 'div').div;
    };

// Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, 'mod').mod;
    };

// Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);

        // Fast case - exact division
        if (dm.mod.cmpn(0) === 0)
            return dm.div;

        var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;

        var half = num.shrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);

        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;

        // Round up
        return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
    };

    BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = (1 << 26) % num;

        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--)
            acc = (p * acc + this.words[i]) % num;

        return acc;
    };

// In-place division by number
    BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);

        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
            var w = this.words[i] + carry * 0x4000000;
            this.words[i] = (w / num) | 0;
            carry = w % num;
        }

        return this.strip();
    };

    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };

    BN.prototype._egcd = function _egcd(x1, p) {
        assert(!p.sign);
        assert(p.cmpn(0) !== 0);

        var a = this;
        var b = p.clone();

        if (a.sign)
            a = a.mod(p);
        else
            a = a.clone();

        var x2 = new BN(0);
        while (b.isEven())
            b.ishrn(1);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            while (a.isEven()) {
                a.ishrn(1);
                if (x1.isEven())
                    x1.ishrn(1);
                else
                    x1.iadd(delta).ishrn(1);
            }
            while (b.isEven()) {
                b.ishrn(1);
                if (x2.isEven())
                    x2.ishrn(1);
                else
                    x2.iadd(delta).ishrn(1);
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        if (a.cmpn(1) === 0)
            return x1;
        else
            return x2;
    };

    BN.prototype.gcd = function gcd(num) {
        if (this.cmpn(0) === 0)
            return num.clone();
        if (num.cmpn(0) === 0)
            return this.clone();

        var a = this.clone();
        var b = num.clone();
        a.sign = false;
        b.sign = false;

        // Remove common factor of two
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.ishrn(1);
            b.ishrn(1);
        }

        while (a.isEven())
            a.ishrn(1);

        do {
            while (b.isEven())
                b.ishrn(1);

            // Swap `a` and `b` to make `a` always bigger than `b`
            if (a.cmp(b) < 0) {
                var t = a;
                a = b;
                b = t;
            }
            a.isub(a.div(b).mul(b));
        } while (a.cmpn(0) !== 0 && b.cmpn(0) !== 0);
        if (a.cmpn(0) === 0)
            return b.ishln(shift);
        else
            return a.ishln(shift);
    };

// Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this._egcd(new BN(1), num).mod(num);
    };

    BN.prototype.isEven = function isEven(num) {
        return (this.words[0] & 1) === 0;
    };

    BN.prototype.isOdd = function isOdd(num) {
        return (this.words[0] & 1) === 1;
    };

// And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };

// Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === 'number');
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;

        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            for (var i = this.length; i < s + 1; i++)
                this.words[i] = 0;
            this.words[s] |= q;
            this.length = s + 1;
            return this;
        }

        // Add bit and propagate, if needed
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i];
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };

    BN.prototype.cmpn = function cmpn(num) {
        var sign = num < 0;
        if (sign)
            num = -num;

        if (this.sign && !sign)
            return -1;
        else if (!this.sign && sign)
            return 1;

        num &= 0x3ffffff;
        this.strip();

        var res;
        if (this.length > 1) {
            res = 1;
        } else {
            var w = this.words[0];
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.sign)
            res = -res;
        return res;
    };

// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.sign && !num.sign)
            return -1;
        else if (!this.sign && num.sign)
            return 1;

        var res = this.ucmp(num);
        if (this.sign)
            return -res;
        else
            return res;
    };

// Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length)
            return 1;
        else if (this.length < num.length)
            return -1;

        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i];
            var b = num.words[i];

            if (a === b)
                continue;
            if (a < b)
                res = -1;
            else if (a > b)
                res = 1;
            break;
        }
        return res;
    };

//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
    BN.red = function red(num) {
        return new Red(num);
    };

    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        assert(!this.sign, 'red works only with positives');
        return ctx.convertTo(this)._forceRed(ctx);
    };

    BN.prototype.fromRed = function fromRed() {
        assert(this.red, 'fromRed works only with numbers in reduction context');
        return this.red.convertFrom(this);
    };

    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };

    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        return this._forceRed(ctx);
    };

    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, 'redAdd works only with red numbers');
        return this.red.add(this, num);
    };

    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, 'redIAdd works only with red numbers');
        return this.red.iadd(this, num);
    };

    BN.prototype.redSub = function redSub(num) {
        assert(this.red, 'redSub works only with red numbers');
        return this.red.sub(this, num);
    };

    BN.prototype.redISub = function redISub(num) {
        assert(this.red, 'redISub works only with red numbers');
        return this.red.isub(this, num);
    };

    BN.prototype.redShl = function redShl(num) {
        assert(this.red, 'redShl works only with red numbers');
        return this.red.shl(this, num);
    };

    BN.prototype.redMul = function redMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };

    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };

    BN.prototype.redSqr = function redSqr() {
        assert(this.red, 'redSqr works only with red numbers');
        this.red._verify1(this);
        return this.red.sqr(this);
    };

    BN.prototype.redISqr = function redISqr() {
        assert(this.red, 'redISqr works only with red numbers');
        this.red._verify1(this);
        return this.red.isqr(this);
    };

// Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, 'redSqrt works only with red numbers');
        this.red._verify1(this);
        return this.red.sqrt(this);
    };

    BN.prototype.redInvm = function redInvm() {
        assert(this.red, 'redInvm works only with red numbers');
        this.red._verify1(this);
        return this.red.invm(this);
    };

// Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, 'redNeg works only with red numbers');
        this.red._verify1(this);
        return this.red.neg(this);
    };

    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, 'redPow(normalNum)');
        this.red._verify1(this);
        return this.red.pow(this, num);
    };

// Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };

// Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).ishln(this.n).isub(this.p);

        this.tmp = this._tmp();
    }

    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };

    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;

        do {
            var pair = r.ishrn(this.n, 0, this.tmp);
            r = this.imulK(pair.hi);
            r = r.iadd(pair.lo);
            rlen = r.bitLength();
        } while (rlen > this.n);

        var cmp = rlen < this.n ? -1 : r.cmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) {
            r.isub(this.p);
        } else {
            r.strip();
        }

        return r;
    };

    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };

    function K256() {
        MPrime.call(
            this,
            'k256',
            'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    inherits(K256, MPrime);

    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;

        var uhi = 0;
        var hi = 0;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
            var w = num.words[i];
            hi += w * 0x40;
            lo += w * 0x3d1;
            hi += (lo / 0x4000000) | 0;
            uhi += (hi / 0x4000000) | 0;
            hi &= 0x3ffffff;
            lo &= 0x3ffffff;

            num.words[i] = lo;

            lo = hi;
            hi = uhi;
            uhi = 0;
        }

        // Fast length reduction
        if (num.words[num.length - 1] === 0)
            num.length--;
        if (num.words[num.length - 1] === 0)
            num.length--;
        return num;
    };

    function P224() {
        MPrime.call(
            this,
            'p224',
            'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    inherits(P224, MPrime);

    function P192() {
        MPrime.call(
            this,
            'p192',
            'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    inherits(P192, MPrime);

    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(
            this,
            '25519',
            '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    inherits(P25519, MPrime);

    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
            var hi = num.words[i] * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;

            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0)
            num.words[num.length++] = carry;
        return num;
    };

// Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name])
            return primes[name];

        var prime;
        if (name === 'k256')
            prime = new K256();
        else if (name === 'p224')
            prime = new P224();
        else if (name === 'p192')
            prime = new P192();
        else if (name === 'p25519')
            prime = new P25519();
        else
            throw new Error('Unknown prime ' + name);
        primes[name] = prime;

        return prime;
    }

//
// Base reduction engine
//
    function Red(m) {
        if (typeof m === 'string') {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            this.m = m;
            this.prime = null;
        }
    }

    Red.prototype._verify1 = function _verify1(a) {
        assert(!a.sign, 'red works only with positives');
        assert(a.red, 'red works only with red numbers');
    };

    Red.prototype._verify2 = function _verify2(a, b) {
        assert(!a.sign && !b.sign, 'red works only with positives');
        assert(a.red && a.red === b.red,
            'red works only with red numbers');
    };

    Red.prototype.imod = function imod(a) {
        if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
        return a.mod(this.m)._forceRed(this);
    };

    Red.prototype.neg = function neg(a) {
        var r = a.clone();
        r.sign = !r.sign;
        return r.iadd(this.m)._forceRed(this);
    };

    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);

        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
            res.isub(this.m);
        return res._forceRed(this);
    };

    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);

        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
            res.isub(this.m);
        return res;
    };

    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);

        var res = a.sub(b);
        if (res.cmpn(0) < 0)
            res.iadd(this.m);
        return res._forceRed(this);
    };

    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);

        var res = a.isub(b);
        if (res.cmpn(0) < 0)
            res.iadd(this.m);
        return res;
    };

    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.shln(num));
    };

    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };

    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };

    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a);
    };

    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };

    Red.prototype.sqrt = function sqrt(a) {
        if (a.cmpn(0) === 0)
            return a.clone();

        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);

        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).ishrn(2);
            var r = this.pow(a, pow);
            return r;
        }

        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
            s++;
            q.ishrn(1);
        }
        assert(q.cmpn(0) !== 0);

        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();

        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).ishrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0)
            z.redIAdd(nOne);

        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).ishrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++)
                tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).ishln(m - i - 1));

            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }

        return r;
    };

    Red.prototype.invm = function invm(a) {
        var inv = a._egcd(new BN(1), this.m);
        if (inv.sign) {
            inv.sign = false;
            return this.imod(inv).redNeg();
        } else {
            return this.imod(inv);
        }
    };

    Red.prototype.pow = function pow(a, num) {
        var w = [];
        var q = num.clone();
        while (q.cmpn(0) !== 0) {
            w.push(q.andln(1));
            q.ishrn(1);
        }

        // Skip leading zeroes
        var res = a;
        for (var i = 0; i < w.length; i++, res = this.sqr(res))
            if (w[i] !== 0)
                break;

        if (++i < w.length) {
            for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
                if (w[i] === 0)
                    continue;
                res = this.mul(res, q);
            }
        }

        return res;
    };

    Red.prototype.convertTo = function convertTo(num) {
        return num.clone();
    };

    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };

//
// Montgomery method engine
//

    BN.mont = function mont(num) {
        return new Mont(num);
    };

    function Mont(m) {
        Red.call(this, m);

        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0)
            this.shift += 26 - (this.shift % 26);
        this.r = new BN(1).ishln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r.invm(this.m);

        // TODO(indutny): simplify it
        this.minv = this.rinv.mul(this.r)
            .sub(new BN(1))
            .div(this.m)
            .neg()
            .mod(this.r);
    }
    inherits(Mont, Red);

    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.shln(this.shift));
    };

    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };

    Mont.prototype.imul = function imul(a, b) {
        if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }

        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).ishrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);

        return res._forceRed(this);
    };

    Mont.prototype.mul = function mul(a, b) {
        if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
            return new BN(0)._forceRed(this);

        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).ishrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);

        return res._forceRed(this);
    };

    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a.invm(this.m).mul(this.r2));
        return res._forceRed(this);
    };

},{}],33:[function(require,module,exports){
    (function (Buffer){
        var bn = require('bn.js');
        module.exports = crt;
        function blind(priv, crypto) {
            var r = getr(priv, crypto);
            var blinder = r.toRed(bn.mont(priv.modulus))
                .redPow(new bn(priv.publicExponent)).fromRed();
            return {
                blinder: blinder,
                unblinder:r.invm(priv.modulus)
            };
        }
        function crt(msg, priv, crypto) {
            var blinds = blind(priv, crypto);
            var len = priv.modulus.byteLength();
            var mod = bn.mont(priv.modulus);
            var blinded = new bn(msg).mul(blinds.blinder).mod(priv.modulus);
            var c1 = blinded.toRed(bn.mont(priv.prime1));
            var c2 = blinded.toRed(bn.mont(priv.prime2));
            var qinv = priv.coefficient;
            var p = priv.prime1;
            var q = priv.prime2;
            var m1 = c1.redPow(priv.exponent1);
            var m2 = c2.redPow(priv.exponent2);
            m1 = m1.fromRed();
            m2 = m2.fromRed();
            var h = m1.isub(m2).imul(qinv).mod(p);
            h.imul(q);
            m2.iadd(h);
            var out = new Buffer(m2.imul(blinds.unblinder).mod(priv.modulus).toArray());
            if (out.length < len) {
                var prefix = new Buffer(len - out.length);
                prefix.fill(0);
                out = Buffer.concat([prefix, out], len);
            }
            return out;
        }
        crt.getr = getr;
        function getr(priv, crypto) {
            var len = priv.modulus.byteLength();
            var r = new bn(crypto.randomBytes(len));
            while (r.cmp(priv.modulus) >=  0 || !r.mod(priv.prime1) || !r.mod(priv.prime2)) {
                r = new bn(crypto.randomBytes(len));
            }
            return r;
        }
    }).call(this,require("buffer").Buffer)
},{"bn.js":34,"buffer":3}],34:[function(require,module,exports){
    arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],35:[function(require,module,exports){
    var elliptic = exports;

    elliptic.version = require('../package.json').version;
    elliptic.utils = require('./elliptic/utils');
    elliptic.rand = require('brorand');
    elliptic.hmacDRBG = require('./elliptic/hmac-drbg');
    elliptic.curve = require('./elliptic/curve');
    elliptic.curves = require('./elliptic/curves');

// Protocols
    elliptic.ec = require('./elliptic/ec');

},{"../package.json":54,"./elliptic/curve":38,"./elliptic/curves":41,"./elliptic/ec":42,"./elliptic/hmac-drbg":45,"./elliptic/utils":46,"brorand":47}],36:[function(require,module,exports){
    var assert = require('assert');
    var bn = require('bn.js');
    var elliptic = require('../../elliptic');

    var getNAF = elliptic.utils.getNAF;
    var getJSF = elliptic.utils.getJSF;

    function BaseCurve(type, conf) {
        this.type = type;
        this.p = new bn(conf.p, 16);

        // Use Montgomery, when there is no fast reduction for the prime
        this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);

        // Useful for many curves
        this.zero = new bn(0).toRed(this.red);
        this.one = new bn(1).toRed(this.red);
        this.two = new bn(2).toRed(this.red);

        // Curve configuration, optional
        this.n = conf.n && new bn(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

        // Temporary arrays
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
    }
    module.exports = BaseCurve;

    BaseCurve.prototype.point = function point() {
        throw new Error('Not implemented');
    };

    BaseCurve.prototype.validate = function validate(point) {
        throw new Error('Not implemented');
    };

    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        var doubles = p._getDoubles();

        var naf = getNAF(k, 1);
        var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;

        // Translate into more windowed form
        var repr = [];
        for (var j = 0; j < naf.length; j += doubles.step) {
            var nafW = 0;
            for (var k = j + doubles.step - 1; k >= j; k--)
                nafW = (nafW << 1) + naf[k];
            repr.push(nafW);
        }

        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
            for (var j = 0; j < repr.length; j++) {
                var nafW = repr[j];
                if (nafW === i)
                    b = b.mixedAdd(doubles.points[j]);
                else if (nafW === -i)
                    b = b.mixedAdd(doubles.points[j].neg());
            }
            a = a.add(b);
        }
        return a.toP();
    };

    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;

        // Precompute window
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;

        // Get NAF form
        var naf = getNAF(k, w);

        // Add `this`*(N+1) for every w-NAF index
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
            // Count zeroes
            for (var k = 0; i >= 0 && naf[i] === 0; i--)
                k++;
            if (i >= 0)
                k++;
            acc = acc.dblp(k);

            if (i < 0)
                break;
            var z = naf[i];
            assert(z !== 0);
            if (p.type === 'affine') {
                // J +- P
                if (z > 0)
                    acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
                else
                    acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
            } else {
                // J +- J
                if (z > 0)
                    acc = acc.add(wnd[(z - 1) >> 1]);
                else
                    acc = acc.add(wnd[(-z - 1) >> 1].neg());
            }
        }
        return p.type === 'affine' ? acc.toP() : acc;
    };

    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                           points,
                                                           coeffs,
                                                           len) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;

        // Fill all arrays
        var max = 0;
        for (var i = 0; i < len; i++) {
            var p = points[i];
            var nafPoints = p._getNAFPoints(defW);
            wndWidth[i] = nafPoints.wnd;
            wnd[i] = nafPoints.points;
        }

        // Comb small window NAFs
        for (var i = len - 1; i >= 1; i -= 2) {
            var a = i - 1;
            var b = i;
            if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
                naf[a] = getNAF(coeffs[a], wndWidth[a]);
                naf[b] = getNAF(coeffs[b], wndWidth[b]);
                max = Math.max(naf[a].length, max);
                max = Math.max(naf[b].length, max);
                continue;
            }

            var comb = [
                points[a], /* 1 */
                null, /* 3 */
                null, /* 5 */
                points[b] /* 7 */
            ];

            // Try to avoid Projective points, if possible
            if (points[a].y.cmp(points[b].y) === 0) {
                comb[1] = points[a].add(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
            } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].add(points[b].neg());
            } else {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
            }

            var index = [
                -3, /* -1 -1 */
                -1, /* -1 0 */
                -5, /* -1 1 */
                -7, /* 0 -1 */
                0, /* 0 0 */
                7, /* 0 1 */
                5, /* 1 -1 */
                1, /* 1 0 */
                3  /* 1 1 */
            ];

            var jsf = getJSF(coeffs[a], coeffs[b]);
            max = Math.max(jsf[0].length, max);
            naf[a] = new Array(max);
            naf[b] = new Array(max);
            for (var j = 0; j < max; j++) {
                var ja = jsf[0][j] | 0;
                var jb = jsf[1][j] | 0;

                naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
                naf[b][j] = 0;
                wnd[a] = comb;
            }
        }

        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (var i = max; i >= 0; i--) {
            var k = 0;

            while (i >= 0) {
                var zero = true;
                for (var j = 0; j < len; j++) {
                    tmp[j] = naf[j][i] | 0;
                    if (tmp[j] !== 0)
                        zero = false;
                }
                if (!zero)
                    break;
                k++;
                i--;
            }
            if (i >= 0)
                k++;
            acc = acc.dblp(k);
            if (i < 0)
                break;

            for (var j = 0; j < len; j++) {
                var z = tmp[j];
                var p;
                if (z === 0)
                    continue;
                else if (z > 0)
                    p = wnd[j][(z - 1) >> 1];
                else if (z < 0)
                    p = wnd[j][(-z - 1) >> 1].neg();

                if (p.type === 'affine')
                    acc = acc.mixedAdd(p);
                else
                    acc = acc.add(p);
            }
        }
        // Zeroify references
        for (var i = 0; i < len; i++)
            wnd[i] = null;
        return acc.toP();
    };

    BaseCurve.BasePoint = BasePoint;

    function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
    }

    BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
    };

    BasePoint.prototype.precompute = function precompute(power, _beta) {
        if (this.precomputed)
            return this;

        var precomputed = {
            doubles: null,
            naf: null,
            beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;

        return this;
    };

    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles)
            return this.precomputed.doubles;

        var doubles = [ this ];
        var acc = this;
        for (var i = 0; i < power; i += step) {
            for (var j = 0; j < step; j++)
                acc = acc.dbl();
            doubles.push(acc);
        }
        return {
            step: step,
            points: doubles
        };
    };

    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
            return this.precomputed.naf;

        var res = [ this ];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i = 1; i < max; i++)
            res[i] = res[i - 1].add(dbl);
        return {
            wnd: wnd,
            points: res
        };
    };

    BasePoint.prototype._getBeta = function _getBeta() {
        return null;
    };

    BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++)
            r = r.dbl();
        return r;
    };

},{"../../elliptic":35,"assert":1,"bn.js":32}],37:[function(require,module,exports){
    var assert = require('assert');
    var curve = require('../curve');
    var elliptic = require('../../elliptic');
    var bn = require('bn.js');
    var inherits = require('inherits');
    var Base = curve.base;

    var getNAF = elliptic.utils.getNAF;

    function EdwardsCurve(conf) {
        // NOTE: Important as we are creating point in Base.call()
        this.twisted = conf.a != 1;
        this.mOneA = this.twisted && conf.a == -1;
        this.extended = this.mOneA;

        Base.call(this, 'mont', conf);

        this.a = new bn(conf.a, 16).mod(this.red.m).toRed(this.red);
        this.c = new bn(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new bn(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);

        assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = conf.c == 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;

    EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
            return num.redNeg();
        else
            return this.a.redMul(num);
    };

    EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
            return num;
        else
            return this.c.redMul(num);
    };

    EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
    };

// Just for compatibility with Short curve
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
    };

    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
    };

    EdwardsCurve.prototype.pointFromX = function pointFromX(odd, x) {
        x = new bn(x, 16);
        if (!x.red)
            x = x.toRed(this.red);

        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

        var y = rhs.redMul(lhs.redInvm()).redSqrt();
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
            y = y.redNeg();

        return this.point(x, y, curve.one);
    };

    EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity())
            return true;

        // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
        point.normalize();

        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

        return lhs.cmp(rhs) === 0;
    };

    function Point(curve, x, y, z, t) {
        Base.BasePoint.call(this, curve, 'projective');
        if (x === null && y === null && z === null) {
            this.x = this.curve.zero;
            this.y = this.curve.one;
            this.z = this.curve.one;
            this.t = this.curve.zero;
            this.zOne = true;
        } else {
            this.x = new bn(x, 16);
            this.y = new bn(y, 16);
            this.z = z ? new bn(z, 16) : this.curve.one;
            this.t = t && new bn(t, 16);
            if (!this.x.red)
                this.x = this.x.toRed(this.curve.red);
            if (!this.y.red)
                this.y = this.y.toRed(this.curve.red);
            if (!this.z.red)
                this.z = this.z.toRed(this.curve.red);
            if (this.t && !this.t.red)
                this.t = this.t.toRed(this.curve.red);
            this.zOne = this.z === this.curve.one;

            // Use extended coordinates
            if (this.curve.extended && !this.t) {
                this.t = this.x.redMul(this.y);
                if (!this.zOne)
                    this.t = this.t.redMul(this.z.redInvm());
            }
        }
    }
    inherits(Point, Base.BasePoint);

    Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
    };

    Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
            return '<EC Point Infinity>';
        return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
            ' y: ' + this.y.fromRed().toString(16, 2) +
            ' z: ' + this.z.fromRed().toString(16, 2) + '>';
    };

    Point.prototype.isInfinity = function isInfinity() {
        // XXX This code assumes that zero is always zero in red
        return this.x.cmpn(0) === 0 &&
            this.y.cmp(this.z) === 0;
    };

    Point.prototype._extDbl = function _extDbl() {
        // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#doubling-dbl-2008-hwcd
        // 4M + 4S

        // A = X1^2
        var a = this.x.redSqr();
        // B = Y1^2
        var b = this.y.redSqr();
        // C = 2 * Z1^2
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        // D = a * A
        var d = this.curve._mulA(a);
        // E = (X1 + Y1)^2 - A - B
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        // G = D + B
        var g = d.redAdd(b);
        // F = G - C
        var f = g.redSub(c);
        // H = D - B
        var h = d.redSub(b);
        // X3 = E * F
        var nx = e.redMul(f);
        // Y3 = G * H
        var ny = g.redMul(h);
        // T3 = E * H
        var nt = e.redMul(h);
        // Z3 = F * G
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
    };

    Point.prototype._projDbl = function _projDbl() {
        // http://hyperelliptic.org/EFD/g1p/auto-twisted-projective.html#doubling-dbl-2008-bbjlp
        // http://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#doubling-dbl-2007-bl
        // and others
        // Generally 3M + 4S or 2M + 4S

        // B = (X1 + Y1)^2
        var b = this.x.redAdd(this.y).redSqr();
        // C = X1^2
        var c = this.x.redSqr();
        // D = Y1^2
        var d = this.y.redSqr();

        if (this.curve.twisted) {
            // E = a * C
            var e = this.curve._mulA(c);
            // F = E + D
            var f = e.redAdd(d);
            if (this.zOne) {
                // X3 = (B - C - D) * (F - 2)
                var nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
                // Y3 = F * (E - D)
                var ny = f.redMul(e.redSub(d));
                // Z3 = F^2 - 2 * F
                var nz = f.redSqr().redSub(f).redSub(f);
            } else {
                // H = Z1^2
                var h = this.z.redSqr();
                // J = F - 2 * H
                var j = f.redSub(h).redISub(h);
                // X3 = (B-C-D)*J
                var nx = b.redSub(c).redISub(d).redMul(j);
                // Y3 = F * (E - D)
                var ny = f.redMul(e.redSub(d));
                // Z3 = F * J
                var nz = f.redMul(j);
            }
        } else {
            // E = C + D
            var e = c.redAdd(d);
            // H = (c * Z1)^2
            var h = this.curve._mulC(redMul(this.z)).redSqr();
            // J = E - 2 * H
            var j = e.redSub(h).redSub(h);
            // X3 = c * (B - E) * J
            var nx = this.curve._mulC(b.redISub(e)).redMul(j);
            // Y3 = c * E * (C - D)
            var ny = this.curve._mulC(e).redMul(c.redISub(d));
            // Z3 = E * J
            var nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
    };

    Point.prototype.dbl = function dbl() {
        if (this.isInfinity())
            return this;

        // Double in extended coordinates
        if (this.curve.extended)
            return this._extDbl();
        else
            return this._projDbl();
    };

    Point.prototype._extAdd = function _extAdd(p) {
        // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3
        // 8M

        // A = (Y1 - X1) * (Y2 - X2)
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        // B = (Y1 + X1) * (Y2 + X2)
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        // C = T1 * k * T2
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        // D = Z1 * 2 * Z2
        var d = this.z.redMul(p.z.redAdd(p.z));
        // E = B - A
        var e = b.redSub(a);
        // F = D - C
        var f = d.redSub(c);
        // G = D + C
        var g = d.redAdd(c);
        // H = B + A
        var h = b.redAdd(a);
        // X3 = E * F
        var nx = e.redMul(f);
        // Y3 = G * H
        var ny = g.redMul(h);
        // T3 = E * H
        var nt = e.redMul(h);
        // Z3 = F * G
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
    };

    Point.prototype._projAdd = function _projAdd(p) {
        // http://hyperelliptic.org/EFD/g1p/auto-twisted-projective.html#addition-add-2008-bbjlp
        // http://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#addition-add-2007-bl
        // 10M + 1S

        // A = Z1 * Z2
        var a = this.z.redMul(p.z);
        // B = A^2
        var b = a.redSqr();
        // C = X1 * X2
        var c = this.x.redMul(p.x);
        // D = Y1 * Y2
        var d = this.y.redMul(p.y);
        // E = d * C * D
        var e = this.curve.d.redMul(c).redMul(d);
        // F = B - E
        var f = b.redSub(e);
        // G = B + E
        var g = b.redAdd(e);
        // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f).redMul(tmp);
        if (this.curve.twisted) {
            // Y3 = A * G * (D - a * C)
            var ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
            // Z3 = F * G
            var nz = f.redMul(g);
        } else {
            // Y3 = A * G * (D - C)
            var ny = a.redMul(g).redMul(d.redSub(c));
            // Z3 = c * F * G
            var nz = this.curve._mulC(f).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
    };

    Point.prototype.add = function add(p) {
        if (this.isInfinity())
            return p;
        if (p.isInfinity())
            return this;

        if (this.curve.extended)
            return this._extAdd(p);
        else
            return this._projAdd(p);
    };

    Point.prototype.mul = function mul(k) {
        if (this.precomputed && this.precomputed.doubles)
            return this.curve._fixedNafMul(this, k);
        else
            return this.curve._wnafMul(this, k);
    };

    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2);
    };

    Point.prototype.normalize = function normalize() {
        if (this.zOne)
            return this;

        // Normalize coordinates
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t)
            this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
    };

    Point.prototype.neg = function neg() {
        return this.curve.point(this.x.redNeg(),
            this.y,
            this.z,
            this.t && this.t.redNeg());
    };

    Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
    };

    Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
    };

// Compatibility with BaseCurve
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;

},{"../../elliptic":35,"../curve":38,"assert":1,"bn.js":32,"inherits":149}],38:[function(require,module,exports){
    var curve = exports;

    curve.base = require('./base');
    curve.short = require('./short');
    curve.mont = require('./mont');
    curve.edwards = require('./edwards');

},{"./base":36,"./edwards":37,"./mont":39,"./short":40}],39:[function(require,module,exports){
    var assert = require('assert');
    var curve = require('../curve');
    var elliptic = require('../../elliptic');
    var bn = require('bn.js');
    var inherits = require('inherits');
    var Base = curve.base;

    var getNAF = elliptic.utils.getNAF;

    function MontCurve(conf) {
        Base.call(this, 'mont', conf);

        this.a = new bn(conf.a, 16).toRed(this.red);
        this.b = new bn(conf.b, 16).toRed(this.red);
        this.i4 = new bn(4).toRed(this.red).redInvm();
        this.two = new bn(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;

    MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
    };

    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
    }

    MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();

        return y.redSqr().cmp(rhs) === 0;
    };

    function Point(curve, x, z) {
        Base.BasePoint.call(this, curve, 'projective');
        if (x === null && z === null) {
            this.x = this.curve.one;
            this.z = this.curve.zero;
        } else {
            this.x = new bn(x, 16);
            this.z = new bn(z, 16);
            if (!this.x.red)
                this.x = this.x.toRed(this.curve.red);
            if (!this.z.red)
                this.z = this.z.toRed(this.curve.red);
        }
    }
    inherits(Point, Base.BasePoint);

    Point.prototype.precompute = function precompute() {
        // No-op
    };

    Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
    };

    Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
            return '<EC Point Infinity>';
        return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
            ' z: ' + this.z.fromRed().toString(16, 2) + '>';
    };

    Point.prototype.isInfinity = function isInfinity() {
        // XXX This code assumes that zero is always zero in red
        return this.z.cmpn(0) === 0;
    };

    Point.prototype.dbl = function dbl() {
        // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
        // 2M + 2S + 4A

        // A = X1 + Z1
        var a = this.x.redAdd(this.z);
        // AA = A^2
        var aa = a.redSqr();
        // B = X1 - Z1
        var b = this.x.redSub(this.z);
        // BB = B^2
        var bb = b.redSqr();
        // C = AA - BB
        var c = aa.redSub(bb);
        // X3 = AA * BB
        var nx = aa.redMul(bb);
        // Z3 = C * (BB + A24 * C)
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
    };

    Point.prototype.add = function add(p) {
        throw new Error('Not supported on Montgomery curve');
    };

    Point.prototype.diffAdd = function diffAdd(p, diff) {
        // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
        // 4M + 2S + 6A

        // A = X2 + Z2
        var a = this.x.redAdd(this.z);
        // B = X2 - Z2
        var b = this.x.redSub(this.z);
        // C = X3 + Z3
        var c = p.x.redAdd(p.z);
        // D = X3 - Z3
        var d = p.x.redSub(p.z);
        // DA = D * A
        var da = d.redMul(a);
        // CB = C * B
        var cb = c.redMul(b);
        // X5 = Z1 * (DA + CB)^2
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        // Z5 = X1 * (DA - CB)^2
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
    };

    Point.prototype.mul = function mul(k) {
        var t = k.clone();
        var a = this; // (N / 2) * Q + Q
        var b = this.curve.point(null, null); // (N / 2) * Q
        var c = this; // Q

        for (var bits = []; t.cmpn(0) !== 0; t.ishrn(1))
            bits.push(t.andln(1));

        for (var i = bits.length - 1; i >= 0; i--) {
            if (bits[i] === 0) {
                // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
                a = a.diffAdd(b, c);
                // N * Q = 2 * ((N / 2) * Q + Q))
                b = b.dbl();
            } else {
                // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
                b = a.diffAdd(b, c);
                // N * Q + Q = 2 * ((N / 2) * Q + Q)
                a = a.dbl();
            }
        }
        return b;
    };

    Point.prototype.mulAdd = function mulAdd() {
        throw new Error('Not supported on Montgomery curve');
    };

    Point.prototype.normalize = function normalize() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
    };

    Point.prototype.getX = function getX() {
        // Normalize coordinates
        this.normalize();

        return this.x.fromRed();
    };

},{"../../elliptic":35,"../curve":38,"assert":1,"bn.js":32,"inherits":149}],40:[function(require,module,exports){
    var assert = require('assert');
    var curve = require('../curve');
    var elliptic = require('../../elliptic');
    var bn = require('bn.js');
    var inherits = require('inherits');
    var Base = curve.base;

    var getNAF = elliptic.utils.getNAF;

    function ShortCurve(conf) {
        Base.call(this, 'short', conf);

        this.a = new bn(conf.a, 16).toRed(this.red);
        this.b = new bn(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();

        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

        // If the curve is endomorphic, precalculate beta and lambda
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;

    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        // No efficient endomorphism
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
            return;

        // Compute beta and lambda, that lambda * P = (beta * Px; Py)
        var beta;
        var lambda;
        if (conf.beta) {
            beta = new bn(conf.beta, 16).toRed(this.red);
        } else {
            var betas = this._getEndoRoots(this.p);
            // Choose the smallest beta
            beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
            beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
            lambda = new bn(conf.lambda, 16);
        } else {
            // Choose the lambda that is matching selected beta
            var lambdas = this._getEndoRoots(this.n);
            if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
                lambda = lambdas[0];
            } else {
                lambda = lambdas[1];
                assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
            }
        }

        // Get basis vectors, used for balanced length-two representation
        var basis;
        if (conf.basis) {
            basis = conf.basis.map(function(vec) {
                return {
                    a: new bn(vec.a, 16),
                    b: new bn(vec.b, 16),
                };
            });
        } else {
            basis = this._getEndoBasis(lambda);
        }

        return {
            beta: beta,
            lambda: lambda,
            basis: basis
        };
    };

    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        // Find roots of for x^2 + x + 1 in F
        // Root = (-1 +- Sqrt(-3)) / 2
        //
        var red = num === this.p ? this.red : bn.mont(num);
        var tinv = new bn(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var one = new bn(1).toRed(red);

        var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);

        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [ l1, l2 ];
    };

    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        // aprxSqrt >= sqrt(this.n)
        var aprxSqrt = this.n.shrn(Math.floor(this.n.bitLength() / 2));

        // 3.74
        // Run EGCD, until r(L + 1) < aprxSqrt
        var u = lambda;
        var v = this.n.clone();
        var x1 = new bn(1);
        var y1 = new bn(0);
        var x2 = new bn(0);
        var y2 = new bn(1);

        // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
        var a0;
        var b0;
        // First vector
        var a1;
        var b1;
        // Second vector
        var a2;
        var b2;

        var prevR;
        var i = 0;
        while (u.cmpn(0) !== 0) {
            var q = v.div(u);
            var r = v.sub(q.mul(u));
            var x = x2.sub(q.mul(x1));
            var y = y2.sub(q.mul(y1));

            if (!a1 && r.cmp(aprxSqrt) < 0) {
                a0 = prevR.neg();
                b0 = x1;
                a1 = r.neg();
                b1 = x;
            } else if (a1 && ++i === 2) {
                break;
            }
            prevR = r;

            v = u;
            u = r;
            x2 = x1;
            x1 = x;
            y2 = y1;
            y1 = y;
        }
        a2 = r.neg();
        b2 = x;

        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
            a2 = a0;
            b2 = b0;
        }

        // Normalize signs
        if (a1.sign) {
            a1 = a1.neg();
            b1 = b1.neg();
        }
        if (a2.sign) {
            a2 = a2.neg();
            b2 = b2.neg();
        }

        return [
            { a: a1, b: b1 },
            { a: a2, b: b2 }
        ];
    };

    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];

        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);

        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);

        // Calculate answer
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return { k1: k1, k2: k2 };
    };

    ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
    };

    ShortCurve.prototype.pointFromX = function pointFromX(odd, x) {
        x = new bn(x, 16);
        if (!x.red)
            x = x.toRed(this.red);

        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();

        // XXX Is there any way to tell if the number is odd without converting it
        // to non-red form?
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
            y = y.redNeg();

        return this.point(x, y);
    };

    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
    };

    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
    };

    ShortCurve.prototype.validate = function validate(point) {
        if (point.inf)
            return true;

        var x = point.x;
        var y = point.y;

        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };

    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
            var split = this._endoSplit(coeffs[i]);
            var p = points[i];
            var beta = p._getBeta();

            if (split.k1.sign) {
                split.k1.sign = !split.k1.sign;
                p = p.neg(true);
            }
            if (split.k2.sign) {
                split.k2.sign = !split.k2.sign;
                beta = beta.neg(true);
            }

            npoints[i * 2] = p;
            npoints[i * 2 + 1] = beta;
            ncoeffs[i * 2] = split.k1;
            ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);

        // Clean-up references to points and coefficients
        for (var j = 0; j < i * 2; j++) {
            npoints[j] = null;
            ncoeffs[j] = null;
        }
        return res;
    };

    function Point(curve, x, y, isRed) {
        Base.BasePoint.call(this, curve, 'affine');
        if (x === null && y === null) {
            this.x = null;
            this.y = null;
            this.inf = true;
        } else {
            this.x = new bn(x, 16);
            this.y = new bn(y, 16);
            // Force redgomery representation when loading from JSON
            if (isRed) {
                this.x.forceRed(this.curve.red);
                this.y.forceRed(this.curve.red);
            }
            if (!this.x.red)
                this.x = this.x.toRed(this.curve.red);
            if (!this.y.red)
                this.y = this.y.toRed(this.curve.red);
            this.inf = false;
        }
    }
    inherits(Point, Base.BasePoint);

    Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
            return;

        var pre = this.precomputed;
        if (pre && pre.beta)
            return pre.beta;

        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
            var curve = this.curve;
            function endoMul(p) {
                return curve.point(p.x.redMul(curve.endo.beta), p.y);
            }
            pre.beta = beta;
            beta.precomputed = {
                beta: null,
                naf: pre.naf && {
                    wnd: pre.naf.wnd,
                    points: pre.naf.points.map(endoMul)
                },
                doubles: pre.doubles && {
                    step: pre.doubles.step,
                    points: pre.doubles.points.map(endoMul)
                }
            };
        }
        return beta;
    };

    Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed)
            return [ this.x, this.y ];

        return [ this.x, this.y, this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        }];
    };

    Point.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === 'string')
            obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2])
            return res;

        function obj2point(obj) {
            return curve.point(obj[0], obj[1], red);
        }

        var pre = obj[2];
        res.precomputed = {
            beta: null,
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: [ res ].concat(pre.doubles.points.map(obj2point))
            },
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: [ res ].concat(pre.naf.points.map(obj2point))
            }
        };
        return res;
    };

    Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
            return '<EC Point Infinity>';
        return '<EC Point x: ' + this.x.fromRed().toString(16 ,2) +
            ' y: ' + this.y.fromRed().toString(16, 2) + '>';
    };

    Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
    };

    Point.prototype.add = function add(p) {
        // O + P = P
        if (this.inf)
            return p;

        // P + O = P
        if (p.inf)
            return this;

        // P + P = 2P
        if (this.eq(p))
            return this.dbl();

        // P + (-P) = O
        if (this.neg().eq(p))
            return this.curve.point(null, null);

        // P + Q = O
        if (this.x.cmp(p.x) === 0)
            return this.curve.point(null, null);

        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0)
            c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
    };

    Point.prototype.dbl = function dbl() {
        if (this.inf)
            return this;

        // 2P = O
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
            return this.curve.point(null, null);

        var a = this.curve.a;

        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
    };

    Point.prototype.getX = function getX() {
        return this.x.fromRed();
    };

    Point.prototype.getY = function getY() {
        return this.y.fromRed();
    };

    Point.prototype.mul = function mul(k) {
        k = new bn(k, 16);

        if (this.precomputed && this.precomputed.doubles)
            return this.curve._fixedNafMul(this, k);
        else if (this.curve.endo)
            return this.curve._endoWnafMulAdd([ this ], [ k ]);
        else
            return this.curve._wnafMul(this, k);
    };

    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [ this, p2 ];
        var coeffs = [ k1, k2 ];
        if (this.curve.endo)
            return this.curve._endoWnafMulAdd(points, coeffs);
        else
            return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };

    Point.prototype.eq = function eq(p) {
        return this === p ||
            this.inf === p.inf &&
            (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };

    Point.prototype.neg = function neg(_precompute) {
        if (this.inf)
            return this;

        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
            var pre = this.precomputed;
            function negate(p) {
                return p.neg();
            }
            res.precomputed = {
                naf: pre.naf && {
                    wnd: pre.naf.wnd,
                    points: pre.naf.points.map(negate)
                },
                doubles: pre.doubles && {
                    step: pre.doubles.step,
                    points: pre.doubles.points.map(negate)
                }
            };
        }
        return res;
    };

    Point.prototype.toJ = function toJ() {
        if (this.inf)
            return this.curve.jpoint(null, null, null);

        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
    };

    function JPoint(curve, x, y, z) {
        Base.BasePoint.call(this, curve, 'jacobian');
        if (x === null && y === null && z === null) {
            this.x = this.curve.one;
            this.y = this.curve.one;
            this.z = new bn(0);
        } else {
            this.x = new bn(x, 16);
            this.y = new bn(y, 16);
            this.z = new bn(z, 16);
        }
        if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);

        this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);

    JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
            return this.curve.point(null, null);

        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);

        return this.curve.point(ax, ay);
    };

    JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };

    JPoint.prototype.add = function add(p) {
        // O + P = P
        if (this.isInfinity())
            return p;

        // P + O = P
        if (p.isInfinity())
            return this;

        // 12M + 4S + 7A
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));

        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
            if (r.cmpn(0) !== 0)
                return this.curve.jpoint(null, null, null);
            else
                return this.dbl();
        }

        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);

        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(p.z).redMul(h);

        return this.curve.jpoint(nx, ny, nz);
    };

    JPoint.prototype.mixedAdd = function mixedAdd(p) {
        // O + P = P
        if (this.isInfinity())
            return p.toJ();

        // P + O = P
        if (p.isInfinity())
            return this;

        // 8M + 3S + 7A
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);

        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
            if (r.cmpn(0) !== 0)
                return this.curve.jpoint(null, null, null);
            else
                return this.dbl();
        }

        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);

        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(h);

        return this.curve.jpoint(nx, ny, nz);
    };

    JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0)
            return this;
        if (this.isInfinity())
            return this;
        if (!pow)
            return this.dbl();

        if (this.curve.zeroA || this.curve.threeA) {
            var r = this;
            for (var i = 0; i < pow; i++)
                r = r.dbl();
            return r;
        }

        // 1M + 2S + 1A + N * (4S + 5M + 8A)
        // N = 1 => 6M + 6S + 9A
        var a = this.curve.a;
        var tinv = this.curve.tinv;

        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();

        // Reuse results
        var jyd = jy.redAdd(jy);
        for (var i = 0; i < pow; i++) {
            var jx2 = jx.redSqr();
            var jyd2 = jyd.redSqr();
            var jyd4 = jyd2.redSqr();
            var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

            var t1 = jx.redMul(jyd2);
            var nx = c.redSqr().redISub(t1.redAdd(t1));
            var t2 = t1.redISub(nx);
            var dny = c.redMul(t2);
            dny = dny.redIAdd(dny).redISub(jyd4);
            var nz = jyd.redMul(jz);
            if (i + 1 < pow)
                jz4 = jz4.redMul(jyd4);

            jx = nx;
            jz = nz;
            jyd = dny;
        }

        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };

    JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
            return this;

        if (this.curve.zeroA)
            return this._zeroDbl();
        else if (this.curve.threeA)
            return this._threeDbl();
        else
            return this._dbl();
    };

    JPoint.prototype._zeroDbl = function _zeroDbl() {
        // Z = 1
        if (this.zOne) {
            // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-mdbl-2007-bl
            // 1M + 5S + 14A

            // XX = X1^2
            var xx = this.x.redSqr();
            // YY = Y1^2
            var yy = this.y.redSqr();
            // YYYY = YY^2
            var yyyy = yy.redSqr();
            // S = 2 * ((X1 + YY)^2 - XX - YYYY)
            var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
            s = s.redIAdd(s);
            // M = 3 * XX + a; a = 0
            var m = xx.redAdd(xx).redIAdd(xx);
            // T = M ^ 2 - 2*S
            var t = m.redSqr().redISub(s).redISub(s);

            // 8 * YYYY
            var yyyy8 = yyyy.redIAdd(yyyy);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            yyyy8 = yyyy8.redIAdd(yyyy8);

            // X3 = T
            var nx = t;
            // Y3 = M * (S - T) - 8 * YYYY
            var ny = m.redMul(s.redISub(t)).redISub(yyyy8);
            // Z3 = 2*Y1
            var nz = this.y.redAdd(this.y);
        } else {
            // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
            // 2M + 5S + 13A

            // A = X1^2
            var a = this.x.redSqr();
            // B = Y1^2
            var b = this.y.redSqr();
            // C = B^2
            var c = b.redSqr();
            // D = 2 * ((X1 + B)^2 - A - C)
            var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
            d = d.redIAdd(d);
            // E = 3 * A
            var e = a.redAdd(a).redIAdd(a);
            // F = E^2
            var f = e.redSqr();

            // 8 * C
            var c8 = c.redIAdd(c);
            c8 = c8.redIAdd(c8);
            c8 = c8.redIAdd(c8);

            // X3 = F - 2 * D
            var nx = f.redISub(d).redISub(d);
            // Y3 = E * (D - X3) - 8 * C
            var ny = e.redMul(d.redISub(nx)).redISub(c8);
            // Z3 = 2 * Y1 * Z1
            var nz = this.y.redMul(this.z);
            nz = nz.redIAdd(nz);
        }

        return this.curve.jpoint(nx, ny, nz);
    };

    JPoint.prototype._threeDbl = function _threeDbl() {
        // Z = 1
        if (this.zOne) {
            // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-mdbl-2007-bl
            // 1M + 5S + 15A

            // XX = X1^2
            var xx = this.x.redSqr();
            // YY = Y1^2
            var yy = this.y.redSqr();
            // YYYY = YY^2
            var yyyy = yy.redSqr();
            // S = 2 * ((X1 + YY)^2 - XX - YYYY)
            var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
            s = s.redIAdd(s);
            // M = 3 * XX + a
            var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
            // T = M^2 - 2 * S
            var t = m.redSqr().redISub(s).redISub(s);
            // X3 = T
            var nx = t;
            // Y3 = M * (S - T) - 8 * YYYY
            var yyyy8 = yyyy.redIAdd(yyyy);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            var ny = m.redMul(s.redISub(t)).redISub(yyyy8);
            // Z3 = 2 * Y1
            var nz = this.y.redAdd(this.y);
        } else {
            // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
            // 3M + 5S

            // delta = Z1^2
            var delta = this.z.redSqr();
            // gamma = Y1^2
            var gamma = this.y.redSqr();
            // beta = X1 * gamma
            var beta = this.x.redMul(gamma);
            // alpha = 3 * (X1 - delta) * (X1 + delta)
            var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
            alpha = alpha.redAdd(alpha).redIAdd(alpha);
            // X3 = alpha^2 - 8 * beta
            var beta4 = beta.redIAdd(beta);
            beta4 = beta4.redIAdd(beta4);
            var beta8 = beta4.redAdd(beta4);
            var nx = alpha.redSqr().redISub(beta8);
            // Z3 = (Y1 + Z1)^2 - gamma - delta
            var nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
            // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
            var ggamma8 = gamma.redSqr();
            ggamma8 = ggamma8.redIAdd(ggamma8);
            ggamma8 = ggamma8.redIAdd(ggamma8);
            ggamma8 = ggamma8.redIAdd(ggamma8);
            var ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }

        return this.curve.jpoint(nx, ny, nz);
    };

    JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var tinv = this.curve.tinv;

        // 4M + 6S + 10A
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();

        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();

        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);

        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);

        return this.curve.jpoint(nx, ny, nz);
    };

    JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
            return this.dbl().add(this);

        // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
        // 5M + 10S + ...

        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // ZZ = Z1^2
        var zz = this.z.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // M = 3 * XX + a * ZZ2; a = 0
        var m = xx.redAdd(xx).redIAdd(xx);
        // MM = M^2
        var mm = m.redSqr();
        // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        // EE = E^2
        var ee = e.redSqr();
        // T = 16*YYYY
        var t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        // U = (M + E)^2 - MM - EE - T
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
        // X3 = 4 * (X1 * EE - 4 * YY * U)
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        // Z3 = (Z1 + E)^2 - ZZ - EE
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

        return this.curve.jpoint(nx, ny, nz);
    };

    JPoint.prototype.mul = function mul(k, kbase) {
        k = new bn(k, kbase);

        return this.curve._wnafMul(this, k);
    };

    JPoint.prototype.eq = function eq(p) {
        if (p.type === 'affine')
            return this.eq(p.toJ());

        if (this === p)
            return true;

        // x1 * z2^2 == x2 * z1^2
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
            return false;

        // y1 * z2^3 == y2 * z1^3
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };

    JPoint.prototype.inspect = function inspect() {
        if (this.isInfinity())
            return '<EC JPoint Infinity>';
        return '<EC JPoint x: ' + this.x.toString(16, 2) +
            ' y: ' + this.y.toString(16, 2) +
            ' z: ' + this.z.toString(16, 2) + '>';
    };

    JPoint.prototype.isInfinity = function isInfinity() {
        // XXX This code assumes that zero is always zero in red
        return this.z.cmpn(0) === 0;
    };

},{"../../elliptic":35,"../curve":38,"assert":1,"bn.js":32,"inherits":149}],41:[function(require,module,exports){
    var curves = exports;

    var assert = require('assert');
    var hash = require('hash.js');
    var bn = require('bn.js');
    var elliptic = require('../elliptic');

    function PresetCurve(options) {
        if (options.type === 'short')
            this.curve = new elliptic.curve.short(options);
        else if (options.type === 'edwards')
            this.curve = new elliptic.curve.edwards(options);
        else
            this.curve = new elliptic.curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;

        assert(this.g.validate(), 'Invalid curve');
        assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
    }
    curves.PresetCurve = PresetCurve;

    function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            get: function() {
                var curve = new PresetCurve(options);
                Object.defineProperty(curves, name, {
                    configurable: true,
                    enumerable: true,
                    value: curve
                });
                return curve;
            }
        });
    }

    defineCurve('p192', {
        type: 'short',
        prime: 'p192',
        p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
        a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
        b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
        n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
        hash: hash.sha256,
        gRed: false,
        g: [
            '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
            '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
        ],
    });

    defineCurve('p224', {
        type: 'short',
        prime: 'p224',
        p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
        a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
        b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
        n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
        hash: hash.sha256,
        gRed: false,
        g: [
            'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
            'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
        ],
    });

    defineCurve('p256', {
        type: 'short',
        prime: null,
        p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
        a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
        b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
        n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
        hash: hash.sha256,
        gRed: false,
        g: [
            '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
            '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
        ],
    });

    defineCurve('curve25519', {
        type: 'mont',
        prime: 'p25519',
        p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
        a: '76d06',
        b: '0',
        n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
        hash: hash.sha256,
        gRed: false,
        g: [
            '9'
        ]
    });

    defineCurve('ed25519', {
        type: 'edwards',
        prime: 'p25519',
        p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
        a: '-1',
        c: '1',
        // -121665 * (121666^(-1)) (mod P)
        d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
        n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
        hash: hash.sha256,
        gRed: false,
        g: [
            '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

            // 4/5
            '6666666666666666666666666666666666666666666666666666666666666658'
        ]
    });

    defineCurve('secp256k1', {
        type: 'short',
        prime: 'k256',
        p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
        a: '0',
        b: '7',
        n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
        h: '1',
        hash: hash.sha256,

        // Precomputed endomorphism
        beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
        lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
        basis: [
            {
                a: '3086d221a7d46bcde86c90e49284eb15',
                b: '-e4437ed6010e88286f547fa90abfe4c3'
            },
            {
                a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
                b: '3086d221a7d46bcde86c90e49284eb15'
            }
        ],

        gRed: false,
        g: [
            '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
            '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
            {
                'doubles': {
                    'step': 4,
                    'points': [
                        [
                            'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
                            'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
                        ],
                        [
                            '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
                            '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
                        ],
                        [
                            '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
                            'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
                        ],
                        [
                            '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
                            '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
                        ],
                        [
                            '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
                            '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
                        ],
                        [
                            '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
                            '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
                        ],
                        [
                            'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
                            '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
                        ],
                        [
                            '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
                            'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
                        ],
                        [
                            'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
                            '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
                        ],
                        [
                            'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
                            'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
                        ],
                        [
                            'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
                            '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
                        ],
                        [
                            '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
                            '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
                        ],
                        [
                            '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
                            '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
                        ],
                        [
                            '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
                            '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
                        ],
                        [
                            '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
                            '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
                        ],
                        [
                            '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
                            '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
                        ],
                        [
                            '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
                            '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
                        ],
                        [
                            '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
                            '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
                        ],
                        [
                            '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
                            'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
                        ],
                        [
                            'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
                            '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
                        ],
                        [
                            'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
                            '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
                        ],
                        [
                            '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
                            '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
                        ],
                        [
                            '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
                            '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
                        ],
                        [
                            'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
                            '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
                        ],
                        [
                            '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
                            'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
                        ],
                        [
                            'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
                            '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
                        ],
                        [
                            'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
                            'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
                        ],
                        [
                            'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
                            '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
                        ],
                        [
                            'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
                            'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
                        ],
                        [
                            'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
                            '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
                        ],
                        [
                            '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
                            'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
                        ],
                        [
                            '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
                            '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
                        ],
                        [
                            'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
                            '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
                        ],
                        [
                            '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
                            'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
                        ],
                        [
                            'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
                            '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
                        ],
                        [
                            'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
                            '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
                        ],
                        [
                            'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
                            'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
                        ],
                        [
                            '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
                            '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
                        ],
                        [
                            '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
                            '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
                        ],
                        [
                            '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
                            'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
                        ],
                        [
                            '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
                            '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
                        ],
                        [
                            'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
                            '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
                        ],
                        [
                            '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
                            '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
                        ],
                        [
                            '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
                            'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
                        ],
                        [
                            '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
                            '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
                        ],
                        [
                            'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
                            '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
                        ],
                        [
                            '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
                            'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
                        ],
                        [
                            'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
                            'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
                        ],
                        [
                            'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
                            '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
                        ],
                        [
                            '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
                            'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
                        ],
                        [
                            '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
                            'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
                        ],
                        [
                            'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
                            '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
                        ],
                        [
                            'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
                            '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
                        ],
                        [
                            'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
                            '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
                        ],
                        [
                            '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
                            'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
                        ],
                        [
                            '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
                            '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
                        ],
                        [
                            'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
                            'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
                        ],
                        [
                            '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
                            'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
                        ],
                        [
                            '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
                            '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
                        ],
                        [
                            '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
                            '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
                        ],
                        [
                            'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
                            'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
                        ],
                        [
                            '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
                            '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
                        ],
                        [
                            '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
                            '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
                        ],
                        [
                            'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
                            '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
                        ],
                        [
                            'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
                            'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
                        ]
                    ]
                },
                'naf': {
                    'wnd': 7,
                    'points': [
                        [
                            'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
                            '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
                        ],
                        [
                            '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
                            'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
                        ],
                        [
                            '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
                            '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
                        ],
                        [
                            'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
                            'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
                        ],
                        [
                            '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
                            'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
                        ],
                        [
                            'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
                            'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
                        ],
                        [
                            'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
                            '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
                        ],
                        [
                            'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
                            '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
                        ],
                        [
                            '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
                            '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
                        ],
                        [
                            '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
                            '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
                        ],
                        [
                            '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
                            '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
                        ],
                        [
                            '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
                            '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
                        ],
                        [
                            'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
                            'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
                        ],
                        [
                            'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
                            '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
                        ],
                        [
                            '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
                            'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
                        ],
                        [
                            '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
                            'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
                        ],
                        [
                            '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
                            '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
                        ],
                        [
                            '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
                            '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
                        ],
                        [
                            '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
                            '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
                        ],
                        [
                            '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
                            'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
                        ],
                        [
                            'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
                            'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
                        ],
                        [
                            '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
                            '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
                        ],
                        [
                            '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
                            '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
                        ],
                        [
                            'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
                            'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
                        ],
                        [
                            '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
                            '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
                        ],
                        [
                            'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
                            'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
                        ],
                        [
                            'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
                            'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
                        ],
                        [
                            '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
                            '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
                        ],
                        [
                            '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
                            '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
                        ],
                        [
                            '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
                            '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
                        ],
                        [
                            'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
                            '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
                        ],
                        [
                            '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
                            '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
                        ],
                        [
                            'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
                            '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
                        ],
                        [
                            '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
                            'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
                        ],
                        [
                            '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
                            'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
                        ],
                        [
                            'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
                            'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
                        ],
                        [
                            '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
                            '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
                        ],
                        [
                            '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
                            'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
                        ],
                        [
                            'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
                            'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
                        ],
                        [
                            '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
                            '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
                        ],
                        [
                            '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
                            'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
                        ],
                        [
                            '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
                            '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
                        ],
                        [
                            '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
                            'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
                        ],
                        [
                            'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
                            '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
                        ],
                        [
                            '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
                            '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
                        ],
                        [
                            '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
                            'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
                        ],
                        [
                            '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
                            'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
                        ],
                        [
                            'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
                            'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
                        ],
                        [
                            'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
                            'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
                        ],
                        [
                            '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
                            '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
                        ],
                        [
                            '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
                            '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
                        ],
                        [
                            'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
                            '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
                        ],
                        [
                            'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
                            'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
                        ],
                        [
                            '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
                            '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
                        ],
                        [
                            '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
                            '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
                        ],
                        [
                            'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
                            '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
                        ],
                        [
                            '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
                            '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
                        ],
                        [
                            'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
                            'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
                        ],
                        [
                            '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
                            'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
                        ],
                        [
                            '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
                            '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
                        ],
                        [
                            'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
                            '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
                        ],
                        [
                            'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
                            '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
                        ],
                        [
                            '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
                            '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
                        ],
                        [
                            '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
                            '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
                        ],
                        [
                            '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
                            'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
                        ],
                        [
                            '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
                            'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
                        ],
                        [
                            '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
                            '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
                        ],
                        [
                            '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
                            '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
                        ],
                        [
                            '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
                            '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
                        ],
                        [
                            '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
                            'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
                        ],
                        [
                            'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
                            'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
                        ],
                        [
                            '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
                            'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
                        ],
                        [
                            'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
                            '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
                        ],
                        [
                            'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
                            '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
                        ],
                        [
                            'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
                            '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
                        ],
                        [
                            'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
                            '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
                        ],
                        [
                            '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
                            'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
                        ],
                        [
                            '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
                            '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
                        ],
                        [
                            '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
                            'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
                        ],
                        [
                            'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
                            'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
                        ],
                        [
                            'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
                            '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
                        ],
                        [
                            'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
                            'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
                        ],
                        [
                            'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
                            '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
                        ],
                        [
                            '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
                            '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
                        ],
                        [
                            'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
                            '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
                        ],
                        [
                            'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
                            '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
                        ],
                        [
                            '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
                            '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
                        ],
                        [
                            '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
                            'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
                        ],
                        [
                            'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
                            '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
                        ],
                        [
                            'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
                            '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
                        ],
                        [
                            'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
                            '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
                        ],
                        [
                            '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
                            '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
                        ],
                        [
                            'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
                            'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
                        ],
                        [
                            '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
                            'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
                        ],
                        [
                            'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
                            'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
                        ],
                        [
                            'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
                            '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
                        ],
                        [
                            '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
                            'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
                        ],
                        [
                            'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
                            '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
                        ],
                        [
                            'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
                            '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
                        ],
                        [
                            'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
                            '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
                        ],
                        [
                            '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
                            'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
                        ],
                        [
                            '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
                            'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
                        ],
                        [
                            'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
                            '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
                        ],
                        [
                            '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
                            'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
                        ],
                        [
                            '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
                            '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
                        ],
                        [
                            '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
                            'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
                        ],
                        [
                            'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
                            'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
                        ],
                        [
                            '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
                            'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
                        ],
                        [
                            '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
                            '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
                        ],
                        [
                            '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
                            'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
                        ],
                        [
                            '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
                            '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
                        ],
                        [
                            'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
                            'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
                        ],
                        [
                            '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
                            '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
                        ],
                        [
                            'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
                            '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
                        ],
                        [
                            '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
                            '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
                        ],
                        [
                            'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
                            'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
                        ],
                        [
                            'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
                            '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
                        ],
                        [
                            'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
                            'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
                        ],
                        [
                            '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
                            'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
                        ],
                        [
                            '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
                            '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
                        ],
                        [
                            '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
                            'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
                        ],
                        [
                            '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
                            '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
                        ],
                        [
                            '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
                            '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
                        ],
                        [
                            '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
                            'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
                        ],
                        [
                            '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
                            '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
                        ],
                        [
                            '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
                            '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
                        ],
                        [
                            '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
                            '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
                        ]
                    ]
                }
            }
        ]
    });

},{"../elliptic":35,"assert":1,"bn.js":32,"hash.js":48}],42:[function(require,module,exports){
    var assert = require('assert');
    var bn = require('bn.js');
    var elliptic = require('../../elliptic');
    var utils = elliptic.utils;

    var KeyPair = require('./key');
    var Signature = require('./signature');

    function EC(options) {
        if (!(this instanceof EC))
            return new EC(options);

        // Shortcut `elliptic.ec(curve-name)`
        if (typeof options === 'string') {
            assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

            options = elliptic.curves[options];
        }

        // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
        if (options instanceof elliptic.curves.PresetCurve)
            options = { curve: options };

        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.shrn(1);
        this.g = this.curve.g;

        // Point on curve
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);

        // Hash for function for DRBG
        this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;

    EC.prototype.keyPair = function keyPair(priv, pub) {
        return new KeyPair(this, priv, pub);
    };

    EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
            options = {};

        // Instantiate Hmac_DRBG
        var drbg = new elliptic.hmacDRBG({
            hash: this.hash,
            pers: options.pers,
            entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
            nonce: this.n.toArray()
        });

        var bytes = this.n.byteLength();
        var ns2 = this.n.sub(new bn(2));
        do {
            var priv = new bn(drbg.generate(bytes));
            if (priv.cmp(ns2) > 0)
                continue;

            priv.iaddn(1);
            return this.keyPair(priv);
        } while (true);
    };

    EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0)
            msg = msg.shrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
            return msg.sub(this.n);
        else
            return msg;
    };

    EC.prototype.sign = function sign(msg, key, options) {
        key = this.keyPair(key, 'hex');
        msg = this._truncateToN(new bn(msg, 16));
        if (!options)
            options = {};

        // Zero-extend key to provide enough entropy
        var bytes = this.n.byteLength();
        var bkey = key.getPrivate().toArray();
        for (var i = bkey.length; i < 21; i++)
            bkey.unshift(0);

        // Zero-extend nonce to have the same byte size as N
        var nonce = msg.toArray();
        for (var i = nonce.length; i < bytes; i++)
            nonce.unshift(0);

        // Instantiate Hmac_DRBG
        var drbg = new elliptic.hmacDRBG({
            hash: this.hash,
            entropy: bkey,
            nonce: nonce
        });

        // Number of bytes to generate
        var ns1 = this.n.sub(new bn(1));
        do {
            var k = new bn(drbg.generate(this.n.byteLength()));
            k = this._truncateToN(k, true);
            if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
                continue;

            var kp = this.g.mul(k);
            if (kp.isInfinity())
                continue;

            var r = kp.getX().mod(this.n);
            if (r.cmpn(0) === 0)
                continue;

            var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg)).mod(this.n);
            if (s.cmpn(0) === 0)
                continue;

            // Use complement of `s`, if it is > `n / 2`
            if (options.canonical && s.cmp(this.nh) > 0)
                s = this.n.sub(s);

            return new Signature(r, s);
        } while (true);
    };

    EC.prototype.verify = function verify(msg, signature, key) {
        msg = this._truncateToN(new bn(msg, 16));
        key = this.keyPair(key, 'hex');
        signature = new Signature(signature, 'hex');

        // Perform primitive values validation
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
            return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
            return false;

        // Validate signature
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).mod(this.n);
        var u2 = sinv.mul(r).mod(this.n);

        var p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
            return false;

        return p.getX().mod(this.n).cmp(r) === 0;
    };

},{"../../elliptic":35,"./key":43,"./signature":44,"assert":1,"bn.js":32}],43:[function(require,module,exports){
    var assert = require('assert');
    var bn = require('bn.js');

    var elliptic = require('../../elliptic');
    var utils = elliptic.utils;

    function KeyPair(ec, priv, pub) {
        if (priv instanceof KeyPair)
            return priv;
        if (pub instanceof KeyPair)
            return pub;

        if (!priv) {
            priv = pub;
            pub = null;
        }
        if (priv !== null && typeof priv === 'object') {
            if (priv.x) {
                // KeyPair(public)
                pub = priv;
                priv = null;
            } else if (priv.priv || priv.pub) {
                // KeyPair({ priv: ..., pub: ... })
                pub = priv.pub;
                priv = priv.priv;
            }
        }

        this.ec = ec;
        this.priv = null;
        this.pub = null;

        // KeyPair(public, 'hex')
        if (this._importPublicHex(priv, pub))
            return;

        if (pub === 'hex')
            pub = null;

        // KeyPair(priv, pub)
        if (priv)
            this._importPrivate(priv);
        if (pub)
            this._importPublic(pub);
    }
    module.exports = KeyPair;

    KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();

        if (pub.isInfinity())
            return { result: false, reason: 'Invalid public key' };
        if (!pub.validate())
            return { result: false, reason: 'Public key is not a point' };
        if (!pub.mul(this.ec.curve.n).isInfinity())
            return { result: false, reason: 'Public key * N != O' };

        return { result: true, reason: null };
    };

    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (!this.pub)
            this.pub = this.ec.g.mul(this.priv);

        // compact is optional argument
        if (typeof compact === 'string') {
            enc = compact;
            compact = null;
        }

        if (!enc)
            return this.pub;

        var len = this.ec.curve.p.byteLength();
        var x = this.pub.getX().toArray();

        for (var i = x.length; i < len; i++)
            x.unshift(0);

        if (compact) {
            var res = [ this.pub.getY().isEven() ? 0x02 : 0x03 ].concat(x);
        } else {
            var y = this.pub.getY().toArray();
            for (var i = y.length; i < len; i++)
                y.unshift(0);
            var res = [ 0x04 ].concat(x, y);
        }
        return utils.encode(res, enc);
    };

    KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === 'hex')
            return this.priv.toString(16, 2);
        else
            return this.priv;
    };

    KeyPair.prototype._importPrivate = function _importPrivate(key) {
        this.priv = new bn(key, 16);

        // Ensure that the priv won't be bigger than n, otherwise we may fail
        // in fixed multiplication method
        this.priv = this.priv.mod(this.ec.curve.n);
    };

    KeyPair.prototype._importPublic = function _importPublic(key) {
        this.pub = this.ec.curve.point(key.x, key.y);
    };

    KeyPair.prototype._importPublicHex = function _importPublic(key, enc) {
        key = utils.toArray(key, enc);
        var len = this.ec.curve.p.byteLength();
        if (key[0] === 0x04 && key.length - 1 === 2 * len) {
            this.pub = this.ec.curve.point(
                key.slice(1, 1 + len),
                key.slice(1 + len, 1 + 2 * len));
        } else if ((key[0] === 0x02 || key[0] === 0x03) && key.length - 1 === len) {
            this.pub = this.ec.curve.pointFromX(key[0] === 0x03,
                key.slice(1, 1 +len));
        } else {
            return false;
        }

        return true;
    };

// ECDH
    KeyPair.prototype.derive = function derive(pub) {
        return pub.mul(this.priv).getX();
    };

// ECDSA
    KeyPair.prototype.sign = function sign(msg) {
        return this.ec.sign(msg, this);
    };

    KeyPair.prototype.verify = function verify(msg, signature) {
        return this.ec.verify(msg, signature, this);
    };

    KeyPair.prototype.inspect = function inspect() {
        return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
            ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
    };

},{"../../elliptic":35,"assert":1,"bn.js":32}],44:[function(require,module,exports){
    var assert = require('assert');
    var bn = require('bn.js');

    var elliptic = require('../../elliptic');
    var utils = elliptic.utils;

    function Signature(r, s) {
        if (r instanceof Signature)
            return r;

        if (this._importDER(r, s))
            return;

        assert(r && s, 'Signature without r or s');
        this.r = new bn(r, 16);
        this.s = new bn(s, 16);
    }
    module.exports = Signature;

    Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        if (data.length < 6 || data[0] !== 0x30 || data[2] !== 0x02)
            return false;
        var total = data[1];
        if (1 + total > data.length)
            return false;
        var rlen = data[3];
        // Short length notation
        if (rlen >= 0x80)
            return false;
        if (4 + rlen + 2 >= data.length)
            return false;
        if (data[4 + rlen] !== 0x02)
            return false;
        var slen = data[5 + rlen];
        // Short length notation
        if (slen >= 0x80)
            return false;
        if (4 + rlen + 2 + slen > data.length)
            return false;

        this.r = new bn(data.slice(4, 4 + rlen));
        this.s = new bn(data.slice(4 + rlen + 2, 4 + rlen + 2 + slen));

        return true;
    };

    Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();

        // Pad values
        if (r[0] & 0x80)
            r = [ 0 ].concat(r);
        // Pad values
        if (s[0] & 0x80)
            s = [ 0 ].concat(s);

        var total = r.length + s.length + 4;
        var res = [ 0x30, total, 0x02, r.length ];
        res = res.concat(r, [ 0x02, s.length ], s);
        return utils.encode(res, enc);
    };

},{"../../elliptic":35,"assert":1,"bn.js":32}],45:[function(require,module,exports){
    var assert = require('assert');

    var hash = require('hash.js');
    var elliptic = require('../elliptic');
    var utils = elliptic.utils;

    function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
            return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;

        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;

        this.reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;

        var entropy = utils.toArray(options.entropy, options.entropyEnc);
        var nonce = utils.toArray(options.nonce, options.nonceEnc);
        var pers = utils.toArray(options.pers, options.persEnc);
        assert(entropy.length >= (this.minEntropy / 8),
            'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
        this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;

    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);

        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
            this.K[i] = 0x00;
            this.V[i] = 0x01;
        }

        this._update(seed);
        this.reseed = 1;
        this.reseedInterval = 0x1000000000000;  // 2^48
    };

    HmacDRBG.prototype._hmac = function hmac() {
        return new hash.hmac(this.hash, this.K);
    };

    HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac()
            .update(this.V)
            .update([ 0x00 ]);
        if (seed)
            kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed)
            return;

        this.K = this._hmac()
            .update(this.V)
            .update([ 0x01 ])
            .update(seed)
            .digest();
        this.V = this._hmac().update(this.V).digest();
    };

    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
        // Optional entropy enc
        if (typeof entropyEnc !== 'string') {
            addEnc = add;
            add = entropyEnc;
            entropyEnc = null;
        }

        entropy = utils.toBuffer(entropy, entropyEnc);
        add = utils.toBuffer(add, addEnc);

        assert(entropy.length >= (this.minEntropy / 8),
            'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

        this._update(entropy.concat(add || []));
        this.reseed = 1;
    };

    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
        if (this.reseed > this.reseedInterval)
            throw new Error('Reseed is required');

        // Optional encoding
        if (typeof enc !== 'string') {
            addEnc = add;
            add = enc;
            enc = null;
        }

        // Optional additional data
        if (add) {
            add = utils.toArray(add, addEnc);
            this._update(add);
        }

        var temp = [];
        while (temp.length < len) {
            this.V = this._hmac().update(this.V).digest();
            temp = temp.concat(this.V);
        }

        var res = temp.slice(0, len);
        this._update(add);
        this.reseed++;
        return utils.encode(res, enc);
    };

},{"../elliptic":35,"assert":1,"hash.js":48}],46:[function(require,module,exports){
    var assert = require('assert');
    var bn = require('bn.js');

    var utils = exports;

    function toArray(msg, enc) {
        if (Array.isArray(msg))
            return msg.slice();
        if (!msg)
            return [];
        var res = [];
        if (typeof msg === 'string') {
            if (!enc) {
                for (var i = 0; i < msg.length; i++) {
                    var c = msg.charCodeAt(i);
                    var hi = c >> 8;
                    var lo = c & 0xff;
                    if (hi)
                        res.push(hi, lo);
                    else
                        res.push(lo);
                }
            } else if (enc === 'hex') {
                msg = msg.replace(/[^a-z0-9]+/ig, '');
                if (msg.length % 2 !== 0)
                    msg = '0' + msg;
                for (var i = 0; i < msg.length; i += 2)
                    res.push(parseInt(msg[i] + msg[i + 1], 16));
            }
        } else {
            for (var i = 0; i < msg.length; i++)
                res[i] = msg[i] | 0;
        }
        return res;
    }
    utils.toArray = toArray;

    function toHex(msg) {
        var res = '';
        for (var i = 0; i < msg.length; i++)
            res += zero2(msg[i].toString(16));
        return res;
    }
    utils.toHex = toHex;

    utils.encode = function encode(arr, enc) {
        if (enc === 'hex')
            return toHex(arr);
        else
            return arr;
    };

    function zero2(word) {
        if (word.length === 1)
            return '0' + word;
        else
            return word;
    }
    utils.zero2 = zero2;

// Represent num in a w-NAF form
    function getNAF(num, w) {
        var naf = [];
        var ws = 1 << (w + 1);
        var k = num.clone();
        while (k.cmpn(1) >= 0) {
            var z;
            if (k.isOdd()) {
                var mod = k.andln(ws - 1);
                if (mod > (ws >> 1) - 1)
                    z = (ws >> 1) - mod;
                else
                    z = mod;
                k.isubn(z);
            } else {
                z = 0;
            }
            naf.push(z);

            // Optimization, shift by word if possible
            var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
            for (var i = 1; i < shift; i++)
                naf.push(0);
            k.ishrn(shift);
        }

        return naf;
    }
    utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
    function getJSF(k1, k2) {
        var jsf = [
            [],
            []
        ];

        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

            // First phase
            var m14 = (k1.andln(3) + d1) & 3;
            var m24 = (k2.andln(3) + d2) & 3;
            if (m14 === 3)
                m14 = -1;
            if (m24 === 3)
                m24 = -1;
            var u1;
            if ((m14 & 1) === 0) {
                u1 = 0;
            } else {
                var m8 = (k1.andln(7) + d1) & 7;
                if ((m8 === 3 || m8 === 5) && m24 === 2)
                    u1 = -m14;
                else
                    u1 = m14;
            }
            jsf[0].push(u1);

            var u2;
            if ((m24 & 1) === 0) {
                u2 = 0;
            } else {
                var m8 = (k2.andln(7) + d2) & 7;
                if ((m8 === 3 || m8 === 5) && m14 === 2)
                    u2 = -m24;
                else
                    u2 = m24;
            }
            jsf[1].push(u2);

            // Second phase
            if (2 * d1 === u1 + 1)
                d1 = 1 - d1;
            if (2 * d2 === u2 + 1)
                d2 = 1 - d2;
            k1.ishrn(1);
            k2.ishrn(1);
        }

        return jsf;
    }
    utils.getJSF = getJSF;

},{"assert":1,"bn.js":32}],47:[function(require,module,exports){
    var r;

    module.exports = function rand(len) {
        if (!r)
            r = new Rand(null);

        return r.generate(len);
    };

    function Rand(rand) {
        this.rand = rand;
    }
    module.exports.Rand = Rand;

    Rand.prototype.generate = function generate(len) {
        return this._rand(len);
    };

    if (typeof window === 'object') {
        if (window.crypto && window.crypto.getRandomValues) {
            // Modern browsers
            Rand.prototype._rand = function _rand(n) {
                var arr = new Uint8Array(n);
                window.crypto.getRandomValues(arr);
                return arr;
            };
        } else if (window.msCrypto && window.msCrypto.getRandomValues) {
            // IE
            Rand.prototype._rand = function _rand(n) {
                var arr = new Uint8Array(n);
                window.msCrypto.getRandomValues(arr);
                return arr;
            };
        } else {
            // Old junk
            Rand.prototype._rand = function() {
                throw new Error('Not implemented yet');
            };
        }
    } else {
        // Node.js or Web worker
        try {
            var crypto = require('cry' + 'pto');

            Rand.prototype._rand = function _rand(n) {
                return crypto.randomBytes(n);
            };
        } catch (e) {
            // Emulate crypto API using randy
            Rand.prototype._rand = function _rand(n) {
                var res = new Uint8Array(n);
                for (var i = 0; i < res.length; i++)
                    res[i] = this.rand.getByte();
                return res;
            };
        }
    }

},{}],48:[function(require,module,exports){
    var hash = exports;

    hash.utils = require('./hash/utils');
    hash.common = require('./hash/common');
    hash.sha = require('./hash/sha');
    hash.ripemd = require('./hash/ripemd');
    hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":49,"./hash/hmac":50,"./hash/ripemd":51,"./hash/sha":52,"./hash/utils":53}],49:[function(require,module,exports){
    var hash = require('../hash');
    var utils = hash.utils;
    var assert = utils.assert;

    function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.endian = 'big';
    }
    exports.BlockHash = BlockHash;

    BlockHash.prototype.update = function update(msg, enc) {
        // Convert message to array, pad it, and join into 32bit blocks
        msg = utils.toArray(msg, enc);
        if (!this.pending)
            this.pending = msg;
        else
            this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;

        // Enough data, try updating
        if (this.pending.length >= this.blockSize / 8) {
            msg = this.pending;

            // Process pending data in blocks
            var r = msg.length % (this.blockSize / 8);
            this.pending = msg.slice(msg.length - r, msg.length);
            if (this.pending.length === 0)
                this.pending = null;

            msg = utils.join32(msg.slice(0, msg.length - r), this.endian);
            for (var i = 0; i < msg.length; i += this.blockSize / 32)
                this._update(msg.slice(i, i + this.blockSize / 32));
        }

        return this;
    };

    BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert(this.pending === null);

        return this._digest(enc);
    };

    BlockHash.prototype._pad = function pad() {
        var len = this.pendingTotal;
        var bytes = this.blockSize / 8;
        var k = bytes - ((len + 8) % bytes);
        var res = new Array(k + 8);
        res[0] = 0x80;
        for (var i = 1; i < k; i++)
            res[i] = 0;

        // Append length
        len <<= 3;
        if (this.endian === 'big') {
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = (len >>> 24) & 0xff;
            res[i++] = (len >>> 16) & 0xff;
            res[i++] = (len >>> 8) & 0xff;
            res[i++] = len & 0xff;
        } else {
            res[i++] = len & 0xff;
            res[i++] = (len >>> 8) & 0xff;
            res[i++] = (len >>> 16) & 0xff;
            res[i++] = (len >>> 24) & 0xff;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
        }

        return res;
    }

},{"../hash":48}],50:[function(require,module,exports){
    var hmac = exports;

    var hash = require('../hash');
    var utils = hash.utils;
    var assert = utils.assert;

    function Hmac(hash, key, enc) {
        if (!(this instanceof Hmac))
            return new Hmac(hash, key, enc);
        this.Hash = hash;
        this.blockSize = hash.blockSize / 8;
        this.outSize = hash.outSize / 8;
        this._init(utils.toArray(key, enc));
    }
    module.exports = Hmac;

    Hmac.prototype._init = function init(key) {
        // Shorten key, if needed
        if (key.length > this.blockSize)
            key = new this.Hash().update(key).digest();
        assert(key.length <= this.blockSize);

        // Add padding to key
        for (var i = key.length; i < this.blockSize; i++)
            key.push(0);

        var okey = key.slice();
        for (var i = 0; i < key.length; i++) {
            key[i] ^= 0x36;
            okey[i] ^= 0x5c;
        }

        this.hash = {
            inner: new this.Hash().update(key),
            outer: new this.Hash().update(okey)
        };
    };

    Hmac.prototype.update = function update(msg, enc) {
        this.hash.inner.update(msg, enc);
        return this;
    };

    Hmac.prototype.digest = function digest(enc) {
        this.hash.outer.update(this.hash.inner.digest());
        return this.hash.outer.digest(enc);
    };

},{"../hash":48}],51:[function(require,module,exports){
    var hash = require('../hash');
    var utils = hash.utils;

    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = hash.common.BlockHash;

    function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
            return new RIPEMD160();

        BlockHash.call(this);

        this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
        this.endian = 'little';
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;

    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;

    RIPEMD160.prototype._update = function update(msg) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
            var T = sum32(
                rotl32(
                    sum32_4(A, f(j, B, C, D), msg[r[j]], K(j)),
                    s[j]),
                E);
            A = E;
            E = D;
            D = rotl32(C, 10);
            C = B;
            B = T;
            T = sum32(
                rotl32(
                    sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j]], Kh(j)),
                    sh[j]),
                Eh);
            Ah = Eh;
            Eh = Dh;
            Dh = rotl32(Ch, 10);
            Ch = Bh;
            Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
    };

    RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === 'hex')
            return utils.toHex32(this.h, 'little');
        else
            return utils.split32(this.h, 'little');
    };

    function f(j, x, y, z) {
        if (j <= 15)
            return x ^ y ^ z;
        else if (j <= 31)
            return (x & y) | ((~x) & z);
        else if (j <= 47)
            return (x | (~y)) ^ z;
        else if (j <= 63)
            return (x & z) | (y & (~z));
        else
            return x ^ (y | (~z));
    }

    function K(j) {
        if (j <= 15)
            return 0x00000000;
        else if (j <= 31)
            return 0x5a827999;
        else if (j <= 47)
            return 0x6ed9eba1;
        else if (j <= 63)
            return 0x8f1bbcdc;
        else
            return 0xa953fd4e;
    }

    function Kh(j) {
        if (j <= 15)
            return 0x50a28be6;
        else if (j <= 31)
            return 0x5c4dd124;
        else if (j <= 47)
            return 0x6d703ef3;
        else if (j <= 63)
            return 0x7a6d76e9;
        else
            return 0x00000000;
    }

    var r = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
        3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
        1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
        4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
    ];

    var rh = [
        5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
        6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
        15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
        8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
        12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
    ];

    var s = [
        11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
        7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
        11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
        11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
        9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
    ];

    var sh = [
        8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
        9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
        9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
        15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
        8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
    ];

},{"../hash":48}],52:[function(require,module,exports){
    var hash = require('../hash');
    var utils = hash.utils;
    var assert = utils.assert;

    var rotr32 = utils.rotr32;
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var BlockHash = hash.common.BlockHash;

    var sha256_K = [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ];

    function SHA256() {
        if (!(this instanceof SHA256))
            return new SHA256();

        BlockHash.call(this);
        this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
            0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];
        this.k = sha256_K;
    }
    utils.inherits(SHA256, BlockHash);
    exports.sha256 = SHA256;

    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;

    SHA256.prototype._update = function _update(msg) {
        var W = new Array(64);
        for (var i = 0; i < 16; i++)
            W[i] = msg[i];
        for (; i < W.length; i++)
            W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f = this.h[5];
        var g = this.h[6];
        var h = this.h[7];

        assert(this.k.length === W.length);
        for (var i = 0; i < W.length; i++) {
            var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
            var T2 = sum32(s0_256(a), maj32(a, b, c));
            h = g;
            g = f;
            f = e;
            e = sum32(d, T1);
            d = c;
            c = b;
            b = a;
            a = sum32(T1, T2);
        }

        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h);
    };

    SHA256.prototype._digest = function digest(enc) {
        if (enc === 'hex')
            return utils.toHex32(this.h, 'big');
        else
            return utils.split32(this.h, 'big');
    };

    function SHA224() {
        if (!(this instanceof SHA224))
            return new SHA224();

        SHA256.call(this);
        this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
            0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
    }
    utils.inherits(SHA224, SHA256);
    exports.sha224 = SHA224;

    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;

    SHA224.prototype._digest = function digest(enc) {
        // Just truncate output
        if (enc === 'hex')
            return utils.toHex32(this.h.slice(0, 7), 'big');
        else
            return utils.split32(this.h.slice(0, 7), 'big');
    };

    function ch32(x, y, z) {
        return (x & y) ^ ((~x) & z);
    }

    function maj32(x, y, z) {
        return (x & y) ^ (x & z) ^ (y & z);
    }

    function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }

    function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }

    function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
    }

    function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
    }

},{"../hash":48}],53:[function(require,module,exports){
    var utils = exports;

    function toArray(msg, enc) {
        if (Array.isArray(msg))
            return msg.slice();
        if (!msg)
            return [];
        var res = [];
        if (typeof msg === 'string') {
            if (!enc) {
                for (var i = 0; i < msg.length; i++) {
                    var c = msg.charCodeAt(i);
                    var hi = c >> 8;
                    var lo = c & 0xff;
                    if (hi)
                        res.push(hi, lo);
                    else
                        res.push(lo);
                }
            } else if (enc === 'hex') {
                msg = msg.replace(/[^a-z0-9]+/ig, '');
                if (msg.length % 2 != 0)
                    msg = '0' + msg;
                for (var i = 0; i < msg.length; i += 2)
                    res.push(parseInt(msg[i] + msg[i + 1], 16));
            }
        } else {
            for (var i = 0; i < msg.length; i++)
                res[i] = msg[i] | 0;
        }
        return res;
    }
    utils.toArray = toArray;

    function toHex(msg) {
        var res = '';
        for (var i = 0; i < msg.length; i++)
            res += zero2(msg[i].toString(16));
        return res;
    }
    utils.toHex = toHex;

    function toHex32(msg, endian) {
        var res = '';
        for (var i = 0; i < msg.length; i++) {
            var w = msg[i];
            if (endian === 'little') {
                w = (w >>> 24) |
                    ((w >>> 8) & 0xff00) |
                    ((w << 8) & 0xff0000) |
                    ((w & 0xff) << 24);
                if (w < 0)
                    w += 0x100000000;
            }
            res += zero8(w.toString(16));
        }
        return res;
    }
    utils.toHex32 = toHex32;

    function zero2(word) {
        if (word.length === 1)
            return '0' + word;
        else
            return word;
    }
    utils.zero2 = zero2;

    function zero8(word) {
        if (word.length === 7)
            return '0' + word;
        else if (word.length === 6)
            return '00' + word;
        else if (word.length === 5)
            return '000' + word;
        else if (word.length === 4)
            return '0000' + word;
        else if (word.length === 3)
            return '00000' + word;
        else if (word.length === 2)
            return '000000' + word;
        else if (word.length === 1)
            return '0000000' + word;
        else
            return word;
    }
    utils.zero8 = zero8;

    function join32(msg, endian) {
        assert(msg.length % 4 === 0);
        var res = new Array(msg.length / 4);
        for (var i = 0, k = 0; i < res.length; i++, k += 4) {
            var w;
            if (endian === 'big')
                w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
            else
                w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
            if (w < 0)
                w += 0x100000000;
            res[i] = w;
        }
        return res;
    }
    utils.join32 = join32;

    function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
            var m = msg[i];
            if (endian === 'big') {
                res[k] = m >>> 24;
                res[k + 1] = (m >>> 16) & 0xff;
                res[k + 2] = (m >>> 8) & 0xff;
                res[k + 3] = m & 0xff;
            } else {
                res[k + 3] = m >>> 24;
                res[k + 2] = (m >>> 16) & 0xff;
                res[k + 1] = (m >>> 8) & 0xff;
                res[k] = m & 0xff;
            }
        }
        return res;
    }
    utils.split32 = split32;

    function rotr32(w, b) {
        return (w >>> b) | (w << (32 - b));
    }
    utils.rotr32 = rotr32;

    function rotl32(w, b) {
        return (w << b) | (w >>> (32 - b));
    }
    utils.rotl32 = rotl32;

    function sum32(a, b) {
        var r = (a + b) & 0xffffffff;
        if (r < 0)
            r += 0x100000000;
        return r;
    }
    utils.sum32 = sum32;

    function sum32_3(a, b, c) {
        var r = (a + b + c) & 0xffffffff;
        if (r < 0)
            r += 0x100000000;
        return r;
    }
    utils.sum32_3 = sum32_3;

    function sum32_4(a, b, c, d) {
        var r = (a + b + c + d) & 0xffffffff;
        if (r < 0)
            r += 0x100000000;
        return r;
    }
    utils.sum32_4 = sum32_4;

    function sum32_5(a, b, c, d, e) {
        var r = (a + b + c + d + e) & 0xffffffff;
        if (r < 0)
            r += 0x100000000;
        return r;
    }
    utils.sum32_5 = sum32_5;

    function assert(cond, msg) {
        if (!cond)
            throw new Error(msg || 'Assertion failed');
    }
    utils.assert = assert;

// Shamelessly copied from browserify
    if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        utils.inherits = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    } else {
        // old school shim for old browsers
        utils.inherits = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function () {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
        }
    }

},{}],54:[function(require,module,exports){
    module.exports={
        "name": "elliptic",
        "version": "0.15.17",
        "description": "EC cryptography",
        "main": "lib/elliptic.js",
        "scripts": {
            "test": "mocha --reporter=spec test/*-test.js"
        },
        "repository": {
            "type": "git",
            "url": "git@github.com:indutny/elliptic"
        },
        "keywords": [
            "EC",
            "Elliptic",
            "curve",
            "Cryptography"
        ],
        "author": {
            "name": "Fedor Indutny",
            "email": "fedor@indutny.com"
        },
        "license": "MIT",
        "bugs": {
            "url": "https://github.com/indutny/elliptic/issues"
        },
        "homepage": "https://github.com/indutny/elliptic",
        "devDependencies": {
            "browserify": "^3.44.2",
            "mocha": "^1.18.2",
            "uglify-js": "^2.4.13"
        },
        "dependencies": {
            "bn.js": "^0.16.0",
            "brorand": "^1.0.1",
            "hash.js": "^0.2.0",
            "inherits": "^2.0.1"
        },
        "readme": "# Elliptic [![Build Status](https://secure.travis-ci.org/indutny/elliptic.png)](http://travis-ci.org/indutny/elliptic)\n\nFast elliptic-curve cryptography in a plain javascript implementation.\n\nNOTE: Please take a look at http://safecurves.cr.yp.to/ before choosing a curve\nfor your cryptography operations.\n\n## Incentive\n\nECC is much slower than regular RSA cryptography, the JS implementations are\neven more slower.\n\n## Benchmarks\n\n```bash\n$ node benchmarks/index.js\nBenchmarking: sign\nelliptic#sign x 262 ops/sec 0.51% (177 runs sampled)\neccjs#sign x 55.91 ops/sec 0.90% (144 runs sampled)\n------------------------\nFastest is elliptic#sign\n========================\nBenchmarking: verify\nelliptic#verify x 113 ops/sec 0.50% (166 runs sampled)\neccjs#verify x 48.56 ops/sec 0.36% (125 runs sampled)\n------------------------\nFastest is elliptic#verify\n========================\nBenchmarking: gen\nelliptic#gen x 294 ops/sec 0.43% (176 runs sampled)\neccjs#gen x 62.25 ops/sec 0.63% (129 runs sampled)\n------------------------\nFastest is elliptic#gen\n========================\nBenchmarking: ecdh\nelliptic#ecdh x 136 ops/sec 0.85% (156 runs sampled)\n------------------------\nFastest is elliptic#ecdh\n========================\n```\n\n## API\n\n### ECDSA\n\n```javascript\nvar EC = require('elliptic').ec;\n\n// Create and initialize EC context\n// (better do it once and reuse it)\nvar ec = new EC('secp256k1');\n\n// Generate keys\nvar key = ec.genKeyPair();\n\n// Sign message (must be an array, or it'll be treated as a hex sequence)\nvar msg = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nvar signature = key.sign(msg);\n\n// Export DER encoded signature in Array\nvar derSign = signature.toDER();\n\n// Verify signature\nconsole.log(key.verify(msg, derSign));\n```\n\n### ECDH\n\n```javascript\n// Generate keys\nvar key1 = ec.genKeyPair();\nvar key2 = ec.genKeyPair();\n\nvar shared1 = key1.derive(key2.getPublic());\nvar shared2 = key2.derive(key1.getPublic());\n\nconsole.log('Both shared secrets are BN instances');\nconsole.log(shared1.toString(16));\nconsole.log(shared2.toString(16));\n```\n\nNOTE: `.derive()` returns a [BN][1] instance.\n\n## Supported curves\n\nElliptic.js support following curve types:\n\n* Short Weierstrass\n* Montgomery\n* Edwards\n* Twisted Edwards\n\nFollowing curve 'presets' are embedded into the library:\n\n* `secp256k1`\n* `p192`\n* `p224`\n* `p256`\n* `curve25519`\n* `ed25519`\n\nNOTE: That `curve25519` could not be used for ECDSA, use `ed25519` instead.\n\n### Implementation details\n\nECDSA is using deterministic `k` value generation as per [RFC6979][0]. Most of\nthe curve operations are performed on non-affine coordinates (either projective\nor extended), various windowing techniques are used for different cases.\n\nAll operations are performed in reduction context using [bn.js][1], hashing is\nprovided by [hash.js][2]\n\n#### LICENSE\n\nThis software is licensed under the MIT License.\n\nCopyright Fedor Indutny, 2014.\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the\nfollowing conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n\n[0]: http://tools.ietf.org/html/rfc6979\n[1]: https://github.com/indutny/bn.js\n[2]: https://github.com/indutny/hash.js\n",
        "readmeFilename": "README.md",
        "_id": "elliptic@0.15.17",
        "_from": "elliptic@^0.15.14"
    }

},{}],55:[function(require,module,exports){
    (function (Buffer){

        module.exports = function evp(crypto, password, salt, keyLen) {
            keyLen = keyLen/8;
            var ki = 0;
            var ii = 0;
            var key = new Buffer(keyLen);
            var addmd = 0;
            var md, md_buf;
            var i;
            while (true) {
                md = crypto.createHash('md5');
                if(addmd++ > 0) {
                    md.update(md_buf);
                }
                md.update(password);
                md.update(salt);
                md_buf = md.digest();
                i = 0;
                if(keyLen > 0) {
                    while(true) {
                        if(keyLen === 0) {
                            break;
                        }
                        if(i === md_buf.length) {
                            break;
                        }
                        key[ki++] = md_buf[i++];
                        keyLen--;
                    }
                }
                if(keyLen === 0) {
                    break;
                }
            }
            for(i=0;i<md_buf.length;i++) {
                md_buf[i] = 0;
            }
            return key;
        };
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],56:[function(require,module,exports){
    module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
        "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
        "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
        "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
        "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
        "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
        "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
        "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
        "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
        "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
        "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
        "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
    }
},{}],57:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.

    var asn1 = require('asn1.js');
    var rfc3280 = require('asn1.js-rfc3280');

    var RSAPrivateKey = asn1.define('RSAPrivateKey', function() {
        this.seq().obj(
            this.key('version').int(),
            this.key('modulus').int(),
            this.key('publicExponent').int(),
            this.key('privateExponent').int(),
            this.key('prime1').int(),
            this.key('prime2').int(),
            this.key('exponent1').int(),
            this.key('exponent2').int(),
            this.key('coefficient').int()
        );
    });
    exports.RSAPrivateKey = RSAPrivateKey;

    var RSAPublicKey = asn1.define('RSAPublicKey', function() {
        this.seq().obj(
            this.key('modulus').int(),
            this.key('publicExponent').int()
        );
    });
    exports.RSAPublicKey = RSAPublicKey;

    var PublicKey = rfc3280.SubjectPublicKeyInfo;
    exports.PublicKey = PublicKey;
    var ECPublicKey =  asn1.define('ECPublicKey', function() {
        this.seq().obj(
            this.key('algorithm').seq().obj(
                this.key('id').objid(),
                this.key('curve').objid()
            ),
            this.key('subjectPrivateKey').bitstr()
        );
    });
    exports.ECPublicKey = ECPublicKey;
    var ECPrivateWrap =  asn1.define('ECPrivateWrap', function() {
        this.seq().obj(
            this.key('version').int(),
            this.key('algorithm').seq().obj(
                this.key('id').objid(),
                this.key('curve').objid()
            ),
            this.key('subjectPrivateKey').octstr()
        );
    });
    exports.ECPrivateWrap = ECPrivateWrap;

    var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function() {
        this.seq().obj(
            this.key('version').int(),
            this.key('algorithm').use(rfc3280.AlgorithmIdentifier),
            this.key('subjectPrivateKey').octstr()
        );
    });
    exports.PrivateKey = PrivateKeyInfo;
    var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function() {
        this.seq().obj(
            this.key('algorithm').seq().obj(
                this.key('id').objid(),
                this.key('decrypt').seq().obj(
                    this.key('kde').seq().obj(
                        this.key('id').objid(),
                        this.key('kdeparams').seq().obj(
                            this.key('salt').octstr(),
                            this.key('iters').int()
                        )
                    ),
                    this.key('cipher').seq().obj(
                        this.key('algo').objid(),
                        this.key('iv').octstr()
                    )
                )
            ),
            this.key('subjectPrivateKey').octstr()
        );
    });
    var dsaParams = asn1.define('dsaParams', function() {
        this.seq().obj(
            this.key('algorithm').objid(),
            this.key('parameters').seq().obj(
                this.key('p').int(),
                this.key('q').int(),
                this.key('g').int()
            )
        );
    });
    exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
    var DSAPublicKey = asn1.define('DSAPublicKey', function() {
        this.seq().obj(
            this.key('algorithm').use(dsaParams),
            this.key('subjectPublicKey').bitstr()
        );
    });
    exports.DSAPublicKey = DSAPublicKey;
    var DSAPrivateWrap =  asn1.define('DSAPrivateWrap', function() {
        this.seq().obj(
            this.key('version').int(),
            this.key('algorithm').seq().obj(
                this.key('id').objid(),
                this.key('parameters').seq().obj(
                    this.key('p').int(),
                    this.key('q').int(),
                    this.key('g').int()
                )
            ),
            this.key('subjectPrivateKey').octstr()
        );
    });
    exports.DSAPrivateWrap = DSAPrivateWrap;
    var DSAPrivateKey = asn1.define('DSAPrivateKey', function() {
        this.seq().obj(
            this.key('version').int(),
            this.key('p').int(),
            this.key('q').int(),
            this.key('g').int(),
            this.key('pub_key').int(),
            this.key('priv_key').int()
        );
    });
    exports.DSAPrivateKey = DSAPrivateKey;

    exports.DSAparam = asn1.define('DSAparam', function () {
        this.int();
    });
    var ECPrivateKey = asn1.define('ECPrivateKey', function() {
        this.seq().obj(
            this.key('version').int(),
            this.key('privateKey').octstr(),
            this.key('parameters').optional().explicit(0).use(ECParameters),
            this.key('publicKey').optional().explicit(1).bitstr()
        );
    });
    exports.ECPrivateKey = ECPrivateKey;
    var ECParameters = asn1.define('ECParameters', function() {
        this.choice({
            namedCurve: this.objid()
        });
    });

    var ECPrivateKey2 = asn1.define('ECPrivateKey2', function() {
        this.seq().obj(
            this.key('version').int(),
            this.key('privateKey').octstr(),
            this.key('publicKey').seq().obj(
                this.key('key').bitstr()
            )
        );
    });
    exports.ECPrivateKey2 = ECPrivateKey2;

    exports.signature = asn1.define('signature', function() {
        this.seq().obj(
            this.key('r').int(),
            this.key('s').int()
        );
    });
},{"asn1.js":61,"asn1.js-rfc3280":60}],58:[function(require,module,exports){
    (function (Buffer){
        var findProc = /Proc-Type: 4,ENCRYPTED\n\r?DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\n\r?\n\r?([0-9A-z\n\r\+\/\=]+)\n\r?/m;
        var startRegex = /^-----BEGIN (.*)-----\n/;
        var evp = require('./EVP_BytesToKey');
        module.exports = function (okey, password, crypto) {
            var key = okey.toString();
            var match = key.match(findProc);
            if (!match) {
                return okey;
            }
            var suite = 'aes' + match[1];
            var iv = new Buffer(match[2], 'hex');
            var cipherText = new Buffer(match[3].replace(/\n\r?/g, ''), 'base64');
            var cipherKey = evp(crypto, password, iv.slice(0,8), parseInt(match[1]));
            var out = [];
            var cipher = crypto.createDecipheriv(suite, cipherKey, iv);
            out.push(cipher.update(cipherText));
            out.push(cipher.final());
            var decrypted = Buffer.concat(out).toString('base64');
            var tag = key.match(startRegex)[1];
            return '-----BEGIN ' + tag + "-----\n" + wrap(decrypted) + "\n" + '-----END ' + tag + "-----\n";
        };
// http://stackoverflow.com/a/7033705
        function wrap(str) {
            var chunks = [];
            while (str) {
                if (str.length < 64) {
                    chunks.push(str);
                    break;
                }
                else {
                    chunks.push(str.slice(0, 64));
                    str = str.slice(64);
                }
            }
            return chunks.join("\n");
        }
    }).call(this,require("buffer").Buffer)
},{"./EVP_BytesToKey":55,"buffer":3}],59:[function(require,module,exports){
    (function (Buffer){
        var pemstrip = require('pemstrip');
        var asn1 = require('./asn1');
        var aesid = require('./aesid.json');
        var fixProc = require('./fixProc');
        module.exports = parseKeys;

        function parseKeys(buffer, crypto) {
            var password;
            if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
                password = buffer.passphrase;
                buffer = buffer.key;
            }
            if (typeof buffer === 'string') {
                buffer = new Buffer(buffer);
            }
            if (password) {
                buffer = fixProc(buffer, password, crypto);
            }
            var stripped = pemstrip.strip(buffer);
            var type = stripped.tag;
            var data = new Buffer(stripped.base64, 'base64');
            var subtype,ndata;
            switch (type) {
                case 'PUBLIC KEY':
                    ndata = asn1.PublicKey.decode(data, 'der');
                    subtype = ndata.algorithm.algorithm.join('.');
                    switch(subtype) {
                        case '1.2.840.113549.1.1.1':
                            return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
                        case '1.2.840.10045.2.1':
                            return {
                                type: 'ec',
                                data:  asn1.ECPublicKey.decode(data, 'der')
                            };
                        case '1.2.840.10040.4.1':
                            ndata = asn1.DSAPublicKey.decode(data, 'der');
                            ndata.algorithm.parameters.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
                            return {
                                type: 'dsa',
                                data: ndata.algorithm.parameters
                            };
                        default: throw new Error('unknown key id ' +  subtype);
                    }
                    throw new Error('unknown key type ' +  type);
                case 'ENCRYPTED PRIVATE KEY':
                    data = asn1.EncryptedPrivateKey.decode(data, 'der');
                    data = decrypt(crypto, data, password);
                //falling through
                case 'PRIVATE KEY':
                    ndata = asn1.PrivateKey.decode(data, 'der');
                    subtype = ndata.algorithm.algorithm.join('.');
                    switch(subtype) {
                        case '1.2.840.113549.1.1.1':
                            return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
                        case '1.2.840.10045.2.1':
                            ndata =  asn1.ECPrivateWrap.decode(data, 'der');
                            return {
                                curve: ndata.algorithm.curve,
                                privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
                            };
                        case '1.2.840.10040.4.1':
                            ndata =  asn1.DSAPrivateWrap.decode(data, 'der');
                            ndata.algorithm.parameters.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
                            return {
                                type: 'dsa',
                                params: ndata.algorithm.parameters
                            };
                        default: throw new Error('unknown key id ' +  subtype);
                    }
                    throw new Error('unknown key type ' +  type);
                case 'RSA PUBLIC KEY':
                    return asn1.RSAPublicKey.decode(data, 'der');
                case 'RSA PRIVATE KEY':
                    return asn1.RSAPrivateKey.decode(data, 'der');
                case 'DSA PRIVATE KEY':
                    return {
                        type: 'dsa',
                        params: asn1.DSAPrivateKey.decode(data, 'der')
                    };
                case 'EC PRIVATE KEY':
                    data = asn1.ECPrivateKey.decode(data, 'der');
                    return {
                        curve: data.parameters.value,
                        privateKey: data.privateKey
                    };
                default: throw new Error('unknown key type ' +  type);
            }
        }
        parseKeys.signature = asn1.signature;
        function decrypt(crypto, data, password) {
            var salt = data.algorithm.decrypt.kde.kdeparams.salt;
            var iters = data.algorithm.decrypt.kde.kdeparams.iters;
            var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
            var iv = data.algorithm.decrypt.cipher.iv;
            var cipherText = data.subjectPrivateKey;
            var keylen = parseInt(algo.split('-')[1], 10)/8;
            var key = crypto.pbkdf2Sync(password, salt, iters, keylen);
            var cipher = crypto.createDecipheriv(algo, key, iv);
            var out = [];
            out.push(cipher.update(cipherText));
            out.push(cipher.final());
            return Buffer.concat(out);
        }
    }).call(this,require("buffer").Buffer)
},{"./aesid.json":56,"./asn1":57,"./fixProc":58,"buffer":3,"pemstrip":74}],60:[function(require,module,exports){
    try {
        var asn1 = require('asn1.js');
    } catch (e) {
        var asn1 = require('../' + '..');
    }

    var CRLReason = asn1.define('CRLReason', function() {
        this.enum({
            0: 'unspecified',
            1: 'keyCompromise',
            2: 'CACompromise',
            3: 'affiliationChanged',
            4: 'superseded',
            5: 'cessationOfOperation',
            6: 'certificateHold',
            8: 'removeFromCRL',
            9: 'privilegeWithdrawn',
            10: 'AACompromise'
        });
    });
    exports.CRLReason = CRLReason;

    var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function() {
        this.seq().obj(
            this.key('algorithm').objid(),
            this.key('parameters').optional().any()
        );
    });
    exports.AlgorithmIdentifier = AlgorithmIdentifier;

    var Certificate = asn1.define('Certificate', function() {
        this.seq().obj(
            this.key('tbsCertificate').use(TBSCertificate),
            this.key('signatureAlgorithm').use(AlgorithmIdentifier),
            this.key('signature').bitstr()
        );
    });
    exports.Certificate = Certificate;

    var TBSCertificate = asn1.define('TBSCertificate', function() {
        this.seq().obj(
            this.key('version').def('v1').explicit(0).use(Version),
            this.key('serialNumber').use(CertificateSerialNumber),
            this.key('signature').use(AlgorithmIdentifier),
            this.key('issuer').use(Name),
            this.key('validity').use(Validity),
            this.key('subject').use(Name),
            this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),

            // TODO(indutny): validate that version is v2 or v3
            this.key('issuerUniqueID').optional().explicit(1).use(UniqueIdentifier),
            this.key('subjectUniqueID').optional().explicit(2).use(UniqueIdentifier),

            // TODO(indutny): validate that version is v3
            this.key('extensions').optional().explicit(3).use(Extensions)
        );
    });
    exports.TBSCertificate = TBSCertificate;

    var Version = asn1.define('Version', function() {
        this.int({
            0: 'v1',
            1: 'v2',
            2: 'v3'
        });
    });
    exports.Version = Version;

    var CertificateSerialNumber = asn1.define('CertificateSerialNumber',
        function() {
            this.int();
        });
    exports.CertificateSerialNumber = CertificateSerialNumber;

    var Validity = asn1.define('Validity', function() {
        this.seq().obj(
            this.key('notBefore').use(Time),
            this.key('notAfter').use(Time)
        );
    });
    exports.Validity = Validity;

    var Time = asn1.define('Time', function() {
        this.choice({
            utcTime: this.utctime(),
            genTime: this.gentime()
        });
    });
    exports.Time = Time;

    var UniqueIdentifier = asn1.define('UniqueIdentifier', function() {
        this.bitstr();
    });
    exports.UniqueIdentifier = UniqueIdentifier;

    var SubjectPublicKeyInfo = asn1.define('SubjectPublicKeyInfo', function() {
        this.seq().obj(
            this.key('algorithm').use(AlgorithmIdentifier),
            this.key('subjectPublicKey').bitstr()
        );
    });
    exports.SubjectPublicKeyInfo = SubjectPublicKeyInfo;

    var Extensions = asn1.define('Extensions', function() {
        this.seqof(Extension);
    });
    exports.Extensions = Extensions;

    var Extension = asn1.define('Extension', function() {
        this.seq().obj(
            this.key('extnID').objid(),
            this.key('critical').bool().def(false),
            this.key('extnValue').octstr()
        );
    });
    exports.Extension = Extension;

    var Name = asn1.define('Name', function() {
        this.choice({
            rdn: this.use(RDNSequence)
        });
    });
    exports.Name = Name;

    var RDNSequence = asn1.define('RDNSequence', function() {
        this.seqof(RelativeDistinguishedName);
    });
    exports.RDNSequence = RDNSequence;

    var RelativeDistinguishedName = asn1.define('RelativeDistinguishedName',
        function() {
            this.setof(AttributeTypeAndValue);
        });
    exports.RelativeDistinguishedName = RelativeDistinguishedName;

    var AttributeTypeAndValue = asn1.define('AttributeTypeAndValue', function() {
        this.seq().obj(
            this.key('type').use(AttributeType),
            this.key('value').use(AttributeValue)
        );
    });
    exports.AttributeTypeAndValue = AttributeTypeAndValue;

    var AttributeType = asn1.define('AttributeType', function() {
        this.objid();
    });
    exports.AttributeType = AttributeType;

    var AttributeValue = asn1.define('AttributeValue', function() {
        this.any();
    });
    exports.AttributeValue = AttributeValue;

},{"asn1.js":61}],61:[function(require,module,exports){
    var asn1 = exports;

    asn1.bignum = require('bn.js');

    asn1.define = require('./asn1/api').define;
    asn1.base = require('./asn1/base');
    asn1.constants = require('./asn1/constants');
    asn1.decoders = require('./asn1/decoders');
    asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":62,"./asn1/base":64,"./asn1/constants":68,"./asn1/decoders":70,"./asn1/encoders":72,"bn.js":73}],62:[function(require,module,exports){
    var asn1 = require('../asn1');
    var util = require('util');
    var vm = require('vm');

    var api = exports;

    api.define = function define(name, body) {
        return new Entity(name, body);
    };

    function Entity(name, body) {
        this.name = name;
        this.body = body;

        this.decoders = {};
        this.encoders = {};
    };

    Entity.prototype._createNamed = function createNamed(base) {
        var named = vm.runInThisContext('(function ' + this.name + '(entity) {\n' +
            '  this._initNamed(entity);\n' +
            '})');
        util.inherits(named, base);
        named.prototype._initNamed = function initnamed(entity) {
            base.call(this, entity);
        };

        return new named(this);
    };

    Entity.prototype._getDecoder = function _getDecoder(enc) {
        // Lazily create decoder
        if (!this.decoders.hasOwnProperty(enc))
            this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
        return this.decoders[enc];
    };

    Entity.prototype.decode = function decode(data, enc, options) {
        return this._getDecoder(enc).decode(data, options);
    };

    Entity.prototype._getEncoder = function _getEncoder(enc) {
        // Lazily create encoder
        if (!this.encoders.hasOwnProperty(enc))
            this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
        return this.encoders[enc];
    };

    Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
        return this._getEncoder(enc).encode(data, reporter);
    };

},{"../asn1":61,"util":166,"vm":167}],63:[function(require,module,exports){
    var assert = require('assert');
    var util = require('util');
    var Reporter = require('../base').Reporter;
    var Buffer = require('buffer').Buffer;

    function DecoderBuffer(base, options) {
        Reporter.call(this, options);
        if (!Buffer.isBuffer(base)) {
            this.error('Input not Buffer');
            return;
        }

        this.base = base;
        this.offset = 0;
        this.length = base.length;
    }
    util.inherits(DecoderBuffer, Reporter);
    exports.DecoderBuffer = DecoderBuffer;

    DecoderBuffer.prototype.save = function save() {
        return { offset: this.offset };
    };

    DecoderBuffer.prototype.restore = function restore(save) {
        // Return skipped data
        var res = new DecoderBuffer(this.base);
        res.offset = save.offset;
        res.length = this.offset;

        this.offset = save.offset;

        return res;
    };

    DecoderBuffer.prototype.isEmpty = function isEmpty() {
        return this.offset === this.length;
    };

    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
        if (this.offset + 1 <= this.length)
            return this.base.readUInt8(this.offset++, true);
        else
            return this.error(fail || 'DecoderBuffer overrun');
    }

    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
        if (!(this.offset + bytes <= this.length))
            return this.error(fail || 'DecoderBuffer overrun');

        var res = new DecoderBuffer(this.base);

        // Share reporter state
        res._reporterState = this._reporterState;

        res.offset = this.offset;
        res.length = this.offset + bytes;
        this.offset += bytes;
        return res;
    }

    DecoderBuffer.prototype.raw = function raw(save) {
        return this.base.slice(save ? save.offset : this.offset, this.length);
    }

    function EncoderBuffer(value, reporter) {
        if (Array.isArray(value)) {
            this.length = 0;
            this.value = value.map(function(item) {
                if (!(item instanceof EncoderBuffer))
                    item = new EncoderBuffer(item, reporter);
                this.length += item.length;
                return item;
            }, this);
        } else if (typeof value === 'number') {
            if (!(0 <= value && value <= 0xff))
                return reporter.error('non-byte EncoderBuffer value');
            this.value = value;
            this.length = 1;
        } else if (typeof value === 'string') {
            this.value = value;
            this.length = Buffer.byteLength(value);
        } else if (Buffer.isBuffer(value)) {
            this.value = value;
            this.length = value.length;
        } else {
            return reporter.error('Unsupported type: ' + typeof value);
        }
    }
    exports.EncoderBuffer = EncoderBuffer;

    EncoderBuffer.prototype.join = function join(out, offset) {
        if (!out)
            out = new Buffer(this.length);
        if (!offset)
            offset = 0;

        if (this.length === 0)
            return out;

        if (Array.isArray(this.value)) {
            this.value.forEach(function(item) {
                item.join(out, offset);
                offset += item.length;
            });
        } else {
            if (typeof this.value === 'number')
                out[offset] = this.value;
            else if (typeof this.value === 'string')
                out.write(this.value, offset);
            else if (Buffer.isBuffer(this.value))
                this.value.copy(out, offset);
            offset += this.length;
        }

        return out;
    };

},{"../base":64,"assert":1,"buffer":3,"util":166}],64:[function(require,module,exports){
    var base = exports;

    base.Reporter = require('./reporter').Reporter;
    base.DecoderBuffer = require('./buffer').DecoderBuffer;
    base.EncoderBuffer = require('./buffer').EncoderBuffer;
    base.Node = require('./node');

},{"./buffer":63,"./node":65,"./reporter":66}],65:[function(require,module,exports){
    var assert = require('assert');
    var Reporter = require('../base').Reporter;
    var EncoderBuffer = require('../base').EncoderBuffer;

// Supported tags
    var tags = [
        'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
        'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str'
    ];

// Public methods list
    var methods = [
        'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
        'any'
    ].concat(tags);

// Overrided methods list
    var overrided = [
        '_peekTag', '_decodeTag', '_use',
        '_decodeStr', '_decodeObjid', '_decodeTime',
        '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

        '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
        '_encodeNull', '_encodeInt', '_encodeBool'
    ];

    function Node(enc, parent) {
        var state = {};
        this._baseState = state;

        state.enc = enc;

        state.parent = parent || null;
        state.children = null;

        // State
        state.tag = null;
        state.args = null;
        state.reverseArgs = null;
        state.choice = null;
        state.optional = false;
        state.any = false;
        state.obj = false;
        state.use = null;
        state.useDecoder = null;
        state.key = null;
        state['default'] = null;
        state.explicit = null;
        state.implicit = null;

        // Should create new instance on each method
        if (!state.parent) {
            state.children = [];
            this._wrap();
        }
    }
    module.exports = Node;

    var stateProps = [
        'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
        'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
        'implicit'
    ];

    Node.prototype.clone = function clone() {
        var state = this._baseState;
        var cstate = {};
        stateProps.forEach(function(prop) {
            cstate[prop] = state[prop];
        });
        var res = new this.constructor(cstate.parent);
        res._baseState = cstate;
        return res;
    };

    Node.prototype._wrap = function wrap() {
        var state = this._baseState;
        methods.forEach(function(method) {
            this[method] = function _wrappedMethod() {
                var clone = new this.constructor(this);
                state.children.push(clone);
                return clone[method].apply(clone, arguments);
            };
        }, this);
    };

    Node.prototype._init = function init(body) {
        var state = this._baseState;

        assert(state.parent === null);
        body.call(this);

        // Filter children
        state.children = state.children.filter(function(child) {
            return child._baseState.parent === this;
        }, this);
        assert.equal(state.children.length, 1, 'Root node can have only one child');
    };

    Node.prototype._useArgs = function useArgs(args) {
        var state = this._baseState;

        // Filter children and args
        var children = args.filter(function(arg) {
            return arg instanceof this.constructor;
        }, this);
        args = args.filter(function(arg) {
            return !(arg instanceof this.constructor);
        }, this);

        if (children.length !== 0) {
            assert(state.children === null);
            state.children = children;

            // Replace parent to maintain backward link
            children.forEach(function(child) {
                child._baseState.parent = this;
            }, this);
        }
        if (args.length !== 0) {
            assert(state.args === null);
            state.args = args;
            state.reverseArgs = args.map(function(arg) {
                if (typeof arg !== 'object' || arg.constructor !== Object)
                    return arg;

                var res = {};
                Object.keys(arg).forEach(function(key) {
                    if (key == (key | 0))
                        key |= 0;
                    var value = arg[key];
                    res[value] = key;
                });
                return res;
            });
        }
    };

//
// Overrided methods
//

    overrided.forEach(function(method) {
        Node.prototype[method] = function _overrided() {
            var state = this._baseState;
            throw new Error(method + ' not implemented for encoding: ' + state.enc);
        };
    });

//
// Public methods
//

    tags.forEach(function(tag) {
        Node.prototype[tag] = function _tagMethod() {
            var state = this._baseState;
            var args = Array.prototype.slice.call(arguments);

            assert(state.tag === null);
            state.tag = tag;

            this._useArgs(args);

            return this;
        };
    });

    Node.prototype.use = function use(item) {
        var state = this._baseState;

        assert(state.use === null);
        state.use = item;

        return this;
    };

    Node.prototype.optional = function optional() {
        var state = this._baseState;

        state.optional = true;

        return this;
    };

    Node.prototype.def = function def(val) {
        var state = this._baseState;

        assert(state['default'] === null);
        state['default'] = val;
        state.optional = true;

        return this;
    };

    Node.prototype.explicit = function explicit(num) {
        var state = this._baseState;

        assert(state.explicit === null && state.implicit === null);
        state.explicit = num;

        return this;
    };

    Node.prototype.implicit = function implicit(num) {
        var state = this._baseState;

        assert(state.explicit === null && state.implicit === null);
        state.implicit = num;

        return this;
    };

    Node.prototype.obj = function obj() {
        var state = this._baseState;
        var args = Array.prototype.slice.call(arguments);

        state.obj = true;

        if (args.length !== 0)
            this._useArgs(args);

        return this;
    };

    Node.prototype.key = function key(key) {
        var state = this._baseState;

        assert(state.key === null);
        state.key = key;

        return this;
    };

    Node.prototype.any = function any() {
        var state = this._baseState;

        state.any = true;

        return this;
    };

    Node.prototype.choice = function choice(obj) {
        var state = this._baseState;

        assert(state.choice === null);
        state.choice = obj;
        this._useArgs(Object.keys(obj).map(function(key) {
            return obj[key];
        }));

        return this;
    };

//
// Decoding
//

    Node.prototype._decode = function decode(input) {
        var state = this._baseState;

        // Decode root node
        if (state.parent === null)
            return input.wrapResult(state.children[0]._decode(input));

        var result = state['default'];
        var present = true;

        var prevKey;
        if (state.key !== null)
            prevKey = input.enterKey(state.key);

        // Check if tag is there
        if (state.optional) {
            present = this._peekTag(
                input,
                state.explicit !== null ? state.explicit :
                    state.implicit !== null ? state.implicit :
                    state.tag || 0
            );
            if (input.isError(present))
                return present;
        }

        // Push object on stack
        var prevObj;
        if (state.obj && present)
            prevObj = input.enterObject();

        if (present) {
            // Unwrap explicit values
            if (state.explicit !== null) {
                var explicit = this._decodeTag(input, state.explicit);
                if (input.isError(explicit))
                    return explicit;
                input = explicit;
            }

            // Unwrap implicit and normal values
            if (state.use === null && state.choice === null) {
                if (state.any)
                    var save = input.save();
                var body = this._decodeTag(
                    input,
                    state.implicit !== null ? state.implicit : state.tag,
                    state.any
                );
                if (input.isError(body))
                    return body;

                if (state.any)
                    result = input.raw(save);
                else
                    input = body;
            }

            // Select proper method for tag
            if (state.any)
                result = result;
            else if (state.choice === null)
                result = this._decodeGeneric(state.tag, input);
            else
                result = this._decodeChoice(input);

            if (input.isError(result))
                return result;

            // Decode children
            if (!state.any && state.choice === null && state.children !== null) {
                var fail = state.children.some(function decodeChildren(child) {
                    // NOTE: We are ignoring errors here, to let parser continue with other
                    // parts of encoded data
                    child._decode(input);
                });
                if (fail)
                    return err;
            }
        }

        // Pop object
        if (state.obj && present)
            result = input.leaveObject(prevObj);

        // Set key
        if (state.key !== null && (result !== null || present === true))
            input.leaveKey(prevKey, state.key, result);

        return result;
    };

    Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
        var state = this._baseState;

        if (tag === 'seq' || tag === 'set')
            return null;
        if (tag === 'seqof' || tag === 'setof')
            return this._decodeList(input, tag, state.args[0]);
        else if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
            return this._decodeStr(input, tag);
        else if (tag === 'objid' && state.args)
            return this._decodeObjid(input, state.args[0], state.args[1]);
        else if (tag === 'objid')
            return this._decodeObjid(input, null, null);
        else if (tag === 'gentime' || tag === 'utctime')
            return this._decodeTime(input, tag);
        else if (tag === 'null_')
            return this._decodeNull(input);
        else if (tag === 'bool')
            return this._decodeBool(input);
        else if (tag === 'int' || tag === 'enum')
            return this._decodeInt(input, state.args && state.args[0]);
        else if (state.use !== null)
            return this._getUse(state.use, input._reporterState.obj)._decode(input);
        else
            return input.error('unknown tag: ' + tag);

        return null;
    };

    Node.prototype._getUse = function _getUse(entity, obj) {

        var state = this._baseState;
        // Create altered use decoder if implicit is set
        state.useDecoder = this._use(entity, obj);
        assert(state.useDecoder._baseState.parent === null);
        state.useDecoder = state.useDecoder._baseState.children[0];
        if (state.implicit !== state.useDecoder._baseState.implicit) {
            state.useDecoder = state.useDecoder.clone();
            state.useDecoder._baseState.implicit = state.implicit;
        }
        return state.useDecoder;
    };

    Node.prototype._decodeChoice = function decodeChoice(input) {
        var state = this._baseState;
        var result = null;
        var match = false;

        Object.keys(state.choice).some(function(key) {
            var save = input.save();
            var node = state.choice[key];
            try {
                var value = node._decode(input);
                if (input.isError(value))
                    return false;

                result = { type: key, value: value };
                match = true;
            } catch (e) {
                input.restore(save);
                return false;
            }
            return true;
        }, this);

        if (!match)
            return input.error('Choice not matched');

        return result;
    };

//
// Encoding
//

    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
        return new EncoderBuffer(data, this.reporter);
    };

    Node.prototype._encode = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state['default'] !== null && state['default'] === data)
            return;

        var result = this._encodeValue(data, reporter, parent);
        if (result === undefined)
            return;

        if (this._skipDefault(result, reporter, parent))
            return;

        return result;
    };

    Node.prototype._encodeValue = function encode(data, reporter, parent) {
        var state = this._baseState;

        // Decode root node
        if (state.parent === null)
            return state.children[0]._encode(data, reporter || new Reporter());

        var result = null;
        var present = true;

        // Set reporter to share it with a child class
        this.reporter = reporter;

        // Check if data is there
        if (state.optional && data === undefined) {
            if (state['default'] !== null)
                data = state['default']
            else
                return;
        }

        // For error reporting
        var prevKey;

        // Encode children first
        var content = null;
        var primitive = false;
        if (state.any) {
            // Anything that was given is translated to buffer
            result = this._createEncoderBuffer(data);
        } else if (state.choice) {
            result = this._encodeChoice(data, reporter);
        } else if (state.children) {
            content = state.children.map(function(child) {
                if (child._baseState.tag === 'null_')
                    return child._encode(null, reporter, data);

                if (child._baseState.key === null)
                    return reporter.error('Child should have a key');
                var prevKey = reporter.enterKey(child._baseState.key);

                if (typeof data !== 'object')
                    return reporter.error('Child expected, but input is not object');

                var res = child._encode(data[child._baseState.key], reporter, data);
                reporter.leaveKey(prevKey);

                return res;
            }, this).filter(function(child) {
                return child;
            });

            content = this._createEncoderBuffer(content);
        } else {
            if (state.tag === 'seqof' || state.tag === 'setof') {
                // TODO(indutny): this should be thrown on DSL level
                if (!(state.args && state.args.length === 1))
                    return reporter.error('Too many args for : ' + state.tag);

                if (!Array.isArray(data))
                    return reporter.error('seqof/setof, but data is not Array');

                var child = this.clone();
                child._baseState.implicit = null;
                content = this._createEncoderBuffer(data.map(function(item) {
                    var state = this._baseState;

                    return this._getUse(state.args[0], data)._encode(item, reporter);
                }, child));
            } else if (state.use !== null) {
                result = this._getUse(state.use, parent)._encode(data, reporter);
            } else {
                content = this._encodePrimitive(state.tag, data);
                primitive = true;
            }
        }

        // Encode data itself
        var result;
        if (!state.any && state.choice === null) {
            var tag = state.implicit !== null ? state.implicit : state.tag;
            var cls = state.implicit === null ? 'universal' : 'context';

            if (tag === null) {
                if (state.use === null)
                    reporter.error('Tag could be ommited only for .use()');
            } else {
                if (state.use === null)
                    result = this._encodeComposite(tag, primitive, cls, content);
            }
        }

        // Wrap in explicit
        if (state.explicit !== null)
            result = this._encodeComposite(state.explicit, false, 'context', result);

        return result;
    };

    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
        var state = this._baseState;

        var node = state.choice[data.type];
        if (!node) {
            assert(
                false,
                data.type + ' not found in ' +
                JSON.stringify(Object.keys(state.choice)));
        }
        return node._encode(data.value, reporter);
    };

    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
        var state = this._baseState;

        if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
            return this._encodeStr(data, tag);
        else if (tag === 'objid' && state.args)
            return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
        else if (tag === 'objid')
            return this._encodeObjid(data, null, null);
        else if (tag === 'gentime' || tag === 'utctime')
            return this._encodeTime(data, tag);
        else if (tag === 'null_')
            return this._encodeNull();
        else if (tag === 'int' || tag === 'enum')
            return this._encodeInt(data, state.args && state.reverseArgs[0]);
        else if (tag === 'bool')
            return this._encodeBool(data);
        else
            throw new Error('Unsupported tag: ' + tag);
    };

},{"../base":64,"assert":1}],66:[function(require,module,exports){
    var util = require('util');

    function Reporter(options) {
        this._reporterState = {
            obj: null,
            path: [],
            options: options || {},
            errors: []
        };
    }
    exports.Reporter = Reporter;

    Reporter.prototype.isError = function isError(obj) {
        return obj instanceof ReporterError;
    };

    Reporter.prototype.enterKey = function enterKey(key) {
        return this._reporterState.path.push(key);
    };

    Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
        var state = this._reporterState;

        state.path = state.path.slice(0, index - 1);
        if (state.obj !== null)
            state.obj[key] = value;
    };

    Reporter.prototype.enterObject = function enterObject() {
        var state = this._reporterState;

        var prev = state.obj;
        state.obj = {};
        return prev;
    };

    Reporter.prototype.leaveObject = function leaveObject(prev) {
        var state = this._reporterState;

        var now = state.obj;
        state.obj = prev;
        return now;
    };

    Reporter.prototype.error = function error(msg) {
        var err;
        var state = this._reporterState;

        var inherited = msg instanceof ReporterError;
        if (inherited) {
            err = msg;
        } else {
            err = new ReporterError(state.path.map(function(elem) {
                return '[' + JSON.stringify(elem) + ']';
            }).join(''), msg.message || msg, msg.stack);
        }

        if (!state.options.partial)
            throw err;

        if (!inherited)
            state.errors.push(err);

        return err;
    };

    Reporter.prototype.wrapResult = function wrapResult(result) {
        var state = this._reporterState;
        if (!state.options.partial)
            return result;

        return {
            result: this.isError(result) ? null : result,
            errors: state.errors
        };
    };

    function ReporterError(path, msg) {
        this.path = path;
        this.rethrow(msg);
    };
    util.inherits(ReporterError, Error);

    ReporterError.prototype.rethrow = function rethrow(msg) {
        this.message = msg + ' at: ' + (this.path || '(shallow)');
        Error.captureStackTrace(this, ReporterError);

        return this;
    };

},{"util":166}],67:[function(require,module,exports){
    var constants = require('../constants');

    exports.tagClass = {
        0: 'universal',
        1: 'application',
        2: 'context',
        3: 'private'
    };
    exports.tagClassByName = constants._reverse(exports.tagClass);

    exports.tag = {
        0x00: 'end',
        0x01: 'bool',
        0x02: 'int',
        0x03: 'bitstr',
        0x04: 'octstr',
        0x05: 'null_',
        0x06: 'objid',
        0x07: 'objDesc',
        0x08: 'external',
        0x09: 'real',
        0x0a: 'enum',
        0x0b: 'embed',
        0x0c: 'utf8str',
        0x0d: 'relativeOid',
        0x10: 'seq',
        0x11: 'set',
        0x12: 'numstr',
        0x13: 'printstr',
        0x14: 't61str',
        0x15: 'videostr',
        0x16: 'ia5str',
        0x17: 'utctime',
        0x18: 'gentime',
        0x19: 'graphstr',
        0x1a: 'iso646str',
        0x1b: 'genstr',
        0x1c: 'unistr',
        0x1d: 'charstr',
        0x1e: 'bmpstr'
    };
    exports.tagByName = constants._reverse(exports.tag);

},{"../constants":68}],68:[function(require,module,exports){
    var constants = exports;

// Helper
    constants._reverse = function reverse(map) {
        var res = {};

        Object.keys(map).forEach(function(key) {
            // Convert key to integer if it is stringified
            if ((key | 0) == key)
                key = key | 0;

            var value = map[key];
            res[value] = key;
        });

        return res;
    };

    constants.der = require('./der');

},{"./der":67}],69:[function(require,module,exports){
    var util = require('util');

    var asn1 = require('../../asn1');
    var base = asn1.base;
    var bignum = asn1.bignum;

// Import DER constants
    var der = asn1.constants.der;

    function DERDecoder(entity) {
        this.enc = 'der';
        this.name = entity.name;
        this.entity = entity;

        // Construct base tree
        this.tree = new DERNode();
        this.tree._init(entity.body);
    };
    module.exports = DERDecoder;

    DERDecoder.prototype.decode = function decode(data, options) {
        if (!(data instanceof base.DecoderBuffer))
            data = new base.DecoderBuffer(data, options);

        return this.tree._decode(data, options);
    };

// Tree methods

    function DERNode(parent) {
        base.Node.call(this, 'der', parent);
    }
    util.inherits(DERNode, base.Node);

    DERNode.prototype._peekTag = function peekTag(buffer, tag) {
        if (buffer.isEmpty())
            return false;

        var state = buffer.save();
        var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
        if (buffer.isError(decodedTag))
            return decodedTag;

        buffer.restore(state);

        return decodedTag.tag === tag || decodedTag.tagStr === tag;
    };

    DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
        var decodedTag = derDecodeTag(buffer,
            'Failed to decode tag of "' + tag + '"');
        if (buffer.isError(decodedTag))
            return decodedTag;

        var len = derDecodeLen(buffer,
            decodedTag.primitive,
            'Failed to get length of "' + tag + '"');

        // Failure
        if (buffer.isError(len))
            return len;

        if (!any &&
            decodedTag.tag !== tag &&
            decodedTag.tagStr !== tag &&
            decodedTag.tagStr + 'of' !== tag) {
            return buffer.error('Failed to match tag: "' + tag + '"');
        }

        if (decodedTag.primitive || len !== null)
            return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

        // Indefinite length... find END tag
        var state = buffer.start();
        var res = this._skipUntilEnd(
            buffer,
            'Failed to skip indefinite length body: "' + this.tag + '"');
        if (buffer.isError(res))
            return res;

        return buffer.cut(state);
    };

    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
        while (true) {
            var tag = derDecodeTag(buffer, fail);
            if (buffer.isError(tag))
                return tag;
            var len = derDecodeLen(buffer, tag.primitive, fail);
            if (buffer.isError(len))
                return len;

            var res;
            if (tag.primitive || len !== null)
                res = buffer.skip(len)
            else
                res = this._skipUntilEnd(buffer, fail);

            // Failure
            if (buffer.isError(res))
                return res;

            if (tag.tagStr === 'end')
                break;
        }
    };

    DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
        var result = [];
        while (!buffer.isEmpty()) {
            var possibleEnd = this._peekTag(buffer, 'end');
            if (buffer.isError(possibleEnd))
                return possibleEnd;

            var res = decoder.decode(buffer, 'der');
            if (buffer.isError(res) && possibleEnd)
                break;
            result.push(res);
        }
        return result;
    };

    DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
        if (tag === 'octstr') {
            return buffer.raw();
        } else if (tag === 'bitstr') {
            var unused = buffer.readUInt8();
            if (buffer.isError(unused))
                return unused;

            return { unused: unused, data: buffer.raw() };
        } else if (tag === 'ia5str') {
            return buffer.raw().toString();
        } else {
            return this.error('Decoding of string type: ' + tag + ' unsupported');
        }
    };

    DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
        var identifiers = [];
        var ident = 0;
        while (!buffer.isEmpty()) {
            var subident = buffer.readUInt8();
            ident <<= 7;
            ident |= subident & 0x7f;
            if ((subident & 0x80) === 0) {
                identifiers.push(ident);
                ident = 0;
            }
        }
        if (subident & 0x80)
            identifiers.push(ident);

        var first = (identifiers[0] / 40) | 0;
        var second = identifiers[0] % 40;

        if (relative)
            result = identifiers;
        else
            result = [first, second].concat(identifiers.slice(1));

        if (values)
            result = values[result.join(' ')];

        return result;
    };

    DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
        var str = buffer.raw().toString();
        if (tag === 'gentime') {
            var year = str.slice(0, 4) | 0;
            var mon = str.slice(4, 6) | 0;
            var day = str.slice(6, 8) | 0;
            var hour = str.slice(8, 10) | 0;
            var min = str.slice(10, 12) | 0;
            var sec = str.slice(12, 14) | 0;
        } else if (tag === 'utctime') {
            var year = str.slice(0, 2) | 0;
            var mon = str.slice(2, 4) | 0;
            var day = str.slice(4, 6) | 0;
            var hour = str.slice(6, 8) | 0;
            var min = str.slice(8, 10) | 0;
            var sec = str.slice(10, 12) | 0;
            if (year < 70)
                year = 2000 + year;
            else
                year = 1900 + year;
        } else {
            return this.error('Decoding ' + tag + ' time is not supported yet');
        }

        return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };

    DERNode.prototype._decodeNull = function decodeNull(buffer) {
        return null;
    };

    DERNode.prototype._decodeBool = function decodeBool(buffer) {
        var res = buffer.readUInt8();
        if (buffer.isError(res))
            return res;
        else
            return res !== 0;
    };

    DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
        var res = 0;

        // Bigint, return as it is (assume big endian)
        var raw = buffer.raw();
        if (raw.length > 3)
            return new bignum(raw);

        while (!buffer.isEmpty()) {
            res <<= 8;
            var i = buffer.readUInt8();
            if (buffer.isError(i))
                return i;
            res |= i;
        }

        if (values)
            res = values[res] || res;

        return res;
    };

    DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === 'function')
            entity = entity(obj);
        return entity._getDecoder('der').tree;
    };

// Utility methods

    function derDecodeTag(buf, fail) {
        var tag = buf.readUInt8(fail);
        if (buf.isError(tag))
            return tag;

        var cls = der.tagClass[tag >> 6];
        var primitive = (tag & 0x20) === 0;

        // Multi-octet tag - load
        if ((tag & 0x1f) === 0x1f) {
            var oct = tag;
            tag = 0;
            while ((oct & 0x80) === 0x80) {
                oct = buf.readUInt8(fail);
                if (buf.isError(oct))
                    return oct;

                tag <<= 7;
                tag |= oct & 0x7f;
            }
        } else {
            tag &= 0x1f;
        }
        var tagStr = der.tag[tag];

        return {
            cls: cls,
            primitive: primitive,
            tag: tag,
            tagStr: tagStr
        };
    }

    function derDecodeLen(buf, primitive, fail) {
        var len = buf.readUInt8(fail);
        if (buf.isError(len))
            return len;

        // Indefinite form
        if (!primitive && len === 0x80)
            return null;

        // Definite form
        if ((len & 0x80) === 0) {
            // Short form
            return len;
        }

        // Long form
        var num = len & 0x7f;
        if (num >= 4)
            return buf.error('length octect is too long');

        len = 0;
        for (var i = 0; i < num; i++) {
            len <<= 8;
            var j = buf.readUInt8(fail);
            if (buf.isError(j))
                return j;
            len |= j;
        }

        return len;
    }

},{"../../asn1":61,"util":166}],70:[function(require,module,exports){
    var decoders = exports;

    decoders.der = require('./der');

},{"./der":69}],71:[function(require,module,exports){
    var util = require('util');
    var Buffer = require('buffer').Buffer;

    var asn1 = require('../../asn1');
    var base = asn1.base;
    var bignum = asn1.bignum;

// Import DER constants
    var der = asn1.constants.der;

    function DEREncoder(entity) {
        this.enc = 'der';
        this.name = entity.name;
        this.entity = entity;

        // Construct base tree
        this.tree = new DERNode();
        this.tree._init(entity.body);
    };
    module.exports = DEREncoder;

    DEREncoder.prototype.encode = function encode(data, reporter) {
        return this.tree._encode(data, reporter).join();
    };

// Tree methods

    function DERNode(parent) {
        base.Node.call(this, 'der', parent);
    }
    util.inherits(DERNode, base.Node);

    DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                                  primitive,
                                                                  cls,
                                                                  content) {
        var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

        // Short form
        if (content.length < 0x80) {
            var header = new Buffer(2);
            header[0] = encodedTag;
            header[1] = content.length;
            return this._createEncoderBuffer([ header, content ]);
        }

        // Long form
        // Count octets required to store length
        var lenOctets = 1;
        for (var i = content.length; i >= 0x100; i >>= 8)
            lenOctets++;

        var header = new Buffer(1 + 1 + lenOctets);
        header[0] = encodedTag;
        header[1] = 0x80 | lenOctets;

        for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
            header[i] = j & 0xff;

        return this._createEncoderBuffer([ header, content ]);
    };

    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
        if (tag === 'octstr')
            return this._createEncoderBuffer(str);
        else if (tag === 'bitstr')
            return this._createEncoderBuffer([ str.unused | 0, str.data ]);
        else if (tag === 'ia5str')
            return this._createEncoderBuffer(str);
        return this.reporter.error('Encoding of string type: ' + tag +
            ' unsupported');
    };

    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
        if (typeof id === 'string') {
            if (!values)
                return this.reporter.error('string objid given, but no values map found');
            if (!values.hasOwnProperty(id))
                return this.reporter.error('objid not found in values map');
            id = values[id].split(/\s+/g);
            for (var i = 0; i < id.length; i++)
                id[i] |= 0;
        } else if (Array.isArray(id)) {
            id = id.slice();
        }

        if (!Array.isArray(id)) {
            return this.reporter.error('objid() should be either array or string, ' +
                'got: ' + JSON.stringify(id));
        }

        if (!relative) {
            if (id[1] >= 40)
                return this.reporter.error('Second objid identifier OOB');
            id.splice(0, 2, id[0] * 40 + id[1]);
        }

        // Count number of octets
        var size = 0;
        for (var i = 0; i < id.length; i++) {
            var ident = id[i];
            for (size++; ident >= 0x80; ident >>= 7)
                size++;
        }

        var objid = new Buffer(size);
        var offset = objid.length - 1;
        for (var i = id.length - 1; i >= 0; i--) {
            var ident = id[i];
            objid[offset--] = ident & 0x7f;
            while ((ident >>= 7) > 0)
                objid[offset--] = 0x80 | (ident & 0x7f);
        }

        return this._createEncoderBuffer(objid);
    };

    function two(num) {
        if (num <= 10)
            return '0' + num;
        else
            return num;
    }

    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
        var str;
        var date = new Date(time);

        if (tag === 'gentime') {
            str = [
                date.getFullYear(),
                two(date.getUTCMonth() + 1),
                two(date.getUTCDate()),
                two(date.getUTCHours()),
                two(date.getUTCMinutes()),
                two(date.getUTCSeconds()),
                'Z'
            ].join('');
        } else if (tag === 'utctime') {
            str = [
                date.getFullYear() % 100,
                two(date.getUTCMonth() + 1),
                two(date.getUTCDate()),
                two(date.getUTCHours()),
                two(date.getUTCMinutes()),
                two(date.getUTCSeconds()),
                'Z'
            ].join('');
        } else {
            this.reporter.error('Encoding ' + tag + ' time is not supported yet');
        }

        return this._encodeStr(str, 'octstr');
    };

    DERNode.prototype._encodeNull = function encodeNull() {
        return this._createEncoderBuffer('');
    };

    DERNode.prototype._encodeInt = function encodeInt(num, values) {
        if (typeof num === 'string') {
            if (!values)
                return this.reporter.error('String int or enum given, but no values map');
            if (!values.hasOwnProperty(num)) {
                return this.reporter.error('Values map doesn\'t contain: ' +
                    JSON.stringify(num));
            }
            num = values[num];
        }

        // Bignum, assume big endian
        if (bignum !== null && num instanceof bignum) {
            var numArray = num.toArray();
            if(num.sign === false && numArray[0] & 0x80) {
                numArray.unshift(0);
            }
            num = new Buffer(numArray);
        }

        if (Buffer.isBuffer(num)) {
            var size = num.length;
            if (num.length === 0)
                size++;

            var out = new Buffer(size);
            num.copy(out);
            if (num.length === 0)
                out[0] = 0
            return this._createEncoderBuffer(out);
        }

        if (num < 0x80)
            return this._createEncoderBuffer(num);

        if (num < 0x100)
            return this._createEncoderBuffer([0, num]);

        var size = 1;
        for (var i = num; i >= 0x100; i >>= 8)
            size++;

        var out = new Array(size);
        for (var i = out.length - 1; i >= 0; i--) {
            out[i] = num & 0xff;
            num >>= 8;
        }
        if(out[0] & 0x80) {
            out.unshift(0);
        }

        return this._createEncoderBuffer(new Buffer(out));
    };

    DERNode.prototype._encodeBool = function encodeBool(value) {
        return this._createEncoderBuffer(value ? 0xff : 0);
    };

    DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === 'function')
            entity = entity(obj);
        return entity._getEncoder('der').tree;
    };

    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
        var state = this._baseState;
        var i;
        if (state['default'] === null)
            return false;

        var data = dataBuffer.join();
        if (state.defaultBuffer === undefined)
            state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

        if (data.length !== state.defaultBuffer.length)
            return false;

        for (i=0; i < data.length; i++)
            if (data[i] !== state.defaultBuffer[i])
                return false;

        return true;
    };

// Utility methods

    function encodeTag(tag, primitive, cls, reporter) {
        var res;

        if (tag === 'seqof')
            tag = 'seq';
        else if (tag === 'setof')
            tag = 'set';

        if (der.tagByName.hasOwnProperty(tag))
            res = der.tagByName[tag];
        else if (typeof tag === 'number' && (tag | 0) === tag)
            res = tag;
        else
            return reporter.error('Unknown tag: ' + tag);

        if (res >= 0x1f)
            return reporter.error('Multi-octet tag encoding unsupported');

        if (!primitive)
            res |= 0x20;

        res |= (der.tagClassByName[cls || 'universal'] << 6);

        return res;
    }

},{"../../asn1":61,"buffer":3,"util":166}],72:[function(require,module,exports){
    var encoders = exports;

    encoders.der = require('./der');

},{"./der":71}],73:[function(require,module,exports){
// Utils

    function assert(val, msg) {
        if (!val)
            throw new Error(msg || 'Assertion failed');
    }

    function assertEqual(l, r, msg) {
        if (l != r)
            throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
    }

// Could use `inherits` module, but don't want to move from single file
// architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor
        var TempCtor = function () {}
        TempCtor.prototype = superCtor.prototype
        ctor.prototype = new TempCtor()
        ctor.prototype.constructor = ctor
    }

// BN

    function BN(number, base) {
        // May be `new BN(bn)` ?
        if (number !== null &&
            typeof number === 'object' &&
            Array.isArray(number.words)) {
            return number;
        }

        this.sign = false;
        this.words = null;
        this.length = 0;

        // Reduction context
        this.red = null;

        if (number !== null)
            this._init(number || 0, base || 10);
    }
    if (typeof module === 'object')
        module.exports = BN;

    BN.BN = BN;
    BN.wordSize = 26;

    BN.prototype._init = function init(number, base) {
        if (typeof number === 'number') {
            if (number < 0) {
                this.sign = true;
                number = -number;
            }
            if (number < 0x4000000) {
                this.words = [ number & 0x3ffffff ];
                this.length = 1;
            } else {
                this.words = [
                    number & 0x3ffffff,
                    (number / 0x4000000) & 0x3ffffff
                ];
                this.length = 2;
            }
            return;
        } else if (typeof number === 'object') {
            // Perhaps a Uint8Array
            assert(typeof number.length === 'number');
            this.length = Math.ceil(number.length / 3);
            this.words = new Array(this.length);
            for (var i = 0; i < this.length; i++)
                this.words[i] = 0;

            // Assume big-endian
            var off = 0;
            for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
                var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
                this.words[j] |= (w << off) & 0x3ffffff;
                this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
                off += 24;
                if (off >= 26) {
                    off -= 26;
                    j++;
                }
            }

            return this.strip();
        }
        if (base === 'hex')
            base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);

        number = number.toString().replace(/\s+/g, '');
        var start = 0;
        if (number[0] === '-')
            start++;

        if (base === 16)
            this._parseHex(number, start);
        else
            this._parseBase(number, base, start);

        if (number[0] === '-')
            this.sign = true;

        this.strip();
    };

    BN.prototype._parseHex = function parseHex(number, start) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++)
            this.words[i] = 0;

        // Scan 24-bit chunks and add them to the number
        var off = 0;
        for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
            var w = parseInt(number.slice(i, i + 6), 16);
            this.words[j] |= (w << off) & 0x3ffffff;
            this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        if (i + 6 !== start) {
            var w = parseInt(number.slice(start, i + 6), 16);
            this.words[j] |= (w << off) & 0x3ffffff;
            this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
        }
        this.strip();
    };

    BN.prototype._parseBase = function parseBase(number, base, start) {
        // Initialize as zero
        this.words = [ 0 ];
        this.length = 1;

        var word = 0;
        var q = 1;
        var p = 0;
        var bigQ = null;
        for (var i = start; i < number.length; i++) {
            var digit;
            var ch = number[i];
            if (base === 10 || ch <= '9')
                digit = ch | 0;
            else if (ch >= 'a')
                digit = ch.charCodeAt(0) - 97 + 10;
            else
                digit = ch.charCodeAt(0) - 65 + 10;
            word *= base;
            word += digit;
            q *= base;
            p++;

            if (q > 0xfffff) {
                assert(q <= 0x3ffffff);
                if (!bigQ)
                    bigQ = new BN(q);
                this.mul(bigQ).copy(this);
                this.iadd(new BN(word));
                word = 0;
                q = 1;
                p = 0;
            }
        }
        if (p !== 0) {
            this.mul(new BN(q)).copy(this);
            this.iadd(new BN(word));
        }
    };

    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++)
            dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.sign = this.sign;
        dest.red = this.red;
    };

    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };

// Remove leading `0` from `this`
    BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0)
            this.length--;
        return this._normSign();
    };

    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0)
            this.sign = false;
        return this;
    };

    BN.prototype.inspect = function inspect() {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    };

    /*

     var zeros = [];
     var groupSizes = [];
     var groupBases = [];

     var s = '';
     var i = -1;
     while (++i < BN.wordSize) {
     zeros[i] = s;
     s += '0';
     }
     groupSizes[0] = 0;
     groupSizes[1] = 0;
     groupBases[0] = 0;
     groupBases[1] = 0;
     var base = 2 - 1;
     while (++base < 36 + 1) {
     var groupSize = 0;
     var groupBase = 1;
     // TODO: <=
     while (groupBase < (1 << BN.wordSize) / base) {
     groupBase *= base;
     groupSize += 1;
     }
     groupSizes[base] = groupSize;
     groupBases[base] = groupBase;
     }

     */

    var zeros = [
        '',
        '0',
        '00',
        '000',
        '0000',
        '00000',
        '000000',
        '0000000',
        '00000000',
        '000000000',
        '0000000000',
        '00000000000',
        '000000000000',
        '0000000000000',
        '00000000000000',
        '000000000000000',
        '0000000000000000',
        '00000000000000000',
        '000000000000000000',
        '0000000000000000000',
        '00000000000000000000',
        '000000000000000000000',
        '0000000000000000000000',
        '00000000000000000000000',
        '000000000000000000000000',
        '0000000000000000000000000'
    ];

    var groupSizes = [
        0, 0,
        25, 16, 12, 11, 10, 9, 8,
        8, 7, 7, 7, 7, 6, 6,
        6, 6, 6, 6, 6, 5, 5,
        5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5
    ];

    var groupBases = [
        0, 0,
        33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
        43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
        16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
        6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
        24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
    ];

    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        if (base === 16 || base === 'hex') {
            var out = '';
            var off = 0;
            var padding = padding | 0 || 1;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
                var w = this.words[i];
                var word = (((w << off) | carry) & 0xffffff).toString(16);
                carry = (w >>> (24 - off)) & 0xffffff;
                if (carry !== 0 || i !== this.length - 1)
                    out = zeros[6 - word.length] + word + out;
                else
                    out = word + out;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
            }
            if (carry !== 0)
                out = carry.toString(16) + out;
            while (out.length % padding !== 0)
                out = '0' + out;
            if (this.sign)
                out = '-' + out;
            return out;
        } else if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            var out = '';
            var c = this.clone();
            c.sign = false;
            while (c.cmpn(0) !== 0) {
                var r = c.modn(groupBase).toString(base);
                c = c.idivn(groupBase);

                if (c.cmpn(0) !== 0)
                    out = zeros[groupSize - r.length] + r + out;
                else
                    out = r + out;
            }
            if (this.cmpn(0) === 0)
                out = '0' + out;
            if (this.sign)
                out = '-' + out;
            return out;
        } else {
            assert(false, 'Base should be between 2 and 36');
        }
    };

    BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
    };

    BN.prototype.toArray = function toArray() {
        this.strip();
        var res = new Array(this.byteLength());
        res[0] = 0;

        var q = this.clone();
        for (var i = 0; q.cmpn(0) !== 0; i++) {
            var b = q.andln(0xff);
            q.ishrn(8);

            // Assume big-endian
            res[res.length - i - 1] = b;
        }

        return res;
    };

    /*
     function genCountBits(bits) {
     var arr = [];

     for (var i = bits - 1; i >= 0; i--) {
     var bit = '0x' + (1 << i).toString(16);
     arr.push('w >= ' + bit + ' ? ' + (i + 1));
     }

     return new Function('w', 'return ' + arr.join(' :\n') + ' :\n0;');
     };

     BN.prototype._countBits = genCountBits(26);
     */

// Sadly chrome apps could not contain `new Function()` calls
    BN.prototype._countBits = function _countBits(w) {
        return w >= 0x2000000 ? 26 :
            w >= 0x1000000 ? 25 :
                w >= 0x800000 ? 24 :
                    w >= 0x400000 ? 23 :
                        w >= 0x200000 ? 22 :
                            w >= 0x100000 ? 21 :
                                w >= 0x80000 ? 20 :
                                    w >= 0x40000 ? 19 :
                                        w >= 0x20000 ? 18 :
                                            w >= 0x10000 ? 17 :
                                                w >= 0x8000 ? 16 :
                                                    w >= 0x4000 ? 15 :
                                                        w >= 0x2000 ? 14 :
                                                            w >= 0x1000 ? 13 :
                                                                w >= 0x800 ? 12 :
                                                                    w >= 0x400 ? 11 :
                                                                        w >= 0x200 ? 10 :
                                                                            w >= 0x100 ? 9 :
                                                                                w >= 0x80 ? 8 :
                                                                                    w >= 0x40 ? 7 :
                                                                                        w >= 0x20 ? 6 :
                                                                                            w >= 0x10 ? 5 :
                                                                                                w >= 0x8 ? 4 :
                                                                                                    w >= 0x4 ? 3 :
                                                                                                        w >= 0x2 ? 2 :
                                                                                                            w >= 0x1 ? 1 :
                                                                                                                0;
    };

// Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var hi = 0;
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };

    BN.prototype.byteLength = function byteLength() {
        var hi = 0;
        var w = this.words[this.length - 1];
        return Math.ceil(this.bitLength() / 8);
    };

// Return negative clone of `this`
    BN.prototype.neg = function neg() {
        if (this.cmpn(0) === 0)
            return this.clone();

        var r = this.clone();
        r.sign = !this.sign;
        return r;
    };

// Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        // negative + positive
        if (this.sign && !num.sign) {
            this.sign = false;
            var r = this.isub(num);
            this.sign = !this.sign;
            return this._normSign();

            // positive + negative
        } else if (!this.sign && num.sign) {
            num.sign = false;
            var r = this.isub(num);
            num.sign = true;
            return r._normSign();
        }

        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }

        var carry = 0;
        for (var i = 0; i < b.length; i++) {
            var r = a.words[i] + b.words[i] + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
            var r = a.words[i] + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }

        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
            // Copy the rest of the words
        } else if (a !== this) {
            for (; i < a.length; i++)
                this.words[i] = a.words[i];
        }

        return this;
    };

// Add `num` to `this`
    BN.prototype.add = function add(num) {
        if (num.sign && !this.sign) {
            num.sign = false;
            var res = this.sub(num);
            num.sign = true;
            return res;
        } else if (!num.sign && this.sign) {
            this.sign = false;
            var res = num.sub(this);
            this.sign = true;
            return res;
        }

        if (this.length > num.length)
            return this.clone().iadd(num);
        else
            return num.clone().iadd(this);
    };

// Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.sign) {
            num.sign = false;
            var r = this.iadd(num);
            num.sign = true;
            return r._normSign();

            // -this - num = -(this + num)
        } else if (this.sign) {
            this.sign = false;
            this.iadd(num);
            this.sign = true;
            return this._normSign();
        }

        // At this point both numbers are positive
        var cmp = this.cmp(num);

        // Optimization - zeroify
        if (cmp === 0) {
            this.sign = false;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }

        // a > b
        if (cmp > 0) {
            var a = this;
            var b = num;
        } else {
            var a = num;
            var b = this;
        }

        var carry = 0;
        for (var i = 0; i < b.length; i++) {
            var r = a.words[i] - b.words[i] - carry;
            if (r < 0) {
                r += 0x4000000;
                carry = 1;
            } else {
                carry = 0;
            }
            this.words[i] = r;
        }
        for (; carry !== 0 && i < a.length; i++) {
            var r = a.words[i] - carry;
            if (r < 0) {
                r += 0x4000000;
                carry = 1;
            } else {
                carry = 0;
            }
            this.words[i] = r;
        }

        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this)
            for (; i < a.length; i++)
                this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);

        if (a !== this)
            this.sign = true;

        return this.strip();
    };

// Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };

    /*
     // NOTE: This could be potentionally used to generate loop-less multiplications
     function _genCombMulTo(alen, blen) {
     var len = alen + blen - 1;
     var src = [
     'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
     'mask = 0x3ffffff, shift = 0x4000000;',
     'out.length = ' + len + ';'
     ];
     for (var k = 0; k < len; k++) {
     var minJ = Math.max(0, k - alen + 1);
     var maxJ = Math.min(k, blen - 1);

     for (var j = minJ; j <= maxJ; j++) {
     var i = k - j;
     var mul = 'a[' + i + '] * b[' + j + ']';

     if (j === minJ) {
     src.push('w = ' + mul + ' + c;');
     src.push('c = (w / shift) | 0;');
     } else {
     src.push('w += ' + mul + ';');
     src.push('c += (w / shift) | 0;');
     }
     src.push('w &= mask;');
     }
     src.push('o[' + k + '] = w;');
     }
     src.push('if (c !== 0) {',
     '  o[' + k + '] = c;',
     '  out.length++;',
     '}',
     'return out;');

     return src.join('\n');
     }
     */

    BN.prototype._smallMulTo = function _smallMulTo(num, out) {
        out.sign = num.sign !== this.sign;
        out.length = this.length + num.length;

        var carry = 0;
        for (var k = 0; k < out.length - 1; k++) {
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                var i = k - j;
                var a = this.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;

                var lo = r & 0x3ffffff;
                ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
                lo = (lo + rword) | 0;
                rword = lo & 0x3ffffff;
                ncarry = (ncarry + (lo >>> 26)) | 0;
            }
            out.words[k] = rword;
            carry = ncarry;
        }
        if (carry !== 0) {
            out.words[k] = carry;
        } else {
            out.length--;
        }

        return out.strip();
    };

    BN.prototype._bigMulTo = function _bigMulTo(num, out) {
        out.sign = num.sign !== this.sign;
        out.length = this.length + num.length;

        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                var i = k - j;
                var a = this.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;

                var lo = r & 0x3ffffff;
                ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
                lo = (lo + rword) | 0;
                rword = lo & 0x3ffffff;
                ncarry = (ncarry + (lo >>> 26)) | 0;

                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) {
            out.words[k] = carry;
        } else {
            out.length--;
        }

        return out.strip();
    };

    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        if (this.length + num.length < 63)
            res = this._smallMulTo(num, out);
        else
            res = this._bigMulTo(num, out);
        return res;
    };

// Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };

// In-place Multiplication
    BN.prototype.imul = function imul(num) {
        if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
            this.words[0] = 0;
            this.length = 1;
            return this;
        }

        var tlen = this.length;
        var nlen = num.length;

        this.sign = num.sign !== this.sign;
        this.length = this.length + num.length;
        this.words[this.length - 1] = 0;

        var lastCarry = 0;
        for (var k = this.length - 2; k >= 0; k--) {
            // Sum all words with the same `i + j = k` and accumulate `carry`,
            // note that carry could be >= 0x3ffffff
            var carry = 0;
            var rword = 0;
            var maxJ = Math.min(k, nlen - 1);
            for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
                var i = k - j;
                var a = this.words[i];
                var b = num.words[j];
                var r = a * b;

                var lo = r & 0x3ffffff;
                carry += (r / 0x4000000) | 0;
                lo += rword;
                rword = lo & 0x3ffffff;
                carry += lo >>> 26;
            }
            this.words[k] = rword;
            this.words[k + 1] += carry;
            carry = 0;
        }

        // Propagate overflows
        var carry = 0;
        for (var i = 1; i < this.length; i++) {
            var w = this.words[i] + carry;
            this.words[i] = w & 0x3ffffff;
            carry = w >>> 26;
        }

        return this.strip();
    };

// `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };

// `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.mul(this);
    };

// Shift-left in-place
    BN.prototype.ishln = function ishln(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

        var o = this.clone();
        if (r !== 0) {
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] - newCarry) << r;
                this.words[i] = c | carry;
                carry = newCarry >>> (26 - r);
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }

        if (s !== 0) {
            for (var i = this.length - 1; i >= 0; i--)
                this.words[i + s] = this.words[i];
            for (var i = 0; i < s; i++)
                this.words[i] = 0;
            this.length += s;
        }

        return this.strip();
    };

// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is true - { lo: ..., hi: } object will be returned
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(typeof bits === 'number' && bits >= 0);
        if (hint)
            hint = (hint - (hint % 26)) / 26;
        else
            hint = 0;

        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
        var maskedWords = extended;

        hint -= s;
        hint = Math.max(0, hint);

        // Extended mode, copy masked part
        if (maskedWords) {
            for (var i = 0; i < s; i++)
                maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }

        if (s === 0) {
            // No-op, we should not move anything at all
        } else if (this.length > s) {
            this.length -= s;
            for (var i = 0; i < this.length; i++)
                this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }

        var carry = 0;
        for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= hint); i--) {
            var word = this.words[i];
            this.words[i] = (carry << (26 - r)) | (word >>> r);
            carry = word & mask;
        }

        // Push carried bits as a mask
        if (maskedWords && carry !== 0)
            maskedWords.words[maskedWords.length++] = carry;

        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }

        this.strip();
        if (extended)
            return { hi: this, lo: maskedWords };

        return this;
    };

// Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };

// Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };

// Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === 'number' && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;

        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            return false;
        }

        // Check bit and return
        var w = this.words[s];

        return !!(w & q);
    };

// Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;

        assert(!this.sign, 'imaskn works only with positive numbers');

        if (r !== 0)
            s++;
        this.length = Math.min(s, this.length);

        if (r !== 0) {
            var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
            this.words[this.length - 1] &= mask;
        }

        return this.strip();
    };

// Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };

// Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === 'number');
        if (num < 0)
            return this.isubn(-num);

        // Possible sign change
        if (this.sign) {
            if (this.length === 1 && this.words[0] < num) {
                this.words[0] = num - this.words[0];
                this.sign = false;
                return this;
            }

            this.sign = false;
            this.isubn(num);
            this.sign = true;
            return this;
        }
        this.words[0] += num;

        // Carry
        for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
            this.words[i] -= 0x4000000;
            if (i === this.length - 1)
                this.words[i + 1] = 1;
            else
                this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);

        return this;
    };

// Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === 'number');
        if (num < 0)
            return this.iaddn(-num);

        if (this.sign) {
            this.sign = false;
            this.iaddn(num);
            this.sign = true;
            return this;
        }

        this.words[0] -= num;

        // Carry
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }

        return this.strip();
    };

    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };

    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };

    BN.prototype.iabs = function iabs() {
        this.sign = false;

        return this
    };

    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };

    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;

        var a = this.clone();
        var b = num;

        var q = mode !== 'mod' && new BN(0);
        var sign = false;

        // Approximate quotient at each step
        while (a.length > b.length) {
            // NOTE: a.length is always >= 2, because of the condition .div()
            var hi = a.words[a.length - 1] * 0x4000000 + a.words[a.length - 2];
            var sq = (hi / b.words[b.length - 1]);
            var sqhi = (sq / 0x4000000) | 0;
            var sqlo = sq & 0x3ffffff;
            sq = new BN(null);
            sq.words = [ sqlo, sqhi ];
            sq.length = 2;

            // Collect quotient
            var shift = (a.length - b.length - 1) * 26;
            if (q) {
                var t = sq.shln(shift);
                if (a.sign)
                    q.isub(t);
                else
                    q.iadd(t);
            }

            sq = sq.mul(b).ishln(shift);
            if (a.sign)
                a.iadd(sq)
            else
                a.isub(sq);
        }
        // At this point a.length <= b.length
        while (a.ucmp(b) >= 0) {
            // NOTE: a.length is always >= 2, because of the condition above
            var hi = a.words[a.length - 1];
            var sq = new BN((hi / b.words[b.length - 1]) | 0);
            var shift = (a.length - b.length) * 26;

            if (q) {
                var t = sq.shln(shift);
                if (a.sign)
                    q.isub(t);
                else
                    q.iadd(t);
            }

            sq = sq.mul(b).ishln(shift);

            if (a.sign)
                a.iadd(sq);
            else
                a.isub(sq);
        }

        if (a.sign) {
            if (q)
                q.isubn(1);
            a.iadd(b);
        }
        return { div: q ? q : null, mod: a };
    };

    BN.prototype.divmod = function divmod(num, mode) {
        assert(num.cmpn(0) !== 0);

        if (this.sign && !num.sign) {
            var res = this.neg().divmod(num, mode);
            var div;
            var mod;
            if (mode !== 'mod')
                div = res.div.neg();
            if (mode !== 'div')
                mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
            return {
                div: div,
                mod: mod
            };
        } else if (!this.sign && num.sign) {
            var res = this.divmod(num.neg(), mode);
            var div;
            if (mode !== 'mod')
                div = res.div.neg();
            return { div: div, mod: res.mod };
        } else if (this.sign && num.sign) {
            return this.neg().divmod(num.neg(), mode);
        }

        // Both numbers are positive at this point

        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0)
            return { div: new BN(0), mod: this };

        // Very short reduction
        if (num.length === 1) {
            if (mode === 'div')
                return { div: this.divn(num.words[0]), mod: null };
            else if (mode === 'mod')
                return { div: null, mod: new BN(this.modn(num.words[0])) };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modn(num.words[0]))
            };
        }

        return this._wordDiv(num, mode);
    };

// Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, 'div').div;
    };

// Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, 'mod').mod;
    };

// Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);

        // Fast case - exact division
        if (dm.mod.cmpn(0) === 0)
            return dm.div;

        var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;

        var half = num.shrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);

        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;

        // Round up
        return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
    };

    BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = (1 << 26) % num;

        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--)
            acc = (p * acc + this.words[i]) % num;

        return acc;
    };

// In-place division by number
    BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);

        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
            var w = this.words[i] + carry * 0x4000000;
            this.words[i] = (w / num) | 0;
            carry = w % num;
        }

        return this.strip();
    };

    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };

    BN.prototype._egcd = function _egcd(x1, p) {
        assert(!p.sign);
        assert(p.cmpn(0) !== 0);

        var a = this;
        var b = p.clone();

        if (a.sign)
            a = a.mod(p);
        else
            a = a.clone();

        var x2 = new BN(0);
        while (b.isEven())
            b.ishrn(1);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            while (a.isEven()) {
                a.ishrn(1);
                if (x1.isEven())
                    x1.ishrn(1);
                else
                    x1.iadd(delta).ishrn(1);
            }
            while (b.isEven()) {
                b.ishrn(1);
                if (x2.isEven())
                    x2.ishrn(1);
                else
                    x2.iadd(delta).ishrn(1);
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        if (a.cmpn(1) === 0)
            return x1;
        else
            return x2;
    };

    BN.prototype.gcd = function gcd(num) {
        if (this.cmpn(0) === 0)
            return num.clone();
        if (num.cmpn(0) === 0)
            return this.clone();

        var a = this.clone();
        var b = num.clone();
        a.sign = false;
        b.sign = false;

        // Remove common factor of two
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.ishrn(1);
            b.ishrn(1);
        }

        while (a.isEven())
            a.ishrn(1);

        do {
            while (b.isEven())
                b.ishrn(1);

            // Swap `a` and `b` to make `a` always bigger than `b`
            if (a.cmp(b) < 0) {
                var t = a;
                a = b;
                b = t;
            }
            a.isub(a.div(b).mul(b));
        } while (a.cmpn(0) !== 0 && b.cmpn(0) !== 0);
        if (a.cmpn(0) === 0)
            return b.ishln(shift);
        else
            return a.ishln(shift);
    };

// Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this._egcd(new BN(1), num).mod(num);
    };

    BN.prototype.isEven = function isEven(num) {
        return (this.words[0] & 1) === 0;
    };

    BN.prototype.isOdd = function isOdd(num) {
        return (this.words[0] & 1) === 1;
    };

// And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };

// Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === 'number');
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;

        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            for (var i = this.length; i < s + 1; i++)
                this.words[i] = 0;
            this.words[s] |= q;
            this.length = s + 1;
            return this;
        }

        // Add bit and propagate, if needed
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i];
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };

    BN.prototype.cmpn = function cmpn(num) {
        var sign = num < 0;
        if (sign)
            num = -num;

        if (this.sign && !sign)
            return -1;
        else if (!this.sign && sign)
            return 1;

        num &= 0x3ffffff;
        this.strip();

        var res;
        if (this.length > 1) {
            res = 1;
        } else {
            var w = this.words[0];
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.sign)
            res = -res;
        return res;
    };

// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.sign && !num.sign)
            return -1;
        else if (!this.sign && num.sign)
            return 1;

        var res = this.ucmp(num);
        if (this.sign)
            return -res;
        else
            return res;
    };

// Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length)
            return 1;
        else if (this.length < num.length)
            return -1;

        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i];
            var b = num.words[i];

            if (a === b)
                continue;
            if (a < b)
                res = -1;
            else if (a > b)
                res = 1;
            break;
        }
        return res;
    };

//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
    BN.red = function red(num) {
        return new Red(num);
    };

    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        assert(!this.sign, 'red works only with positives');
        return ctx.convertTo(this)._forceRed(ctx);
    };

    BN.prototype.fromRed = function fromRed() {
        assert(this.red, 'fromRed works only with numbers in reduction context');
        return this.red.convertFrom(this);
    };

    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };

    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        return this._forceRed(ctx);
    };

    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, 'redAdd works only with red numbers');
        return this.red.add(this, num);
    };

    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, 'redIAdd works only with red numbers');
        return this.red.iadd(this, num);
    };

    BN.prototype.redSub = function redSub(num) {
        assert(this.red, 'redSub works only with red numbers');
        return this.red.sub(this, num);
    };

    BN.prototype.redISub = function redISub(num) {
        assert(this.red, 'redISub works only with red numbers');
        return this.red.isub(this, num);
    };

    BN.prototype.redShl = function redShl(num) {
        assert(this.red, 'redShl works only with red numbers');
        return this.red.shl(this, num);
    };

    BN.prototype.redMul = function redMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };

    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };

    BN.prototype.redSqr = function redSqr() {
        assert(this.red, 'redSqr works only with red numbers');
        this.red._verify1(this);
        return this.red.sqr(this);
    };

    BN.prototype.redISqr = function redISqr() {
        assert(this.red, 'redISqr works only with red numbers');
        this.red._verify1(this);
        return this.red.isqr(this);
    };

// Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, 'redSqrt works only with red numbers');
        this.red._verify1(this);
        return this.red.sqrt(this);
    };

    BN.prototype.redInvm = function redInvm() {
        assert(this.red, 'redInvm works only with red numbers');
        this.red._verify1(this);
        return this.red.invm(this);
    };

// Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, 'redNeg works only with red numbers');
        this.red._verify1(this);
        return this.red.neg(this);
    };

    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, 'redPow(normalNum)');
        this.red._verify1(this);
        return this.red.pow(this, num);
    };

// Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };

// Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).ishln(this.n).isub(this.p);

        this.tmp = this._tmp();
    }

    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };

    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;

        do {
            var pair = r.ishrn(this.n, 0, this.tmp);
            r = this.imulK(pair.hi);
            r = r.iadd(pair.lo);
            rlen = r.bitLength();
        } while (rlen > this.n);

        var cmp = rlen < this.n ? -1 : r.cmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) {
            r.isub(this.p);
        } else {
            r.strip();
        }

        return r;
    };

    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };

    function K256() {
        MPrime.call(
            this,
            'k256',
            'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    inherits(K256, MPrime);

    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        for (var i = num.length - 3; i >= 0; i--) {
            var w = num.words[i];
            var hi = w * 0x40;
            var lo = w * 0x3d1;
            hi += (lo / 0x4000000) | 0;
            var uhi = (hi / 0x4000000) | 0;
            hi &= 0x3ffffff;
            lo &= 0x3ffffff;

            num.words[i + 2] += uhi;
            num.words[i + 1] += hi;
            num.words[i] = lo;
        }
        var w = num.words[num.length - 2];
        if (w >= 0x4000000) {
            num.words[num.length - 1] += w >>> 26;
            num.words[num.length - 2] = w & 0x3ffffff;
        }
        if (num.words[num.length - 1] === 0)
            num.length--;
        if (num.words[num.length - 1] === 0)
            num.length--;
        return num;
    };

    function P224() {
        MPrime.call(
            this,
            'p224',
            'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    inherits(P224, MPrime);

    function P192() {
        MPrime.call(
            this,
            'p192',
            'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    inherits(P192, MPrime);

    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(
            this,
            '25519',
            '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    inherits(P25519, MPrime);

    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
            var hi = num.words[i] * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;

            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0)
            num.words[num.length++] = carry;
        return num;
    };

// Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name])
            return primes[name];

        var prime;
        if (name === 'k256')
            prime = new K256();
        else if (name === 'p224')
            prime = new P224();
        else if (name === 'p192')
            prime = new P192();
        else if (name === 'p25519')
            prime = new P25519();
        else
            throw new Error('Unknown prime ' + name);
        primes[name] = prime;

        return prime;
    }

//
// Base reduction engine
//
    function Red(m) {
        if (typeof m === 'string') {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            this.m = m;
            this.prime = null;
        }
    }

    Red.prototype._verify1 = function _verify1(a) {
        assert(!a.sign, 'red works only with positives');
        assert(a.red, 'red works only with red numbers');
    };

    Red.prototype._verify2 = function _verify2(a, b) {
        assert(!a.sign && !b.sign, 'red works only with positives');
        assert(a.red && a.red === b.red,
            'red works only with red numbers');
    };

    Red.prototype.imod = function imod(a) {
        if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
        return a.mod(this.m)._forceRed(this);
    };

    Red.prototype.neg = function neg(a) {
        var r = a.clone();
        r.sign = !r.sign;
        return r.iadd(this.m)._forceRed(this);
    };

    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);

        var res = a.add(b);
        if (res.cmp(this.m) >= 0)
            res.isub(this.m);
        return res._forceRed(this);
    };

    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);

        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0)
            res.isub(this.m);
        return res;
    };

    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);

        var res = a.sub(b);
        if (res.cmpn(0) < 0)
            res.iadd(this.m);
        return res._forceRed(this);
    };

    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);

        var res = a.isub(b);
        if (res.cmpn(0) < 0)
            res.iadd(this.m);
        return res;
    };

    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.shln(num));
    };

    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };

    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };

    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a);
    };

    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };

    Red.prototype.sqrt = function sqrt(a) {
        if (a.cmpn(0) === 0)
            return a.clone();

        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);

        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).ishrn(2);
            var r = this.pow(a, pow);
            return r;
        }

        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
            s++;
            q.ishrn(1);
        }
        assert(q.cmpn(0) !== 0);

        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();

        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).ishrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0)
            z.redIAdd(nOne);

        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).ishrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++)
                tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).ishln(m - i - 1));

            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }

        return r;
    };

    Red.prototype.invm = function invm(a) {
        var inv = a._egcd(new BN(1), this.m);
        if (inv.sign) {
            inv.sign = false;
            return this.imod(inv).redNeg();
        } else {
            return this.imod(inv);
        }
    };

    Red.prototype.pow = function pow(a, num) {
        var w = [];
        var q = num.clone();
        while (q.cmpn(0) !== 0) {
            w.push(q.andln(1));
            q.ishrn(1);
        }

        // Skip leading zeroes
        var res = a;
        for (var i = 0; i < w.length; i++, res = this.sqr(res))
            if (w[i] !== 0)
                break;

        if (++i < w.length) {
            for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
                if (w[i] === 0)
                    continue;
                res = this.mul(res, q);
            }
        }

        return res;
    };

    Red.prototype.convertTo = function convertTo(num) {
        return num.clone();
    };

    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };

//
// Montgomery method engine
//

    BN.mont = function mont(num) {
        return new Mont(num);
    };

    function Mont(m) {
        Red.call(this, m);

        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0)
            this.shift += 26 - (this.shift % 26);
        this.r = new BN(1).ishln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r.invm(this.m);

        // TODO(indutny): simplify it
        this.minv = this.rinv.mul(this.r)
            .sub(new BN(1))
            .div(this.m)
            .neg()
            .mod(this.r);
    }
    inherits(Mont, Red);

    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.shln(this.shift));
    };

    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };

    Mont.prototype.imul = function imul(a, b) {
        if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }

        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).ishrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);

        return res._forceRed(this);
    };

    Mont.prototype.mul = function mul(a, b) {
        if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
            return new BN(0)._forceRed(this);

        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).ishrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
        else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);

        return res._forceRed(this);
    };

    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a.invm(this.m).mul(this.r2));
        return res._forceRed(this);
    };

},{}],74:[function(require,module,exports){
    exports.strip = function strip(artifact) {
        artifact = artifact.toString()
        var startRegex = /^-----BEGIN (.*)-----\n/;
        var match = startRegex.exec(artifact);
        var tag = match[1];
        var endRegex = new RegExp("\n-----END " + tag + "-----(\n*)$");
        var base64 = artifact.slice(match[0].length).replace(endRegex, "").replace(/\n/g, "");
        return {tag: tag, base64: base64};
    };

// http://stackoverflow.com/a/7033705
    var wrap = function wrap(str, l) {
        var chunks = [];
        while (str) {
            if (str.length < l) {
                chunks.push(str);
                break;
            }
            else {
                chunks.push(str.substr(0, l));
                str = str.substr(l);
            }
        }
        return chunks.join("\n");
    }

    exports.assemble = function assemble(info) {
        var tag = info.tag;
        var base64 = info.base64;
        var startLine = "-----BEGIN " + tag + "-----";
        var endLine = "-----END " + tag + "-----";
        return startLine + "\n" + wrap(base64, 64) + "\n" + endLine + "\n";
    }
},{}],75:[function(require,module,exports){
    (function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
        var parseKeys = require('parse-asn1');
        var bn = require('bn.js');
        var elliptic = require('elliptic');
        var crt = require("browserify-rsa");
        module.exports = sign;
        function sign(hash, key, crypto) {
            var priv = parseKeys(key, crypto);
            if (priv.curve) {
                return ecSign(hash, priv, crypto);
            } else if (priv.type === 'dsa') {
                return dsaSign(hash, priv, crypto);
            }
            var len = priv.modulus.byteLength();
            var pad = [ 0, 1 ];
            while (hash.length + pad.length + 1 < len) {
                pad.push(0xff);
            }
            pad.push(0x00);
            var i = -1;
            while (++i < hash.length) {
                pad.push(hash[i]);
            }

            var out = crt(pad, priv, crypto);
            return out;
        }
        function ecSign(hash, priv, crypto) {
            elliptic.rand = crypto.randomBytes;
            var curve;
            if (priv.curve.join('.')  === '1.3.132.0.10') {
                curve = new elliptic.ec('secp256k1');
            }
            var key = curve.genKeyPair();
            key._importPrivate(priv.privateKey);
            var out = key.sign(hash);
            return new Buffer(out.toDER());
        }
        function dsaSign(hash, priv, crypto) {
            var x = priv.params.priv_key;
            var p = priv.params.p;
            var q = priv.params.q;
            var montq = bn.mont(q);
            var g = priv.params.g;
            var r = new bn(0);
            var k;
            var H = new bn(hash);
            var s = false;
            while (s === false) {
                while (!r.cmpn(0)) {
                    k = getKay(q, crypto);
                    r = makeR(g, k, p, q);
                }
                s = k.invm(q).imul(H.add(x.imul(r).mod(q)).mod(q)).mod(q);
                if (!s.cmpn(0)) {
                    s = false;
                    r = new bn(0);
                }
            }
            return toDER(r,s);
        }
        function toDER(r, s) {
            r = r.toArray();
            s = s.toArray();

            // Pad values
            if (r[0] & 0x80)
                r = [ 0 ].concat(r);
            // Pad values
            if (s[0] & 0x80)
                s = [ 0 ].concat(s);

            var total = r.length + s.length + 4;
            var res = [ 0x30, total, 0x02, r.length ];
            res = res.concat(r, [ 0x02, s.length ], s);
            return new Buffer(res);
        }
        function getKay(q, crypto) {
            var k = new bn(crypto.randomBytes(q.byteLength()));
            while (k.cmp(q) >= 0) {
                k = new bn(crypto.randomBytes(q.byteLength()));
            }
            return k;
        }
        function makeR(g, k, p, q) {
            return g.toRed(bn.mont(p)).redPow(k).fromRed().mod(q);
        }
    }).call(this,require("buffer").Buffer)
},{"bn.js":32,"browserify-rsa":33,"buffer":3,"elliptic":35,"parse-asn1":59}],76:[function(require,module,exports){
    (function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
        var parseKeys = require('parse-asn1');
        var elliptic = require('elliptic');
        var bn = require('bn.js');
        module.exports = verify;
        function verify(sig, hash, key) {
            var pub = parseKeys(key);
            if (pub.type === 'ec') {
                return ecVerify(sig, hash, pub);
            } else if (pub.type === 'dsa') {
                return dsaVerify(sig, hash, pub);
            }
            var len = pub.modulus.byteLength();
            var pad = [ 0, 1 ];
            while (hash.length + pad.length + 1 < len) {
                pad.push(0xff);
            }
            pad.push(0x00);
            var i = -1;
            while (++i < hash.length) {
                pad.push(hash[i]);
            }
            pad = hash;
            var red = bn.mont(pub.modulus);
            sig = new bn(sig).toRed(red);

            sig = sig.redPow(new bn(pub.publicExponent));

            sig = new Buffer(sig.fromRed().toArray());
            sig = sig.slice(sig.length - hash.length);
            var out = 0;
            len = sig.length;
            i = -1;
            while (++i < len) {
                out += (sig[i] ^ hash[i]);
            }
            return !out;
        }
        function ecVerify(sig, hash, pub) {
            var curve;
            if (pub.data.algorithm.curve.join('.')  === '1.3.132.0.10') {
                curve = new elliptic.ec('secp256k1');
            }
            var pubkey = pub.data.subjectPrivateKey.data;
            return curve.verify(hash.toString('hex'), sig.toString('hex'), pubkey.toString('hex'));
        }
        function dsaVerify(sig, hash, pub) {
            var p = pub.data.p;
            var q = pub.data.q;
            var g = pub.data.g;
            var y = pub.data.pub_key;
            var unpacked = parseKeys.signature.decode(sig, 'der');
            var s = unpacked.s;
            var r = unpacked.r;
            checkValue(s, q);
            checkValue(r, q);
            var montq = bn.mont(q);
            var montp = bn.mont(p);
            var w =  s.invm(q);
            var v = g.toRed(montp)
                .redPow(new bn(hash).mul(w).mod(q))
                .fromRed()
                .mul(
                y.toRed(montp)
                    .redPow(r.mul(w).mod(q))
                    .fromRed()
            ).mod(p).mod(q);
            return !v.cmp(r);
        }
        function checkValue(b, q) {
            if (b.cmpn(0) <= 0) {
                throw new Error('invalid sig');
            }
            if (b.cmp(q) >= q) {
                throw new Error('invalid sig');
            }
        }
    }).call(this,require("buffer").Buffer)
},{"bn.js":32,"buffer":3,"elliptic":35,"parse-asn1":59}],77:[function(require,module,exports){
    (function (Buffer){
        var elliptic = require('elliptic');
        var BN = require('bn.js');
        module.exports = ECDH;

        function ECDH(curve, crypto) {
            elliptic.rand = crypto.randomBytes;
            this.curve = new elliptic.ec(curve);
            this.keys = void 0;
        }
        ECDH.prototype.generateKeys = function (enc, format) {
            this.keys = this.curve.genKeyPair();
            return this.getPublicKey(enc, format);
        };

        ECDH.prototype.computeSecret = function (other, inenc, enc) {
            inenc = inenc || 'utf8';
            if (!Buffer.isBuffer(other)) {
                other = new Buffer(other, inenc);
            }
            other = new BN(other);
            other = other.toString(16);
            var otherPub = this.curve.keyPair(other, 'hex').getPublic();
            var out = otherPub.mul(this.keys.getPrivate()).getX();
            return returnValue(out, enc);
        };
        ECDH.prototype.getPublicKey = function (enc, format) {
            var key = this.keys.getPublic(format === 'compressed', true);
            if (format === 'hybrid') {
                if (key[key.length - 1] % 2) {
                    key[0] = 7;
                } else {
                    key [0] = 6;
                }
            }
            return returnValue(key, enc);
        };
        ECDH.prototype.getPrivateKey = function (enc) {
            return returnValue(this.keys.getPrivate(), enc);
        };

        ECDH.prototype.setPublicKey = function (pub, enc) {
            enc = enc || 'utf8';
            if (!Buffer.isBuffer(pub)) {
                pub = new Buffer(pub, enc);
            }
            var pkey = new BN(pub);
            pkey = pkey.toArray();
            this.keys._importPublicHex(pkey);
        };
        ECDH.prototype.setPrivateKey = function (priv, enc) {
            enc = enc || 'utf8';
            if (!Buffer.isBuffer(priv)) {
                priv = new Buffer(priv, enc);
            }
            var _priv = new BN(priv);
            _priv = _priv.toString(16);
            this.keys._importPrivate(_priv);
        };
        function returnValue(bn, enc) {
            if (!Array.isArray(bn)) {
                bn = bn.toArray();
            }
            var buf = new Buffer(bn);
            if (!enc) {
                return buf;
            } else {
                return buf.toString(enc);
            }
        }
    }).call(this,require("buffer").Buffer)
},{"bn.js":79,"buffer":3,"elliptic":80}],78:[function(require,module,exports){
    var ECDH = require('./ecdh');
    module.exports = function (crypto, exports) {
        exports.createECDH = function (curve) {
            return new ECDH(curve, crypto);
        };
    };
},{"./ecdh":77}],79:[function(require,module,exports){
    arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],80:[function(require,module,exports){
    arguments[4][35][0].apply(exports,arguments)
},{"../package.json":99,"./elliptic/curve":83,"./elliptic/curves":86,"./elliptic/ec":87,"./elliptic/hmac-drbg":90,"./elliptic/utils":91,"brorand":92,"dup":35}],81:[function(require,module,exports){
    arguments[4][36][0].apply(exports,arguments)
},{"../../elliptic":80,"assert":1,"bn.js":79,"dup":36}],82:[function(require,module,exports){
    arguments[4][37][0].apply(exports,arguments)
},{"../../elliptic":80,"../curve":83,"assert":1,"bn.js":79,"dup":37,"inherits":149}],83:[function(require,module,exports){
    arguments[4][38][0].apply(exports,arguments)
},{"./base":81,"./edwards":82,"./mont":84,"./short":85,"dup":38}],84:[function(require,module,exports){
    arguments[4][39][0].apply(exports,arguments)
},{"../../elliptic":80,"../curve":83,"assert":1,"bn.js":79,"dup":39,"inherits":149}],85:[function(require,module,exports){
    arguments[4][40][0].apply(exports,arguments)
},{"../../elliptic":80,"../curve":83,"assert":1,"bn.js":79,"dup":40,"inherits":149}],86:[function(require,module,exports){
    arguments[4][41][0].apply(exports,arguments)
},{"../elliptic":80,"assert":1,"bn.js":79,"dup":41,"hash.js":93}],87:[function(require,module,exports){
    arguments[4][42][0].apply(exports,arguments)
},{"../../elliptic":80,"./key":88,"./signature":89,"assert":1,"bn.js":79,"dup":42}],88:[function(require,module,exports){
    arguments[4][43][0].apply(exports,arguments)
},{"../../elliptic":80,"assert":1,"bn.js":79,"dup":43}],89:[function(require,module,exports){
    arguments[4][44][0].apply(exports,arguments)
},{"../../elliptic":80,"assert":1,"bn.js":79,"dup":44}],90:[function(require,module,exports){
    arguments[4][45][0].apply(exports,arguments)
},{"../elliptic":80,"assert":1,"dup":45,"hash.js":93}],91:[function(require,module,exports){
    arguments[4][46][0].apply(exports,arguments)
},{"assert":1,"bn.js":79,"dup":46}],92:[function(require,module,exports){
    arguments[4][47][0].apply(exports,arguments)
},{"dup":47}],93:[function(require,module,exports){
    arguments[4][48][0].apply(exports,arguments)
},{"./hash/common":94,"./hash/hmac":95,"./hash/ripemd":96,"./hash/sha":97,"./hash/utils":98,"dup":48}],94:[function(require,module,exports){
    arguments[4][49][0].apply(exports,arguments)
},{"../hash":93,"dup":49}],95:[function(require,module,exports){
    arguments[4][50][0].apply(exports,arguments)
},{"../hash":93,"dup":50}],96:[function(require,module,exports){
    arguments[4][51][0].apply(exports,arguments)
},{"../hash":93,"dup":51}],97:[function(require,module,exports){
    arguments[4][52][0].apply(exports,arguments)
},{"../hash":93,"dup":52}],98:[function(require,module,exports){
    arguments[4][53][0].apply(exports,arguments)
},{"dup":53}],99:[function(require,module,exports){
    arguments[4][54][0].apply(exports,arguments)
},{"dup":54}],100:[function(require,module,exports){
    (function (Buffer){
        var BN = require('bn.js');
        var MillerRabin = require('miller-rabin');
        var millerRabin = new MillerRabin();
        var TWENTYFOUR = new BN(24);
        var ELEVEN = new BN(11);
        var TEN = new BN(10);
        var THREE = new BN(3);
        var SEVEN = new BN(7);
        var primes = require('./generatePrime');
        module.exports = DH;
        function setPublicKey(pub, enc) {
            enc = enc || 'utf8';
            if (!Buffer.isBuffer(pub)) {
                pub = new Buffer(pub, enc);
            }
            this._pub = new BN(pub);
        }
        function setPrivateKey(priv, enc) {
            enc = enc || 'utf8';
            if (!Buffer.isBuffer(priv)) {
                priv = new Buffer(priv, enc);
            }
            this._priv = new BN(priv);
        }
        var primeCache = {};
        function checkPrime(prime, generator) {
            var gen = generator.toString('hex');
            var hex = [gen, prime.toString(16)].join('_');
            if (hex in primeCache) {
                return primeCache[hex];
            }
            var error = 0;

            if (prime.isEven() ||
                !primes.simpleSieve ||
                !primes.fermatTest(prime) ||
                !millerRabin.test(prime)) {
                //not a prime so +1
                error += 1;

                if (gen === '02' || gen === '05') {
                    // we'd be able to check the generator
                    // it would fail so +8
                    error += 8;
                } else {
                    //we wouldn't be able to test the generator
                    // so +4
                    error += 4;
                }
                primeCache[hex] = error;
                return error;
            }
            if (!millerRabin.test(prime.shrn(1))) {
                //not a safe prime
                error += 2;
            }
            var gen = generator.toString('hex');
            var rem;
            switch (gen) {
                case '02':
                    if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
                        // unsuidable generator
                        error += 8;
                    }
                    break;
                case '05':
                    rem = prime.mod(TEN);
                    if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
                        // prime mod 10 needs to equal 3 or 7
                        error += 8;
                    }
                    break;
                default:
                    error += 4;
            }
            primeCache[hex] = error;
            return error;
        }
        function defineError (self, error) {
            try {
                Object.defineProperty(self, 'verifyError', {
                    enumerable: true,
                    value: error,
                    writable: false
                });
            } catch(e) {
                self.verifyError = error;
            }
        }
        function DH(prime, generator,crypto, malleable) {
            this.setGenerator(generator);
            this.__prime = new BN(prime);
            this._prime = BN.mont(this.__prime);
            this._pub = void 0;
            this._priv = void 0;

            if (malleable) {
                this.setPublicKey = setPublicKey;
                this.setPrivateKey = setPrivateKey;
                defineError(this, checkPrime(this.__prime, generator));
            } else {
                defineError(this, 8);
            }
            this._makeNum = function makeNum() {
                return crypto.randomBytes(prime.length);
            };
        }
        DH.prototype.generateKeys = function () {
            if (!this._priv) {
                this._priv = new BN(this._makeNum());
            }
            this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
            return this.getPublicKey();
        };

        DH.prototype.computeSecret = function (other) {
            other = new BN(other);
            other = other.toRed(this._prime);
            var secret = other.redPow(this._priv).fromRed();
            var out = new Buffer(secret.toArray());
            var prime = this.getPrime();
            if (out.length < prime.length) {
                var front = new Buffer(prime.length - out.length);
                front.fill(0);
                out = Buffer.concat([front, out]);
            }
            return out;
        };
        DH.prototype.getPublicKey = function getPublicKey(enc) {
            return returnValue(this._pub, enc);
        };
        DH.prototype.getPrivateKey = function getPrivateKey(enc) {
            return returnValue(this._priv, enc);
        };

        DH.prototype.getPrime = function (enc) {
            return returnValue(this.__prime, enc);
        };
        DH.prototype.getGenerator = function (enc) {
            return returnValue(this._gen, enc);
        };
        DH.prototype.setGenerator = function (gen, enc) {
            enc = enc || 'utf8';
            if (!Buffer.isBuffer(gen)) {
                gen = new Buffer(gen, enc);
            }
            this._gen = new BN(gen);
        };

        function returnValue(bn, enc) {
            var buf = new Buffer(bn.toArray());
            if (!enc) {
                return buf;
            } else {
                return buf.toString(enc);
            }
        }
    }).call(this,require("buffer").Buffer)
},{"./generatePrime":101,"bn.js":103,"buffer":3,"miller-rabin":104}],101:[function(require,module,exports){

    module.exports = findPrime;
    findPrime.simpleSieve = simpleSieve;
    findPrime.fermatTest = fermatTest;
    var BN = require('bn.js');
    var TWENTYFOUR = new BN(24);
    var MillerRabin = require('miller-rabin');
    var millerRabin = new MillerRabin();
    var ONE = new BN(1);
    var TWO = new BN(2);
    var FIVE = new BN(5);
    var SIXTEEN = new BN(16);
    var EIGHT = new BN(8);
    var TEN = new BN(10);
    var THREE = new BN(3);
    var SEVEN = new BN(7);
    var ELEVEN = new BN(11);
    var FOUR = new BN(4);
    var TWELVE = new BN(12);
    var primes = null;

    function _getPrimes() {
        if (primes !== null)
            return primes;

        var limit = 0x100000;
        var res = [];
        res[0] = 2;
        for (var i = 1, k = 3; k < limit; k += 2) {
            var sqrt = Math.ceil(Math.sqrt(k));
            for (var j = 0; j < i && res[j] <= sqrt; j++)
                if (k % res[j] === 0)
                    break;

            if (i !== j && res[j] <= sqrt)
                continue;

            res[i++] = k;
        }
        primes = res;
        return res;
    }
    function simpleSieve(p) {
        var primes = _getPrimes();

        for (var i = 0; i < primes.length; i++)
            if (p.modn(primes[i]) === 0) {
                if (p.cmpn(primes[i]) === 0) {
                    return true;
                } else {
                    return false;
                }
            }

        return true;
    }
    function fermatTest(p) {
        var red = BN.mont(p);
        return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
    }
    function findPrime(bits, gen ,crypto) {
        if (bits < 16) {
            // this is what openssl does
            if (gen === 2 || gen === 5) {
                return new BN([0x8c, 0x7b]);
            } else {
                return new BN([0x8c, 0x27]);
            }
        }
        gen = new BN(gen);
        var runs, comp;
        function generateRandom(bits) {
            runs = -1;
            var out = new BN(crypto.randomBytes(Math.ceil(bits / 8)));
            while (out.bitLength() > bits) {
                out.ishrn(1);
            }
            if (out.isEven()) {
                out.iadd(ONE);
            }
            if (!out.testn(1)) {
                out.iadd(TWO);
            }
            if (!gen.cmp(TWO)) {
                while (out.mod(TWENTYFOUR).cmp(ELEVEN)) {
                    out.iadd(FOUR);
                }
                comp = {
                    major: [TWENTYFOUR],
                    minor: [TWELVE]
                };
            } else if (!gen.cmp(FIVE)) {
                rem = out.mod(TEN);
                while (rem.cmp(THREE)) {
                    out.iadd(FOUR);
                    rem = out.mod(TEN);
                }
                comp = {
                    major: [FOUR, SIXTEEN],
                    minor: [TWO, EIGHT]
                };
            } else {
                comp = {
                    major: [FOUR],
                    minor: [TWO]
                };
            }
            return out;
        }
        var num = generateRandom(bits);



        var n2 = num.shrn(1);

        while (true) {
            while (num.bitLength() > bits) {
                num = generateRandom(bits);
                n2 = num.shrn(1);
            }
            runs++;
            if (simpleSieve(n2) &&  simpleSieve(num) &&
                fermatTest(n2) &&  fermatTest(num) &&
                millerRabin.test(n2) && millerRabin.test(num)) {
                return num;
            }
            num.iadd(comp.major[runs%comp.major.length]);
            n2.iadd(comp.minor[runs%comp.minor.length]);
        }

    }
},{"bn.js":103,"miller-rabin":104}],102:[function(require,module,exports){
    (function (Buffer){
        var primes = require('./primes.json');
        var DH = require('./dh');
        var generatePrime = require('./generatePrime');
        module.exports = function (crypto, exports) {
            exports.DiffieHellmanGroup =
                exports.createDiffieHellmanGroup =
                    exports.getDiffieHellman = DiffieHellmanGroup;
            function DiffieHellmanGroup(mod) {
                return new DH(new Buffer(primes[mod].prime, 'hex'),
                    new Buffer(primes[mod].gen, 'hex'), crypto);
            }
            exports.createDiffieHellman = exports.DiffieHellman = DiffieHellman;
            function DiffieHellman(prime, enc, generator, genc) {

                if (Buffer.isBuffer(enc) ||
                    (typeof enc === 'string' && ['hex', 'binary', 'base64'].indexOf(enc) === -1)) {
                    genc = generator;
                    generator = enc
                    enc = void 0;
                }
                enc = enc || 'binary';
                genc = genc || 'binary';
                generator = generator || new Buffer([2]);
                if (!Buffer.isBuffer(generator)) {
                    generator = new Buffer(generator, genc);
                }
                if (typeof prime === 'number') {
                    return new DH(generatePrime(prime, generator, crypto), generator, crypto, true);
                }
                if (!Buffer.isBuffer(prime)) {
                    prime = new Buffer(prime, enc);
                }

                return new DH(prime, generator, crypto, true);
            };
        }
    }).call(this,require("buffer").Buffer)
},{"./dh":100,"./generatePrime":101,"./primes.json":107,"buffer":3}],103:[function(require,module,exports){
    arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],104:[function(require,module,exports){
    var bn = require('bn.js');
    var brorand = require('brorand');

    function MillerRabin(rand) {
        this.rand = rand || new brorand.Rand();
    }
    module.exports = MillerRabin;

    MillerRabin.create = function create(rand) {
        return new MillerRabin(rand);
    };

    MillerRabin.prototype._rand = function _rand(n) {
        var len = n.bitLength();
        var buf = this.rand.generate(Math.ceil(len / 8));

        // Set low bits
        buf[0] |= 3;

        // Mask high bits
        var mask = len & 0x7;
        if (mask !== 0)
            buf[buf.length - 1] >>= 7 - mask;

        return new bn(buf);
    }

    MillerRabin.prototype.test = function test(n, k, cb) {
        var len = n.bitLength();
        var red = bn.mont(n);
        var rone = new bn(1).toRed(red);

        if (!k)
            k = Math.max(1, (len / 48) | 0);

        // Find d and s, (n - 1) = (2 ^ s) * d;
        var n1 = n.subn(1);
        var n2 = n1.subn(1);
        for (var s = 0; !n1.testn(s); s++) {}
        var d = n.shrn(s);

        var rn1 = n1.toRed(red);

        var prime = true;
        for (; k > 0; k--) {
            var a = this._rand(n2);
            if (cb)
                cb(a);

            var x = a.toRed(red).redPow(d);
            if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
                continue;

            for (var i = 1; i < s; i++) {
                x = x.redSqr();

                if (x.cmp(rone) === 0)
                    return false;
                if (x.cmp(rn1) === 0)
                    break;
            }

            if (i === s)
                return false;
        }

        return prime;
    };

    MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
        var len = n.bitLength();
        var red = bn.mont(n);
        var rone = new bn(1).toRed(red);

        if (!k)
            k = Math.max(1, (len / 48) | 0);

        // Find d and s, (n - 1) = (2 ^ s) * d;
        var n1 = n.subn(1);
        var n2 = n1.subn(1);
        for (var s = 0; !n1.testn(s); s++) {}
        var d = n.shrn(s);

        var rn1 = n1.toRed(red);

        var prime = true;
        for (; k > 0; k--) {
            var a = this._rand(n2);

            var g = n.gcd(a);
            if (g.cmpn(1) !== 0)
                return g;

            var x = a.toRed(red).redPow(d);
            if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
                continue;

            for (var i = 1; i < s; i++) {
                x = x.redSqr();

                if (x.cmp(rone) === 0)
                    return x.fromRed().subn(1).gcd(n);
                if (x.cmp(rn1) === 0)
                    break;
            }

            if (i === s) {
                x = x.redSqr();
                return x.fromRed().subn(1).gcd(n);
            }
        }

        return prime;
    };

},{"bn.js":105,"brorand":106}],105:[function(require,module,exports){
    arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],106:[function(require,module,exports){
    arguments[4][47][0].apply(exports,arguments)
},{"dup":47}],107:[function(require,module,exports){
    module.exports={
        "modp1": {
            "gen": "02",
            "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
        },
        "modp2": {
            "gen": "02",
            "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
        },
        "modp5": {
            "gen": "02",
            "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
        },
        "modp14": {
            "gen": "02",
            "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
        },
        "modp15": {
            "gen": "02",
            "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
        },
        "modp16": {
            "gen": "02",
            "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
        },
        "modp17": {
            "gen": "02",
            "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
        },
        "modp18": {
            "gen": "02",
            "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
        }
    }
},{}],108:[function(require,module,exports){
    (function (Buffer){
        module.exports = function(crypto) {
            function pbkdf2(password, salt, iterations, keylen, digest, callback) {
                if ('function' === typeof digest) {
                    callback = digest
                    digest = undefined
                }

                if ('function' !== typeof callback)
                    throw new Error('No callback provided to pbkdf2')

                setTimeout(function() {
                    var result

                    try {
                        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
                    } catch (e) {
                        return callback(e)
                    }

                    callback(undefined, result)
                })
            }

            function pbkdf2Sync(password, salt, iterations, keylen, digest) {
                if ('number' !== typeof iterations)
                    throw new TypeError('Iterations not a number')

                if (iterations < 0)
                    throw new TypeError('Bad iterations')

                if ('number' !== typeof keylen)
                    throw new TypeError('Key length not a number')

                if (keylen < 0)
                    throw new TypeError('Bad key length')

                digest = digest || 'sha1'

                if (!Buffer.isBuffer(password)) password = new Buffer(password)
                if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)

                var hLen, l = 1, r, T
                var DK = new Buffer(keylen)
                var block1 = new Buffer(salt.length + 4)
                salt.copy(block1, 0, 0, salt.length)

                for (var i = 1; i <= l; i++) {
                    block1.writeUInt32BE(i, salt.length)

                    var U = crypto.createHmac(digest, password).update(block1).digest()

                    if (!hLen) {
                        hLen = U.length
                        T = new Buffer(hLen)
                        l = Math.ceil(keylen / hLen)
                        r = keylen - (l - 1) * hLen

                        if (keylen > (Math.pow(2, 32) - 1) * hLen)
                            throw new TypeError('keylen exceeds maximum length')
                    }

                    U.copy(T, 0, 0, hLen)

                    for (var j = 1; j < iterations; j++) {
                        U = crypto.createHmac(digest, password).update(U).digest()

                        for (var k = 0; k < hLen; k++) {
                            T[k] ^= U[k]
                        }
                    }

                    var destPos = (i - 1) * hLen
                    var len = (i == l ? r : hLen)
                    T.copy(DK, destPos, 0, len)
                }

                return DK
            }

            return {
                pbkdf2: pbkdf2,
                pbkdf2Sync: pbkdf2Sync
            }
        }

    }).call(this,require("buffer").Buffer)
},{"buffer":3}],109:[function(require,module,exports){

    module.exports = function (exports, crypto) {
        exports.publicEncrypt = require('./publicEncrypt')(crypto);
        exports.privateDecrypt = require('./privateDecrypt')(crypto);
    };
},{"./privateDecrypt":134,"./publicEncrypt":135}],110:[function(require,module,exports){
    (function (Buffer){
        module.exports = function (seed, len, crypto) {
            var t = new Buffer('');
            var  i = 0, c;
            while (t.length < len) {
                c = i2ops(i++);
                t = Buffer.concat([t, crypto.createHash('sha1').update(seed).update(c).digest()]);
            }
            return t.slice(0, len);
        };

        function i2ops(c) {
            var out = new Buffer(4);
            out.writeUInt32BE(c,0);
            return out;
        }
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],111:[function(require,module,exports){
    arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],112:[function(require,module,exports){
    arguments[4][33][0].apply(exports,arguments)
},{"bn.js":113,"buffer":3,"dup":33}],113:[function(require,module,exports){
    arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],114:[function(require,module,exports){
    arguments[4][55][0].apply(exports,arguments)
},{"buffer":3,"dup":55}],115:[function(require,module,exports){
    arguments[4][56][0].apply(exports,arguments)
},{"dup":56}],116:[function(require,module,exports){
    arguments[4][57][0].apply(exports,arguments)
},{"asn1.js":120,"asn1.js-rfc3280":119,"dup":57}],117:[function(require,module,exports){
    arguments[4][58][0].apply(exports,arguments)
},{"./EVP_BytesToKey":114,"buffer":3,"dup":58}],118:[function(require,module,exports){
    arguments[4][59][0].apply(exports,arguments)
},{"./aesid.json":115,"./asn1":116,"./fixProc":117,"buffer":3,"dup":59,"pemstrip":133}],119:[function(require,module,exports){
    arguments[4][60][0].apply(exports,arguments)
},{"asn1.js":120,"dup":60}],120:[function(require,module,exports){
    arguments[4][61][0].apply(exports,arguments)
},{"./asn1/api":121,"./asn1/base":123,"./asn1/constants":127,"./asn1/decoders":129,"./asn1/encoders":131,"bn.js":132,"dup":61}],121:[function(require,module,exports){
    arguments[4][62][0].apply(exports,arguments)
},{"../asn1":120,"dup":62,"util":166,"vm":167}],122:[function(require,module,exports){
    arguments[4][63][0].apply(exports,arguments)
},{"../base":123,"assert":1,"buffer":3,"dup":63,"util":166}],123:[function(require,module,exports){
    arguments[4][64][0].apply(exports,arguments)
},{"./buffer":122,"./node":124,"./reporter":125,"dup":64}],124:[function(require,module,exports){
    arguments[4][65][0].apply(exports,arguments)
},{"../base":123,"assert":1,"dup":65}],125:[function(require,module,exports){
    arguments[4][66][0].apply(exports,arguments)
},{"dup":66,"util":166}],126:[function(require,module,exports){
    arguments[4][67][0].apply(exports,arguments)
},{"../constants":127,"dup":67}],127:[function(require,module,exports){
    arguments[4][68][0].apply(exports,arguments)
},{"./der":126,"dup":68}],128:[function(require,module,exports){
    arguments[4][69][0].apply(exports,arguments)
},{"../../asn1":120,"dup":69,"util":166}],129:[function(require,module,exports){
    arguments[4][70][0].apply(exports,arguments)
},{"./der":128,"dup":70}],130:[function(require,module,exports){
    arguments[4][71][0].apply(exports,arguments)
},{"../../asn1":120,"buffer":3,"dup":71,"util":166}],131:[function(require,module,exports){
    arguments[4][72][0].apply(exports,arguments)
},{"./der":130,"dup":72}],132:[function(require,module,exports){
    arguments[4][73][0].apply(exports,arguments)
},{"dup":73}],133:[function(require,module,exports){
    arguments[4][74][0].apply(exports,arguments)
},{"dup":74}],134:[function(require,module,exports){
    (function (Buffer){
        var parseKeys = require('parse-asn1');
        var mgf = require('./mgf');
        var xor = require('./xor');
        var bn = require('bn.js');
        var crt = require('browserify-rsa');
        module.exports = function (crypto) {
            return privateDecrypt;
            function privateDecrypt(private_key, enc) {
                var padding;
                if (private_key.padding) {
                    padding = private_key.padding;
                } else {
                    padding = 4;
                }

                var key = parseKeys(private_key, crypto);
                var k = key.modulus.byteLength();
                if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
                    throw new Error('decryption error');
                }
                var msg = crt(enc, key, crypto);
                var zBuffer = new Buffer(k - msg.length);
                zBuffer.fill(0);
                msg = Buffer.concat([zBuffer, msg], k);
                if (padding === 4) {
                    return oaep(key, msg, crypto);
                } else if (padding === 1) {
                    return pkcs1(key, msg, crypto);
                } else if (padding === 3) {
                    return msg;
                } else {
                    throw new Error('unknown padding');
                }
            }
        };

        function oaep(key, msg, crypto){
            var n = key.modulus;
            var k = key.modulus.byteLength();
            var mLen = msg.length;
            var iHash = crypto.createHash('sha1').update(new Buffer('')).digest();
            var hLen = iHash.length;
            var hLen2 = 2 * hLen;
            if (msg[0] !== 0) {
                throw new Error('decryption error');
            }
            var maskedSeed = msg.slice(1, hLen + 1);
            var maskedDb =  msg.slice(hLen + 1);
            var seed = xor(maskedSeed, mgf(maskedDb, hLen, crypto));
            var db = xor(maskedDb, mgf(seed, k - hLen - 1, crypto));
            if (compare(iHash, db.slice(0, hLen))) {
                throw new Error('decryption error');
            }
            var i = hLen;
            while (db[i] === 0) {
                i++;
            }
            if (db[i++] !== 1) {
                throw new Error('decryption error');
            }
            return db.slice(i);
        }

        function pkcs1(key, msg, crypto){
            var p1 = msg.slice(0, 2);
            var i = 2;
            var status = 0;
            while (msg[i++] !== 0) {
                if (i >= msg.length) {
                    status++;
                    break;
                }
            }
            var ps = msg.slice(2, i - 1);
            var p2 = msg.slice(i - 1, i);

            if (p1.toString('hex') !== '0002') {
                status++;
            }
            if (ps.length < 8) {
                status++;
            }
            return  msg.slice(i);
        }
        function compare(a, b){
            var dif = 0;
            var len = a.length;
            if (a.length !== b.length) {
                dif++;
                len = Math.min(a.length, b.length);
            }
            var i = -1;
            while (++i < len) {
                dif += (a[i] ^ b[i]);
            }
            return dif;
        }
    }).call(this,require("buffer").Buffer)
},{"./mgf":110,"./xor":136,"bn.js":111,"browserify-rsa":112,"buffer":3,"parse-asn1":118}],135:[function(require,module,exports){
    (function (Buffer){
        var parseKeys = require('parse-asn1');
        var mgf = require('./mgf');
        var xor = require('./xor');
        var bn = require('bn.js');
        var constants = {
            RSA_PKCS1_OAEP_PADDING: 4,
            RSA_PKCS1_PADDIN: 1,
            RSA_NO_PADDING: 3
        };

        module.exports = function (crypto) {
            return publicEncrypt;
            function publicEncrypt(public_key, msg) {
                var padding;
                if (public_key.padding) {
                    padding = public_key.padding;
                } else {
                    padding = 4;
                }
                var key = parseKeys(public_key);
                var paddedMsg;
                if (padding === 4) {
                    paddedMsg = oaep(key, msg, crypto);
                } else if (padding === 1) {
                    paddedMsg = pkcs1(key, msg, crypto);
                } else if (padding === 3) {
                    paddedMsg = new bn(msg);
                    if (paddedMsg.cmp(key.modulus) >= 0) {
                        throw new Error('data too long for modulus');
                    }
                } else {
                    throw new Error('unknown padding');
                }
                var enc = paddedMsg
                    .toRed(bn.mont(key.modulus))
                    .redPow(new bn(key.publicExponent))
                    .fromRed()
                    .toArray();
                return new Buffer(enc);
            }
        };

        function oaep(key, msg, crypto){
            var k = key.modulus.byteLength();
            var mLen = msg.length;
            var iHash = crypto.createHash('sha1').update(new Buffer('')).digest();
            var hLen = iHash.length;
            var hLen2 = 2 * hLen;
            if (mLen > k - hLen2 - 2) {
                throw new Error('message too long');
            }
            var ps = new Buffer(k - mLen - hLen2 - 2);
            ps.fill(0);
            var dblen = k - hLen - 1;
            var seed = crypto.randomBytes(hLen);
            var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen, crypto));
            var maskedSeed = xor(seed, mgf(maskedDb, hLen, crypto));
            return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
        }
        function pkcs1(key, msg, crypto){
            var mLen = msg.length;
            var k = key.modulus.byteLength();
            if (mLen > k - 11) {
                throw new Error('message too long');
            }
            var ps = nonZero(k - mLen - 3, crypto);
            return new bn(Buffer.concat([new Buffer([0, 2]), ps, new Buffer([0]), msg], k));
        }
        function nonZero(len, crypto) {
            var out = new Buffer(len);
            var i = 0;
            var cache = crypto.randomBytes(len*2);
            var cur = 0;
            var num;
            while (i < len) {
                if (cur === cache.length) {
                    cache = crypto.randomBytes(len*2);
                    cur = 0;
                }
                num = cache[cur++];
                if (num) {
                    out[i++] = num;
                }
            }
            return out;
        }
    }).call(this,require("buffer").Buffer)
},{"./mgf":110,"./xor":136,"bn.js":111,"buffer":3,"parse-asn1":118}],136:[function(require,module,exports){
    module.exports = function xor(a, b) {
        var len = a.length;
        var i = -1;
        while (++i < len) {
            a[i] ^= b[i];
        }
        return a
    };
},{}],137:[function(require,module,exports){
    (function (Buffer){

        module.exports = ripemd160



        /*
         CryptoJS v3.1.2
         code.google.com/p/crypto-js
         (c) 2009-2013 by Jeff Mott. All rights reserved.
         code.google.com/p/crypto-js/wiki/License
         */
        /** @preserve
         (c) 2012 by Cdric Mesnil. All rights reserved.

         Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

         - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
         - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

         THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         */

// Constants table
        var zl = [
            0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
            7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
            3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
            1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
            4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
        var zr = [
            5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
            6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
            15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
            8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
            12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
        var sl = [
            11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
            7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
            11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
            11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
            9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
        var sr = [
            8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
            9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
            9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
            15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
            8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];

        var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
        var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];

        var bytesToWords = function (bytes) {
            var words = [];
            for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
                words[b >>> 5] |= bytes[i] << (24 - b % 32);
            }
            return words;
        };

        var wordsToBytes = function (words) {
            var bytes = [];
            for (var b = 0; b < words.length * 32; b += 8) {
                bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
            }
            return bytes;
        };

        var processBlock = function (H, M, offset) {

            // Swap endian
            for (var i = 0; i < 16; i++) {
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];

                // Swap
                M[offset_i] = (
                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                );
            }

            // Working variables
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;

            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            // Computation
            var t;
            for (var i = 0; i < 80; i += 1) {
                t = (al +  M[offset+zl[i]])|0;
                if (i<16){
                    t +=  f1(bl,cl,dl) + hl[0];
                } else if (i<32) {
                    t +=  f2(bl,cl,dl) + hl[1];
                } else if (i<48) {
                    t +=  f3(bl,cl,dl) + hl[2];
                } else if (i<64) {
                    t +=  f4(bl,cl,dl) + hl[3];
                } else {// if (i<80) {
                    t +=  f5(bl,cl,dl) + hl[4];
                }
                t = t|0;
                t =  rotl(t,sl[i]);
                t = (t+el)|0;
                al = el;
                el = dl;
                dl = rotl(cl, 10);
                cl = bl;
                bl = t;

                t = (ar + M[offset+zr[i]])|0;
                if (i<16){
                    t +=  f5(br,cr,dr) + hr[0];
                } else if (i<32) {
                    t +=  f4(br,cr,dr) + hr[1];
                } else if (i<48) {
                    t +=  f3(br,cr,dr) + hr[2];
                } else if (i<64) {
                    t +=  f2(br,cr,dr) + hr[3];
                } else {// if (i<80) {
                    t +=  f1(br,cr,dr) + hr[4];
                }
                t = t|0;
                t =  rotl(t,sr[i]) ;
                t = (t+er)|0;
                ar = er;
                er = dr;
                dr = rotl(cr, 10);
                cr = br;
                br = t;
            }
            // Intermediate hash value
            t    = (H[1] + cl + dr)|0;
            H[1] = (H[2] + dl + er)|0;
            H[2] = (H[3] + el + ar)|0;
            H[3] = (H[4] + al + br)|0;
            H[4] = (H[0] + bl + cr)|0;
            H[0] =  t;
        };

        function f1(x, y, z) {
            return ((x) ^ (y) ^ (z));
        }

        function f2(x, y, z) {
            return (((x)&(y)) | ((~x)&(z)));
        }

        function f3(x, y, z) {
            return (((x) | (~(y))) ^ (z));
        }

        function f4(x, y, z) {
            return (((x) & (z)) | ((y)&(~(z))));
        }

        function f5(x, y, z) {
            return ((x) ^ ((y) |(~(z))));
        }

        function rotl(x,n) {
            return (x<<n) | (x>>>(32-n));
        }

        function ripemd160(message) {
            var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];

            if (typeof message == 'string')
                message = new Buffer(message, 'utf8');

            var m = bytesToWords(message);

            var nBitsLeft = message.length * 8;
            var nBitsTotal = message.length * 8;

            // Add padding
            m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
            );

            for (var i=0 ; i<m.length; i += 16) {
                processBlock(H, m, i);
            }

            // Swap endian
            for (var i = 0; i < 5; i++) {
                // Shortcut
                var H_i = H[i];

                // Swap
                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                    (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
            }

            var digestbytes = wordsToBytes(H);
            return new Buffer(digestbytes);
        }



    }).call(this,require("buffer").Buffer)
},{"buffer":3}],138:[function(require,module,exports){
    (function (Buffer){


//prototype class for hash functions
        function Hash (blockSize, finalSize) {
            this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
            this._finalSize = finalSize
            this._blockSize = blockSize
            this._len = 0
            this._s = 0
        }

        Hash.prototype.init = function () {
            this._s = 0
            this._len = 0
        }

        Hash.prototype.update = function (data, enc) {
            if ("string" === typeof data) {
                enc = enc || "utf8"
                data = new Buffer(data, enc)
            }

            var l = this._len += data.length
            var s = this._s = (this._s || 0)
            var f = 0
            var buffer = this._block

            while (s < l) {
                var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
                var ch = (t - f)

                for (var i = 0; i < ch; i++) {
                    buffer[(s % this._blockSize) + i] = data[i + f]
                }

                s += ch
                f += ch

                if ((s % this._blockSize) === 0) {
                    this._update(buffer)
                }
            }
            this._s = s

            return this
        }

        Hash.prototype.digest = function (enc) {
            // Suppose the length of the message M, in bits, is l
            var l = this._len * 8

            // Append the bit 1 to the end of the message
            this._block[this._len % this._blockSize] = 0x80

            // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
            this._block.fill(0, this._len % this._blockSize + 1)

            if (l % (this._blockSize * 8) >= this._finalSize * 8) {
                this._update(this._block)
                this._block.fill(0)
            }

            // to this append the block which is equal to the number l written in binary
            // TODO: handle case where l is > Math.pow(2, 29)
            this._block.writeInt32BE(l, this._blockSize - 4)

            var hash = this._update(this._block) || this._hash()

            return enc ? hash.toString(enc) : hash
        }

        Hash.prototype._update = function () {
            throw new Error('_update must be implemented by subclass')
        }

        module.exports = Hash

    }).call(this,require("buffer").Buffer)
},{"buffer":3}],139:[function(require,module,exports){
    var exports = module.exports = function (alg) {
        var Alg = exports[alg.toLowerCase()]
        if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
        return new Alg()
    }


    exports.sha1 = require('./sha1')
    exports.sha224 = require('./sha224')
    exports.sha256 = require('./sha256')
    exports.sha384 = require('./sha384')
    exports.sha512 = require('./sha512')

},{"./sha1":140,"./sha224":141,"./sha256":142,"./sha384":143,"./sha512":144}],140:[function(require,module,exports){
    (function (Buffer){
        /*
         * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
         * in FIPS PUB 180-1
         * Version 2.1a Copyright Paul Johnston 2000 - 2002.
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         * Distributed under the BSD License
         * See http://pajhome.org.uk/crypt/md5 for details.
         */

        var inherits = require('util').inherits

        var Hash = require('./hash')

        var A = 0|0
        var B = 4|0
        var C = 8|0
        var D = 12|0
        var E = 16|0

        var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)

        var POOL = []

        function Sha1 () {
            if(POOL.length)
                return POOL.pop().init()

            if(!(this instanceof Sha1)) return new Sha1()
            this._w = W
            Hash.call(this, 16*4, 14*4)

            this._h = null
            this.init()
        }

        inherits(Sha1, Hash)

        Sha1.prototype.init = function () {
            this._a = 0x67452301
            this._b = 0xefcdab89
            this._c = 0x98badcfe
            this._d = 0x10325476
            this._e = 0xc3d2e1f0

            Hash.prototype.init.call(this)
            return this
        }

        Sha1.prototype._POOL = POOL
        Sha1.prototype._update = function (X) {

            var a, b, c, d, e, _a, _b, _c, _d, _e

            a = _a = this._a
            b = _b = this._b
            c = _c = this._c
            d = _d = this._d
            e = _e = this._e

            var w = this._w

            for(var j = 0; j < 80; j++) {
                var W = w[j] = j < 16 ? X.readInt32BE(j*4)
                    : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)

                var t = add(
                    add(rol(a, 5), sha1_ft(j, b, c, d)),
                    add(add(e, W), sha1_kt(j))
                )

                e = d
                d = c
                c = rol(b, 30)
                b = a
                a = t
            }

            this._a = add(a, _a)
            this._b = add(b, _b)
            this._c = add(c, _c)
            this._d = add(d, _d)
            this._e = add(e, _e)
        }

        Sha1.prototype._hash = function () {
            if(POOL.length < 100) POOL.push(this)
            var H = new Buffer(20)
            //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
            H.writeInt32BE(this._a|0, A)
            H.writeInt32BE(this._b|0, B)
            H.writeInt32BE(this._c|0, C)
            H.writeInt32BE(this._d|0, D)
            H.writeInt32BE(this._e|0, E)
            return H
        }

        /*
         * Perform the appropriate triplet combination function for the current
         * iteration
         */
        function sha1_ft(t, b, c, d) {
            if(t < 20) return (b & c) | ((~b) & d);
            if(t < 40) return b ^ c ^ d;
            if(t < 60) return (b & c) | (b & d) | (c & d);
            return b ^ c ^ d;
        }

        /*
         * Determine the appropriate additive constant for the current iteration
         */
        function sha1_kt(t) {
            return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
                (t < 60) ? -1894007588 : -899497514;
        }

        /*
         * Add integers, wrapping at 2^32. This uses 16-bit operations internally
         * to work around bugs in some JS interpreters.
         * //dominictarr: this is 10 years old, so maybe this can be dropped?)
         *
         */
        function add(x, y) {
            return (x + y ) | 0
//lets see how this goes on testling.
//  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
//  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
//  return (msw << 16) | (lsw & 0xFFFF);
        }

        /*
         * Bitwise rotate a 32-bit number to the left.
         */
        function rol(num, cnt) {
            return (num << cnt) | (num >>> (32 - cnt));
        }

        module.exports = Sha1


    }).call(this,require("buffer").Buffer)
},{"./hash":138,"buffer":3,"util":166}],141:[function(require,module,exports){
    (function (Buffer){

        /**
         * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
         * in FIPS 180-2
         * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         *
         */

        var inherits = require('util').inherits
        var SHA256 = require('./sha256')
        var Hash = require('./hash')

        var W = new Array(64)

        function Sha224() {
            this.init()

            this._w = W //new Array(64)

            Hash.call(this, 16*4, 14*4)
        }

        inherits(Sha224, SHA256)

        Sha224.prototype.init = function () {

            this._a = 0xc1059ed8|0
            this._b = 0x367cd507|0
            this._c = 0x3070dd17|0
            this._d = 0xf70e5939|0
            this._e = 0xffc00b31|0
            this._f = 0x68581511|0
            this._g = 0x64f98fa7|0
            this._h = 0xbefa4fa4|0

            this._len = this._s = 0

            return this
        }


        Sha224.prototype._hash = function () {
            var H = new Buffer(28)

            H.writeInt32BE(this._a,  0)
            H.writeInt32BE(this._b,  4)
            H.writeInt32BE(this._c,  8)
            H.writeInt32BE(this._d, 12)
            H.writeInt32BE(this._e, 16)
            H.writeInt32BE(this._f, 20)
            H.writeInt32BE(this._g, 24)

            return H
        }

        module.exports = Sha224

    }).call(this,require("buffer").Buffer)
},{"./hash":138,"./sha256":142,"buffer":3,"util":166}],142:[function(require,module,exports){
    (function (Buffer){

        /**
         * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
         * in FIPS 180-2
         * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         *
         */

        var inherits = require('util').inherits

        var Hash = require('./hash')

        var K = [
            0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
            0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
            0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
            0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
            0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
            0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
            0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
            0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
            0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
            0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
            0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
            0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
            0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
            0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
            0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
            0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
        ]

        var W = new Array(64)

        function Sha256() {
            this.init()

            this._w = W //new Array(64)

            Hash.call(this, 16*4, 14*4)
        }

        inherits(Sha256, Hash)

        Sha256.prototype.init = function () {

            this._a = 0x6a09e667|0
            this._b = 0xbb67ae85|0
            this._c = 0x3c6ef372|0
            this._d = 0xa54ff53a|0
            this._e = 0x510e527f|0
            this._f = 0x9b05688c|0
            this._g = 0x1f83d9ab|0
            this._h = 0x5be0cd19|0

            this._len = this._s = 0

            return this
        }

        function S (X, n) {
            return (X >>> n) | (X << (32 - n));
        }

        function R (X, n) {
            return (X >>> n);
        }

        function Ch (x, y, z) {
            return ((x & y) ^ ((~x) & z));
        }

        function Maj (x, y, z) {
            return ((x & y) ^ (x & z) ^ (y & z));
        }

        function Sigma0256 (x) {
            return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
        }

        function Sigma1256 (x) {
            return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
        }

        function Gamma0256 (x) {
            return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
        }

        function Gamma1256 (x) {
            return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
        }

        Sha256.prototype._update = function(M) {

            var W = this._w
            var a, b, c, d, e, f, g, h
            var T1, T2

            a = this._a | 0
            b = this._b | 0
            c = this._c | 0
            d = this._d | 0
            e = this._e | 0
            f = this._f | 0
            g = this._g | 0
            h = this._h | 0

            for (var j = 0; j < 64; j++) {
                var w = W[j] = j < 16
                    ? M.readInt32BE(j * 4)
                    : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]

                T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w

                T2 = Sigma0256(a) + Maj(a, b, c);
                h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
            }

            this._a = (a + this._a) | 0
            this._b = (b + this._b) | 0
            this._c = (c + this._c) | 0
            this._d = (d + this._d) | 0
            this._e = (e + this._e) | 0
            this._f = (f + this._f) | 0
            this._g = (g + this._g) | 0
            this._h = (h + this._h) | 0

        };

        Sha256.prototype._hash = function () {
            var H = new Buffer(32)

            H.writeInt32BE(this._a,  0)
            H.writeInt32BE(this._b,  4)
            H.writeInt32BE(this._c,  8)
            H.writeInt32BE(this._d, 12)
            H.writeInt32BE(this._e, 16)
            H.writeInt32BE(this._f, 20)
            H.writeInt32BE(this._g, 24)
            H.writeInt32BE(this._h, 28)

            return H
        }

        module.exports = Sha256

    }).call(this,require("buffer").Buffer)
},{"./hash":138,"buffer":3,"util":166}],143:[function(require,module,exports){
    (function (Buffer){
        var inherits = require('util').inherits
        var SHA512 = require('./sha512');
        var Hash = require('./hash')

        var W = new Array(160)

        function Sha384() {
            this.init()
            this._w = W

            Hash.call(this, 128, 112)
        }

        inherits(Sha384, SHA512)

        Sha384.prototype.init = function () {

            this._a = 0xcbbb9d5d|0
            this._b = 0x629a292a|0
            this._c = 0x9159015a|0
            this._d = 0x152fecd8|0
            this._e = 0x67332667|0
            this._f = 0x8eb44a87|0
            this._g = 0xdb0c2e0d|0
            this._h = 0x47b5481d|0

            this._al = 0xc1059ed8|0
            this._bl = 0x367cd507|0
            this._cl = 0x3070dd17|0
            this._dl = 0xf70e5939|0
            this._el = 0xffc00b31|0
            this._fl = 0x68581511|0
            this._gl = 0x64f98fa7|0
            this._hl = 0xbefa4fa4|0

            this._len = this._s = 0

            return this
        }



        Sha384.prototype._hash = function () {
            var H = new Buffer(48)

            function writeInt64BE(h, l, offset) {
                H.writeInt32BE(h, offset)
                H.writeInt32BE(l, offset + 4)
            }

            writeInt64BE(this._a, this._al, 0)
            writeInt64BE(this._b, this._bl, 8)
            writeInt64BE(this._c, this._cl, 16)
            writeInt64BE(this._d, this._dl, 24)
            writeInt64BE(this._e, this._el, 32)
            writeInt64BE(this._f, this._fl, 40)

            return H
        }

        module.exports = Sha384

    }).call(this,require("buffer").Buffer)
},{"./hash":138,"./sha512":144,"buffer":3,"util":166}],144:[function(require,module,exports){
    (function (Buffer){
        var inherits = require('util').inherits

        var Hash = require('./hash')

        var K = [
            0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
            0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
            0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
            0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
            0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
            0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
            0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
            0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
            0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
            0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
            0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
            0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
            0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
            0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
            0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
            0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
            0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
            0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
            0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
            0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
            0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
            0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
            0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
            0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
            0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
            0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
            0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
            0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
            0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
            0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
            0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
            0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
            0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
            0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
            0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
            0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
            0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
            0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
            0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
            0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
        ]

        var W = new Array(160)

        function Sha512() {
            this.init()
            this._w = W

            Hash.call(this, 128, 112)
        }

        inherits(Sha512, Hash)

        Sha512.prototype.init = function () {

            this._a = 0x6a09e667|0
            this._b = 0xbb67ae85|0
            this._c = 0x3c6ef372|0
            this._d = 0xa54ff53a|0
            this._e = 0x510e527f|0
            this._f = 0x9b05688c|0
            this._g = 0x1f83d9ab|0
            this._h = 0x5be0cd19|0

            this._al = 0xf3bcc908|0
            this._bl = 0x84caa73b|0
            this._cl = 0xfe94f82b|0
            this._dl = 0x5f1d36f1|0
            this._el = 0xade682d1|0
            this._fl = 0x2b3e6c1f|0
            this._gl = 0xfb41bd6b|0
            this._hl = 0x137e2179|0

            this._len = this._s = 0

            return this
        }

        function S (X, Xl, n) {
            return (X >>> n) | (Xl << (32 - n))
        }

        function Ch (x, y, z) {
            return ((x & y) ^ ((~x) & z));
        }

        function Maj (x, y, z) {
            return ((x & y) ^ (x & z) ^ (y & z));
        }

        Sha512.prototype._update = function(M) {

            var W = this._w
            var a, b, c, d, e, f, g, h
            var al, bl, cl, dl, el, fl, gl, hl

            a = this._a | 0
            b = this._b | 0
            c = this._c | 0
            d = this._d | 0
            e = this._e | 0
            f = this._f | 0
            g = this._g | 0
            h = this._h | 0

            al = this._al | 0
            bl = this._bl | 0
            cl = this._cl | 0
            dl = this._dl | 0
            el = this._el | 0
            fl = this._fl | 0
            gl = this._gl | 0
            hl = this._hl | 0

            for (var i = 0; i < 80; i++) {
                var j = i * 2

                var Wi, Wil

                if (i < 16) {
                    Wi = W[j] = M.readInt32BE(j * 4)
                    Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)

                } else {
                    var x  = W[j - 15*2]
                    var xl = W[j - 15*2 + 1]
                    var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
                    var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)

                    x  = W[j - 2*2]
                    xl = W[j - 2*2 + 1]
                    var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
                    var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)

                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                    var Wi7  = W[j - 7*2]
                    var Wi7l = W[j - 7*2 + 1]

                    var Wi16  = W[j - 16*2]
                    var Wi16l = W[j - 16*2 + 1]

                    Wil = gamma0l + Wi7l
                    Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
                    Wil = Wil + gamma1l
                    Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
                    Wil = Wil + Wi16l
                    Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)

                    W[j] = Wi
                    W[j + 1] = Wil
                }

                var maj = Maj(a, b, c)
                var majl = Maj(al, bl, cl)

                var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
                var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
                var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
                var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)

                // t1 = h + sigma1 + ch + K[i] + W[i]
                var Ki = K[j]
                var Kil = K[j + 1]

                var ch = Ch(e, f, g)
                var chl = Ch(el, fl, gl)

                var t1l = hl + sigma1l
                var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
                t1l = t1l + chl
                t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
                t1l = t1l + Kil
                t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
                t1l = t1l + Wil
                t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

                // t2 = sigma0 + maj
                var t2l = sigma0l + majl
                var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

                h  = g
                hl = gl
                g  = f
                gl = fl
                f  = e
                fl = el
                el = (dl + t1l) | 0
                e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
                d  = c
                dl = cl
                c  = b
                cl = bl
                b  = a
                bl = al
                al = (t1l + t2l) | 0
                a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
            }

            this._al = (this._al + al) | 0
            this._bl = (this._bl + bl) | 0
            this._cl = (this._cl + cl) | 0
            this._dl = (this._dl + dl) | 0
            this._el = (this._el + el) | 0
            this._fl = (this._fl + fl) | 0
            this._gl = (this._gl + gl) | 0
            this._hl = (this._hl + hl) | 0

            this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
            this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
            this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
            this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
            this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
            this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
            this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
            this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
        }

        Sha512.prototype._hash = function () {
            var H = new Buffer(64)

            function writeInt64BE(h, l, offset) {
                H.writeInt32BE(h, offset)
                H.writeInt32BE(l, offset + 4)
            }

            writeInt64BE(this._a, this._al, 0)
            writeInt64BE(this._b, this._bl, 8)
            writeInt64BE(this._c, this._cl, 16)
            writeInt64BE(this._d, this._dl, 24)
            writeInt64BE(this._e, this._el, 32)
            writeInt64BE(this._f, this._fl, 40)
            writeInt64BE(this._g, this._gl, 48)
            writeInt64BE(this._h, this._hl, 56)

            return H
        }

        module.exports = Sha512

    }).call(this,require("buffer").Buffer)
},{"./hash":138,"buffer":3,"util":166}],145:[function(require,module,exports){
    
    var pbkdf2Export = require('pbkdf2-compat/pbkdf2')

    module.exports = function (crypto, exports) {
        exports = exports || {}

        var exported = pbkdf2Export(crypto)

        exports.pbkdf2 = exported.pbkdf2
        exports.pbkdf2Sync = exported.pbkdf2Sync

        return exports
    }

},{"pbkdf2-compat/pbkdf2":108}],146:[function(require,module,exports){
    (function (global,Buffer){
        
        (function() {
            var g = ('undefined' === typeof window ? global : window) || {}
            var _crypto = (
                g.crypto || g.msCrypto || require('crypto')
            )
            module.exports = function(size) {
                // Modern Browsers
                if(_crypto.getRandomValues) {
                    var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
                    /* This will not work in older browsers.
                     * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
                     */

                    _crypto.getRandomValues(bytes);
                    return bytes;
                }
                else if (_crypto.pseudoRandomBytes) {
                    return _crypto.pseudoRandomBytes(size)
                }
                else
                    throw new Error(
                        'pseudo random number generation not yet implemented for this browser\n'+
                        'use chrome, FireFox or Internet Explorer 11'
                    )
            }
        }())

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"buffer":3,"crypto":2}],147:[function(require,module,exports){
    (function (global,Buffer){
        
        (function() {
            var g = ('undefined' === typeof window ? global : window) || {}
            var _crypto = (
                g.crypto || g.msCrypto || require('crypto')
            )
            module.exports = function(size) {
                // Modern Browsers
                if(_crypto.getRandomValues) {
                    var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
                    /* This will not work in older browsers.
                     * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
                     */

                    _crypto.getRandomValues(bytes);
                    return bytes;
                }
                else if (_crypto.randomBytes) {
                    return _crypto.randomBytes(size)
                }
                else
                    throw new Error(
                        'secure random number generation not supported by this browser\n'+
                        'use chrome, FireFox or Internet Explorer 11'
                    )
            }
        }())

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"buffer":3,"crypto":2}],148:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function(n) {
        if (!isNumber(n) || n < 0 || isNaN(n))
            throw TypeError('n must be a positive number');
        this._maxListeners = n;
        return this;
    };

    EventEmitter.prototype.emit = function(type) {
        var er, handler, len, args, i, listeners;

        if (!this._events)
            this._events = {};

        // If there is no 'error' event listener then throw.
        if (type === 'error') {
            if (!this._events.error ||
                (isObject(this._events.error) && !this._events.error.length)) {
                er = arguments[1];
                if (er instanceof Error) {
                    throw er; // Unhandled 'error' event
                }
                throw TypeError('Uncaught, unspecified "error" event.');
            }
        }

        handler = this._events[type];

        if (isUndefined(handler))
            return false;

        if (isFunction(handler)) {
            switch (arguments.length) {
                // fast cases
                case 1:
                    handler.call(this);
                    break;
                case 2:
                    handler.call(this, arguments[1]);
                    break;
                case 3:
                    handler.call(this, arguments[1], arguments[2]);
                    break;
                // slower
                default:
                    len = arguments.length;
                    args = new Array(len - 1);
                    for (i = 1; i < len; i++)
                        args[i - 1] = arguments[i];
                    handler.apply(this, args);
            }
        } else if (isObject(handler)) {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
                args[i - 1] = arguments[i];

            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)
                listeners[i].apply(this, args);
        }

        return true;
    };

    EventEmitter.prototype.addListener = function(type, listener) {
        var m;

        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        if (!this._events)
            this._events = {};

        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (this._events.newListener)
            this.emit('newListener', type,
                isFunction(listener.listener) ?
                    listener.listener : listener);

        if (!this._events[type])
        // Optimize the case of one listener. Don't need the extra array object.
            this._events[type] = listener;
        else if (isObject(this._events[type]))
        // If we've already got an array, just append.
            this._events[type].push(listener);
        else
        // Adding the second element, need to change to array.
            this._events[type] = [this._events[type], listener];

        // Check for listener leak
        if (isObject(this._events[type]) && !this._events[type].warned) {
            var m;
            if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
            } else {
                m = EventEmitter.defaultMaxListeners;
            }

            if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
                if (typeof console.trace === 'function') {
                    // not supported in IE 10
                    console.trace();
                }
            }
        }

        return this;
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.once = function(type, listener) {
        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        var fired = false;

        function g() {
            this.removeListener(type, g);

            if (!fired) {
                fired = true;
                listener.apply(this, arguments);
            }
        }

        g.listener = listener;
        this.on(type, g);

        return this;
    };

// emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener = function(type, listener) {
        var list, position, length, i;

        if (!isFunction(listener))
            throw TypeError('listener must be a function');

        if (!this._events || !this._events[type])
            return this;

        list = this._events[type];
        length = list.length;
        position = -1;

        if (list === listener ||
            (isFunction(list.listener) && list.listener === listener)) {
            delete this._events[type];
            if (this._events.removeListener)
                this.emit('removeListener', type, listener);

        } else if (isObject(list)) {
            for (i = length; i-- > 0;) {
                if (list[i] === listener ||
                    (list[i].listener && list[i].listener === listener)) {
                    position = i;
                    break;
                }
            }

            if (position < 0)
                return this;

            if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
            } else {
                list.splice(position, 1);
            }

            if (this._events.removeListener)
                this.emit('removeListener', type, listener);
        }

        return this;
    };

    EventEmitter.prototype.removeAllListeners = function(type) {
        var key, listeners;

        if (!this._events)
            return this;

        // not listening for removeListener, no need to emit
        if (!this._events.removeListener) {
            if (arguments.length === 0)
                this._events = {};
            else if (this._events[type])
                delete this._events[type];
            return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
            for (key in this._events) {
                if (key === 'removeListener') continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = {};
            return this;
        }

        listeners = this._events[type];

        if (isFunction(listeners)) {
            this.removeListener(type, listeners);
        } else {
            // LIFO order
            while (listeners.length)
                this.removeListener(type, listeners[listeners.length - 1]);
        }
        delete this._events[type];

        return this;
    };

    EventEmitter.prototype.listeners = function(type) {
        var ret;
        if (!this._events || !this._events[type])
            ret = [];
        else if (isFunction(this._events[type]))
            ret = [this._events[type]];
        else
            ret = this._events[type].slice();
        return ret;
    };

    EventEmitter.listenerCount = function(emitter, type) {
        var ret;
        if (!emitter._events || !emitter._events[type])
            ret = 0;
        else if (isFunction(emitter._events[type]))
            ret = 1;
        else
            ret = emitter._events[type].length;
        return ret;
    };

    function isFunction(arg) {
        return typeof arg === 'function';
    }

    function isNumber(arg) {
        return typeof arg === 'number';
    }

    function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
    }

    function isUndefined(arg) {
        return arg === void 0;
    }

},{}],149:[function(require,module,exports){
    if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function () {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
        }
    }

},{}],150:[function(require,module,exports){
    module.exports = Array.isArray || function (arr) {
            return Object.prototype.toString.call(arr) == '[object Array]';
        };

},{}],151:[function(require,module,exports){
// shim for using process in browser

    var process = module.exports = {};

    process.nextTick = (function () {
        var canSetImmediate = typeof window !== 'undefined'
            && window.setImmediate;
        var canMutationObserver = typeof window !== 'undefined'
            && window.MutationObserver;
        var canPost = typeof window !== 'undefined'
                && window.postMessage && window.addEventListener
            ;

        if (canSetImmediate) {
            return function (f) { return window.setImmediate(f) };
        }

        var queue = [];

        if (canMutationObserver) {
            var hiddenDiv = document.createElement("div");
            var observer = new MutationObserver(function () {
                var queueList = queue.slice();
                queue.length = 0;
                queueList.forEach(function (fn) {
                    fn();
                });
            });

            observer.observe(hiddenDiv, { attributes: true });

            return function nextTick(fn) {
                if (!queue.length) {
                    hiddenDiv.setAttribute('yes', 'no');
                }
                queue.push(fn);
            };
        }

        if (canPost) {
            window.addEventListener('message', function (ev) {
                var source = ev.source;
                if ((source === window || source === null) && ev.data === 'process-tick') {
                    ev.stopPropagation();
                    if (queue.length > 0) {
                        var fn = queue.shift();
                        fn();
                    }
                }
            }, true);

            return function nextTick(fn) {
                queue.push(fn);
                window.postMessage('process-tick', '*');
            };
        }

        return function nextTick(fn) {
            setTimeout(fn, 0);
        };
    })();

    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

// TODO(shtylman)
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };

},{}],152:[function(require,module,exports){
    module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":153}],153:[function(require,module,exports){
    (function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

        module.exports = Duplex;

        /*<replacement>*/
        var objectKeys = Object.keys || function (obj) {
                var keys = [];
                for (var key in obj) keys.push(key);
                return keys;
            }
        /*</replacement>*/


        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/

        var Readable = require('./_stream_readable');
        var Writable = require('./_stream_writable');

        util.inherits(Duplex, Readable);

        forEach(objectKeys(Writable.prototype), function(method) {
            if (!Duplex.prototype[method])
                Duplex.prototype[method] = Writable.prototype[method];
        });

        function Duplex(options) {
            if (!(this instanceof Duplex))
                return new Duplex(options);

            Readable.call(this, options);
            Writable.call(this, options);

            if (options && options.readable === false)
                this.readable = false;

            if (options && options.writable === false)
                this.writable = false;

            this.allowHalfOpen = true;
            if (options && options.allowHalfOpen === false)
                this.allowHalfOpen = false;

            this.once('end', onend);
        }

// the no-half-open enforcer
        function onend() {
            // if we allow half-open state, or if the writable side ended,
            // then we're ok.
            if (this.allowHalfOpen || this._writableState.ended)
                return;

            // no more data can be written.
            // But allow more writes to happen in this tick.
            process.nextTick(this.end.bind(this));
        }

        function forEach (xs, f) {
            for (var i = 0, l = xs.length; i < l; i++) {
                f(xs[i], i);
            }
        }

    }).call(this,require('_process'))
},{"./_stream_readable":155,"./_stream_writable":157,"_process":151,"core-util-is":158,"inherits":149}],154:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

    module.exports = PassThrough;

    var Transform = require('./_stream_transform');

    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/

    util.inherits(PassThrough, Transform);

    function PassThrough(options) {
        if (!(this instanceof PassThrough))
            return new PassThrough(options);

        Transform.call(this, options);
    }

    PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
    };

},{"./_stream_transform":156,"core-util-is":158,"inherits":149}],155:[function(require,module,exports){
    (function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

        module.exports = Readable;

        /*<replacement>*/
        var isArray = require('isarray');
        /*</replacement>*/


        /*<replacement>*/
        var Buffer = require('buffer').Buffer;
        /*</replacement>*/

        Readable.ReadableState = ReadableState;

        var EE = require('events').EventEmitter;

        /*<replacement>*/
        if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
            return emitter.listeners(type).length;
        };
        /*</replacement>*/

        var Stream = require('stream');

        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/

        var StringDecoder;

        util.inherits(Readable, Stream);

        function ReadableState(options, stream) {
            options = options || {};

            // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"
            var hwm = options.highWaterMark;
            this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

            // cast to ints.
            this.highWaterMark = ~~this.highWaterMark;

            this.buffer = [];
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = false;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;

            // In streams that never have any data, and do push(null) right away,
            // the consumer can miss the 'end' event if they do some I/O before
            // consuming the stream.  So, we don't emit('end') until some reading
            // happens.
            this.calledRead = false;

            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, becuase any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true;

            // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;


            // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away
            this.objectMode = !!options.objectMode;

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || 'utf8';

            // when piping, we only care about 'readable' events that happen
            // after read()ing all the bytes and not getting any pushback.
            this.ranOut = false;

            // the number of writers that are awaiting a drain event in .pipe()s
            this.awaitDrain = 0;

            // if true, a maybeReadMore has been scheduled
            this.readingMore = false;

            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
                if (!StringDecoder)
                    StringDecoder = require('string_decoder/').StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
            }
        }

        function Readable(options) {
            if (!(this instanceof Readable))
                return new Readable(options);

            this._readableState = new ReadableState(options, this);

            // legacy
            this.readable = true;

            Stream.call(this);
        }

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
        Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;

            if (typeof chunk === 'string' && !state.objectMode) {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                    chunk = new Buffer(chunk, encoding);
                    encoding = '';
                }
            }

            return readableAddChunk(this, state, chunk, encoding, false);
        };

// Unshift should *always* be something directly out of read()
        Readable.prototype.unshift = function(chunk) {
            var state = this._readableState;
            return readableAddChunk(this, state, chunk, '', true);
        };

        function readableAddChunk(stream, state, chunk, encoding, addToFront) {
            var er = chunkInvalid(state, chunk);
            if (er) {
                stream.emit('error', er);
            } else if (chunk === null || chunk === undefined) {
                state.reading = false;
                if (!state.ended)
                    onEofChunk(stream, state);
            } else if (state.objectMode || chunk && chunk.length > 0) {
                if (state.ended && !addToFront) {
                    var e = new Error('stream.push() after EOF');
                    stream.emit('error', e);
                } else if (state.endEmitted && addToFront) {
                    var e = new Error('stream.unshift() after end event');
                    stream.emit('error', e);
                } else {
                    if (state.decoder && !addToFront && !encoding)
                        chunk = state.decoder.write(chunk);

                    // update the buffer info.
                    state.length += state.objectMode ? 1 : chunk.length;
                    if (addToFront) {
                        state.buffer.unshift(chunk);
                    } else {
                        state.reading = false;
                        state.buffer.push(chunk);
                    }

                    if (state.needReadable)
                        emitReadable(stream);

                    maybeReadMore(stream, state);
                }
            } else if (!addToFront) {
                state.reading = false;
            }

            return needMoreData(state);
        }



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
        function needMoreData(state) {
            return !state.ended &&
                (state.needReadable ||
                state.length < state.highWaterMark ||
                state.length === 0);
        }

// backwards compatibility.
        Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
                StringDecoder = require('string_decoder/').StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
        };

// Don't raise the hwm > 128MB
        var MAX_HWM = 0x800000;
        function roundUpToNextPowerOf2(n) {
            if (n >= MAX_HWM) {
                n = MAX_HWM;
            } else {
                // Get the next highest power of 2
                n--;
                for (var p = 1; p < 32; p <<= 1) n |= n >> p;
                n++;
            }
            return n;
        }

        function howMuchToRead(n, state) {
            if (state.length === 0 && state.ended)
                return 0;

            if (state.objectMode)
                return n === 0 ? 0 : 1;

            if (n === null || isNaN(n)) {
                // only flow one buffer at a time
                if (state.flowing && state.buffer.length)
                    return state.buffer[0].length;
                else
                    return state.length;
            }

            if (n <= 0)
                return 0;

            // If we're asking for more than the target buffer level,
            // then raise the water mark.  Bump up to the next highest
            // power of 2, to prevent increasing it excessively in tiny
            // amounts.
            if (n > state.highWaterMark)
                state.highWaterMark = roundUpToNextPowerOf2(n);

            // don't have that much.  return null, unless we've ended.
            if (n > state.length) {
                if (!state.ended) {
                    state.needReadable = true;
                    return 0;
                } else
                    return state.length;
            }

            return n;
        }

// you can override either this method, or the async _read(n) below.
        Readable.prototype.read = function(n) {
            var state = this._readableState;
            state.calledRead = true;
            var nOrig = n;
            var ret;

            if (typeof n !== 'number' || n > 0)
                state.emittedReadable = false;

            // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.
            if (n === 0 &&
                state.needReadable &&
                (state.length >= state.highWaterMark || state.ended)) {
                emitReadable(this);
                return null;
            }

            n = howMuchToRead(n, state);

            // if we've ended, and we're now clear, then finish it up.
            if (n === 0 && state.ended) {
                ret = null;

                // In cases where the decoder did not receive enough data
                // to produce a full chunk, then immediately received an
                // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
                // howMuchToRead will see this and coerce the amount to
                // read to zero (because it's looking at the length of the
                // first <Buffer > in state.buffer), and we'll end up here.
                //
                // This can only happen via state.decoder -- no other venue
                // exists for pushing a zero-length chunk into state.buffer
                // and triggering this behavior. In this case, we return our
                // remaining data and end the stream, if appropriate.
                if (state.length > 0 && state.decoder) {
                    ret = fromList(n, state);
                    state.length -= ret.length;
                }

                if (state.length === 0)
                    endReadable(this);

                return ret;
            }

            // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.

            // if we need a readable event, then we need to do some reading.
            var doRead = state.needReadable;

            // if we currently have less than the highWaterMark, then also read some
            if (state.length - n <= state.highWaterMark)
                doRead = true;

            // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.
            if (state.ended || state.reading)
                doRead = false;

            if (doRead) {
                state.reading = true;
                state.sync = true;
                // if the length is currently zero, then we *need* a readable event.
                if (state.length === 0)
                    state.needReadable = true;
                // call internal read method
                this._read(state.highWaterMark);
                state.sync = false;
            }

            // If _read called its callback synchronously, then `reading`
            // will be false, and we need to re-evaluate how much data we
            // can return to the user.
            if (doRead && !state.reading)
                n = howMuchToRead(nOrig, state);

            if (n > 0)
                ret = fromList(n, state);
            else
                ret = null;

            if (ret === null) {
                state.needReadable = true;
                n = 0;
            }

            state.length -= n;

            // If we have nothing in the buffer, then we want to know
            // as soon as we *do* get something into the buffer.
            if (state.length === 0 && !state.ended)
                state.needReadable = true;

            // If we happened to read() exactly the remaining amount in the
            // buffer, and the EOF has been seen at this point, then make sure
            // that we emit 'end' on the very next tick.
            if (state.ended && !state.endEmitted && state.length === 0)
                endReadable(this);

            return ret;
        };

        function chunkInvalid(state, chunk) {
            var er = null;
            if (!Buffer.isBuffer(chunk) &&
                'string' !== typeof chunk &&
                chunk !== null &&
                chunk !== undefined &&
                !state.objectMode) {
                er = new TypeError('Invalid non-string/buffer chunk');
            }
            return er;
        }


        function onEofChunk(stream, state) {
            if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                    state.buffer.push(chunk);
                    state.length += state.objectMode ? 1 : chunk.length;
                }
            }
            state.ended = true;

            // if we've ended and we have some data left, then emit
            // 'readable' now to make sure it gets picked up.
            if (state.length > 0)
                emitReadable(stream);
            else
                endReadable(stream);
        }

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
        function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (state.emittedReadable)
                return;

            state.emittedReadable = true;
            if (state.sync)
                process.nextTick(function() {
                    emitReadable_(stream);
                });
            else
                emitReadable_(stream);
        }

        function emitReadable_(stream) {
            stream.emit('readable');
        }


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
        function maybeReadMore(stream, state) {
            if (!state.readingMore) {
                state.readingMore = true;
                process.nextTick(function() {
                    maybeReadMore_(stream, state);
                });
            }
        }

        function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended &&
            state.length < state.highWaterMark) {
                stream.read(0);
                if (len === state.length)
                // didn't get any data, stop spinning.
                    break;
                else
                    len = state.length;
            }
            state.readingMore = false;
        }

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
        Readable.prototype._read = function(n) {
            this.emit('error', new Error('not implemented'));
        };

        Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;

            switch (state.pipesCount) {
                case 0:
                    state.pipes = dest;
                    break;
                case 1:
                    state.pipes = [state.pipes, dest];
                    break;
                default:
                    state.pipes.push(dest);
                    break;
            }
            state.pipesCount += 1;

            var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                dest !== process.stdout &&
                dest !== process.stderr;

            var endFn = doEnd ? onend : cleanup;
            if (state.endEmitted)
                process.nextTick(endFn);
            else
                src.once('end', endFn);

            dest.on('unpipe', onunpipe);
            function onunpipe(readable) {
                if (readable !== src) return;
                cleanup();
            }

            function onend() {
                dest.end();
            }

            // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            var ondrain = pipeOnDrain(src);
            dest.on('drain', ondrain);

            function cleanup() {
                // cleanup event handlers once the pipe is broken
                dest.removeListener('close', onclose);
                dest.removeListener('finish', onfinish);
                dest.removeListener('drain', ondrain);
                dest.removeListener('error', onerror);
                dest.removeListener('unpipe', onunpipe);
                src.removeListener('end', onend);
                src.removeListener('end', cleanup);

                // if the reader is waiting for a drain event from this
                // specific writer, then it would cause it to never start
                // flowing again.
                // So, if this is awaiting a drain, then we just call it now.
                // If we don't know, then assume that we are waiting for one.
                if (!dest._writableState || dest._writableState.needDrain)
                    ondrain();
            }

            // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.
            function onerror(er) {
                unpipe();
                dest.removeListener('error', onerror);
                if (EE.listenerCount(dest, 'error') === 0)
                    dest.emit('error', er);
            }
            // This is a brutally ugly hack to make sure that our error handler
            // is attached before any userland ones.  NEVER DO THIS.
            if (!dest._events || !dest._events.error)
                dest.on('error', onerror);
            else if (isArray(dest._events.error))
                dest._events.error.unshift(onerror);
            else
                dest._events.error = [onerror, dest._events.error];



            // Both close and finish should trigger unpipe, but only once.
            function onclose() {
                dest.removeListener('finish', onfinish);
                unpipe();
            }
            dest.once('close', onclose);
            function onfinish() {
                dest.removeListener('close', onclose);
                unpipe();
            }
            dest.once('finish', onfinish);

            function unpipe() {
                src.unpipe(dest);
            }

            // tell the dest that it's being piped to
            dest.emit('pipe', src);

            // start the flow if it hasn't been started already.
            if (!state.flowing) {
                // the handler that waits for readable events after all
                // the data gets sucked out in flow.
                // This would be easier to follow with a .once() handler
                // in flow(), but that is too slow.
                this.on('readable', pipeOnReadable);

                state.flowing = true;
                process.nextTick(function() {
                    flow(src);
                });
            }

            return dest;
        };

        function pipeOnDrain(src) {
            return function() {
                var dest = this;
                var state = src._readableState;
                state.awaitDrain--;
                if (state.awaitDrain === 0)
                    flow(src);
            };
        }

        function flow(src) {
            var state = src._readableState;
            var chunk;
            state.awaitDrain = 0;

            function write(dest, i, list) {
                var written = dest.write(chunk);
                if (false === written) {
                    state.awaitDrain++;
                }
            }

            while (state.pipesCount && null !== (chunk = src.read())) {

                if (state.pipesCount === 1)
                    write(state.pipes, 0, null);
                else
                    forEach(state.pipes, write);

                src.emit('data', chunk);

                // if anyone needs a drain, then we have to wait for that.
                if (state.awaitDrain > 0)
                    return;
            }

            // if every destination was unpiped, either before entering this
            // function, or in the while loop, then stop flowing.
            //
            // NB: This is a pretty rare edge case.
            if (state.pipesCount === 0) {
                state.flowing = false;

                // if there were data event listeners added, then switch to old mode.
                if (EE.listenerCount(src, 'data') > 0)
                    emitDataEvents(src);
                return;
            }

            // at this point, no one needed a drain, so we just ran out of data
            // on the next readable event, start it over again.
            state.ranOut = true;
        }

        function pipeOnReadable() {
            if (this._readableState.ranOut) {
                this._readableState.ranOut = false;
                flow(this);
            }
        }


        Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;

            // if we're not piping anywhere, then do nothing.
            if (state.pipesCount === 0)
                return this;

            // just one destination.  most common case.
            if (state.pipesCount === 1) {
                // passed in one, but it's not the right one.
                if (dest && dest !== state.pipes)
                    return this;

                if (!dest)
                    dest = state.pipes;

                // got a match.
                state.pipes = null;
                state.pipesCount = 0;
                this.removeListener('readable', pipeOnReadable);
                state.flowing = false;
                if (dest)
                    dest.emit('unpipe', this);
                return this;
            }

            // slow case. multiple pipe destinations.

            if (!dest) {
                // remove all.
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                this.removeListener('readable', pipeOnReadable);
                state.flowing = false;

                for (var i = 0; i < len; i++)
                    dests[i].emit('unpipe', this);
                return this;
            }

            // try to find the right one.
            var i = indexOf(state.pipes, dest);
            if (i === -1)
                return this;

            state.pipes.splice(i, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
                state.pipes = state.pipes[0];

            dest.emit('unpipe', this);

            return this;
        };

// set up data events if they are asked for
// Ensure readable listeners eventually get something
        Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);

            if (ev === 'data' && !this._readableState.flowing)
                emitDataEvents(this);

            if (ev === 'readable' && this.readable) {
                var state = this._readableState;
                if (!state.readableListening) {
                    state.readableListening = true;
                    state.emittedReadable = false;
                    state.needReadable = true;
                    if (!state.reading) {
                        this.read(0);
                    } else if (state.length) {
                        emitReadable(this, state);
                    }
                }
            }

            return res;
        };
        Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
        Readable.prototype.resume = function() {
            emitDataEvents(this);
            this.read(0);
            this.emit('resume');
        };

        Readable.prototype.pause = function() {
            emitDataEvents(this, true);
            this.emit('pause');
        };

        function emitDataEvents(stream, startPaused) {
            var state = stream._readableState;

            if (state.flowing) {
                // https://github.com/isaacs/readable-stream/issues/16
                throw new Error('Cannot switch to old mode now.');
            }

            var paused = startPaused || false;
            var readable = false;

            // convert to an old-style stream.
            stream.readable = true;
            stream.pipe = Stream.prototype.pipe;
            stream.on = stream.addListener = Stream.prototype.on;

            stream.on('readable', function() {
                readable = true;

                var c;
                while (!paused && (null !== (c = stream.read())))
                    stream.emit('data', c);

                if (c === null) {
                    readable = false;
                    stream._readableState.needReadable = true;
                }
            });

            stream.pause = function() {
                paused = true;
                this.emit('pause');
            };

            stream.resume = function() {
                paused = false;
                if (readable)
                    process.nextTick(function() {
                        stream.emit('readable');
                    });
                else
                    this.read(0);
                this.emit('resume');
            };

            // now make it start, just in case it hadn't already.
            stream.emit('readable');
        }

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
        Readable.prototype.wrap = function(stream) {
            var state = this._readableState;
            var paused = false;

            var self = this;
            stream.on('end', function() {
                if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length)
                        self.push(chunk);
                }

                self.push(null);
            });

            stream.on('data', function(chunk) {
                if (state.decoder)
                    chunk = state.decoder.write(chunk);

                // don't skip over falsy values in objectMode
                //if (state.objectMode && util.isNullOrUndefined(chunk))
                if (state.objectMode && (chunk === null || chunk === undefined))
                    return;
                else if (!state.objectMode && (!chunk || !chunk.length))
                    return;

                var ret = self.push(chunk);
                if (!ret) {
                    paused = true;
                    stream.pause();
                }
            });

            // proxy all the other methods.
            // important when wrapping filters and duplexes.
            for (var i in stream) {
                if (typeof stream[i] === 'function' &&
                    typeof this[i] === 'undefined') {
                    this[i] = function(method) { return function() {
                        return stream[method].apply(stream, arguments);
                    }}(i);
                }
            }

            // proxy certain important events.
            var events = ['error', 'close', 'destroy', 'pause', 'resume'];
            forEach(events, function(ev) {
                stream.on(ev, self.emit.bind(self, ev));
            });

            // when we try to consume some more bytes, simply unpause the
            // underlying stream.
            self._read = function(n) {
                if (paused) {
                    paused = false;
                    stream.resume();
                }
            };

            return self;
        };



// exposed for testing purposes only.
        Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
        function fromList(n, state) {
            var list = state.buffer;
            var length = state.length;
            var stringMode = !!state.decoder;
            var objectMode = !!state.objectMode;
            var ret;

            // nothing in the list, definitely empty.
            if (list.length === 0)
                return null;

            if (length === 0)
                ret = null;
            else if (objectMode)
                ret = list.shift();
            else if (!n || n >= length) {
                // read it all, truncate the array.
                if (stringMode)
                    ret = list.join('');
                else
                    ret = Buffer.concat(list, length);
                list.length = 0;
            } else {
                // read just some of it.
                if (n < list[0].length) {
                    // just take a part of the first list item.
                    // slice is the same for buffers and strings.
                    var buf = list[0];
                    ret = buf.slice(0, n);
                    list[0] = buf.slice(n);
                } else if (n === list[0].length) {
                    // first list is a perfect match
                    ret = list.shift();
                } else {
                    // complex case.
                    // we have enough to cover it, but it spans past the first buffer.
                    if (stringMode)
                        ret = '';
                    else
                        ret = new Buffer(n);

                    var c = 0;
                    for (var i = 0, l = list.length; i < l && c < n; i++) {
                        var buf = list[0];
                        var cpy = Math.min(n - c, buf.length);

                        if (stringMode)
                            ret += buf.slice(0, cpy);
                        else
                            buf.copy(ret, c, 0, cpy);

                        if (cpy < buf.length)
                            list[0] = buf.slice(cpy);
                        else
                            list.shift();

                        c += cpy;
                    }
                }
            }

            return ret;
        }

        function endReadable(stream) {
            var state = stream._readableState;

            // If we get here before consuming all the bytes, then that is a
            // bug in node.  Should never happen.
            if (state.length > 0)
                throw new Error('endReadable called on non-empty stream');

            if (!state.endEmitted && state.calledRead) {
                state.ended = true;
                process.nextTick(function() {
                    // Check that we didn't get one last unshift.
                    if (!state.endEmitted && state.length === 0) {
                        state.endEmitted = true;
                        stream.readable = false;
                        stream.emit('end');
                    }
                });
            }
        }

        function forEach (xs, f) {
            for (var i = 0, l = xs.length; i < l; i++) {
                f(xs[i], i);
            }
        }

        function indexOf (xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x) return i;
            }
            return -1;
        }

    }).call(this,require('_process'))
},{"_process":151,"buffer":3,"core-util-is":158,"events":148,"inherits":149,"isarray":150,"stream":163,"string_decoder/":164}],156:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

    module.exports = Transform;

    var Duplex = require('./_stream_duplex');

    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/

    util.inherits(Transform, Duplex);


    function TransformState(options, stream) {
        this.afterTransform = function(er, data) {
            return afterTransform(stream, er, data);
        };

        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null;
    }

    function afterTransform(stream, er, data) {
        var ts = stream._transformState;
        ts.transforming = false;

        var cb = ts.writecb;

        if (!cb)
            return stream.emit('error', new Error('no writecb in Transform class'));

        ts.writechunk = null;
        ts.writecb = null;

        if (data !== null && data !== undefined)
            stream.push(data);

        if (cb)
            cb(er);

        var rs = stream._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
            stream._read(rs.highWaterMark);
        }
    }


    function Transform(options) {
        if (!(this instanceof Transform))
            return new Transform(options);

        Duplex.call(this, options);

        var ts = this._transformState = new TransformState(options, this);

        // when the writable side finishes, then flush out anything remaining.
        var stream = this;

        // start out asking for a readable event once data is transformed.
        this._readableState.needReadable = true;

        // we have implemented the _read method, and done the other things
        // that Readable wants before the first _read call, so unset the
        // sync guard flag.
        this._readableState.sync = false;

        this.once('finish', function() {
            if ('function' === typeof this._flush)
                this._flush(function(er) {
                    done(stream, er);
                });
            else
                done(stream);
        });
    }

    Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
    };

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error('not implemented');
    };

    Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform ||
                rs.needReadable ||
                rs.length < rs.highWaterMark)
                this._read(rs.highWaterMark);
        }
    };

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
        var ts = this._transformState;

        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
            // mark that we need a transform, so that any data that comes in
            // will get processed, now that we've asked for it.
            ts.needTransform = true;
        }
    };


    function done(stream, er) {
        if (er)
            return stream.emit('error', er);

        // if there's nothing in the write buffer, then that means
        // that nothing more will ever be provided
        var ws = stream._writableState;
        var rs = stream._readableState;
        var ts = stream._transformState;

        if (ws.length)
            throw new Error('calling transform done when ws.length != 0');

        if (ts.transforming)
            throw new Error('calling transform done when still transforming');

        return stream.push(null);
    }

},{"./_stream_duplex":153,"core-util-is":158,"inherits":149}],157:[function(require,module,exports){
    (function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

        module.exports = Writable;

        /*<replacement>*/
        var Buffer = require('buffer').Buffer;
        /*</replacement>*/

        Writable.WritableState = WritableState;


        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/

        var Stream = require('stream');

        util.inherits(Writable, Stream);

        function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
        }

        function WritableState(options, stream) {
            options = options || {};

            // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()
            var hwm = options.highWaterMark;
            this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

            // object stream flag to indicate whether or not this stream
            // contains buffers or objects.
            this.objectMode = !!options.objectMode;

            // cast to ints.
            this.highWaterMark = ~~this.highWaterMark;

            this.needDrain = false;
            // at the start of calling end()
            this.ending = false;
            // when end() has been called, and returned
            this.ended = false;
            // when 'finish' is emitted
            this.finished = false;

            // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || 'utf8';

            // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.
            this.length = 0;

            // a flag to see when we're in the middle of a write.
            this.writing = false;

            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, becuase any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true;

            // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.
            this.bufferProcessing = false;

            // the callback that's passed to _write(chunk,cb)
            this.onwrite = function(er) {
                onwrite(stream, er);
            };

            // the callback that the user supplies to write(chunk,encoding,cb)
            this.writecb = null;

            // the amount that is being written when _write is called.
            this.writelen = 0;

            this.buffer = [];

            // True if the error was already emitted and should not be thrown again
            this.errorEmitted = false;
        }

        function Writable(options) {
            var Duplex = require('./_stream_duplex');

            // Writable ctor is applied to Duplexes, though they're not
            // instanceof Writable, they're instanceof Readable.
            if (!(this instanceof Writable) && !(this instanceof Duplex))
                return new Writable(options);

            this._writableState = new WritableState(options, this);

            // legacy.
            this.writable = true;

            Stream.call(this);
        }

// Otherwise people can pipe Writable streams, which is just wrong.
        Writable.prototype.pipe = function() {
            this.emit('error', new Error('Cannot pipe. Not readable.'));
        };


        function writeAfterEnd(stream, state, cb) {
            var er = new Error('write after end');
            // TODO: defer error events consistently everywhere, not just the cb
            stream.emit('error', er);
            process.nextTick(function() {
                cb(er);
            });
        }

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
        function validChunk(stream, state, chunk, cb) {
            var valid = true;
            if (!Buffer.isBuffer(chunk) &&
                'string' !== typeof chunk &&
                chunk !== null &&
                chunk !== undefined &&
                !state.objectMode) {
                var er = new TypeError('Invalid non-string/buffer chunk');
                stream.emit('error', er);
                process.nextTick(function() {
                    cb(er);
                });
                valid = false;
            }
            return valid;
        }

        Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;

            if (typeof encoding === 'function') {
                cb = encoding;
                encoding = null;
            }

            if (Buffer.isBuffer(chunk))
                encoding = 'buffer';
            else if (!encoding)
                encoding = state.defaultEncoding;

            if (typeof cb !== 'function')
                cb = function() {};

            if (state.ended)
                writeAfterEnd(this, state, cb);
            else if (validChunk(this, state, chunk, cb))
                ret = writeOrBuffer(this, state, chunk, encoding, cb);

            return ret;
        };

        function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode &&
                state.decodeStrings !== false &&
                typeof chunk === 'string') {
                chunk = new Buffer(chunk, encoding);
            }
            return chunk;
        }

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
        function writeOrBuffer(stream, state, chunk, encoding, cb) {
            chunk = decodeChunk(state, chunk, encoding);
            if (Buffer.isBuffer(chunk))
                encoding = 'buffer';
            var len = state.objectMode ? 1 : chunk.length;

            state.length += len;

            var ret = state.length < state.highWaterMark;
            // we must ensure that previous needDrain will not be reset to false.
            if (!ret)
                state.needDrain = true;

            if (state.writing)
                state.buffer.push(new WriteReq(chunk, encoding, cb));
            else
                doWrite(stream, state, len, chunk, encoding, cb);

            return ret;
        }

        function doWrite(stream, state, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
        }

        function onwriteError(stream, state, sync, er, cb) {
            if (sync)
                process.nextTick(function() {
                    cb(er);
                });
            else
                cb(er);

            stream._writableState.errorEmitted = true;
            stream.emit('error', er);
        }

        function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
        }

        function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;

            onwriteStateUpdate(state);

            if (er)
                onwriteError(stream, state, sync, er, cb);
            else {
                // Check if we're actually ready to finish, but don't emit yet
                var finished = needFinish(stream, state);

                if (!finished && !state.bufferProcessing && state.buffer.length)
                    clearBuffer(stream, state);

                if (sync) {
                    process.nextTick(function() {
                        afterWrite(stream, state, finished, cb);
                    });
                } else {
                    afterWrite(stream, state, finished, cb);
                }
            }
        }

        function afterWrite(stream, state, finished, cb) {
            if (!finished)
                onwriteDrain(stream, state);
            cb();
            if (finished)
                finishMaybe(stream, state);
        }

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
        function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit('drain');
            }
        }


// if there's something in the buffer waiting, then process it
        function clearBuffer(stream, state) {
            state.bufferProcessing = true;

            for (var c = 0; c < state.buffer.length; c++) {
                var entry = state.buffer[c];
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;

                doWrite(stream, state, len, chunk, encoding, cb);

                // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.
                if (state.writing) {
                    c++;
                    break;
                }
            }

            state.bufferProcessing = false;
            if (c < state.buffer.length)
                state.buffer = state.buffer.slice(c);
            else
                state.buffer.length = 0;
        }

        Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error('not implemented'));
        };

        Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;

            if (typeof chunk === 'function') {
                cb = chunk;
                chunk = null;
                encoding = null;
            } else if (typeof encoding === 'function') {
                cb = encoding;
                encoding = null;
            }

            if (typeof chunk !== 'undefined' && chunk !== null)
                this.write(chunk, encoding);

            // ignore unnecessary end() calls.
            if (!state.ending && !state.finished)
                endWritable(this, state, cb);
        };


        function needFinish(stream, state) {
            return (state.ending &&
            state.length === 0 &&
            !state.finished &&
            !state.writing);
        }

        function finishMaybe(stream, state) {
            var need = needFinish(stream, state);
            if (need) {
                state.finished = true;
                stream.emit('finish');
            }
            return need;
        }

        function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
                if (state.finished)
                    process.nextTick(cb);
                else
                    stream.once('finish', cb);
            }
            state.ended = true;
        }

    }).call(this,require('_process'))
},{"./_stream_duplex":153,"_process":151,"buffer":3,"core-util-is":158,"inherits":149,"stream":163}],158:[function(require,module,exports){
    (function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
        function isArray(ar) {
            return Array.isArray(ar);
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
            return typeof arg === 'boolean';
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
            return arg === null;
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
            return typeof arg === 'number';
        }
        exports.isNumber = isNumber;

        function isString(arg) {
            return typeof arg === 'string';
        }
        exports.isString = isString;

        function isSymbol(arg) {
            return typeof arg === 'symbol';
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
        }
        exports.isObject = isObject;

        function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
        }
        exports.isDate = isDate;

        function isError(e) {
            return isObject(e) &&
                (objectToString(e) === '[object Error]' || e instanceof Error);
        }
        exports.isError = isError;

        function isFunction(arg) {
            return typeof arg === 'function';
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
            return arg === null ||
                typeof arg === 'boolean' ||
                typeof arg === 'number' ||
                typeof arg === 'string' ||
                typeof arg === 'symbol' ||  // ES6 symbol
                typeof arg === 'undefined';
        }
        exports.isPrimitive = isPrimitive;

        function isBuffer(arg) {
            return Buffer.isBuffer(arg);
        }
        exports.isBuffer = isBuffer;

        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],159:[function(require,module,exports){
    module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":154}],160:[function(require,module,exports){
    var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify
    exports = module.exports = require('./lib/_stream_readable.js');
    exports.Stream = Stream;
    exports.Readable = exports;
    exports.Writable = require('./lib/_stream_writable.js');
    exports.Duplex = require('./lib/_stream_duplex.js');
    exports.Transform = require('./lib/_stream_transform.js');
    exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":153,"./lib/_stream_passthrough.js":154,"./lib/_stream_readable.js":155,"./lib/_stream_transform.js":156,"./lib/_stream_writable.js":157,"stream":163}],161:[function(require,module,exports){
    module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":156}],162:[function(require,module,exports){
    module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":157}],163:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    module.exports = Stream;

    var EE = require('events').EventEmitter;
    var inherits = require('inherits');

    inherits(Stream, EE);
    Stream.Readable = require('readable-stream/readable.js');
    Stream.Writable = require('readable-stream/writable.js');
    Stream.Duplex = require('readable-stream/duplex.js');
    Stream.Transform = require('readable-stream/transform.js');
    Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
    Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

    function Stream() {
        EE.call(this);
    }

    Stream.prototype.pipe = function(dest, options) {
        var source = this;

        function ondata(chunk) {
            if (dest.writable) {
                if (false === dest.write(chunk) && source.pause) {
                    source.pause();
                }
            }
        }

        source.on('data', ondata);

        function ondrain() {
            if (source.readable && source.resume) {
                source.resume();
            }
        }

        dest.on('drain', ondrain);

        // If the 'end' option is not supplied, dest.end() will be called when
        // source gets the 'end' or 'close' events.  Only dest.end() once.
        if (!dest._isStdio && (!options || options.end !== false)) {
            source.on('end', onend);
            source.on('close', onclose);
        }

        var didOnEnd = false;
        function onend() {
            if (didOnEnd) return;
            didOnEnd = true;

            dest.end();
        }


        function onclose() {
            if (didOnEnd) return;
            didOnEnd = true;

            if (typeof dest.destroy === 'function') dest.destroy();
        }

        // don't leave dangling pipes when there are errors.
        function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, 'error') === 0) {
                throw er; // Unhandled stream error in pipe.
            }
        }

        source.on('error', onerror);
        dest.on('error', onerror);

        // remove all the event listeners that were added.
        function cleanup() {
            source.removeListener('data', ondata);
            dest.removeListener('drain', ondrain);

            source.removeListener('end', onend);
            source.removeListener('close', onclose);

            source.removeListener('error', onerror);
            dest.removeListener('error', onerror);

            source.removeListener('end', cleanup);
            source.removeListener('close', cleanup);

            dest.removeListener('close', cleanup);
        }

        source.on('end', cleanup);
        source.on('close', cleanup);

        dest.on('close', cleanup);

        dest.emit('pipe', source);

        // Allow for unix-like usage: A.pipe(B).pipe(C)
        return dest;
    };

},{"events":148,"inherits":149,"readable-stream/duplex.js":152,"readable-stream/passthrough.js":159,"readable-stream/readable.js":160,"readable-stream/transform.js":161,"readable-stream/writable.js":162}],164:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

    var Buffer = require('buffer').Buffer;

    var isBufferEncoding = Buffer.isEncoding
        || function(encoding) {
            switch (encoding && encoding.toLowerCase()) {
                case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
                default: return false;
            }
        }


    function assertEncoding(encoding) {
        if (encoding && !isBufferEncoding(encoding)) {
            throw new Error('Unknown encoding: ' + encoding);
        }
    }

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
    var StringDecoder = exports.StringDecoder = function(encoding) {
        this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
        assertEncoding(encoding);
        switch (this.encoding) {
            case 'utf8':
                // CESU-8 represents each of Surrogate Pair by 3-bytes
                this.surrogateSize = 3;
                break;
            case 'ucs2':
            case 'utf16le':
                // UTF-16 represents each of Surrogate Pair by 2-bytes
                this.surrogateSize = 2;
                this.detectIncompleteChar = utf16DetectIncompleteChar;
                break;
            case 'base64':
                // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
                this.surrogateSize = 3;
                this.detectIncompleteChar = base64DetectIncompleteChar;
                break;
            default:
                this.write = passThroughWrite;
                return;
        }

        // Enough space to store all bytes of a single character. UTF-8 needs 4
        // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
        this.charBuffer = new Buffer(6);
        // Number of bytes received for the current incomplete multi-byte character.
        this.charReceived = 0;
        // Number of bytes expected for the current incomplete multi-byte character.
        this.charLength = 0;
    };


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder.prototype.write = function(buffer) {
        var charStr = '';
        // if our last write ended with an incomplete multibyte character
        while (this.charLength) {
            // determine how many remaining bytes this buffer has to offer for this char
            var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
                buffer.length;

            // add the new bytes to the char buffer
            buffer.copy(this.charBuffer, this.charReceived, 0, available);
            this.charReceived += available;

            if (this.charReceived < this.charLength) {
                // still not enough chars in this buffer? wait for more ...
                return '';
            }

            // remove bytes belonging to the current character from the buffer
            buffer = buffer.slice(available, buffer.length);

            // get the character that was split
            charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

            // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
            var charCode = charStr.charCodeAt(charStr.length - 1);
            if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                this.charLength += this.surrogateSize;
                charStr = '';
                continue;
            }
            this.charReceived = this.charLength = 0;

            // if there are no more bytes in this buffer, just emit our char
            if (buffer.length === 0) {
                return charStr;
            }
            break;
        }

        // determine and set charLength / charReceived
        this.detectIncompleteChar(buffer);

        var end = buffer.length;
        if (this.charLength) {
            // buffer the incomplete character bytes we got
            buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
            end -= this.charReceived;
        }

        charStr += buffer.toString(this.encoding, 0, end);

        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
            var size = this.surrogateSize;
            this.charLength += size;
            this.charReceived += size;
            this.charBuffer.copy(this.charBuffer, size, 0, size);
            buffer.copy(this.charBuffer, 0, 0, size);
            return charStr.substring(0, end);
        }

        // or just emit the charStr
        return charStr;
    };

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        // determine how many bytes we have to check at the end of this buffer
        var i = (buffer.length >= 3) ? 3 : buffer.length;

        // Figure out if one of the last i bytes of our buffer announces an
        // incomplete char.
        for (; i > 0; i--) {
            var c = buffer[buffer.length - i];

            // See http://en.wikipedia.org/wiki/UTF-8#Description

            // 110XXXXX
            if (i == 1 && c >> 5 == 0x06) {
                this.charLength = 2;
                break;
            }

            // 1110XXXX
            if (i <= 2 && c >> 4 == 0x0E) {
                this.charLength = 3;
                break;
            }

            // 11110XXX
            if (i <= 3 && c >> 3 == 0x1E) {
                this.charLength = 4;
                break;
            }
        }
        this.charReceived = i;
    };

    StringDecoder.prototype.end = function(buffer) {
        var res = '';
        if (buffer && buffer.length)
            res = this.write(buffer);

        if (this.charReceived) {
            var cr = this.charReceived;
            var buf = this.charBuffer;
            var enc = this.encoding;
            res += buf.slice(0, cr).toString(enc);
        }

        return res;
    };

    function passThroughWrite(buffer) {
        return buffer.toString(this.encoding);
    }

    function utf16DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 2;
        this.charLength = this.charReceived ? 2 : 0;
    }

    function base64DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 3;
        this.charLength = this.charReceived ? 3 : 0;
    }

},{"buffer":3}],165:[function(require,module,exports){
    module.exports = function isBuffer(arg) {
        return arg && typeof arg === 'object'
            && typeof arg.copy === 'function'
            && typeof arg.fill === 'function'
            && typeof arg.readUInt8 === 'function';
    }
},{}],166:[function(require,module,exports){
    (function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

        var formatRegExp = /%[sdj%]/g;
        exports.format = function(f) {
            if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                }
                return objects.join(' ');
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
                if (x === '%%') return '%';
                if (i >= len) return x;
                switch (x) {
                    case '%s': return String(args[i++]);
                    case '%d': return Number(args[i++]);
                    case '%j':
                        try {
                            return JSON.stringify(args[i++]);
                        } catch (_) {
                            return '[Circular]';
                        }
                    default:
                        return x;
                }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                    str += ' ' + x;
                } else {
                    str += ' ' + inspect(x);
                }
            }
            return str;
        };


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
        exports.deprecate = function(fn, msg) {
            // Allow for deprecating things in the process of starting up.
            if (isUndefined(global.process)) {
                return function() {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                };
            }

            if (process.noDeprecation === true) {
                return fn;
            }

            var warned = false;
            function deprecated() {
                if (!warned) {
                    if (process.throwDeprecation) {
                        throw new Error(msg);
                    } else if (process.traceDeprecation) {
                        console.trace(msg);
                    } else {
                        console.error(msg);
                    }
                    warned = true;
                }
                return fn.apply(this, arguments);
            }

            return deprecated;
        };


        var debugs = {};
        var debugEnviron;
        exports.debuglog = function(set) {
            if (isUndefined(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || '';
            set = set.toUpperCase();
            if (!debugs[set]) {
                if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                        var msg = exports.format.apply(exports, arguments);
                        console.error('%s %d: %s', set, pid, msg);
                    };
                } else {
                    debugs[set] = function() {};
                }
            }
            return debugs[set];
        };


        /**
         * Echos the value of a value. Trys to print the value out
         * in the best way possible given the different types.
         *
         * @param {Object} obj The object to print out.
         * @param {Object} opts Optional options object that alters the output.
         */
        /* legacy: obj, showHidden, depth, colors*/
        function inspect(obj, opts) {
            // default options
            var ctx = {
                seen: [],
                stylize: stylizeNoColor
            };
            // legacy...
            if (arguments.length >= 3) ctx.depth = arguments[2];
            if (arguments.length >= 4) ctx.colors = arguments[3];
            if (isBoolean(opts)) {
                // legacy...
                ctx.showHidden = opts;
            } else if (opts) {
                // got an "options" object
                exports._extend(ctx, opts);
            }
            // set default options
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
        }
        exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
        inspect.colors = {
            'bold' : [1, 22],
            'italic' : [3, 23],
            'underline' : [4, 24],
            'inverse' : [7, 27],
            'white' : [37, 39],
            'grey' : [90, 39],
            'black' : [30, 39],
            'blue' : [34, 39],
            'cyan' : [36, 39],
            'green' : [32, 39],
            'magenta' : [35, 39],
            'red' : [31, 39],
            'yellow' : [33, 39]
        };

// Don't use 'blue' not visible on cmd.exe
        inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            // "name": intentionally not styling
            'regexp': 'red'
        };


        function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];

            if (style) {
                return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                    '\u001b[' + inspect.colors[style][1] + 'm';
            } else {
                return str;
            }
        }


        function stylizeNoColor(str, styleType) {
            return str;
        }


        function arrayToHash(array) {
            var hash = {};

            array.forEach(function(val, idx) {
                hash[val] = true;
            });

            return hash;
        }


        function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect &&
                value &&
                isFunction(value.inspect) &&
                    // Filter out the util module, it's inspect function is special
                value.inspect !== exports.inspect &&
                    // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
                return primitive;
            }

            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
            }

            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (isError(value)
                && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                return formatError(value);
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
                if (isFunction(value)) {
                    var name = value.name ? ': ' + value.name : '';
                    return ctx.stylize('[Function' + name + ']', 'special');
                }
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                }
                if (isDate(value)) {
                    return ctx.stylize(Date.prototype.toString.call(value), 'date');
                }
                if (isError(value)) {
                    return formatError(value);
                }
            }

            var base = '', array = false, braces = ['{', '}'];

            // Make Array say that they are Array
            if (isArray(value)) {
                array = true;
                braces = ['[', ']'];
            }

            // Make functions say that they are functions
            if (isFunction(value)) {
                var n = value.name ? ': ' + value.name : '';
                base = ' [Function' + n + ']';
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
                base = ' ' + RegExp.prototype.toString.call(value);
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
                base = ' ' + Date.prototype.toUTCString.call(value);
            }

            // Make error with message first say the error
            if (isError(value)) {
                base = ' ' + formatError(value);
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
            }

            if (recurseTimes < 0) {
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                } else {
                    return ctx.stylize('[Object]', 'special');
                }
            }

            ctx.seen.push(value);

            var output;
            if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
                output = keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
            }

            ctx.seen.pop();

            return reduceToSingleString(output, base, braces);
        }


        function formatPrimitive(ctx, value) {
            if (isUndefined(value))
                return ctx.stylize('undefined', 'undefined');
            if (isString(value)) {
                var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                        .replace(/'/g, "\\'")
                        .replace(/\\"/g, '"') + '\'';
                return ctx.stylize(simple, 'string');
            }
            if (isNumber(value))
                return ctx.stylize('' + value, 'number');
            if (isBoolean(value))
                return ctx.stylize('' + value, 'boolean');
            // For some reason typeof null is "object", so special case here.
            if (isNull(value))
                return ctx.stylize('null', 'null');
        }


        function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
        }


        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        String(i), true));
                } else {
                    output.push('');
                }
            }
            keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        key, true));
                }
            });
            return output;
        }


        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
            if (desc.get) {
                if (desc.set) {
                    str = ctx.stylize('[Getter/Setter]', 'special');
                } else {
                    str = ctx.stylize('[Getter]', 'special');
                }
            } else {
                if (desc.set) {
                    str = ctx.stylize('[Setter]', 'special');
                }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
                name = '[' + key + ']';
            }
            if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                        str = formatValue(ctx, desc.value, null);
                    } else {
                        str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf('\n') > -1) {
                        if (array) {
                            str = str.split('\n').map(function(line) {
                                return '  ' + line;
                            }).join('\n').substr(2);
                        } else {
                            str = '\n' + str.split('\n').map(function(line) {
                                    return '   ' + line;
                                }).join('\n');
                        }
                    }
                } else {
                    str = ctx.stylize('[Circular]', 'special');
                }
            }
            if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                    return str;
                }
                name = JSON.stringify('' + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, 'name');
                } else {
                    name = name.replace(/'/g, "\\'")
                        .replace(/\\"/g, '"')
                        .replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, 'string');
                }
            }

            return name + ': ' + str;
        }


        function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf('\n') >= 0) numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
            }, 0);

            if (length > 60) {
                return braces[0] +
                    (base === '' ? '' : base + '\n ') +
                    ' ' +
                    output.join(',\n  ') +
                    ' ' +
                    braces[1];
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
        }


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
        function isArray(ar) {
            return Array.isArray(ar);
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
            return typeof arg === 'boolean';
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
            return arg === null;
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
            return typeof arg === 'number';
        }
        exports.isNumber = isNumber;

        function isString(arg) {
            return typeof arg === 'string';
        }
        exports.isString = isString;

        function isSymbol(arg) {
            return typeof arg === 'symbol';
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
        }
        exports.isObject = isObject;

        function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
        }
        exports.isDate = isDate;

        function isError(e) {
            return isObject(e) &&
                (objectToString(e) === '[object Error]' || e instanceof Error);
        }
        exports.isError = isError;

        function isFunction(arg) {
            return typeof arg === 'function';
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
            return arg === null ||
                typeof arg === 'boolean' ||
                typeof arg === 'number' ||
                typeof arg === 'string' ||
                typeof arg === 'symbol' ||  // ES6 symbol
                typeof arg === 'undefined';
        }
        exports.isPrimitive = isPrimitive;

        exports.isBuffer = require('./support/isBuffer');

        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }


        function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
        }


        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
            'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
        function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
        }


// log is just a thin wrapper to console.log that prepends a timestamp
        exports.log = function() {
            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
        };


        /**
         * Inherit the prototype methods from one constructor into another.
         *
         * The Function.prototype.inherits from lang.js rewritten as a standalone
         * function (not on Function.prototype). NOTE: If this file is to be loaded
         * during bootstrapping this function needs to be rewritten using some native
         * functions as prototype setup using normal JavaScript does not work as
         * expected during bootstrapping (see mirror.js in r114903).
         *
         * @param {function} ctor Constructor function which needs to inherit the
         *     prototype.
         * @param {function} superCtor Constructor function to inherit prototype from.
         */
        exports.inherits = require('inherits');

        exports._extend = function(origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin;

            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
                origin[keys[i]] = add[keys[i]];
            }
            return origin;
        };

        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }

    }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":165,"_process":151,"inherits":149}],167:[function(require,module,exports){
    var indexOf = require('indexof');

    var Object_keys = function (obj) {
        if (Object.keys) return Object.keys(obj)
        else {
            var res = [];
            for (var key in obj) res.push(key)
            return res;
        }
    };

    var forEach = function (xs, fn) {
        if (xs.forEach) return xs.forEach(fn)
        else for (var i = 0; i < xs.length; i++) {
            fn(xs[i], i, xs);
        }
    };

    var defineProp = (function() {
        try {
            Object.defineProperty({}, '_', {});
            return function(obj, name, value) {
                Object.defineProperty(obj, name, {
                    writable: true,
                    enumerable: false,
                    configurable: true,
                    value: value
                })
            };
        } catch(e) {
            return function(obj, name, value) {
                obj[name] = value;
            };
        }
    }());

    var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
        'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
        'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
        'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
        'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

    function Context() {}
    Context.prototype = {};

    var Script = exports.Script = function NodeScript (code) {
        if (!(this instanceof Script)) return new Script(code);
        this.code = code;
    };

    Script.prototype.runInContext = function (context) {
        if (!(context instanceof Context)) {
            throw new TypeError("needs a 'context' argument.");
        }

        var iframe = document.createElement('iframe');
        if (!iframe.style) iframe.style = {};
        iframe.style.display = 'none';

        document.body.appendChild(iframe);

        var win = iframe.contentWindow;
        var wEval = win.eval, wExecScript = win.execScript;

        if (!wEval && wExecScript) {
            // win.eval() magically appears when this is called in IE:
            wExecScript.call(win, 'null');
            wEval = win.eval;
        }

        forEach(Object_keys(context), function (key) {
            win[key] = context[key];
        });
        forEach(globals, function (key) {
            if (context[key]) {
                win[key] = context[key];
            }
        });

        var winKeys = Object_keys(win);

        var res = wEval.call(win, this.code);

        forEach(Object_keys(win), function (key) {
            // Avoid copying circular objects like `top` and `window` by only
            // updating existing context properties or new properties in the `win`
            // that was only introduced after the eval.
            if (key in context || indexOf(winKeys, key) === -1) {
                context[key] = win[key];
            }
        });

        forEach(globals, function (key) {
            if (!(key in context)) {
                defineProp(context, key, win[key]);
            }
        });

        document.body.removeChild(iframe);

        return res;
    };

    Script.prototype.runInThisContext = function () {
        return eval(this.code); // maybe...
    };

    Script.prototype.runInNewContext = function (context) {
        var ctx = Script.createContext(context);
        var res = this.runInContext(ctx);

        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });

        return res;
    };

    forEach(Object_keys(Script.prototype), function (name) {
        exports[name] = Script[name] = function (code) {
            var s = Script(code);
            return s[name].apply(s, [].slice.call(arguments, 1));
        };
    });

    exports.createScript = function (code) {
        return exports.Script(code);
    };

    exports.createContext = Script.createContext = function (context) {
        var copy = new Context();
        if(typeof context === 'object') {
            forEach(Object_keys(context), function (key) {
                copy[key] = context[key];
            });
        }
        return copy;
    };

},{"indexof":168}],168:[function(require,module,exports){

    var indexOf = [].indexOf;

    module.exports = function(arr, obj){
        if (indexOf) return arr.indexOf(obj);
        for (var i = 0; i < arr.length; ++i) {
            if (arr[i] === obj) return i;
        }
        return -1;
    };
},{}],169:[function(require,module,exports){
    (function (Buffer){
        
        var crypto = require('crypto');
        var chacha = require('chacha');
        var PouchPromise = require('pouchdb-promise');
        var configId = '_local/crypto';
        var filter = require('filter-pouch').filter;
        var uuid = require('node-uuid');
        function genKey(password, salt) {
            return new PouchPromise(function (resolve, reject) {
                crypto.pbkdf2(password, salt, 1000, 256 / 8, function (err, key) {
                    password = null;
                    if (err) {
                        return reject(err);
                    }
                    resolve(key);
                });
            });
        }
        function cryptoInit(password, modP) {
            var db = this;
            var key, pub;
            var turnedOff = false;
            return db.get(configId).catch(function (err) {
                if (err.status === 404) {
                    var doc = {
                        _id: configId,
                        salt: crypto.randomBytes(16).toString('hex')
                    };
                    return db.put(doc).then(function () {
                        return doc;
                    });
                }
                throw err;
            }).then(function (doc) {
                var dh;
                if (typeof modP === 'string') {
                    dh = crypto.getDiffieHellman(modP);
                    dh.generateKeys();
                    pub = dh.getPublicKey();
                    password = dh.computeSecret(password);
                } else if (Buffer.isBuffer(modP)) {
                    dh = crypto.createDiffieHellman(modP);
                    dh.generateKeys();
                    pub = dh.getPublicKey();
                    password = dh.computeSecret(password);
                }
                return genKey(password, new Buffer(doc.salt, 'hex'));
            }).then(function (_key) {
                password = null;
                key = _key;
                db.filter({
                    incoming: encrypt,
                    outgoing: decrypt
                });
                db.removeCrypto = function () {
                    randomize(key);
                    turnedOff = true;
                };
                if (pub) {
                    return pub;
                }
            });
            function encrypt(doc) {
                if (turnedOff) {
                    return doc;
                }
                var id, rev;
                if ('_id' in doc) {
                    id = doc._id;
                    delete doc._id;
                } else {
                    id = uuid.v4();
                }
                if ('_rev' in doc) {
                    rev = doc._rev;
                    delete doc._rev;
                }
                var nonce = crypto.randomBytes(12);
                var data = JSON.stringify(doc);
                var outDoc = {
                    _id: id,
                    nonce: nonce.toString('hex')
                };
                if (rev) {
                    outDoc._rev = rev;
                }
                var cipher = chacha.createCipher(key, nonce);
                cipher.setAAD(new Buffer(id));
                outDoc.data = cipher.update(data).toString('hex');
                cipher.final();
                outDoc.tag = cipher.getAuthTag().toString('hex');
                return outDoc;
            }
            function decrypt(doc) {
                if (turnedOff || !doc.nonce) {
                    return doc;
                }
                var decipher = chacha.createDecipher(key, new Buffer(doc.nonce, 'hex'));
                decipher.setAAD(new Buffer(doc._id));
                decipher.setAuthTag(new Buffer(doc.tag, 'hex'));
                var out = decipher.update(new Buffer(doc.data, 'hex')).toString();
                decipher.final();
                // parse it AFTER calling final
                // you don't want to parse it if it has been manipulated
                out = JSON.parse(out);
                out._id = doc._id;
                out._rev = doc._rev;
                return out;
            }
        }
        function randomize(buf) {
            var len = buf.length;
            var data = crypto.randomBytes(len);
            var i = -1;
            while (++i < len) {
                buf[i] = data[i];
            }
        }
        function decrypt(key, doc) {
            if (!key || !doc.nonce) {
                return doc;
            }
            var decipher = chacha.createDecipher(key, new Buffer(doc.nonce, 'hex'));
            decipher.setAAD(new Buffer(doc._id));
            decipher.setAuthTag(new Buffer(doc.tag, 'hex'));
            var out = decipher.update(new Buffer(doc.data, 'hex')).toString();
            decipher.final();
            // parse it AFTER calling final
            // you don't want to parse it if it has been manipulated
            out = JSON.parse(out);
            out._id = doc._id;
            out._rev = doc._rev;
            return out;
        }

        exports.filter = filter;
        exports.crypto = cryptoInit;
        exports.decrypt = decrypt;

        if (typeof window !== 'undefined' && window.PouchDB) {
            window.PouchDB.plugin(module.exports);
        }

    }).call(this,require("buffer").Buffer)
},{"buffer":3,"chacha":174,"crypto":10,"filter-pouch":188,"node-uuid":208,"pouchdb-promise":209}],170:[function(require,module,exports){
    (function (Buffer){
        var inherits = require('inherits');
        var CipherBase = require('./cipherbase');
        var Chacha20 = require('./chacha20');
        var CipherBase = require('./cipherbase');
        var Poly1305 = require('./poly1305');
        inherits(Cipher, CipherBase);
        module.exports = Cipher;
        function Cipher(key, iv, decrypt){
            if (!(this instanceof Cipher)) {
                return new Cipher(key, iv, decrypt);
            }
            CipherBase.call(this);
            this.alen = 0;
            this.clen = 0;
            this.chacha = new Chacha20(key, iv);
            this.poly = new Poly1305(this.chacha.getBytes(64));
            this.tag = null;
            this._decrypt = decrypt;
            this._hasData = false;
        }
        Cipher.prototype.setAAD = function (aad) {
            if (this._hasData) {
                throw new Error('Attempting to set AAD in unsupported state');
            }
            this.alen = aad.length;
            this.poly.update(aad);
            var padding = new Buffer(padAmount(this.alen));
            if (padding.length) {
                padding.fill(0);
                this.poly.update(padding);
            }
        };
        Cipher.prototype._update = function (chunk) {
            if (!this._hasData) {
                this._hasData = true;
            }
            var len = chunk.length;
            if (!len) {
                return next();
            }
            this.clen += len;
            var pad = this.chacha.getBytes(len);
            var i = -1;
            while (++i < len) {
                pad[i] ^= chunk[i];
            }
            if (this._decrypt) {
                this.poly.update(chunk);
            } else {
                this.poly.update(pad);
            }
            return pad;
        };
        Cipher.prototype._final = function () {
            if (this._decrypt && !this.tag) {
                throw new Error('Unsupported state or unable to authenticate data');
            }
            var padding = new Buffer(padAmount(this.clen));
            if (padding.length) {
                padding.fill(0);
                this.poly.update(padding);
            }
            var lens = new Buffer(16);
            lens.fill(0);
            lens.writeUInt32LE(this.alen, 0);
            lens.writeUInt32LE(this.clen, 8);
            var tag = this.poly.update(lens).finish();
            if (this._decrypt) {
                if (xorTest(tag, this.tag)) {
                    throw new Error('Unsupported state or unable to authenticate data');
                }
            } else {
                this.tag = tag;
            }
        };
        Cipher.prototype.getAuthTag = function () {
            if(this._decrypt || this.tag === null) {
                throw new Error('Attempting to get auth tag in unsupported state');
            }
            return this.tag;
        };
        Cipher.prototype.setAuthTag = function setAuthTag (tag) {
            if (this._decrypt) {
                this.tag = tag;
            } else {
                throw new Error('Attempting to set auth tag in unsupported state');
            }
        };
        function padAmount(len) {
            var rem = len % 16;
            if (!rem) {
                return 0;
            }
            return 16 - rem;
        }
        function xorTest(a, b) {
            var out = 0;
            if (a.length !== b.length) {
                out++;
            }
            var len = Math.min(a.length, b.length);
            var i = -1;
            while (++i < len) {
                out += (a[i] ^ b[i]);
            }
            return out;
        }

    }).call(this,require("buffer").Buffer)
},{"./chacha20":171,"./cipherbase":173,"./poly1305":186,"buffer":3,"inherits":176}],171:[function(require,module,exports){
    (function (Buffer){
        function ROTATE(v, c) {
            return (v << c) | (v >>> (32 - c));
        }
        var constants = new Buffer('expand 32-byte k');
        module.exports = Chacha20;
        function Chacha20(key, nonce) {
            this.input = new Uint32Array(16);

            // https://tools.ietf.org/html/draft-irtf-cfrg-chacha20-poly1305-01#section-2.3
            this.input[0] = constants.readUInt32LE(0);
            this.input[1] =  constants.readUInt32LE(4);
            this.input[2] = constants.readUInt32LE(8);
            this.input[3] = constants.readUInt32LE(12);
            this.input[4] = key.readUInt32LE(0);
            this.input[5] = key.readUInt32LE(4);
            this.input[6] = key.readUInt32LE(8);
            this.input[7] = key.readUInt32LE(12);
            this.input[8] = key.readUInt32LE(16);
            this.input[9] = key.readUInt32LE(20);
            this.input[10] = key.readUInt32LE(24);
            this.input[11] = key.readUInt32LE(28);

            this.input[12] = 0;

            this.input[13] = nonce.readUInt32LE(0);
            this.input[14] = nonce.readUInt32LE(4);
            this.input[15] = nonce.readUInt32LE(8);

            this.cachePos = 64;
            this.buffer = new Uint32Array(16);
            this.output = new Buffer(64);
        }

        Chacha20.prototype.quarterRound = function(a, b, c, d) {
            var x = this.buffer;
            x[a] += x[b]; x[d] = ROTATE(x[d] ^ x[a], 16);
            x[c] += x[d]; x[b] = ROTATE(x[b] ^ x[c], 12);
            x[a] += x[b]; x[d] = ROTATE(x[d] ^ x[a],  8);
            x[c] += x[d]; x[b] = ROTATE(x[b] ^ x[c],  7);
        };
        Chacha20.prototype.makeBlock = function (output, start) {
            var i = -1;
            // copy input into working buffer
            while (++i < 16) {
                this.buffer[i] = this.input[i];
            }
            i = -1;
            while (++i < 10) {
                // straight round
                this.quarterRound(0, 4, 8,12);
                this.quarterRound(1, 5, 9,13);
                this.quarterRound(2, 6,10,14);
                this.quarterRound(3, 7,11,15);


                //diaganle round
                this.quarterRound(0, 5,10,15);
                this.quarterRound(1, 6,11,12);
                this.quarterRound(2, 7, 8,13);
                this.quarterRound(3, 4, 9,14);
            }
            i = -1;
            // copy working buffer into output
            while (++i < 16) {
                this.buffer[i] += this.input[i];
                output.writeUInt32LE(this.buffer[i], start);
                start += 4;
            }

            this.input[12]++;
            if (!this.input[12]) {
                throw new Error('counter is exausted');
            }
        };
        Chacha20.prototype.getBytes = function(len) {
            var dpos = 0;
            var dst = new Buffer(len);
            var cacheLen = 64 - this.cachePos;
            if (cacheLen) {
                if (cacheLen >= len) {
                    this.output.copy(dst, 0, this.cachePos, 64);
                    this.cachePos += len;
                    return dst;
                } else {
                    this.output.copy(dst, 0, this.cachePos, 64);
                    len -= cacheLen;
                    dpos += cacheLen;
                    this.cachePos = 64;
                }
            }
            while (len > 0 ) {
                if (len <= 64) {
                    this.makeBlock(this.output, 0);
                    this.output.copy(dst, dpos, 0, len);
                    if (len < 64) {
                        this.cachePos = len;
                    }
                    return dst;
                } else {
                    this.makeBlock(dst, dpos);
                }
                len -= 64;
                dpos += 64;
            }
            throw new Error('something bad happended');
        };
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],172:[function(require,module,exports){
    var Chacha20 = require('./chacha20');
    var inherits = require('inherits');
    var CipherBase = require('./cipherbase');
    inherits(ChaChaStream, CipherBase);
    module.exports = ChaChaStream;
    function ChaChaStream (key, iv) {
        if (!(this instanceof ChaChaStream)) {
            return new ChaChaStream(key, iv);
        }
        CipherBase.call(this);
        this.chacha = new Chacha20(key, iv);
    }
    ChaChaStream.prototype._update = function (chunk) {
        var len = chunk.length;
        if (!len) {
            return;
        }
        var pad = this.chacha.getBytes(len);
        var i = -1;
        while (++i < len) {
            pad[i] ^= chunk[i];
        }
        return pad;
    };
},{"./chacha20":171,"./cipherbase":173,"inherits":176}],173:[function(require,module,exports){
    (function (Buffer){
        var Transform = require('readable-stream').Transform;
        var inherits = require('inherits');

        module.exports = CipherBase;
        inherits(CipherBase, Transform);
        function CipherBase(digest) {
            if (digest) {
                this.digest = finalFunc;
            } else {
                this.final = finalFunc;
            }

        }
        [
            '_readableState',
            '_writableState',
            '_transformState'
        ].forEach(function(prop) {
                Object.defineProperty(CipherBase.prototype, prop, {
                    get: function() {
                        Transform.call(this);
                        return this[prop];
                    },
                    set: function(val) {
                        Object.defineProperty(this, prop, {
                            value: val,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    },
                    configurable: true,
                    enumerable: true
                });
            });
        CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
            if (typeof data === 'string') {
                data = new Buffer(data, inputEnc);
            }
            var outData = this._update(data) || new Buffer('');
            if (outputEnc) {
                outData = outData.toString(outputEnc);
            }
            if (this.digest) {
                return this;
            }
            return outData;
        };
        CipherBase.prototype._transform = function (data, _, next) {
            this.push(this._update(data));
            next();
        };
        CipherBase.prototype._flush = function (next) {
            try {
                this.push(this._final());
            } catch(e) {
                return next(e);
            }
            next();
        };
        function finalFunc (outputEnc) {
            var outData = this._final() || new Buffer('');
            if (outputEnc) {
                outData = outData.toString(outputEnc);
            }
            return outData;
        };
        CipherBase.prototype._final = function () {};

    }).call(this,require("buffer").Buffer)
},{"buffer":3,"inherits":176,"readable-stream":185}],174:[function(require,module,exports){


    var Cipher = require('./aead');
    exports.aead = Cipher;
    exports.createCipher = createCipher;
    function createCipher(key, iv) {
        return new Cipher(key, iv);
    }
    exports.createDecipher = createDecipher;
    function createDecipher(key, iv) {
        return new Cipher(key, iv, true);
    }

    exports.createHmac = require('./polystream');
    exports.chacha20 = exports.ChaCha20 = require('./chachastream');
    exports.aeadLegacy = exports.AeadLegacy = require('./legacy-aead');
},{"./aead":170,"./chachastream":172,"./legacy-aead":175,"./polystream":187}],175:[function(require,module,exports){
    (function (Buffer){
        var inherits = require('inherits');
        var CipherBase = require('./cipherbase');
        var Chacha20 = require('./chacha20');
        var Poly1305 = require('./poly1305');
        inherits(Cipher, CipherBase);
        module.exports = Cipher;
        var zeros = new Buffer (4);
        zeros.fill(0);
        function Cipher(key, iv, decrypt){
            if (!(this instanceof Cipher)) {
                return new Cipher(key, iv, decrypt);
            }
            CipherBase.call(this);
            this.alen = 0;
            this.clen = 0;
            this.chacha = new Chacha20(key, Buffer.concat([zeros,iv]));
            this.poly = new Poly1305(this.chacha.getBytes(64));
            this.tag = null;
            this._decrypt = decrypt;
            this._hasData = false;
        }
        Cipher.prototype.setAAD = function (aad) {
            if (this._hasData) {
                throw new Error('Attempting to set AAD in unsupported state');
            }
            this.alen += aad.length;
            this.poly.update(aad);
            // var padding = new Buffer(padAmount(this.alen));
            // if (padding.length) {
            //   padding.fill(0);
            //   this.poly.update(padding);
            // }
            //this.poly.update(len);
        };
        Cipher.prototype._flushlentag = function () {
            this._hasData = true;
            var len = new Buffer(8);
            len.fill(0);
            len.writeUInt32LE(this.alen, 0);
            this.poly.update(len);
        };
        Cipher.prototype._update = function (chunk) {
            if (!this._hasData) {
                this._flushlentag();
            }
            var len = chunk.length;
            if (!len) {
                return;
            }
            this.clen += len;
            var pad = this.chacha.getBytes(len);
            var i = -1;
            while (++i < len) {
                pad[i] ^= chunk[i];
            }
            if (this._decrypt) {
                this.poly.update(chunk);
            } else {
                this.poly.update(pad);
            }
            return pad;
        };
        Cipher.prototype._final = function () {
            if (this._decrypt && !this.tag) {
                throw new Error('Unsupported state or unable to authenticate data');
            }
            if (!this._hasData) {
                this._flushlentag();
            }
            // var padding = new Buffer(padAmount(this.clen));
            // if (padding.length) {
            //   padding.fill(0);
            //   this.poly.update(padding);
            // }
            var lens = new Buffer(8);
            lens.fill(0);
            //lens.writeUInt32LE(this.alen, 0);
            lens.writeUInt32LE(this.clen, 0);
            var tag = this.poly.update(lens).finish();
            if (this._decrypt) {
                if (xorTest(tag, this.tag)) {
                    throw new Error('Unsupported state or unable to authenticate data');
                }
            } else {
                this.tag = tag;
            }
        };
        Cipher.prototype.getAuthTag = function () {
            if(this._decrypt || this.tag === null) {
                throw new Error('Attempting to get auth tag in unsupported state');
            }
            return this.tag;
        };
        Cipher.prototype.setAuthTag = function setAuthTag (tag) {
            if (this._decrypt) {
                this.tag = tag;
            } else {
                throw new Error('Attempting to set auth tag in unsupported state');
            }
        };
        function padAmount(len) {
            var rem = len % 16;
            if (rem === 16) {
                return 0;
            }
            return 16 - rem;
        }
        function xorTest(a, b) {
            var out = 0;
            if (a.length !== b.length) {
                out++;
            }
            var len = Math.min(a.length, b.length);
            var i = -1;
            while (++i < len) {
                out += (a[i] ^ b[i]);
            }
            return out;
        }

    }).call(this,require("buffer").Buffer)
},{"./chacha20":171,"./cipherbase":173,"./poly1305":186,"buffer":3,"inherits":176}],176:[function(require,module,exports){
    arguments[4][149][0].apply(exports,arguments)
},{"dup":149}],177:[function(require,module,exports){
    arguments[4][153][0].apply(exports,arguments)
},{"./_stream_readable":179,"./_stream_writable":181,"_process":151,"core-util-is":182,"dup":153,"inherits":176}],178:[function(require,module,exports){
    arguments[4][154][0].apply(exports,arguments)
},{"./_stream_transform":180,"core-util-is":182,"dup":154,"inherits":176}],179:[function(require,module,exports){
    (function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

        module.exports = Readable;

        /*<replacement>*/
        var isArray = require('isarray');
        /*</replacement>*/


        /*<replacement>*/
        var Buffer = require('buffer').Buffer;
        /*</replacement>*/

        Readable.ReadableState = ReadableState;

        var EE = require('events').EventEmitter;

        /*<replacement>*/
        if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
            return emitter.listeners(type).length;
        };
        /*</replacement>*/

        var Stream = require('stream');

        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/

        var StringDecoder;


        /*<replacement>*/
        var debug = require('util');
        if (debug && debug.debuglog) {
            debug = debug.debuglog('stream');
        } else {
            debug = function () {};
        }
        /*</replacement>*/


        util.inherits(Readable, Stream);

        function ReadableState(options, stream) {
            var Duplex = require('./_stream_duplex');

            options = options || {};

            // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"
            var hwm = options.highWaterMark;
            var defaultHwm = options.objectMode ? 16 : 16 * 1024;
            this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

            // cast to ints.
            this.highWaterMark = ~~this.highWaterMark;

            this.buffer = [];
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;

            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true;

            // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;


            // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away
            this.objectMode = !!options.objectMode;

            if (stream instanceof Duplex)
                this.objectMode = this.objectMode || !!options.readableObjectMode;

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || 'utf8';

            // when piping, we only care about 'readable' events that happen
            // after read()ing all the bytes and not getting any pushback.
            this.ranOut = false;

            // the number of writers that are awaiting a drain event in .pipe()s
            this.awaitDrain = 0;

            // if true, a maybeReadMore has been scheduled
            this.readingMore = false;

            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
                if (!StringDecoder)
                    StringDecoder = require('string_decoder/').StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
            }
        }

        function Readable(options) {
            var Duplex = require('./_stream_duplex');

            if (!(this instanceof Readable))
                return new Readable(options);

            this._readableState = new ReadableState(options, this);

            // legacy
            this.readable = true;

            Stream.call(this);
        }

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
        Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;

            if (util.isString(chunk) && !state.objectMode) {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                    chunk = new Buffer(chunk, encoding);
                    encoding = '';
                }
            }

            return readableAddChunk(this, state, chunk, encoding, false);
        };

// Unshift should *always* be something directly out of read()
        Readable.prototype.unshift = function(chunk) {
            var state = this._readableState;
            return readableAddChunk(this, state, chunk, '', true);
        };

        function readableAddChunk(stream, state, chunk, encoding, addToFront) {
            var er = chunkInvalid(state, chunk);
            if (er) {
                stream.emit('error', er);
            } else if (util.isNullOrUndefined(chunk)) {
                state.reading = false;
                if (!state.ended)
                    onEofChunk(stream, state);
            } else if (state.objectMode || chunk && chunk.length > 0) {
                if (state.ended && !addToFront) {
                    var e = new Error('stream.push() after EOF');
                    stream.emit('error', e);
                } else if (state.endEmitted && addToFront) {
                    var e = new Error('stream.unshift() after end event');
                    stream.emit('error', e);
                } else {
                    if (state.decoder && !addToFront && !encoding)
                        chunk = state.decoder.write(chunk);

                    if (!addToFront)
                        state.reading = false;

                    // if we want the data now, just emit it.
                    if (state.flowing && state.length === 0 && !state.sync) {
                        stream.emit('data', chunk);
                        stream.read(0);
                    } else {
                        // update the buffer info.
                        state.length += state.objectMode ? 1 : chunk.length;
                        if (addToFront)
                            state.buffer.unshift(chunk);
                        else
                            state.buffer.push(chunk);

                        if (state.needReadable)
                            emitReadable(stream);
                    }

                    maybeReadMore(stream, state);
                }
            } else if (!addToFront) {
                state.reading = false;
            }

            return needMoreData(state);
        }



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
        function needMoreData(state) {
            return !state.ended &&
                (state.needReadable ||
                state.length < state.highWaterMark ||
                state.length === 0);
        }

// backwards compatibility.
        Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
                StringDecoder = require('string_decoder/').StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
            return this;
        };

// Don't raise the hwm > 128MB
        var MAX_HWM = 0x800000;
        function roundUpToNextPowerOf2(n) {
            if (n >= MAX_HWM) {
                n = MAX_HWM;
            } else {
                // Get the next highest power of 2
                n--;
                for (var p = 1; p < 32; p <<= 1) n |= n >> p;
                n++;
            }
            return n;
        }

        function howMuchToRead(n, state) {
            if (state.length === 0 && state.ended)
                return 0;

            if (state.objectMode)
                return n === 0 ? 0 : 1;

            if (isNaN(n) || util.isNull(n)) {
                // only flow one buffer at a time
                if (state.flowing && state.buffer.length)
                    return state.buffer[0].length;
                else
                    return state.length;
            }

            if (n <= 0)
                return 0;

            // If we're asking for more than the target buffer level,
            // then raise the water mark.  Bump up to the next highest
            // power of 2, to prevent increasing it excessively in tiny
            // amounts.
            if (n > state.highWaterMark)
                state.highWaterMark = roundUpToNextPowerOf2(n);

            // don't have that much.  return null, unless we've ended.
            if (n > state.length) {
                if (!state.ended) {
                    state.needReadable = true;
                    return 0;
                } else
                    return state.length;
            }

            return n;
        }

// you can override either this method, or the async _read(n) below.
        Readable.prototype.read = function(n) {
            debug('read', n);
            var state = this._readableState;
            var nOrig = n;

            if (!util.isNumber(n) || n > 0)
                state.emittedReadable = false;

            // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.
            if (n === 0 &&
                state.needReadable &&
                (state.length >= state.highWaterMark || state.ended)) {
                debug('read: emitReadable', state.length, state.ended);
                if (state.length === 0 && state.ended)
                    endReadable(this);
                else
                    emitReadable(this);
                return null;
            }

            n = howMuchToRead(n, state);

            // if we've ended, and we're now clear, then finish it up.
            if (n === 0 && state.ended) {
                if (state.length === 0)
                    endReadable(this);
                return null;
            }

            // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.

            // if we need a readable event, then we need to do some reading.
            var doRead = state.needReadable;
            debug('need readable', doRead);

            // if we currently have less than the highWaterMark, then also read some
            if (state.length === 0 || state.length - n < state.highWaterMark) {
                doRead = true;
                debug('length less than watermark', doRead);
            }

            // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.
            if (state.ended || state.reading) {
                doRead = false;
                debug('reading or ended', doRead);
            }

            if (doRead) {
                debug('do read');
                state.reading = true;
                state.sync = true;
                // if the length is currently zero, then we *need* a readable event.
                if (state.length === 0)
                    state.needReadable = true;
                // call internal read method
                this._read(state.highWaterMark);
                state.sync = false;
            }

            // If _read pushed data synchronously, then `reading` will be false,
            // and we need to re-evaluate how much data we can return to the user.
            if (doRead && !state.reading)
                n = howMuchToRead(nOrig, state);

            var ret;
            if (n > 0)
                ret = fromList(n, state);
            else
                ret = null;

            if (util.isNull(ret)) {
                state.needReadable = true;
                n = 0;
            }

            state.length -= n;

            // If we have nothing in the buffer, then we want to know
            // as soon as we *do* get something into the buffer.
            if (state.length === 0 && !state.ended)
                state.needReadable = true;

            // If we tried to read() past the EOF, then emit end on the next tick.
            if (nOrig !== n && state.ended && state.length === 0)
                endReadable(this);

            if (!util.isNull(ret))
                this.emit('data', ret);

            return ret;
        };

        function chunkInvalid(state, chunk) {
            var er = null;
            if (!util.isBuffer(chunk) &&
                !util.isString(chunk) &&
                !util.isNullOrUndefined(chunk) &&
                !state.objectMode) {
                er = new TypeError('Invalid non-string/buffer chunk');
            }
            return er;
        }


        function onEofChunk(stream, state) {
            if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                    state.buffer.push(chunk);
                    state.length += state.objectMode ? 1 : chunk.length;
                }
            }
            state.ended = true;

            // emit 'readable' now to make sure it gets picked up.
            emitReadable(stream);
        }

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
        function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (!state.emittedReadable) {
                debug('emitReadable', state.flowing);
                state.emittedReadable = true;
                if (state.sync)
                    process.nextTick(function() {
                        emitReadable_(stream);
                    });
                else
                    emitReadable_(stream);
            }
        }

        function emitReadable_(stream) {
            debug('emit readable');
            stream.emit('readable');
            flow(stream);
        }


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
        function maybeReadMore(stream, state) {
            if (!state.readingMore) {
                state.readingMore = true;
                process.nextTick(function() {
                    maybeReadMore_(stream, state);
                });
            }
        }

        function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended &&
            state.length < state.highWaterMark) {
                debug('maybeReadMore read 0');
                stream.read(0);
                if (len === state.length)
                // didn't get any data, stop spinning.
                    break;
                else
                    len = state.length;
            }
            state.readingMore = false;
        }

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
        Readable.prototype._read = function(n) {
            this.emit('error', new Error('not implemented'));
        };

        Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;

            switch (state.pipesCount) {
                case 0:
                    state.pipes = dest;
                    break;
                case 1:
                    state.pipes = [state.pipes, dest];
                    break;
                default:
                    state.pipes.push(dest);
                    break;
            }
            state.pipesCount += 1;
            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

            var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                dest !== process.stdout &&
                dest !== process.stderr;

            var endFn = doEnd ? onend : cleanup;
            if (state.endEmitted)
                process.nextTick(endFn);
            else
                src.once('end', endFn);

            dest.on('unpipe', onunpipe);
            function onunpipe(readable) {
                debug('onunpipe');
                if (readable === src) {
                    cleanup();
                }
            }

            function onend() {
                debug('onend');
                dest.end();
            }

            // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.
            var ondrain = pipeOnDrain(src);
            dest.on('drain', ondrain);

            function cleanup() {
                debug('cleanup');
                // cleanup event handlers once the pipe is broken
                dest.removeListener('close', onclose);
                dest.removeListener('finish', onfinish);
                dest.removeListener('drain', ondrain);
                dest.removeListener('error', onerror);
                dest.removeListener('unpipe', onunpipe);
                src.removeListener('end', onend);
                src.removeListener('end', cleanup);
                src.removeListener('data', ondata);

                // if the reader is waiting for a drain event from this
                // specific writer, then it would cause it to never start
                // flowing again.
                // So, if this is awaiting a drain, then we just call it now.
                // If we don't know, then assume that we are waiting for one.
                if (state.awaitDrain &&
                    (!dest._writableState || dest._writableState.needDrain))
                    ondrain();
            }

            src.on('data', ondata);
            function ondata(chunk) {
                debug('ondata');
                var ret = dest.write(chunk);
                if (false === ret) {
                    debug('false write response, pause',
                        src._readableState.awaitDrain);
                    src._readableState.awaitDrain++;
                    src.pause();
                }
            }

            // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.
            function onerror(er) {
                debug('onerror', er);
                unpipe();
                dest.removeListener('error', onerror);
                if (EE.listenerCount(dest, 'error') === 0)
                    dest.emit('error', er);
            }
            // This is a brutally ugly hack to make sure that our error handler
            // is attached before any userland ones.  NEVER DO THIS.
            if (!dest._events || !dest._events.error)
                dest.on('error', onerror);
            else if (isArray(dest._events.error))
                dest._events.error.unshift(onerror);
            else
                dest._events.error = [onerror, dest._events.error];



            // Both close and finish should trigger unpipe, but only once.
            function onclose() {
                dest.removeListener('finish', onfinish);
                unpipe();
            }
            dest.once('close', onclose);
            function onfinish() {
                debug('onfinish');
                dest.removeListener('close', onclose);
                unpipe();
            }
            dest.once('finish', onfinish);

            function unpipe() {
                debug('unpipe');
                src.unpipe(dest);
            }

            // tell the dest that it's being piped to
            dest.emit('pipe', src);

            // start the flow if it hasn't been started already.
            if (!state.flowing) {
                debug('pipe resume');
                src.resume();
            }

            return dest;
        };

        function pipeOnDrain(src) {
            return function() {
                var state = src._readableState;
                debug('pipeOnDrain', state.awaitDrain);
                if (state.awaitDrain)
                    state.awaitDrain--;
                if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
                    state.flowing = true;
                    flow(src);
                }
            };
        }


        Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;

            // if we're not piping anywhere, then do nothing.
            if (state.pipesCount === 0)
                return this;

            // just one destination.  most common case.
            if (state.pipesCount === 1) {
                // passed in one, but it's not the right one.
                if (dest && dest !== state.pipes)
                    return this;

                if (!dest)
                    dest = state.pipes;

                // got a match.
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest)
                    dest.emit('unpipe', this);
                return this;
            }

            // slow case. multiple pipe destinations.

            if (!dest) {
                // remove all.
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;

                for (var i = 0; i < len; i++)
                    dests[i].emit('unpipe', this);
                return this;
            }

            // try to find the right one.
            var i = indexOf(state.pipes, dest);
            if (i === -1)
                return this;

            state.pipes.splice(i, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
                state.pipes = state.pipes[0];

            dest.emit('unpipe', this);

            return this;
        };

// set up data events if they are asked for
// Ensure readable listeners eventually get something
        Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);

            // If listening to data, and it has not explicitly been paused,
            // then call resume to start the flow of data on the next tick.
            if (ev === 'data' && false !== this._readableState.flowing) {
                this.resume();
            }

            if (ev === 'readable' && this.readable) {
                var state = this._readableState;
                if (!state.readableListening) {
                    state.readableListening = true;
                    state.emittedReadable = false;
                    state.needReadable = true;
                    if (!state.reading) {
                        var self = this;
                        process.nextTick(function() {
                            debug('readable nexttick read 0');
                            self.read(0);
                        });
                    } else if (state.length) {
                        emitReadable(this, state);
                    }
                }
            }

            return res;
        };
        Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
        Readable.prototype.resume = function() {
            var state = this._readableState;
            if (!state.flowing) {
                debug('resume');
                state.flowing = true;
                if (!state.reading) {
                    debug('resume read 0');
                    this.read(0);
                }
                resume(this, state);
            }
            return this;
        };

        function resume(stream, state) {
            if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                process.nextTick(function() {
                    resume_(stream, state);
                });
            }
        }

        function resume_(stream, state) {
            state.resumeScheduled = false;
            stream.emit('resume');
            flow(stream);
            if (state.flowing && !state.reading)
                stream.read(0);
        }

        Readable.prototype.pause = function() {
            debug('call pause flowing=%j', this._readableState.flowing);
            if (false !== this._readableState.flowing) {
                debug('pause');
                this._readableState.flowing = false;
                this.emit('pause');
            }
            return this;
        };

        function flow(stream) {
            var state = stream._readableState;
            debug('flow', state.flowing);
            if (state.flowing) {
                do {
                    var chunk = stream.read();
                } while (null !== chunk && state.flowing);
            }
        }

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
        Readable.prototype.wrap = function(stream) {
            var state = this._readableState;
            var paused = false;

            var self = this;
            stream.on('end', function() {
                debug('wrapped end');
                if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length)
                        self.push(chunk);
                }

                self.push(null);
            });

            stream.on('data', function(chunk) {
                debug('wrapped data');
                if (state.decoder)
                    chunk = state.decoder.write(chunk);
                if (!chunk || !state.objectMode && !chunk.length)
                    return;

                var ret = self.push(chunk);
                if (!ret) {
                    paused = true;
                    stream.pause();
                }
            });

            // proxy all the other methods.
            // important when wrapping filters and duplexes.
            for (var i in stream) {
                if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
                    this[i] = function(method) { return function() {
                        return stream[method].apply(stream, arguments);
                    }}(i);
                }
            }

            // proxy certain important events.
            var events = ['error', 'close', 'destroy', 'pause', 'resume'];
            forEach(events, function(ev) {
                stream.on(ev, self.emit.bind(self, ev));
            });

            // when we try to consume some more bytes, simply unpause the
            // underlying stream.
            self._read = function(n) {
                debug('wrapped _read', n);
                if (paused) {
                    paused = false;
                    stream.resume();
                }
            };

            return self;
        };



// exposed for testing purposes only.
        Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
        function fromList(n, state) {
            var list = state.buffer;
            var length = state.length;
            var stringMode = !!state.decoder;
            var objectMode = !!state.objectMode;
            var ret;

            // nothing in the list, definitely empty.
            if (list.length === 0)
                return null;

            if (length === 0)
                ret = null;
            else if (objectMode)
                ret = list.shift();
            else if (!n || n >= length) {
                // read it all, truncate the array.
                if (stringMode)
                    ret = list.join('');
                else
                    ret = Buffer.concat(list, length);
                list.length = 0;
            } else {
                // read just some of it.
                if (n < list[0].length) {
                    // just take a part of the first list item.
                    // slice is the same for buffers and strings.
                    var buf = list[0];
                    ret = buf.slice(0, n);
                    list[0] = buf.slice(n);
                } else if (n === list[0].length) {
                    // first list is a perfect match
                    ret = list.shift();
                } else {
                    // complex case.
                    // we have enough to cover it, but it spans past the first buffer.
                    if (stringMode)
                        ret = '';
                    else
                        ret = new Buffer(n);

                    var c = 0;
                    for (var i = 0, l = list.length; i < l && c < n; i++) {
                        var buf = list[0];
                        var cpy = Math.min(n - c, buf.length);

                        if (stringMode)
                            ret += buf.slice(0, cpy);
                        else
                            buf.copy(ret, c, 0, cpy);

                        if (cpy < buf.length)
                            list[0] = buf.slice(cpy);
                        else
                            list.shift();

                        c += cpy;
                    }
                }
            }

            return ret;
        }

        function endReadable(stream) {
            var state = stream._readableState;

            // If we get here before consuming all the bytes, then that is a
            // bug in node.  Should never happen.
            if (state.length > 0)
                throw new Error('endReadable called on non-empty stream');

            if (!state.endEmitted) {
                state.ended = true;
                process.nextTick(function() {
                    // Check that we didn't get one last unshift.
                    if (!state.endEmitted && state.length === 0) {
                        state.endEmitted = true;
                        stream.readable = false;
                        stream.emit('end');
                    }
                });
            }
        }

        function forEach (xs, f) {
            for (var i = 0, l = xs.length; i < l; i++) {
                f(xs[i], i);
            }
        }

        function indexOf (xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x) return i;
            }
            return -1;
        }

    }).call(this,require('_process'))
},{"./_stream_duplex":177,"_process":151,"buffer":3,"core-util-is":182,"events":148,"inherits":176,"isarray":183,"stream":163,"string_decoder/":184,"util":2}],180:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

    module.exports = Transform;

    var Duplex = require('./_stream_duplex');

    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/

    util.inherits(Transform, Duplex);


    function TransformState(options, stream) {
        this.afterTransform = function(er, data) {
            return afterTransform(stream, er, data);
        };

        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null;
    }

    function afterTransform(stream, er, data) {
        var ts = stream._transformState;
        ts.transforming = false;

        var cb = ts.writecb;

        if (!cb)
            return stream.emit('error', new Error('no writecb in Transform class'));

        ts.writechunk = null;
        ts.writecb = null;

        if (!util.isNullOrUndefined(data))
            stream.push(data);

        if (cb)
            cb(er);

        var rs = stream._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
            stream._read(rs.highWaterMark);
        }
    }


    function Transform(options) {
        if (!(this instanceof Transform))
            return new Transform(options);

        Duplex.call(this, options);

        this._transformState = new TransformState(options, this);

        // when the writable side finishes, then flush out anything remaining.
        var stream = this;

        // start out asking for a readable event once data is transformed.
        this._readableState.needReadable = true;

        // we have implemented the _read method, and done the other things
        // that Readable wants before the first _read call, so unset the
        // sync guard flag.
        this._readableState.sync = false;

        this.once('prefinish', function() {
            if (util.isFunction(this._flush))
                this._flush(function(er) {
                    done(stream, er);
                });
            else
                done(stream);
        });
    }

    Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
    };

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error('not implemented');
    };

    Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform ||
                rs.needReadable ||
                rs.length < rs.highWaterMark)
                this._read(rs.highWaterMark);
        }
    };

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
        var ts = this._transformState;

        if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
            // mark that we need a transform, so that any data that comes in
            // will get processed, now that we've asked for it.
            ts.needTransform = true;
        }
    };


    function done(stream, er) {
        if (er)
            return stream.emit('error', er);

        // if there's nothing in the write buffer, then that means
        // that nothing more will ever be provided
        var ws = stream._writableState;
        var ts = stream._transformState;

        if (ws.length)
            throw new Error('calling transform done when ws.length != 0');

        if (ts.transforming)
            throw new Error('calling transform done when still transforming');

        return stream.push(null);
    }

},{"./_stream_duplex":177,"core-util-is":182,"inherits":176}],181:[function(require,module,exports){
    (function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

        module.exports = Writable;

        /*<replacement>*/
        var Buffer = require('buffer').Buffer;
        /*</replacement>*/

        Writable.WritableState = WritableState;


        /*<replacement>*/
        var util = require('core-util-is');
        util.inherits = require('inherits');
        /*</replacement>*/

        var Stream = require('stream');

        util.inherits(Writable, Stream);

        function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
        }

        function WritableState(options, stream) {
            var Duplex = require('./_stream_duplex');

            options = options || {};

            // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()
            var hwm = options.highWaterMark;
            var defaultHwm = options.objectMode ? 16 : 16 * 1024;
            this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

            // object stream flag to indicate whether or not this stream
            // contains buffers or objects.
            this.objectMode = !!options.objectMode;

            if (stream instanceof Duplex)
                this.objectMode = this.objectMode || !!options.writableObjectMode;

            // cast to ints.
            this.highWaterMark = ~~this.highWaterMark;

            this.needDrain = false;
            // at the start of calling end()
            this.ending = false;
            // when end() has been called, and returned
            this.ended = false;
            // when 'finish' is emitted
            this.finished = false;

            // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;

            // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.
            this.defaultEncoding = options.defaultEncoding || 'utf8';

            // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.
            this.length = 0;

            // a flag to see when we're in the middle of a write.
            this.writing = false;

            // when true all writes will be buffered until .uncork() call
            this.corked = 0;

            // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.
            this.sync = true;

            // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.
            this.bufferProcessing = false;

            // the callback that's passed to _write(chunk,cb)
            this.onwrite = function(er) {
                onwrite(stream, er);
            };

            // the callback that the user supplies to write(chunk,encoding,cb)
            this.writecb = null;

            // the amount that is being written when _write is called.
            this.writelen = 0;

            this.buffer = [];

            // number of pending user-supplied write callbacks
            // this must be 0 before 'finish' can be emitted
            this.pendingcb = 0;

            // emit prefinish if the only thing we're waiting for is _write cbs
            // This is relevant for synchronous Transform streams
            this.prefinished = false;

            // True if the error was already emitted and should not be thrown again
            this.errorEmitted = false;
        }

        function Writable(options) {
            var Duplex = require('./_stream_duplex');

            // Writable ctor is applied to Duplexes, though they're not
            // instanceof Writable, they're instanceof Readable.
            if (!(this instanceof Writable) && !(this instanceof Duplex))
                return new Writable(options);

            this._writableState = new WritableState(options, this);

            // legacy.
            this.writable = true;

            Stream.call(this);
        }

// Otherwise people can pipe Writable streams, which is just wrong.
        Writable.prototype.pipe = function() {
            this.emit('error', new Error('Cannot pipe. Not readable.'));
        };


        function writeAfterEnd(stream, state, cb) {
            var er = new Error('write after end');
            // TODO: defer error events consistently everywhere, not just the cb
            stream.emit('error', er);
            process.nextTick(function() {
                cb(er);
            });
        }

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
        function validChunk(stream, state, chunk, cb) {
            var valid = true;
            if (!util.isBuffer(chunk) &&
                !util.isString(chunk) &&
                !util.isNullOrUndefined(chunk) &&
                !state.objectMode) {
                var er = new TypeError('Invalid non-string/buffer chunk');
                stream.emit('error', er);
                process.nextTick(function() {
                    cb(er);
                });
                valid = false;
            }
            return valid;
        }

        Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;

            if (util.isFunction(encoding)) {
                cb = encoding;
                encoding = null;
            }

            if (util.isBuffer(chunk))
                encoding = 'buffer';
            else if (!encoding)
                encoding = state.defaultEncoding;

            if (!util.isFunction(cb))
                cb = function() {};

            if (state.ended)
                writeAfterEnd(this, state, cb);
            else if (validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, chunk, encoding, cb);
            }

            return ret;
        };

        Writable.prototype.cork = function() {
            var state = this._writableState;

            state.corked++;
        };

        Writable.prototype.uncork = function() {
            var state = this._writableState;

            if (state.corked) {
                state.corked--;

                if (!state.writing &&
                    !state.corked &&
                    !state.finished &&
                    !state.bufferProcessing &&
                    state.buffer.length)
                    clearBuffer(this, state);
            }
        };

        function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode &&
                state.decodeStrings !== false &&
                util.isString(chunk)) {
                chunk = new Buffer(chunk, encoding);
            }
            return chunk;
        }

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
        function writeOrBuffer(stream, state, chunk, encoding, cb) {
            chunk = decodeChunk(state, chunk, encoding);
            if (util.isBuffer(chunk))
                encoding = 'buffer';
            var len = state.objectMode ? 1 : chunk.length;

            state.length += len;

            var ret = state.length < state.highWaterMark;
            // we must ensure that previous needDrain will not be reset to false.
            if (!ret)
                state.needDrain = true;

            if (state.writing || state.corked)
                state.buffer.push(new WriteReq(chunk, encoding, cb));
            else
                doWrite(stream, state, false, len, chunk, encoding, cb);

            return ret;
        }

        function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (writev)
                stream._writev(chunk, state.onwrite);
            else
                stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
        }

        function onwriteError(stream, state, sync, er, cb) {
            if (sync)
                process.nextTick(function() {
                    state.pendingcb--;
                    cb(er);
                });
            else {
                state.pendingcb--;
                cb(er);
            }

            stream._writableState.errorEmitted = true;
            stream.emit('error', er);
        }

        function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
        }

        function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;

            onwriteStateUpdate(state);

            if (er)
                onwriteError(stream, state, sync, er, cb);
            else {
                // Check if we're actually ready to finish, but don't emit yet
                var finished = needFinish(stream, state);

                if (!finished &&
                    !state.corked &&
                    !state.bufferProcessing &&
                    state.buffer.length) {
                    clearBuffer(stream, state);
                }

                if (sync) {
                    process.nextTick(function() {
                        afterWrite(stream, state, finished, cb);
                    });
                } else {
                    afterWrite(stream, state, finished, cb);
                }
            }
        }

        function afterWrite(stream, state, finished, cb) {
            if (!finished)
                onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
        }

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
        function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit('drain');
            }
        }


// if there's something in the buffer waiting, then process it
        function clearBuffer(stream, state) {
            state.bufferProcessing = true;

            if (stream._writev && state.buffer.length > 1) {
                // Fast case, write everything using _writev()
                var cbs = [];
                for (var c = 0; c < state.buffer.length; c++)
                    cbs.push(state.buffer[c].callback);

                // count the one we are adding, as well.
                // TODO(isaacs) clean this up
                state.pendingcb++;
                doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
                    for (var i = 0; i < cbs.length; i++) {
                        state.pendingcb--;
                        cbs[i](err);
                    }
                });

                // Clear buffer
                state.buffer = [];
            } else {
                // Slow case, write chunks one-by-one
                for (var c = 0; c < state.buffer.length; c++) {
                    var entry = state.buffer[c];
                    var chunk = entry.chunk;
                    var encoding = entry.encoding;
                    var cb = entry.callback;
                    var len = state.objectMode ? 1 : chunk.length;

                    doWrite(stream, state, false, len, chunk, encoding, cb);

                    // if we didn't call the onwrite immediately, then
                    // it means that we need to wait until it does.
                    // also, that means that the chunk and cb are currently
                    // being processed, so move the buffer counter past them.
                    if (state.writing) {
                        c++;
                        break;
                    }
                }

                if (c < state.buffer.length)
                    state.buffer = state.buffer.slice(c);
                else
                    state.buffer.length = 0;
            }

            state.bufferProcessing = false;
        }

        Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error('not implemented'));

        };

        Writable.prototype._writev = null;

        Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;

            if (util.isFunction(chunk)) {
                cb = chunk;
                chunk = null;
                encoding = null;
            } else if (util.isFunction(encoding)) {
                cb = encoding;
                encoding = null;
            }

            if (!util.isNullOrUndefined(chunk))
                this.write(chunk, encoding);

            // .end() fully uncorks
            if (state.corked) {
                state.corked = 1;
                this.uncork();
            }

            // ignore unnecessary end() calls.
            if (!state.ending && !state.finished)
                endWritable(this, state, cb);
        };


        function needFinish(stream, state) {
            return (state.ending &&
            state.length === 0 &&
            !state.finished &&
            !state.writing);
        }

        function prefinish(stream, state) {
            if (!state.prefinished) {
                state.prefinished = true;
                stream.emit('prefinish');
            }
        }

        function finishMaybe(stream, state) {
            var need = needFinish(stream, state);
            if (need) {
                if (state.pendingcb === 0) {
                    prefinish(stream, state);
                    state.finished = true;
                    stream.emit('finish');
                } else
                    prefinish(stream, state);
            }
            return need;
        }

        function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
                if (state.finished)
                    process.nextTick(cb);
                else
                    stream.once('finish', cb);
            }
            state.ended = true;
        }

    }).call(this,require('_process'))
},{"./_stream_duplex":177,"_process":151,"buffer":3,"core-util-is":182,"inherits":176,"stream":163}],182:[function(require,module,exports){
    (function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

        function isArray(arg) {
            if (Array.isArray) {
                return Array.isArray(arg);
            }
            return objectToString(arg) === '[object Array]';
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
            return typeof arg === 'boolean';
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
            return arg === null;
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
            return typeof arg === 'number';
        }
        exports.isNumber = isNumber;

        function isString(arg) {
            return typeof arg === 'string';
        }
        exports.isString = isString;

        function isSymbol(arg) {
            return typeof arg === 'symbol';
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
            return objectToString(re) === '[object RegExp]';
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
        }
        exports.isObject = isObject;

        function isDate(d) {
            return objectToString(d) === '[object Date]';
        }
        exports.isDate = isDate;

        function isError(e) {
            return (objectToString(e) === '[object Error]' || e instanceof Error);
        }
        exports.isError = isError;

        function isFunction(arg) {
            return typeof arg === 'function';
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
            return arg === null ||
                typeof arg === 'boolean' ||
                typeof arg === 'number' ||
                typeof arg === 'string' ||
                typeof arg === 'symbol' ||  // ES6 symbol
                typeof arg === 'undefined';
        }
        exports.isPrimitive = isPrimitive;

        exports.isBuffer = Buffer.isBuffer;

        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }

    }).call(this,require("buffer").Buffer)
},{"buffer":3}],183:[function(require,module,exports){
    arguments[4][150][0].apply(exports,arguments)
},{"dup":150}],184:[function(require,module,exports){
    arguments[4][164][0].apply(exports,arguments)
},{"buffer":3,"dup":164}],185:[function(require,module,exports){
    arguments[4][160][0].apply(exports,arguments)
},{"./lib/_stream_duplex.js":177,"./lib/_stream_passthrough.js":178,"./lib/_stream_readable.js":179,"./lib/_stream_transform.js":180,"./lib/_stream_writable.js":181,"dup":160,"stream":163}],186:[function(require,module,exports){
    (function (Buffer){
        var Poly1305KeySize = 32;
        var Poly1305TagSize = 16;
        module.exports = Poly1305;
        function Poly1305(key) {
            if (!(this instanceof Poly1305)) {
                return new Poly1305(key);
            }
            this.buffer = new Buffer(16);
            this.leftover = 0;
            this.r = new Uint16Array(10);
            this.h = new Uint16Array(10);
            this.pad = new Uint16Array(8);
            this.finished = 0;

            var t = new Uint16Array(8), i;

            for (i = 8; i--;) t[i] = key.readUInt16LE(i*2);

            this.r[0] =   t[0]                         & 0x1fff;
            this.r[1] = ((t[0] >>> 13) | (t[1] <<  3)) & 0x1fff;
            this.r[2] = ((t[1] >>> 10) | (t[2] <<  6)) & 0x1f03;
            this.r[3] = ((t[2] >>>  7) | (t[3] <<  9)) & 0x1fff;
            this.r[4] = ((t[3] >>>  4) | (t[4] << 12)) & 0x00ff;
            this.r[5] =  (t[4] >>>  1)                 & 0x1ffe;
            this.r[6] = ((t[4] >>> 14) | (t[5] <<  2)) & 0x1fff;
            this.r[7] = ((t[5] >>> 11) | (t[6] <<  5)) & 0x1f81;
            this.r[8] = ((t[6] >>>  8) | (t[7] <<  8)) & 0x1fff;
            this.r[9] =  (t[7] >>>  5)                 & 0x007f;

            for (i = 8; i--;) {
                this.h[i]   = 0;
                this.pad[i] = key.readUInt16LE( 16+(2*i));
            }
            this.h[8] = 0;
            this.h[9] = 0;
            this.leftover = 0;
            this.finished = 0;
        }


        function U16TO8_LE(p, pos, v) {
            p[pos]   = v;
            p[pos+1] = v >>> 8;
        }

        Poly1305.prototype.blocks = function(m, mpos, bytes) {
            var hibit = this.finished ? 0 : (1 << 11);
            var t = new Uint16Array(8),
                d = new Uint32Array(10),
                c = 0, i = 0, j = 0;

            while (bytes >= 16) {
                for (i = 8; i--;) t[i] = m.readUInt16LE(i*2+mpos);

                this.h[0] +=   t[0]                         & 0x1fff;
                this.h[1] += ((t[0] >>> 13) | (t[1] <<  3)) & 0x1fff;
                this.h[2] += ((t[1] >>> 10) | (t[2] <<  6)) & 0x1fff;
                this.h[3] += ((t[2] >>>  7) | (t[3] <<  9)) & 0x1fff;
                this.h[4] += ((t[3] >>>  4) | (t[4] << 12)) & 0x1fff;
                this.h[5] +=  (t[4] >>>  1)                 & 0x1fff;
                this.h[6] += ((t[4] >>> 14) | (t[5] <<  2)) & 0x1fff;
                this.h[7] += ((t[5] >>> 11) | (t[6] <<  5)) & 0x1fff;
                this.h[8] += ((t[6] >>>  8) | (t[7] <<  8)) & 0x1fff;
                this.h[9] +=  (t[7] >>>  5)                 | hibit;

                for (i = 0, c = 0; i < 10; i++) {
                    d[i] = c;
                    for (j = 0; j < 10; j++) {
                        d[i] += (this.h[j] & 0xffffffff) * ((j <= i) ? this.r[i-j] : (5 * this.r[i+10-j]));
                        if (j === 4) {
                            c = (d[i] >>> 13);
                            d[i] &= 0x1fff;
                        }
                    }
                    c += (d[i] >>> 13);
                    d[i] &= 0x1fff;
                }
                c = ((c << 2) + c);
                c += d[0];
                d[0] = ((c & 0xffff) & 0x1fff);
                c = (c >>> 13);
                d[1] += c;

                for (i = 10; i--;) this.h[i] = d[i];

                mpos += 16;
                bytes -= 16;
            }
        };

        Poly1305.prototype.update = function(m) {
            var bytes = m.length;
            var want = 0, i = 0, mpos = 0;
            // var chunk;
            // this.buffer = Buffer.concat([this.buffer, m]);
            // while (this.buffer.length >= 16) {
            //   chunk = this.buffer.slice(0, 16);
            //   this.buffer = this.buffer.slice(16)
            //   this.blocks(chunk, 0, 16);
            // }
            if (this.leftover) {
                want = 16 - this.leftover;
                if (want > bytes)
                    want = bytes;
                for (i = want; i--;) {
                    this.buffer[this.leftover+i] = m[i+mpos];
                }
                bytes -= want;
                mpos += want;
                this.leftover += want;
                if (this.leftover < 16)
                    return this;
                this.blocks(this.buffer, 0, 16);
                this.leftover = 0;
            }

            if (bytes >= 16) {
                want = (bytes & ~(16 - 1));
                this.blocks(m, mpos, want);
                mpos += want;
                bytes -= want;
            }

            if (bytes) {
                for (i = bytes; i--;) {
                    this.buffer[this.leftover+i] = m[i+mpos];
                }
                this.leftover += bytes;
            }
            return this;
        };

        Poly1305.prototype.finish = function() {
            var mac = new Buffer(16),
                g = new Uint16Array(10),
                c = 0, mask = 0, f = 0, i = 0;
            if (this.leftover) {
                i = this.leftover;
                this.buffer[i++] = 1;
                for (; i < 16; i++) {
                    this.buffer[i] = 0;
                }
                this.finished = 1;
                this.blocks(this.buffer, 0, 16);
            }

            c = this.h[1] >>> 13;
            this.h[1] &= 0x1fff;
            for (i = 2; i < 10; i++) {
                this.h[i] += c;
                c = this.h[i] >>> 13;
                this.h[i] &= 0x1fff;
            }
            this.h[0] += (c * 5);
            c = this.h[0] >>> 13;
            this.h[0] &= 0x1fff;
            this.h[1] += c;
            c = this.h[1] >>> 13;
            this.h[1] &= 0x1fff;
            this.h[2] += c;

            g[0] = this.h[0] + 5;
            c = g[0] >>> 13;
            g[0] &= 0x1fff;
            for (i = 1; i < 10; i++) {
                g[i] = this.h[i] + c;
                c = g[i] >>> 13;
                g[i] &= 0x1fff;
            }
            g[9] -= (1 << 13);

            mask = (g[9] >>> 15) - 1;
            for (i = 10; i--;) g[i] &= mask;
            mask = ~mask;
            for (i = 10; i--;) {
                this.h[i] = (this.h[i] & mask) | g[i];
            }

            this.h[0] = (this.h[0]      ) | (this.h[1] << 13);
            this.h[1] = (this.h[1] >>  3) | (this.h[2] << 10);
            this.h[2] = (this.h[2] >>  6) | (this.h[3] <<  7);
            this.h[3] = (this.h[3] >>  9) | (this.h[4] <<  4);
            this.h[4] = (this.h[4] >> 12) | (this.h[5] <<  1) | (this.h[6] << 14);
            this.h[5] = (this.h[6] >>  2) | (this.h[7] << 11);
            this.h[6] = (this.h[7] >>  5) | (this.h[8] <<  8);
            this.h[7] = (this.h[8] >>  8) | (this.h[9] <<  5);

            f = (this.h[0] & 0xffffffff) + this.pad[0];
            this.h[0] = f;
            for (i = 1; i < 8; i++) {
                f = (this.h[i] & 0xffffffff) + this.pad[i] + (f >>> 16);
                this.h[i] = f;
            }

            for (i = 8; i--;) {
                mac.writeUInt16LE(this.h[i], i*2);
                this.pad[i] = 0;
            }
            for (i = 10; i--;) {
                this.h[i] = 0;
                this.r[i] = 0;
            }

            return mac;
        };
    }).call(this,require("buffer").Buffer)
},{"buffer":3}],187:[function(require,module,exports){
    var inherits = require('inherits');

    var CipherBase = require('./cipherbase');
    var Poly1305 = require('./poly1305');
    module.exports = PolyStream;
    inherits(PolyStream, CipherBase);
    function PolyStream (key) {
        if (!(this instanceof PolyStream)) {
            return new PolyStream(key);
        }
        CipherBase.call(this, true);
        this.poly = new Poly1305(key);
    }
    PolyStream.prototype._update = function (data) {
        this.poly.update(data);
    };

    PolyStream.prototype._final = function () {
        return this.poly.finish();
    };

},{"./cipherbase":173,"./poly1305":186,"inherits":176}],188:[function(require,module,exports){
    

    var utils = require('./pouch-utils');
    var wrappers = require('pouchdb-wrappers');

    function isUntransformable(doc) {
        var isLocal = typeof doc._id === 'string' && utils.isLocalId(doc._id);
        return isLocal || doc._deleted;
    }

// api.filter provided for backwards compat with the old "filter-pouch"
    exports.transform = exports.filter = function transform(config) {
        var db = this;

        var incoming = function (doc) {
            if (!isUntransformable(doc) && config.incoming) {
                return config.incoming(utils.clone(doc));
            }
            return doc;
        };
        var outgoing = function (doc) {
            if (!isUntransformable(doc) && config.outgoing) {
                return config.outgoing(utils.clone(doc));
            }
            return doc;
        };

        var handlers = {};

        if (db.type() === 'http') {
            handlers.put = function (orig, args) {
                args.doc = incoming(args.doc);
                return orig();
            };
            handlers.query = function (orig) {
                return orig().then(function (res) {
                    res.rows.forEach(function (row) {
                        if (row.doc) {
                            row.doc = outgoing(row.doc);
                        }
                    });

                    return res;
                });
            };
        }

        handlers.get = function (orig) {
            return orig().then(function (res) {
                if (Array.isArray(res)) {
                    // open_revs style, it's a list of docs
                    res.forEach(function (doc) {
                        if (doc.ok) {
                            doc.ok = outgoing(doc.ok);
                        }
                    });
                } else {
                    res = outgoing(res);
                }
                return res;
            });
        };

        handlers.bulkDocs = function (orig, args) {
            for (var i = 0; i < args.docs.length; i++) {
                args.docs[i] = incoming(args.docs[i]);
            }
            return orig();
        };

        handlers.allDocs = function (orig) {
            return orig().then(function (res) {
                res.rows.forEach(function (row) {
                    if (row.doc) {
                        row.doc = outgoing(row.doc);
                    }
                });
                return res;
            });
        };

        handlers.changes = function (orig, args) {
            function modifyChange(change) {
                if (change.doc) {
                    change.doc = outgoing(change.doc);
                }
                return change;
            }

            function modifyChanges(res) {
                res.results = res.results.map(modifyChange);
                return res;
            }

            if (args.options.complete) {
                var origComplete = args.options.complete;
                args.options.complete = function (err, res) {
                    /* istanbul ignore next */
                    if (err) {
                        return origComplete(err);
                    }
                    origComplete(null, modifyChanges(res));
                };
            }

            var changes = orig();
            // override some events
            var origOn = changes.on;
            changes.on = function (event, listener) {
                if (event === 'change') {
                    return origOn.apply(changes, [event, function (change) {
                        listener(modifyChange(change));
                    }]);
                } else if (event === 'complete') {
                    return origOn.apply(changes, [event, function (res) {
                        listener(modifyChanges(res));
                    }]);
                }
                return origOn.apply(changes, [event, listener]);
            };

            var origThen = changes.then;
            changes.then = function (resolve, reject) {
                return origThen.apply(changes, [function (res) {
                    resolve(modifyChanges(res));
                }, reject]);
            };
            return changes;
        };
        wrappers.installWrapperMethods(db, handlers);
    };

    /* istanbul ignore next */
    if (typeof window !== 'undefined' && window.PouchDB) {
        window.PouchDB.plugin(exports);
    }

},{"./pouch-utils":207,"pouchdb-wrappers":205}],189:[function(require,module,exports){
    arguments[4][149][0].apply(exports,arguments)
},{"dup":149}],190:[function(require,module,exports){
    

    module.exports = INTERNAL;

    function INTERNAL() {}
},{}],191:[function(require,module,exports){
    
    var Promise = require('./promise');
    var reject = require('./reject');
    var resolve = require('./resolve');
    var INTERNAL = require('./INTERNAL');
    var handlers = require('./handlers');
    module.exports = all;
    function all(iterable) {
        if (Object.prototype.toString.call(iterable) !== '[object Array]') {
            return reject(new TypeError('must be an array'));
        }

        var len = iterable.length;
        var called = false;
        if (!len) {
            return resolve([]);
        }

        var values = new Array(len);
        var resolved = 0;
        var i = -1;
        var promise = new Promise(INTERNAL);

        while (++i < len) {
            allResolver(iterable[i], i);
        }
        return promise;
        function allResolver(value, i) {
            resolve(value).then(resolveFromAll, function (error) {
                if (!called) {
                    called = true;
                    handlers.reject(promise, error);
                }
            });
            function resolveFromAll(outValue) {
                values[i] = outValue;
                if (++resolved === len & !called) {
                    called = true;
                    handlers.resolve(promise, values);
                }
            }
        }
    }
},{"./INTERNAL":190,"./handlers":192,"./promise":194,"./reject":197,"./resolve":198}],192:[function(require,module,exports){
    
    var tryCatch = require('./tryCatch');
    var resolveThenable = require('./resolveThenable');
    var states = require('./states');

    exports.resolve = function (self, value) {
        var result = tryCatch(getThen, value);
        if (result.status === 'error') {
            return exports.reject(self, result.value);
        }
        var thenable = result.value;

        if (thenable) {
            resolveThenable.safely(self, thenable);
        } else {
            self.state = states.FULFILLED;
            self.outcome = value;
            var i = -1;
            var len = self.queue.length;
            while (++i < len) {
                self.queue[i].callFulfilled(value);
            }
        }
        return self;
    };
    exports.reject = function (self, error) {
        self.state = states.REJECTED;
        self.outcome = error;
        var i = -1;
        var len = self.queue.length;
        while (++i < len) {
            self.queue[i].callRejected(error);
        }
        return self;
    };

    function getThen(obj) {
        // Make sure we only access the accessor once as required by the spec
        var then = obj && obj.then;
        if (obj && typeof obj === 'object' && typeof then === 'function') {
            return function appyThen() {
                then.apply(obj, arguments);
            };
        }
    }

},{"./resolveThenable":199,"./states":200,"./tryCatch":201}],193:[function(require,module,exports){
    module.exports = exports = require('./promise');

    exports.resolve = require('./resolve');
    exports.reject = require('./reject');
    exports.all = require('./all');
    exports.race = require('./race');

},{"./all":191,"./promise":194,"./race":196,"./reject":197,"./resolve":198}],194:[function(require,module,exports){
    

    var unwrap = require('./unwrap');
    var INTERNAL = require('./INTERNAL');
    var resolveThenable = require('./resolveThenable');
    var states = require('./states');
    var QueueItem = require('./queueItem');

    module.exports = Promise;
    function Promise(resolver) {
        if (!(this instanceof Promise)) {
            return new Promise(resolver);
        }
        if (typeof resolver !== 'function') {
            throw new TypeError('resolver must be a function');
        }
        this.state = states.PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (resolver !== INTERNAL) {
            resolveThenable.safely(this, resolver);
        }
    }

    Promise.prototype['catch'] = function (onRejected) {
        return this.then(null, onRejected);
    };
    Promise.prototype.then = function (onFulfilled, onRejected) {
        if (typeof onFulfilled !== 'function' && this.state === states.FULFILLED ||
            typeof onRejected !== 'function' && this.state === states.REJECTED) {
            return this;
        }
        var promise = new Promise(INTERNAL);
        if (this.state !== states.PENDING) {
            var resolver = this.state === states.FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
        } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }

        return promise;
    };

},{"./INTERNAL":190,"./queueItem":195,"./resolveThenable":199,"./states":200,"./unwrap":202}],195:[function(require,module,exports){
    
    var handlers = require('./handlers');
    var unwrap = require('./unwrap');

    module.exports = QueueItem;
    function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;
        if (typeof onFulfilled === 'function') {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === 'function') {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
        }
    }
    QueueItem.prototype.callFulfilled = function (value) {
        handlers.resolve(this.promise, value);
    };
    QueueItem.prototype.otherCallFulfilled = function (value) {
        unwrap(this.promise, this.onFulfilled, value);
    };
    QueueItem.prototype.callRejected = function (value) {
        handlers.reject(this.promise, value);
    };
    QueueItem.prototype.otherCallRejected = function (value) {
        unwrap(this.promise, this.onRejected, value);
    };

},{"./handlers":192,"./unwrap":202}],196:[function(require,module,exports){
    
    var Promise = require('./promise');
    var reject = require('./reject');
    var resolve = require('./resolve');
    var INTERNAL = require('./INTERNAL');
    var handlers = require('./handlers');
    module.exports = race;
    function race(iterable) {
        if (Object.prototype.toString.call(iterable) !== '[object Array]') {
            return reject(new TypeError('must be an array'));
        }

        var len = iterable.length;
        var called = false;
        if (!len) {
            return resolve([]);
        }

        var i = -1;
        var promise = new Promise(INTERNAL);

        while (++i < len) {
            resolver(iterable[i]);
        }
        return promise;
        function resolver(value) {
            resolve(value).then(function (response) {
                if (!called) {
                    called = true;
                    handlers.resolve(promise, response);
                }
            }, function (error) {
                if (!called) {
                    called = true;
                    handlers.reject(promise, error);
                }
            });
        }
    }

},{"./INTERNAL":190,"./handlers":192,"./promise":194,"./reject":197,"./resolve":198}],197:[function(require,module,exports){
    

    var Promise = require('./promise');
    var INTERNAL = require('./INTERNAL');
    var handlers = require('./handlers');
    module.exports = reject;

    function reject(reason) {
        var promise = new Promise(INTERNAL);
        return handlers.reject(promise, reason);
    }
},{"./INTERNAL":190,"./handlers":192,"./promise":194}],198:[function(require,module,exports){
    

    var Promise = require('./promise');
    var INTERNAL = require('./INTERNAL');
    var handlers = require('./handlers');
    module.exports = resolve;

    var FALSE = handlers.resolve(new Promise(INTERNAL), false);
    var NULL = handlers.resolve(new Promise(INTERNAL), null);
    var UNDEFINED = handlers.resolve(new Promise(INTERNAL), void 0);
    var ZERO = handlers.resolve(new Promise(INTERNAL), 0);
    var EMPTYSTRING = handlers.resolve(new Promise(INTERNAL), '');

    function resolve(value) {
        if (value) {
            if (value instanceof Promise) {
                return value;
            }
            return handlers.resolve(new Promise(INTERNAL), value);
        }
        var valueType = typeof value;
        switch (valueType) {
            case 'boolean':
                return FALSE;
            case 'undefined':
                return UNDEFINED;
            case 'object':
                return NULL;
            case 'number':
                return ZERO;
            case 'string':
                return EMPTYSTRING;
        }
    }
},{"./INTERNAL":190,"./handlers":192,"./promise":194}],199:[function(require,module,exports){
    
    var handlers = require('./handlers');
    var tryCatch = require('./tryCatch');
    function safelyResolveThenable(self, thenable) {
        // Either fulfill, reject or reject with error
        var called = false;
        function onError(value) {
            if (called) {
                return;
            }
            called = true;
            handlers.reject(self, value);
        }

        function onSuccess(value) {
            if (called) {
                return;
            }
            called = true;
            handlers.resolve(self, value);
        }

        function tryToUnwrap() {
            thenable(onSuccess, onError);
        }

        var result = tryCatch(tryToUnwrap);
        if (result.status === 'error') {
            onError(result.value);
        }
    }
    exports.safely = safelyResolveThenable;
},{"./handlers":192,"./tryCatch":201}],200:[function(require,module,exports){
// Lazy man's symbols for states

    exports.REJECTED = ['REJECTED'];
    exports.FULFILLED = ['FULFILLED'];
    exports.PENDING = ['PENDING'];

},{}],201:[function(require,module,exports){
    

    module.exports = tryCatch;

    function tryCatch(func, value) {
        var out = {};
        try {
            out.value = func(value);
            out.status = 'success';
        } catch (e) {
            out.status = 'error';
            out.value = e;
        }
        return out;
    }
},{}],202:[function(require,module,exports){
    

    var immediate = require('immediate');
    var handlers = require('./handlers');
    module.exports = unwrap;

    function unwrap(promise, func, value) {
        immediate(function () {
            var returnValue;
            try {
                returnValue = func(value);
            } catch (e) {
                return handlers.reject(promise, e);
            }
            if (returnValue === promise) {
                handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
            } else {
                handlers.resolve(promise, returnValue);
            }
        });
    }
},{"./handlers":192,"immediate":203}],203:[function(require,module,exports){
    (function (global){
        
        var Mutation = global.MutationObserver || global.WebKitMutationObserver;

        var scheduleDrain;

        {
            if (Mutation) {
                var called = 0;
                var observer = new Mutation(nextTick);
                var element = global.document.createTextNode('');
                observer.observe(element, {
                    characterData: true
                });
                scheduleDrain = function () {
                    element.data = (called = ++called % 2);
                };
            } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
                var channel = new global.MessageChannel();
                channel.port1.onmessage = nextTick;
                scheduleDrain = function () {
                    channel.port2.postMessage(0);
                };
            } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
                scheduleDrain = function () {

                    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                    var scriptEl = global.document.createElement('script');
                    scriptEl.onreadystatechange = function () {
                        nextTick();

                        scriptEl.onreadystatechange = null;
                        scriptEl.parentNode.removeChild(scriptEl);
                        scriptEl = null;
                    };
                    global.document.documentElement.appendChild(scriptEl);
                };
            } else {
                scheduleDrain = function () {
                    setTimeout(nextTick, 0);
                };
            }
        }

        var draining;
        var queue = [];
//named nextTick for less confusing stack traces
        function nextTick() {
            draining = true;
            var i, oldQueue;
            var len = queue.length;
            while (len) {
                oldQueue = queue;
                queue = [];
                i = -1;
                while (++i < len) {
                    oldQueue[i]();
                }
                len = queue.length;
            }
            draining = false;
        }

        module.exports = immediate;
        function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
                scheduleDrain();
            }
        }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],204:[function(require,module,exports){
    

// Extends method
// (taken from http://code.jquery.com/jquery-1.9.0.js)
// Populate the class2type map
    var class2type = {};

    var types = [
        "Boolean", "Number", "String", "Function", "Array",
        "Date", "RegExp", "Object", "Error"
    ];
    for (var i = 0; i < types.length; i++) {
        var typename = types[i];
        class2type["[object " + typename + "]"] = typename.toLowerCase();
    }

    var core_toString = class2type.toString;
    var core_hasOwn = class2type.hasOwnProperty;

    function type(obj) {
        if (obj === null) {
            return String(obj);
        }
        return typeof obj === "object" || typeof obj === "function" ?
        class2type[core_toString.call(obj)] || "object" :
            typeof obj;
    }

    function isWindow(obj) {
        return obj !== null && obj === obj.window;
    }

    function isPlainObject(obj) {
        // Must be an Object.
        // Because of IE, we also have to check the presence of
        // the constructor property.
        // Make sure that DOM nodes and window objects don't pass through, as well
        if (!obj || type(obj) !== "object" || obj.nodeType || isWindow(obj)) {
            return false;
        }

        try {
            // Not own constructor property must be Object
            if (obj.constructor &&
                !core_hasOwn.call(obj, "constructor") &&
                !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
            }
        } catch ( e ) {
            // IE8,9 Will throw exceptions on certain host objects #9897
            return false;
        }

        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.
        var key;
        for (key in obj) {}

        return key === undefined || core_hasOwn.call(obj, key);
    }


    function isFunction(obj) {
        return type(obj) === "function";
    }

    var isArray = Array.isArray || function (obj) {
            return type(obj) === "array";
        };

    function extend() {
        // originally extend() was recursive, but this ended up giving us
        // "call stack exceeded", so it's been unrolled to use a literal stack
        // (see https://github.com/pouchdb/pouchdb/issues/2543)
        var stack = [];
        var i = -1;
        var len = arguments.length;
        var args = new Array(len);
        while (++i < len) {
            args[i] = arguments[i];
        }
        var container = {};
        stack.push({args: args, result: {container: container, key: 'key'}});
        var next;
        while ((next = stack.pop())) {
            extendInner(stack, next.args, next.result);
        }
        return container.key;
    }

    function extendInner(stack, args, result) {
        var options, name, src, copy, copyIsArray, clone,
            target = args[0] || {},
            i = 1,
            length = args.length,
            deep = false,
            numericStringRegex = /\d+/,
            optionsIsArray;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            target = args[1] || {};
            // skip the boolean and the target
            i = 2;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !isFunction(target)) {
            target = {};
        }

        // extend jQuery itself if only one argument is passed
        if (length === i) {
            /* jshint validthis: true */
            target = this;
            --i;
        }

        for (; i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = args[i]) != null) {
                optionsIsArray = isArray(options);
                // Extend the base object
                for (name in options) {
                    //if (options.hasOwnProperty(name)) {
                    if (!(name in Object.prototype)) {
                        if (optionsIsArray && !numericStringRegex.test(name)) {
                            continue;
                        }

                        src = target[name];
                        copy = options[name];

                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && (isPlainObject(copy) ||
                            (copyIsArray = isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && isArray(src) ? src : [];

                            } else {
                                clone = src && isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            stack.push({
                                args: [deep, clone, copy],
                                result: {
                                    container: target,
                                    key: name
                                }
                            });

                            // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            if (!(isArray(options) && isFunction(copy))) {
                                target[name] = copy;
                            }
                        }
                    }
                }
            }
        }

        // "Return" the modified object by setting the key
        // on the given container
        result.container[result.key] = target;
    }


    module.exports = extend;



},{}],205:[function(require,module,exports){
    /*
     Copyright 2014-2015, Marten de Vries

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
     */

    

    var nodify = require("promise-nodify");

    exports.installStaticWrapperMethods = function (PouchDB, handlers) {
        //set an 'alternative constructor' so the constructor can be easily
        //wrapped, since wrapping 'real' constructors is hard.
        PouchDB.new = PouchDB.new || function (name, options, callback) {
                return new PouchDB(name, options, callback);
            };
        PouchDB.destroy = PouchDB.destroy || function (name, options, callback) {
                var args = parseBaseArgs(PouchDB, this, options, callback);
                var db = new PouchDB(name, args.options);
                var promise = db.destroy();
                nodify(promise, args.callback);
                return promise;
            };

        installWrappers(PouchDB, handlers, exports.createStaticWrapperMethod);
    };

    exports.installWrapperMethods = function (db, handlers) {
        installWrappers(db, handlers, exports.createWrapperMethod);
    };

    function installWrappers(base, handlers, createWrapperMethod) {
        for (var name in handlers) {
            if (!handlers.hasOwnProperty(name)) {
                continue;
            }
            var info = getBaseAndName(base, name);
            var original = info.base[info.name];
            if (!original) {
                //no method to wrap
                continue;
            }
            if (original.hasOwnProperty("_handlers")) {
                if (original._handlers.indexOf(handlers[name]) !== -1) {
                    throw new Error("Wrapper method for '" + name + "' already installed: " + handlers[name]);
                }
                original._handlers.push(handlers[name]);
            } else {
                info.base[info.name] = createWrapperMethod(name, original, handlers[name], base);
            }
        }
    }

    function getBaseAndName(base, name) {
        name = name.split(".");
        while (name.length > 1) {
            base = base[name.shift(0)];
        }
        return {
            base: base,
            name: name[0]
        };
    }

    exports.createStaticWrapperMethod = function (name, original, handler, PouchDB) {
        //PouchDB is optional
        return createWrapper(name, original, handler, staticWrapperBuilders, PouchDB);
    };

    exports.createWrapperMethod = function (name, original, handler, db) {
        //db is optional
        return createWrapper(name, original, handler, wrapperBuilders, db);
    };

    function createWrapper(name, original, handler, theWrapperBuilders, thisVal) {
        //thisVal is optional
        var buildWrapper = theWrapperBuilders[name];
        if (typeof createWrapper === "undefined") {
            throw new Error("No known wrapper for method name: " + name); //coverage: ignore
        }
        var handlers = [handler];
        var wrapper = buildWrapper(thisVal, original, handlers);
        wrapper._original = original;
        wrapper._handlers = handlers;
        return wrapper;
    }

    var wrapperBuilders = {};

    wrapperBuilders.destroy = function (db, destroy, handlers) {
        return function (options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            return callHandlers(handlers, args, makeCall(destroy));
        };
    };

    wrapperBuilders.put = function (db, put, handlers) {
        return function (doc, docId, docRev, options, callback) {
            var args = {};
            args.base = db || this;
            args.db = db || this; //backwards compatibility
            var argsList = Array.prototype.slice.call(arguments);
            //parsing code borrowed from PouchDB (adapted).
            args.doc = argsList.shift();
            var id = '_id' in args.doc;
            while (true) {
                var temp = argsList.shift();
                var temptype = typeof temp;
                if (temptype === "string" && !id) {
                    args.doc._id = temp;
                    id = true;
                } else if (temptype === "string" && id && !('_rev' in args.doc)) {
                    args.doc._rev = temp;
                } else if (temptype === "object") {
                    args.options = temp;
                } else if (temptype === "function") {
                    args.callback = temp;
                }
                if (!argsList.length) {
                    break;
                }
            }
            args.options = args.options || {};
            return callHandlers(handlers, args, function () {
                return put.call(this, args.doc, args.options);
            });
        };
    };

    wrapperBuilders.post = function (db, post, handlers) {
        return function (doc, options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            args.doc = doc;
            return callHandlers(handlers, args, function () {
                return post.call(this, args.doc, args.options);
            });
        };
    };

    wrapperBuilders.get = function (db, get, handlers) {
        return function(docId, options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            args.docId = docId;
            return callHandlers(handlers, args, function () {
                return get.call(this, args.docId, args.options);
            });
        };
    };

    wrapperBuilders.remove = function (db, remove, handlers) {
        return function (docOrId, optsOrRev, opts, callback) {
            var args;

            //originally borrowed from PouchDB
            if (typeof optsOrRev === 'string') {
                // id, rev, opts, callback style
                args = parseBaseArgs(db, this, opts, callback);
                args.doc = {
                    _id: docOrId,
                    _rev: optsOrRev
                };
            } else {
                // doc, opts, callback style
                args = parseBaseArgs(db, this, optsOrRev, opts);
                args.doc = docOrId;
            }

            return callHandlers(handlers, args, function () {
                return remove.call(this, args.doc, args.options);
            });
        };
    };

    wrapperBuilders.bulkDocs = function (db, bulkDocs, handlers) {
        return function (docs, options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            //support the deprecated signature.
            if ('new_edits' in docs) {
                args.options.new_edits = docs.new_edits;
            }
            args.docs = docs.docs || docs;
            return callHandlers(handlers, args, function () {
                return bulkDocs.call(this, args.docs, args.options);
            });
        };
    };

    wrapperBuilders.allDocs = function (db, allDocs, handlers) {
        return function (options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            return callHandlers(handlers, args, makeCallWithOptions(allDocs, args));
        };
    };

    wrapperBuilders.changes = function (db, changes, handlers) {
        return function (options, callback) {
            //the callback argument is no longer documented. (And deprecated?)
            var args = parseBaseArgs(db, this, options, callback);
            return callHandlers(handlers, args, makeCallWithOptions(changes, args));
        };
    };

    wrapperBuilders.sync = function (db, replicate, handlers) {
        return function (url, options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            args.url = url;
            return callHandlers(handlers, args, function () {
                return replicate.call(this, args.url, args.options);
            });
        };
    };

    wrapperBuilders["replicate.from"] = wrapperBuilders.sync;
    wrapperBuilders["replicate.to"] = wrapperBuilders.sync;

    wrapperBuilders.putAttachment = function (db, putAttachment, handlers) {
        return function (docId, attachmentId, rev, doc, type, options, callback) {
            //options is not an 'official' argument. But some plug-ins need it
            //and maybe (?) also the http adapter.

            //valid calls:
            //- "id", "aid", "rev", new Blob(), "text/plain", {}, function () {}
            //- "id", "aid", new Blob(), "text/plain", {}, function () {}
            //- "id", "aid", new Blob(), "text/plain"
            var args;
            if (typeof type === "string") {
                //rev is specified
                args = parseBaseArgs(db, this, options, callback);
                args.rev = rev;
                args.doc = doc;
                args.type = type;
            } else {
                //rev is unspecified
                args = parseBaseArgs(db, this, type, options);
                args.rev = null;
                args.doc = rev;
                args.type = doc;
            }
            //fixed arguments
            args.docId = docId;
            args.attachmentId = attachmentId;

            return callHandlers(handlers, args, function () {
                return putAttachment.call(this, args.docId, args.attachmentId, args.rev, args.doc, args.type);
            });
        };
    };

    wrapperBuilders.getAttachment = function (db, getAttachment, handlers) {
        return function (docId, attachmentId, options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            args.docId = docId;
            args.attachmentId = attachmentId;
            return callHandlers(handlers, args, function () {
                return getAttachment.call(this, args.docId, args.attachmentId, args.options);
            });
        };
    };

    wrapperBuilders.removeAttachment = function (db, removeAttachment, handlers) {
        return function (docId, attachmentId, rev, options, callback) {
            //see note on the options argument at putAttachment.
            var args = parseBaseArgs(db, this, options, callback);
            args.docId = docId;
            args.attachmentId = attachmentId;
            args.rev = rev;
            return callHandlers(handlers, args, function () {
                return removeAttachment.call(this, args.docId, args.attachmentId, args.rev);
            });
        };
    };

    wrapperBuilders.query = function (db, query, handlers) {
        return function (fun, options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            args.fun = fun;
            return callHandlers(handlers, args, function () {
                return query.call(this, args.fun, args.options);
            });
        };
    };

    wrapperBuilders.viewCleanup = function (db, viewCleanup, handlers) {
        return function (options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            return callHandlers(handlers, args, makeCallWithOptions(viewCleanup, args));
        };
    };

    wrapperBuilders.info = function (db, info, handlers) {
        return function (options, callback) {
            //see note on the options argument at putAttachment.
            var args = parseBaseArgs(db, this, options, callback);
            return callHandlers(handlers, args, makeCall(info));
        };
    };

    wrapperBuilders.compact = function (db, compact, handlers) {
        return function (options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            return callHandlers(handlers, args, makeCallWithOptions(compact, args));
        };
    };

    wrapperBuilders.revsDiff = function (db, revsDiff, handlers) {
        return function (diff, options, callback) {
            //see note on the options argument at putAttachment.
            var args = parseBaseArgs(db, this, options, callback);
            args.diff = diff;
            return callHandlers(handlers, args, function () {
                return revsDiff.call(this, args.diff);
            });
        };
    };

//Plug-in wrapperBuilders; only of the plug-ins for which a wrapper
//has been necessary.

    wrapperBuilders.list = function (db, orig, handlers) {
        return function (path, options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            args.path = path;

            return callHandlers(handlers, args, function () {
                return orig.call(this, args.path, args.options);
            });
        };
    };

    wrapperBuilders.rewriteResultRequestObject = wrapperBuilders.list;
    wrapperBuilders.show = wrapperBuilders.list;
    wrapperBuilders.update = wrapperBuilders.list;

    wrapperBuilders.getSecurity = function (db, getSecurity, handlers) {
        return function (options, callback) {
            var args = parseBaseArgs(db, this, options, callback);
            return callHandlers(handlers, args, makeCallWithOptions(getSecurity, args));
        };
    };

    wrapperBuilders.putSecurity = function (db, putSecurity, handlers) {
        return function (secObj, options, callback) {
            //see note on the options argument at putAttachment.
            var args = parseBaseArgs(db, this, options, callback);
            args.secObj = secObj;
            return callHandlers(handlers, args, function () {
                return putSecurity.call(this, args.secObj);
            });
        };
    };

//static
    var staticWrapperBuilders = {};

    staticWrapperBuilders.new = function (PouchDB, construct, handlers) {
        return function (name, options, callback) {
            var args;
            if (typeof name === "object") {
                args = parseBaseArgs(PouchDB, this, name, options);
            } else {
                args = parseBaseArgs(PouchDB, this, options, callback);
                args.options.name = name;
            }
            return callHandlers(handlers, args, function () {
                return construct.call(this, args.options);
            });
        };
    };

    staticWrapperBuilders.destroy = function (PouchDB, destroy, handlers) {
        return function (name, options, callback) {
            var args;
            if (typeof name === "object") {
                args = parseBaseArgs(PouchDB, this, name, options);
            } else {
                args = parseBaseArgs(PouchDB, this, options, callback);
                args.options.name = name;
            }
            if (args.options.internal) {
                return destroy.apply(PouchDB, arguments);
            }
            return callHandlers(handlers, args, function () {
                var name = args.options.name;
                delete args.options.name;

                return destroy.call(this, name, args.options);
            });
        };
    };

    staticWrapperBuilders.replicate = function (PouchDB, replicate, handlers) {
        return function (source, target, options, callback) {
            //no callback
            var args = parseBaseArgs(PouchDB, this, options, callback);
            args.source = source;
            args.target = target;
            return callHandlers(handlers, args, function () {
                return replicate.call(this, args.source, args.target, args.options);
            });
        };
    };

    staticWrapperBuilders.allDbs = function (PouchDB, allDbs, handlers) {
        return function (options, callback) {
            var args = parseBaseArgs(PouchDB, this, options, callback);
            return callHandlers(handlers, args, makeCall(allDbs));
        };
    };

//Wrap .plugin()? .on()? .defaults()? No use case yet, but it's
//possible...

    function parseBaseArgs(thisVal1, thisVal2, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = {};
        }
        return {
            base: thisVal1 || thisVal2,
            db: thisVal1 || thisVal2, //backwards compatibility
            options: options || {},
            callback: callback
        };
    }

    function callHandlers(handlers, args, method) {
        var callback = args.callback;
        delete args.callback;

        //build a chain of handlers: the bottom handler calls the 'real'
        //method, the other handlers call other handlers.
        method = method.bind(args.base);
        for (var i = handlers.length - 1; i >= 0; i -= 1) {
            method = handlers[i].bind(null, method, args);
        }
        //start running the chain.
        var promise = method();
        nodify(promise, callback);
        return promise;
    }

    function makeCall(func) {
        return function () {
            return func.call(this);
        };
    }

    function makeCallWithOptions(func, args) {
        return function () {
            return func.call(this, args.options);
        };
    }

    exports.uninstallWrapperMethods = function (db, handlers) {
        uninstallWrappers(db, handlers);
    };

    exports.uninstallStaticWrapperMethods = function (PouchDB, handlers) {
        uninstallWrappers(PouchDB, handlers);
    };

    function uninstallWrappers(base, handlers) {
        for (var name in handlers) {
            if (!handlers.hasOwnProperty(name)) {
                continue;
            }
            var info = getBaseAndName(base, name);
            var wrapper = info.base[info.name];
            if (typeof wrapper === "undefined") {
                //method doesn't exist, so was never wrapped in the first place.
                continue;
            }

            var idx;
            try {
                idx = wrapper._handlers.indexOf(handlers[name]);
            } catch (err) {
                idx = -1;
            }
            if (idx === -1) {
                throw new Error("Wrapper method for '" + name + "' not installed: " + handlers[name]);
            }
            wrapper._handlers.splice(idx, 1);
            if (!wrapper._handlers.length) {
                //fall back to the original on the prototype.
                delete info.base[info.name];
                if (info.base[info.name] !== wrapper._original) {
                    //nothing or something unexpected was on the prototype. (E.g.
                    //replicate.to). Reset the original manually.
                    info.base[info.name] = wrapper._original;
                }
            }
        }
    }

},{"promise-nodify":206}],206:[function(require,module,exports){
    /*
     Copyright 2013-2014, Marten de Vries

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
     */

    

    module.exports = function nodify(promise, callback) {
        if (typeof callback === "function") {
            promise.then(function (resp) {
                callback(null, resp);
            }, function (err) {
                callback(err, null);
            });
        }
    };

},{}],207:[function(require,module,exports){
    (function (process,global){
        

        var Promise;
        /* istanbul ignore next */
        if (typeof window !== 'undefined' && window.PouchDB) {
            Promise = window.PouchDB.utils.Promise;
        } else {
            Promise = typeof global.Promise === 'function' ? global.Promise : require('lie');
        }
        /* istanbul ignore next */
        exports.once = function (fun) {
            var called = false;
            return exports.getArguments(function (args) {
                if (called) {
                    console.trace();
                    throw new Error('once called  more than once');
                } else {
                    called = true;
                    fun.apply(this, args);
                }
            });
        };
        /* istanbul ignore next */
        exports.getArguments = function (fun) {
            return function () {
                var len = arguments.length;
                var args = new Array(len);
                var i = -1;
                while (++i < len) {
                    args[i] = arguments[i];
                }
                return fun.call(this, args);
            };
        };
        /* istanbul ignore next */
        exports.toPromise = function (func) {
            //create the function we will be returning
            return exports.getArguments(function (args) {
                var self = this;
                var tempCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;
                // if the last argument is a function, assume its a callback
                var usedCB;
                if (tempCB) {
                    // if it was a callback, create a new callback which calls it,
                    // but do so async so we don't trap any errors
                    usedCB = function (err, resp) {
                        process.nextTick(function () {
                            tempCB(err, resp);
                        });
                    };
                }
                var promise = new Promise(function (fulfill, reject) {
                    try {
                        var callback = exports.once(function (err, mesg) {
                            if (err) {
                                reject(err);
                            } else {
                                fulfill(mesg);
                            }
                        });
                        // create a callback for this invocation
                        // apply the function in the orig context
                        args.push(callback);
                        func.apply(self, args);
                    } catch (e) {
                        reject(e);
                    }
                });
                // if there is a callback, call it back
                if (usedCB) {
                    promise.then(function (result) {
                        usedCB(null, result);
                    }, usedCB);
                }
                promise.cancel = function () {
                    return this;
                };
                return promise;
            });
        };

        exports.inherits = require('inherits');
        exports.Promise = Promise;
        exports.extend = require('pouchdb-extend');
        exports.clone = function (obj) {
            return exports.extend(true, {}, obj);
        };

        exports.isLocalId = function (id) {
            return (/^_local/).test(id);
        };
    }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":151,"inherits":189,"lie":193,"pouchdb-extend":204}],208:[function(require,module,exports){
    (function (Buffer){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

        /*global window, require, define */
        (function(_window) {
            

            // Unique ID creation requires a high quality random # generator.  We feature
            // detect to determine the best RNG source, normalizing to a function that
            // returns 128-bits of randomness, since that's what's usually required
            var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;

            function setupBrowser() {
                // Allow for MSIE11 msCrypto
                var _crypto = _window.crypto || _window.msCrypto;

                if (!_rng && _crypto && _crypto.getRandomValues) {
                    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
                    //
                    // Moderately fast, high quality
                    try {
                        var _rnds8 = new Uint8Array(16);
                        _whatwgRNG = _rng = function whatwgRNG() {
                            _crypto.getRandomValues(_rnds8);
                            return _rnds8;
                        };
                        _rng();
                    } catch(e) {}
                }

                if (!_rng) {
                    // Math.random()-based (RNG)
                    //
                    // If all else fails, use Math.random().  It's fast, but is of unspecified
                    // quality.
                    var  _rnds = new Array(16);
                    _mathRNG = _rng = function() {
                        for (var i = 0, r; i < 16; i++) {
                            if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
                            _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
                        }

                        return _rnds;
                    };
                    if ('undefined' !== typeof console && console.warn) {
                        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
                    }
                }
            }

            function setupNode() {
                // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
                //
                // Moderately fast, high quality
                if ('function' === typeof require) {
                    try {
                        var _rb = require('crypto').randomBytes;
                        _nodeRNG = _rng = _rb && function() {return _rb(16);};
                        _rng();
                    } catch(e) {}
                }
            }

            if (_window) {
                setupBrowser();
            } else {
                setupNode();
            }

            // Buffer class to use
            var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;

            // Maps for number <-> hex string conversion
            var _byteToHex = [];
            var _hexToByte = {};
            for (var i = 0; i < 256; i++) {
                _byteToHex[i] = (i + 0x100).toString(16).substr(1);
                _hexToByte[_byteToHex[i]] = i;
            }

            // **`parse()` - Parse a UUID into it's component bytes**
            function parse(s, buf, offset) {
                var i = (buf && offset) || 0, ii = 0;

                buf = buf || [];
                s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
                    if (ii < 16) { // Don't overflow!
                        buf[i + ii++] = _hexToByte[oct];
                    }
                });

                // Zero out remaining bytes if string was short
                while (ii < 16) {
                    buf[i + ii++] = 0;
                }

                return buf;
            }

            // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
            function unparse(buf, offset) {
                var i = offset || 0, bth = _byteToHex;
                return  bth[buf[i++]] + bth[buf[i++]] +
                    bth[buf[i++]] + bth[buf[i++]] + '-' +
                    bth[buf[i++]] + bth[buf[i++]] + '-' +
                    bth[buf[i++]] + bth[buf[i++]] + '-' +
                    bth[buf[i++]] + bth[buf[i++]] + '-' +
                    bth[buf[i++]] + bth[buf[i++]] +
                    bth[buf[i++]] + bth[buf[i++]] +
                    bth[buf[i++]] + bth[buf[i++]];
            }

            // **`v1()` - Generate time-based UUID**
            //
            // Inspired by https://github.com/LiosK/UUID.js
            // and http://docs.python.org/library/uuid.html

            // random #'s we need to init node and clockseq
            var _seedBytes = _rng();

            // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
            var _nodeId = [
                _seedBytes[0] | 0x01,
                _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
            ];

            // Per 4.2.2, randomize (14 bit) clockseq
            var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

            // Previous uuid creation time
            var _lastMSecs = 0, _lastNSecs = 0;

            // See https://github.com/broofa/node-uuid for API details
            function v1(options, buf, offset) {
                var i = buf && offset || 0;
                var b = buf || [];

                options = options || {};

                var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;

                // UUID timestamps are 100 nano-second units since the Gregorian epoch,
                // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
                // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
                // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
                var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();

                // Per 4.2.1.2, use count of uuid's generated during the current clock
                // cycle to simulate higher resolution clock
                var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;

                // Time since last uuid creation (in msecs)
                var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

                // Per 4.2.1.2, Bump clockseq on clock regression
                if (dt < 0 && options.clockseq == null) {
                    clockseq = clockseq + 1 & 0x3fff;
                }

                // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
                // time interval
                if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
                    nsecs = 0;
                }

                // Per 4.2.1.2 Throw error if too many uuids are requested
                if (nsecs >= 10000) {
                    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
                }

                _lastMSecs = msecs;
                _lastNSecs = nsecs;
                _clockseq = clockseq;

                // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
                msecs += 12219292800000;

                // `time_low`
                var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
                b[i++] = tl >>> 24 & 0xff;
                b[i++] = tl >>> 16 & 0xff;
                b[i++] = tl >>> 8 & 0xff;
                b[i++] = tl & 0xff;

                // `time_mid`
                var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
                b[i++] = tmh >>> 8 & 0xff;
                b[i++] = tmh & 0xff;

                // `time_high_and_version`
                b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
                b[i++] = tmh >>> 16 & 0xff;

                // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
                b[i++] = clockseq >>> 8 | 0x80;

                // `clock_seq_low`
                b[i++] = clockseq & 0xff;

                // `node`
                var node = options.node || _nodeId;
                for (var n = 0; n < 6; n++) {
                    b[i + n] = node[n];
                }

                return buf ? buf : unparse(b);
            }

            // **`v4()` - Generate random UUID**

            // See https://github.com/broofa/node-uuid for API details
            function v4(options, buf, offset) {
                // Deprecated - 'format' argument, as supported in v1.2
                var i = buf && offset || 0;

                if (typeof(options) === 'string') {
                    buf = (options === 'binary') ? new BufferClass(16) : null;
                    options = null;
                }
                options = options || {};

                var rnds = options.random || (options.rng || _rng)();

                // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
                rnds[6] = (rnds[6] & 0x0f) | 0x40;
                rnds[8] = (rnds[8] & 0x3f) | 0x80;

                // Copy bytes to buffer, if provided
                if (buf) {
                    for (var ii = 0; ii < 16; ii++) {
                        buf[i + ii] = rnds[ii];
                    }
                }

                return buf || unparse(rnds);
            }

            // Export public API
            var uuid = v4;
            uuid.v1 = v1;
            uuid.v4 = v4;
            uuid.parse = parse;
            uuid.unparse = unparse;
            uuid.BufferClass = BufferClass;
            uuid._rng = _rng;
            uuid._mathRNG = _mathRNG;
            uuid._nodeRNG = _nodeRNG;
            uuid._whatwgRNG = _whatwgRNG;

            if (('undefined' !== typeof module) && module.exports) {
                // Publish as node.js module
                module.exports = uuid;
            } else if (typeof define === 'function' && define.amd) {
                // Publish as AMD module
                define(function() {return uuid;});


            } else {
                // Publish as global (in browsers)
                _previousRoot = _window.uuid;

                // **`noConflict()` - (browser only) to reset global 'uuid' var**
                uuid.noConflict = function() {
                    _window.uuid = _previousRoot;
                    return uuid;
                };

                _window.uuid = uuid;
            }
        })('undefined' !== typeof window ? window : null);

    }).call(this,require("buffer").Buffer)
},{"buffer":3,"crypto":10}],209:[function(require,module,exports){
    (function (global){
        if (typeof global.Promise === 'function') {
            module.exports = global.Promise;
        } else {
            module.exports = require('bluebird');
        }
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bluebird":213}],210:[function(require,module,exports){
    arguments[4][190][0].apply(exports,arguments)
},{"dup":190}],211:[function(require,module,exports){
    
    var Promise = require('./promise');
    var reject = require('./reject');
    var resolve = require('./resolve');
    var INTERNAL = require('./INTERNAL');
    var handlers = require('./handlers');
    var noArray = reject(new TypeError('must be an array'));
    module.exports = function all(iterable) {
        if (Object.prototype.toString.call(iterable) !== '[object Array]') {
            return noArray;
        }

        var len = iterable.length;
        var called = false;
        if (!len) {
            return resolve([]);
        }

        var values = new Array(len);
        var resolved = 0;
        var i = -1;
        var promise = new Promise(INTERNAL);

        while (++i < len) {
            allResolver(iterable[i], i);
        }
        return promise;
        function allResolver(value, i) {
            resolve(value).then(resolveFromAll, function (error) {
                if (!called) {
                    called = true;
                    handlers.reject(promise, error);
                }
            });
            function resolveFromAll(outValue) {
                values[i] = outValue;
                if (++resolved === len & !called) {
                    called = true;
                    handlers.resolve(promise, values);
                }
            }
        }
    };
},{"./INTERNAL":210,"./handlers":212,"./promise":214,"./reject":216,"./resolve":217}],212:[function(require,module,exports){
    
    var tryCatch = require('./tryCatch');
    var resolveThenable = require('./resolveThenable');
    var states = require('./states');

    exports.resolve = function (self, value) {
        var result = tryCatch(getThen, value);
        if (result.status === 'error') {
            return exports.reject(self, result.value);
        }
        var thenable = result.value;

        if (thenable) {
            resolveThenable.safely(self, thenable);
        } else {
            self.state = states.FULFILLED;
            self.outcome = value;
            var i = -1;
            var len = self.queue.length;
            while (++i < len) {
                self.queue[i].callFulfilled(value);
            }
        }
        return self;
    };
    exports.reject = function (self, error) {
        self.state = states.REJECTED;
        self.outcome = error;
        var i = -1;
        var len = self.queue.length;
        while (++i < len) {
            self.queue[i].callRejected(error);
        }
        return self;
    };

    function getThen(obj) {
        // Make sure we only access the accessor once as required by the spec
        var then = obj && obj.then;
        if (obj && typeof obj === 'object' && typeof then === 'function') {
            return function appyThen() {
                then.apply(obj, arguments);
            };
        }
    }
},{"./resolveThenable":218,"./states":219,"./tryCatch":220}],213:[function(require,module,exports){
    module.exports = exports = require('./promise');

    exports.resolve = require('./resolve');
    exports.reject = require('./reject');
    exports.all = require('./all');
},{"./all":211,"./promise":214,"./reject":216,"./resolve":217}],214:[function(require,module,exports){
    

    var unwrap = require('./unwrap');
    var INTERNAL = require('./INTERNAL');
    var resolveThenable = require('./resolveThenable');
    var states = require('./states');
    var QueueItem = require('./queueItem');

    module.exports = Promise;
    function Promise(resolver) {
        if (!(this instanceof Promise)) {
            return new Promise(resolver);
        }
        if (typeof resolver !== 'function') {
            throw new TypeError('reslover must be a function');
        }
        this.state = states.PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (resolver !== INTERNAL) {
            resolveThenable.safely(this, resolver);
        }
    }

    Promise.prototype['catch'] = function (onRejected) {
        return this.then(null, onRejected);
    };
    Promise.prototype.then = function (onFulfilled, onRejected) {
        if (typeof onFulfilled !== 'function' && this.state === states.FULFILLED ||
            typeof onRejected !== 'function' && this.state === states.REJECTED) {
            return this;
        }
        var promise = new Promise(INTERNAL);


        if (this.state !== states.PENDING) {
            var resolver = this.state === states.FULFILLED ? onFulfilled: onRejected;
            unwrap(promise, resolver, this.outcome);
        } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }

        return promise;
    };

},{"./INTERNAL":210,"./queueItem":215,"./resolveThenable":218,"./states":219,"./unwrap":221}],215:[function(require,module,exports){
    
    var handlers = require('./handlers');
    var unwrap = require('./unwrap');

    module.exports = QueueItem;
    function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;
        if (typeof onFulfilled === 'function') {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === 'function') {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
        }
    }
    QueueItem.prototype.callFulfilled = function (value) {
        handlers.resolve(this.promise, value);
    };
    QueueItem.prototype.otherCallFulfilled = function (value) {
        unwrap(this.promise, this.onFulfilled, value);
    };
    QueueItem.prototype.callRejected = function (value) {
        handlers.reject(this.promise, value);
    };
    QueueItem.prototype.otherCallRejected = function (value) {
        unwrap(this.promise, this.onRejected, value);
    };
},{"./handlers":212,"./unwrap":221}],216:[function(require,module,exports){
    arguments[4][197][0].apply(exports,arguments)
},{"./INTERNAL":210,"./handlers":212,"./promise":214,"dup":197}],217:[function(require,module,exports){
    arguments[4][198][0].apply(exports,arguments)
},{"./INTERNAL":210,"./handlers":212,"./promise":214,"dup":198}],218:[function(require,module,exports){
    arguments[4][199][0].apply(exports,arguments)
},{"./handlers":212,"./tryCatch":220,"dup":199}],219:[function(require,module,exports){
// Lazy man's symbols for states

    exports.REJECTED = ['REJECTED'];
    exports.FULFILLED = ['FULFILLED'];
    exports.PENDING = ['PENDING'];
},{}],220:[function(require,module,exports){
    arguments[4][201][0].apply(exports,arguments)
},{"dup":201}],221:[function(require,module,exports){
    arguments[4][202][0].apply(exports,arguments)
},{"./handlers":212,"dup":202,"immediate":222}],222:[function(require,module,exports){
    
    var types = [
        require('./nextTick'),
        require('./mutation.js'),
        require('./messageChannel'),
        require('./stateChange'),
        require('./timeout')
    ];
    var draining;
    var currentQueue;
    var queueIndex = -1;
    var queue = [];
    var scheduled = false;
    function cleanUpNextTick() {
        draining = false;
        if (currentQueue && currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            nextTick();
        }
    }

//named nextTick for less confusing stack traces
    function nextTick() {
        scheduled = false;
        draining = true;
        var len = queue.length;
        var timeout = setTimeout(cleanUpNextTick);
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                currentQueue[queueIndex].run();
            }
            queueIndex = -1;
            len = queue.length;
        }
        queueIndex = -1;
        draining = false;
        clearTimeout(timeout);
    }
    var scheduleDrain;
    var i = -1;
    var len = types.length;
    while (++i < len) {
        if (types[i] && types[i].test && types[i].test()) {
            scheduleDrain = types[i].install(nextTick);
            break;
        }
    }
// v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    module.exports = immediate;
    function immediate(task) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(task, args));
        if (!scheduled && !draining) {
            scheduled = true;
            scheduleDrain();
        }
    }

},{"./messageChannel":223,"./mutation.js":224,"./nextTick":2,"./stateChange":225,"./timeout":226}],223:[function(require,module,exports){
    (function (global){
        

        exports.test = function () {
            if (global.setImmediate) {
                // we can only get here in IE10
                // which doesn't handel postMessage well
                return false;
            }
            return typeof global.MessageChannel !== 'undefined';
        };

        exports.install = function (func) {
            var channel = new global.MessageChannel();
            channel.port1.onmessage = func;
            return function () {
                channel.port2.postMessage(0);
            };
        };
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],224:[function(require,module,exports){
    (function (global){
        
//based off rsvp https://github.com/tildeio/rsvp.js
//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE
//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js

        var Mutation = global.MutationObserver || global.WebKitMutationObserver;

        exports.test = function () {
            return Mutation;
        };

        exports.install = function (handle) {
            var called = 0;
            var observer = new Mutation(handle);
            var element = global.document.createTextNode('');
            observer.observe(element, {
                characterData: true
            });
            return function () {
                element.data = (called = ++called % 2);
            };
        };
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],225:[function(require,module,exports){
    (function (global){
        

        exports.test = function () {
            return 'document' in global && 'onreadystatechange' in global.document.createElement('script');
        };

        exports.install = function (handle) {
            return function () {

                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                var scriptEl = global.document.createElement('script');
                scriptEl.onreadystatechange = function () {
                    handle();

                    scriptEl.onreadystatechange = null;
                    scriptEl.parentNode.removeChild(scriptEl);
                    scriptEl = null;
                };
                global.document.documentElement.appendChild(scriptEl);

                return handle;
            };
        };
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],226:[function(require,module,exports){
    
    exports.test = function () {
        return true;
    };

    exports.install = function (t) {
        return function () {
            setTimeout(t, 0);
        };
    };
},{}]},{},[169])(169)
});

/*!
 * pickadate.js v3.4.0, 2014/02/15
 * By Amsul, http://amsul.ca
 * Hosted on http://amsul.github.io/pickadate.js
 * Licensed under MIT
 */

(function ( factory ) {

    // Register as an anonymous module.
    if ( typeof define === 'function' && define.amd )
        define( 'picker', ['angular'], factory )

    // Or using browser globals.
    else this.Picker = factory( angular )

}(function( $ ) {

var $document = angular.element( document )


/**
 * The picker constructor that creates a blank picker.
 */
function PickerConstructor( ELEMENT, NAME, COMPONENT, OPTIONS ) {

    // If theres no element, return the picker constructor.
    if ( !ELEMENT ) return PickerConstructor

	var SETTINGS;
	
	// Merge the defaults and options passed.
	if (COMPONENT) {
		SETTINGS = COMPONENT.defaults;
		angular.extend(SETTINGS, OPTIONS);
	} else {
		SETTINGS = OPTIONS || {};
	}
	
	// Merge the default classes with the settings classes.
	var CLASSES = PickerConstructor.klasses();
	angular.extend(CLASSES, SETTINGS.klass);
	

    var
        // The state of the picker.
        STATE = {
            id: ELEMENT.id || 'P' + Math.abs( ~~(Math.random() * new Date()) )
        },

        // The element node wrapper into a jQuery object.
        $ELEMENT = angular.element(ELEMENT),


        // Pseudo picker constructor.
        PickerInstance = function() {
            return this.start()
        },


        // The picker prototype.
        P = PickerInstance.prototype = {

            constructor: PickerInstance,

            $node: $ELEMENT,


            /**
             * Initialize everything
             */
            start: function() {

                // If its already started, do nothing.
                if ( STATE && STATE.start ) return P


                // Update the picker states.
                STATE.methods = {}
                STATE.start = true
                STATE.open = false
                STATE.type = ELEMENT.type


                // Confirm focus state, convert into text input to remove UA stylings,
                // and set as readonly to prevent keyboard popup.
                ELEMENT.autofocus = ELEMENT == document.activeElement
                ELEMENT.type = 'text'
                ELEMENT.readOnly = !SETTINGS.editable
                ELEMENT.id = ELEMENT.id || STATE.id


                // Create a new picker component with the settings.
                P.component = new COMPONENT(P, SETTINGS)

                // Create the picker root with a holder and then prepare it.
                P.$root = angular.element( PickerConstructor._.node('div', createWrappedComponent(), CLASSES.picker, 'id="' + ELEMENT.id + '_root"') )
                prepareElementRoot()


                // If theres a format for the hidden input element, create the element.
                if ( SETTINGS.formatSubmit ) {
                    prepareElementHidden()
                }


                // Prepare the input element.
                prepareElement()


                // Insert the root as specified in the settings.
                if ( SETTINGS.container ) {
                  angular.element( SETTINGS.container ).append( P.$root )
                } 
                else {
                  $ELEMENT.after( P.$root )
                }


                // Bind the default component and settings events.
                P.on({
                    start: P.component.onStart,
                    render: P.component.onRender,
                    stop: P.component.onStop,
                    open: P.component.onOpen,
                    close: P.component.onClose,
                    set: P.component.onSet
                }).on({
                    start: SETTINGS.onStart,
                    render: SETTINGS.onRender,
                    stop: SETTINGS.onStop,
                    open: SETTINGS.onOpen,
                    close: SETTINGS.onClose,
                    set: SETTINGS.onSet
                })


                // If the element has autofocus, open the picker.
                if ( ELEMENT.autofocus ) {
                    P.open()
                }

                P.attachLiveEvents();
                // Trigger queued the start and render events.
                return P.trigger( 'start' ).trigger( 'render' )
            }, //start


            /**
             * Render a new picker
             */
            render: function( entireComponent ) {
                // Insert a new component holder in the root or box.
                if ( entireComponent ) P.$root.html( createWrappedComponent() )
                else angular.element(P.$root[0].querySelectorAll( '.' + CLASSES.box )).html( P.component.nodes( STATE.open ) )

                P.attachLiveEvents();
                // Trigger the queued render events.
                return P.trigger( 'render' )
            }, //render


            /**
             * Destroy everything
             */
            stop: function() {

                // If its already stopped, do nothing.
                if ( !STATE.start ) return P

                // Then close the picker.
                P.close()

                // Remove the hidden field.
                if ( P._hidden ) {
                    P._hidden.parentNode.removeChild( P._hidden )
                }

                // Remove the root.
                P.$root.remove()

                // Remove the input class, remove the stored data, and unbind
                // the events (after a tick for IE - see `P.close`).
                $ELEMENT.removeClass( CLASSES.input ).removeData( NAME )
                setTimeout( function() {
                    $ELEMENT.off( '.' + STATE.id )
                }, 0)

                // Restore the element state
                ELEMENT.type = STATE.type
                ELEMENT.readOnly = false

                // Trigger the queued stop events.
                P.trigger( 'stop' )

                // Reset the picker states.
                STATE.methods = {}
                STATE.start = false

                return P
            }, //stop


            /*
             * Open up the picker
             */
            open: function( dontGiveFocus ) {
                // If its already open, do nothing.
                if ( STATE.open ) return P


                // Add the active class.
                $ELEMENT.addClass( CLASSES.active )
                aria( ELEMENT, 'expanded', true )

                // Add the opened class to the picker root.
                P.$root.addClass( CLASSES.opened )
                aria( P.$root[0], 'hidden', false )

                // If we have to give focus, bind the element and doc events.
                if ( dontGiveFocus !== false ) {

                    // Set it as open.
                    STATE.open = true

                    // Pass focus to the elements jQuery object.
                    $ELEMENT.triggerHandler( 'focus' )

                    // Bind the document events.
					angular.element(document.querySelectorAll('#' + STATE.id)).off('click focusin').on('click focusin', function( event ) {
                        var target = event.target;
                        // If the target of the event is not the element, close the picker picker.
                        // * Dont worry about clicks or focusins on the root because those dont bubble up.
                        //   Also, for Firefox, a click on an `option` element bubbles up directly
                        //   to the doc. So make sure the target wasn't the doc.
                        // * In Firefox stopPropagation() doesnt prevent right-click events from bubbling,
                        //   which causes the picker to unexpectedly close when right-clicking it. So make
                        //   sure the event wasnt a right-click.
                        if ( target != ELEMENT && target != document && event.which != 3 ) {

                            // If the target was the holder that covers the screen,
                            // keep the element focused to maintain tabindex.
                            P.close( target === P.$root.children()[0] )
                        }

                    });
					
					angular.element(document.querySelectorAll('#' + STATE.id)).off('keydown').on('keydown', function( event ) {
                        var
                            // Get the keycode.
                            keycode = event.keyCode,

                            // Translate that to a selection change.
                            keycodeToMove = P.component.key[ keycode ],

                            // Grab the target.
                            target = event.target


                        // On escape, close the picker and give focus.
                        if ( keycode == 27 ) {
                            P.close( true )
                        }


                        // Check if there is a key movement or enter keypress on the element.
                        else if ( target == ELEMENT && ( keycodeToMove || keycode == 13 ) ) {

                            // Prevent the default action to stop page movement.
                            event.preventDefault()

                            // Trigger the key movement action.
                            if ( keycodeToMove ) {
                                PickerConstructor._.trigger( P.component.key.go, P, [ PickerConstructor._.trigger( keycodeToMove ) ] )
                            }

                            // On enter, if the highlighted item isnt disabled, set the value and close.
                            else if ( !angular.element(P.$root[0].querySelectorAll( '.' + CLASSES.highlighted )).hasClass( CLASSES.disabled ) ) {
                                P.set( 'select', P.component.item.highlight ).close()
                            }
                        }


                        // If the target is within the root and enter is pressed,
                        // prevent the default action and trigger a click on the target instead.
                        else if ( P.$root[0].contains(target) && keycode == 13 ) {
                            event.preventDefault()
                            target.click()
                        }
                    })
                }

                // Trigger the queued open events.
                return P.trigger( 'open' )
            }, //open


            /**
             * Close the picker
             */
            close: function( giveFocus ) {

                // If we need to give focus, do it before changing states.
                if ( giveFocus ) {
                    // ....ah yes! It wouldve been incomplete without a crazy workaround for IE :|
                    // The focus is triggered *after* the close has completed - causing it
                    // to open again. So unbind and rebind the event at the next tick.
                    $ELEMENT.off( 'focus.' + STATE.id );
					$ELEMENT.triggerHandler( 'focus' );
                    setTimeout( function() {
                        angular.element(document.querySelectorAll('#' + STATE.id)).on( 'focus', focusToOpen )
                    }, 0 )
                }

                // Remove the active class.
                $ELEMENT.removeClass( CLASSES.active )
                aria( ELEMENT, 'expanded', false )

                // Remove the opened and focused class from the picker root.
                P.$root.removeClass( CLASSES.opened + ' ' + CLASSES.focused )
                aria( P.$root[0], 'hidden', true )
                aria( P.$root[0], 'selected', false )

                // If its already closed, do nothing more.
                if ( !STATE.open ) return P

                // Set it as closed.
                STATE.open = false;
                $ELEMENT[0].blur();

                // Unbind the document events.
                $document.off( '.' + STATE.id )

                // Trigger the queued close events.
                return P.trigger( 'close' )
            }, //close


            /**
             * Clear the values
             */
            clear: function() {
                return P.set( 'clear' )
            }, //clear


            /**
             * Set something
             */
            set: function( thing, value, options ) {

                var thingItem, thingValue,
                    thingIsObject = angular.isObject( thing ),
                    thingObject = thingIsObject ? thing : {}

                // Make sure we have usable options.
                options = thingIsObject && angular.isObject( value ) ?value : options || {}

                if ( thing ) {

                    // If the thing isnt an object, make it one.
                    if ( !thingIsObject ) {
                        thingObject[ thing ] = value
                    }

                    // Go through the things of items to set.
                    for ( thingItem in thingObject ) {

                        // Grab the value of the thing.
                        thingValue = thingObject[ thingItem ]

                        // First, if the item exists and theres a value, set it.
                        if ( thingItem in P.component.item ) {
                            P.component.set( thingItem, thingValue, options )
                        }

                        // Then, check to update the element value and broadcast a change.
                        if ( thingItem == 'select' || thingItem == 'clear' ) {
                            $ELEMENT[0].value = thingItem == 'clear' ?
                                '' : P.get( thingItem, SETTINGS.format );
							$ELEMENT.triggerHandler('change');
                        }
                    }

                    // Render a new picker.
                    P.render()
                }

                // When the method isnt muted, trigger queued set events and pass the `thingObject`.
                return options.muted ? P : P.trigger( 'set', thingObject )
            }, //set


            /**
             * Get something
             */
            get: function( thing, format ) {

                // Make sure theres something to get.
                thing = thing || 'value'

                // If a picker state exists, return that.
                if ( STATE[ thing ] != null ) {
                    return STATE[ thing ]
                }

                // Return the value, if that.
                if ( thing == 'value' ) {
                    return ELEMENT.value
                }

                // Check if a component item exists, return that.
                if ( thing in P.component.item ) {
                    if ( typeof format == 'string' ) {
                        return PickerConstructor._.trigger(
                            P.component.formats.toString,
                            P.component,
                            [ format, P.component.get( thing ) ]
                        )
                    }
                    return P.component.get( thing )
                }
            }, //get



            /**
             * Bind events on the things.
             */
            on: function( thing, method ) {
                var thingName, thingMethod,
                    thingIsObject = angular.isObject( thing ),
                    thingObject = thingIsObject ? thing : {}

                if ( thing ) {

                    // If the thing isnt an object, make it one.
                    if ( !thingIsObject ) {
                        thingObject[ thing ] = method
                    }

                    // Go through the things to bind to.
                    for ( thingName in thingObject ) {

                        // Grab the method of the thing.
                        thingMethod = thingObject[ thingName ]

                        // Make sure the thing methods collection exists.
                        STATE.methods[ thingName ] = STATE.methods[ thingName ] || []

                        // Add the method to the relative method collection.
                        STATE.methods[ thingName ].push( thingMethod )
                    }
                }

                return P
            }, //on



            /**
             * Unbind events on the things.
             */
            off: function() {
                var i, thingName,
                    names = arguments;
                for ( i = 0, namesCount = names.length; i < namesCount; i += 1 ) {
                    thingName = names[i]
                    if ( thingName in STATE.methods ) {
                        delete STATE.methods[thingName]
                    }
                }
                return P
            },


            /**
             * Fire off method events.
             */
            trigger: function( name, data ) {
                var methodList = STATE.methods[ name ]
                if ( methodList ) {
                    methodList.map( function( method ) {
                        PickerConstructor._.trigger( method, P, [ data ] )
                    })
                }
                return P
            } //trigger
        } //PickerInstance.prototype


    /**
     * Wrap the picker holder components together.
     */
    function createWrappedComponent() {

        // Create a picker wrapper holder
        return PickerConstructor._.node( 'div',

            // Create a picker wrapper node
            PickerConstructor._.node( 'div',

                // Create a picker frame
                PickerConstructor._.node( 'div',

                    // Create a picker box node
                    PickerConstructor._.node( 'div',

                        // Create the components nodes.
                        P.component.nodes( STATE.open ),

                        // The picker box class
                        CLASSES.box
                    ),

                    // Picker wrap class
                    CLASSES.wrap
                ),

                // Picker frame class
                CLASSES.frame
            ),

            // Picker holder class
            CLASSES.holder
        ) //endreturn
    } //createWrappedComponent



    /**
     * Prepare the input element with all bindings.
     */
    function prepareElement() {
		// Store the picker data by component name.
        $ELEMENT.data(NAME, P);

        // Add the input class name.
        $ELEMENT.addClass(CLASSES.input)
		
		// If theres a `data-value`, update the value of the element.
		$ELEMENT[0].value = $ELEMENT.attr('data-value') ?
			P.get('select', SETTINGS.format) :
			ELEMENT.value;

		// On focus/click, open the picker and adjust the root focused state.
		angular.element(document.querySelectorAll('#' + STATE.id)).on('focus', focusToOpen);
		angular.element(document.querySelectorAll('#' + STATE.id)).on('click', focusToOpen);
		
        // Only bind keydown events if the element isnt editable.
        if ( !SETTINGS.editable ) {

            // Handle keyboard event based on the picker being opened or not.
            angular.element(document.querySelectorAll('#' + STATE.id)).on('keydown', function(event) {

                var keycode = event.keyCode,

                    // Check if one of the delete keys was pressed.
                    isKeycodeDelete = /^(8|46)$/.test(keycode)

                // For some reason IE clears the input value on escape.
                if ( keycode == 27 ) {
                    P.close()
                    return false
                }

                // Check if `space` or `delete` was pressed or the picker is closed with a key movement.
                if ( keycode == 32 || isKeycodeDelete || !STATE.open && P.component.key[keycode] ) {

                    // Prevent it from moving the page and bubbling to doc.
                    event.preventDefault()
                    event.stopPropagation()

                    // If `delete` was pressed, clear the values and close the picker.
                    // Otherwise open the picker.
                    if ( isKeycodeDelete ) { P.clear().close() }
                    else { P.open() }
                }
            })
        }


        // Update the aria attributes.
        aria(ELEMENT, {
            haspopup: true,
            expanded: false,
            readonly: false,
            owns: ELEMENT.id + '_root' + (P._hidden ? ' ' + P._hidden.id : '')
        })
    }


    /**
     * Prepare the root picker element with all bindings.
     */
    function prepareElementRoot() {
		// When something within the root is focused, stop from bubbling
		// to the doc and remove the focused state from the root.	
        P.$root.on('focusin', function( event ) {
			P.$root.removeClass( CLASSES.focused )
			aria( P.$root[0], 'selected', false )
			event.stopPropagation()
		});
	
		// When something within the root holder is clicked, stop it
        // from bubbling to the doc.
        P.$root.on('mousedown click', function( event ) {

			var target = event.target

			// Make sure the target isnt the root holder so it can bubble up.
			if ( target != P.$root.children()[ 0 ] ) {

				event.stopPropagation()

				// * For mousedown events, cancel the default action in order to
				//   prevent cases where focus is shifted onto external elements
				//   when using things like jQuery mobile or MagnificPopup (ref: #249 & #120).
				//   Also, for Firefox, dont prevent action on the `option` element.
				if ( event.type == 'mousedown' && angular.element( target )[0].tagName !== 'input' && target.nodeName != 'SELECT' && target.nodeName != 'OPTION' ) {

					event.preventDefault()

					// Re-focus onto the element so that users can click away
					// from elements focused within the picker.
					ELEMENT.focus()
				}
			} else if ( event.type == 'click' && P.get('open') ) {
				P.close();
			}
		});

        P.attachLiveEvents = function() {
            // If theres a click on an actionable element, carry out the actions.
            angular.element(P.$root[0].querySelectorAll('[data-pick], [data-nav], [data-clear], [data-close]')).off('click').on('click', function() {
                var $target = angular.element( this ),
                    targetDisabled = $target.hasClass( CLASSES.navDisabled ) || $target.hasClass( CLASSES.disabled ),

                // * For IE, non-focusable elements can be active elements as well
                //   (http://stackoverflow.com/a/2684561).
                    activeElement = document.activeElement
                activeElement = activeElement && ( activeElement.type || activeElement.href ) && activeElement;

                // If its disabled or nothing inside is actively focused, re-focus the element.
                if ( targetDisabled || activeElement && !P.$root[0].contains(activeElement) ) {
                    ELEMENT.focus()
                }

                // If something is superficially changed, update the `highlight` based on the `nav`.
                if ( $target.attr('data-nav') && !targetDisabled ) {
                    P.set( 'highlight', P.component.item.highlight, { nav: parseInt($target.attr('data-nav')) } )
                    P.attachLiveEvents();
                }

                // If something is picked, set `select` then close with focus.
                else if ( PickerConstructor._.isInteger( parseInt($target.attr('data-pick')) ) && !targetDisabled ) {
                    P.set( 'select', parseInt($target.attr('data-pick')) ).close( true )
                    P.attachLiveEvents();
                }

                // If a clear button is pressed, empty the values and close with focus.
                else if ( $target.attr('data-clear') ) {
                    P.clear().close( true )
                    P.attachLiveEvents();
                }

                // If a "close" button is pressed, close with focus.
                else if ( $target.attr('data-close') ) {
                    P.close( true );
                    P.attachLiveEvents();
                }

            });
        }
		
        aria( P.$root[0], 'hidden', true )
    }


     /**
      * Prepare the hidden input element along with all bindings.
      */
    function prepareElementHidden() {

        var id = [
            typeof SETTINGS.hiddenPrefix == 'string' ? SETTINGS.hiddenPrefix : '',
            typeof SETTINGS.hiddenSuffix == 'string' ? SETTINGS.hiddenSuffix : '_submit'
        ]

        P._hidden = angular.element(
            '<input ' +
            'type=hidden ' +

            // Create the name and ID by using the original
            // inputs with a prefix and suffix.
            'name="' + id[0] + ELEMENT.name + id[1] + '"' +
            'id="' + id[0] + ELEMENT.id + id[1] + '"' +

            // If the element has a value, set the hidden value as well.
            (
                $ELEMENT.attr('data-value') || ELEMENT.value ?
                    ' value="' + P.get('select', SETTINGS.formatSubmit) + '"' :
                    ''
            ) +
            '>'
        )[0]

        $ELEMENT.

            // If the value changes, update the hidden input with the correct format.
            on('change.' + STATE.id, function() {
                P._hidden.value = ELEMENT.value ?
                    P.get('select', SETTINGS.formatSubmit) :
                    ''
            }).

            // Insert the hidden input after the element.
            after(P._hidden)
    }


    // Separated for IE
    function focusToOpen( event ) {

        // Stop the event from propagating to the doc.
        event.stopPropagation()

        // If its a focus event, add the focused class to the root.
        if ( event.type == 'focus' ) {
            P.$root.addClass( CLASSES.focused )
            aria( P.$root[0], 'selected', true )
        }

        // And then finally open the picker.
        P.open()
    }


    // Return a new picker instance.
    return new PickerInstance()
} //PickerConstructor



/**
 * The default classes and prefix to use for the HTML classes.
 */
PickerConstructor.klasses = function( prefix ) {
    prefix = prefix || 'picker'
    return {

        picker: prefix,
        opened: prefix + '--opened',
        focused: prefix + '--focused',

        input: prefix + '__input',
        active: prefix + '__input--active',

        holder: prefix + '__holder',

        frame: prefix + '__frame',
        wrap: prefix + '__wrap',

        box: prefix + '__box'
    }
} //PickerConstructor.klasses



/**
 * PickerConstructor helper methods.
 */
PickerConstructor._ = {

    /**
     * Create a group of nodes. Expects:
     * `
        {
            min:    {Integer},
            max:    {Integer},
            i:      {Integer},
            node:   {String},
            item:   {Function}
        }
     * `
     */
    group: function( groupObject ) {

        var
            // Scope for the looped object
            loopObjectScope,

            // Create the nodes list
            nodesList = '',

            // The counter starts from the `min`
            counter = PickerConstructor._.trigger( groupObject.min, groupObject )


        // Loop from the `min` to `max`, incrementing by `i`
        for ( ; counter <= PickerConstructor._.trigger( groupObject.max, groupObject, [ counter ] ); counter += groupObject.i ) {

            // Trigger the `item` function within scope of the object
            loopObjectScope = PickerConstructor._.trigger( groupObject.item, groupObject, [ counter ] )

            // Splice the subgroup and create nodes out of the sub nodes
            nodesList += PickerConstructor._.node(
                groupObject.node,
                loopObjectScope[ 0 ],   // the node
                loopObjectScope[ 1 ],   // the classes
                loopObjectScope[ 2 ]    // the attributes
            )
        }

        // Return the list of nodes
        return nodesList
    }, //group


    /**
     * Create a dom node string
     */
    node: function( wrapper, item, klass, attribute ) {

        // If the item is false-y, just return an empty string
        if ( !item ) return ''

        // If the item is an array, do a join
        item = $.isArray( item ) ? item.join( '' ) : item

        // Check for the class
        klass = klass ? ' class="' + klass + '"' : ''

        // Check for any attributes
        attribute = attribute ? ' ' + attribute : ''

        // Return the wrapped item
        return '<' + wrapper + klass + attribute + '>' + item + '</' + wrapper + '>'
    }, //node


    /**
     * Lead numbers below 10 with a zero.
     */
    lead: function( number ) {
        return ( number < 10 ? '0': '' ) + number
    },


    /**
     * Trigger a function otherwise return the value.
     */
    trigger: function( callback, scope, args ) {
        return typeof callback == 'function' ? callback.apply( scope, args || [] ) : callback
    },


    /**
     * If the second character is a digit, length is 2 otherwise 1.
     */
    digits: function( string ) {
        return ( /\d/ ).test( string[ 1 ] ) ? 2 : 1
    },


    /**
     * Tell if something is a date object.
     */
    isDate: function( value ) {
        return {}.toString.call( value ).indexOf( 'Date' ) > -1 && this.isInteger( value.getDate() )
    },


    /**
     * Tell if something is an integer.
     */
    isInteger: function( value ) {
        return {}.toString.call( value ).indexOf( 'Number' ) > -1 && value % 1 === 0
    },


    /**
     * Create ARIA attribute strings.
     */
    ariaAttr: ariaAttr
} //PickerConstructor._



/**
 * Extend the picker with a component and defaults.
 */
PickerConstructor.extend = function( name, Component ) {

    // Extend jQuery.
    angular.element.prototype[ name ] = function( options, action ) {

        // Grab the component data.
        var componentData = this.data( name )

        // If the picker is requested, return the data object.
        if ( options == 'picker' ) {
            return componentData
        }

        // If the component data exists and `options` is a string, carry out the action.
        if ( componentData && typeof options == 'string' ) {
            PickerConstructor._.trigger( componentData[ options ], componentData, [ action ] )
            return this
        }

        // Otherwise go through each matched element and if the component
        // doesnt exist, create a new picker using `this` element
        // and merging the defaults and options with a deep copy.
		for (var i = 0; i < this.length; i++) {
			var element = angular.element(this[i]);
		    if ( !element.data( name ) ) {
                new PickerConstructor( element[0], name, Component, options )
            }
		}
    }

    // Set the defaults.
    angular.element.prototype[ name ].defaults = Component.defaults
} //PickerConstructor.extend



function aria(element, attribute, value) {
    if ( angular.isObject(attribute) ) {
        for ( var key in attribute ) {
            ariaSet(element, key, attribute[key])
        }
    }
    else {
        ariaSet(element, attribute, value)
    }
}
function ariaSet(element, attribute, value) {
    angular.element(element).attr(
        (attribute == 'role' ? '' : 'aria-') +attribute,
        value
    )
}
function ariaAttr(attribute, data) {
    if ( !angular.isObject(attribute) ) {
        attribute = {attribute: data }
    }
    data = ''
    for ( var key in attribute ) {
        var attr = (key == 'role' ? '' : 'aria-') +key,
            attrVal = attribute[key]
        data += attrVal == null ? '' : attr + '="' + attribute[key] + '"'
    }
    return data
}



// Expose the picker constructor.
return PickerConstructor


}));





/*!
 * Date picker for pickadate.js v3.4.0
 * http://amsul.github.io/pickadate.js/date.htm
 */

(function ( factory ) {

    // Register as an anonymous module.
    if ( typeof define == 'function' && define.amd )
        define( ['picker','angular'], factory )

    // Or using browser globals.
    else factory( Picker, angular )

}(function( Picker, angular ) {


/**
 * Globals and constants
 */
var DAYS_IN_WEEK = 7,
    WEEKS_IN_CALENDAR = 6,
    _ = Picker._



/**
 * The date picker constructor
 */
function DatePicker( picker, settings ) {

    var calendar = this,
        elementValue = picker.$node[ 0 ].value,
        elementDataValue = picker.$node.attr( 'data-value' ),
        valueString = elementDataValue || elementValue,
        formatString = elementDataValue ? settings.formatSubmit : settings.format,
        isRTL = function() {
            return getComputedStyle( picker.$root[0] ).direction === 'rtl'
        }

    calendar.settings = settings
    calendar.$node = picker.$node

    // The queue of methods that will be used to build item objects.
    calendar.queue = {
        min: 'measure create',
        max: 'measure create',
        now: 'now create',
        select: 'parse create validate',
        highlight: 'parse navigate create validate',
        view: 'parse create validate viewset',
        disable: 'deactivate',
        enable: 'activate'
    }

    // The component's item object.
    calendar.item = {}

    calendar.item.disable = ( settings.disable || [] ).slice( 0 )
    calendar.item.enable = -(function( collectionDisabled ) {
        return collectionDisabled[ 0 ] === true ? collectionDisabled.shift() : -1
    })( calendar.item.disable )

    calendar.
        set( 'min', settings.min ).
        set( 'max', settings.max ).
        set( 'now' )

    // When theres a value, set the `select`, which in turn
    // also sets the `highlight` and `view`.
    if ( valueString ) {
        calendar.set( 'select', valueString, {
            format: formatString,
            fromValue: !!elementValue
        })
    }

    // If theres no value, default to highlighting today.
    else {
        calendar.
            set( 'select', null ).
            set( 'highlight', calendar.item.now )
    }


    // The keycode to movement mapping.
    calendar.key = {
        40: 7, // Down
        38: -7, // Up
        39: function() { return isRTL() ? -1 : 1 }, // Right
        37: function() { return isRTL() ? 1 : -1 }, // Left
        go: function( timeChange ) {
            var highlightedObject = calendar.item.highlight,
                targetDate = new Date( highlightedObject.year, highlightedObject.month, highlightedObject.date + timeChange),
                dateObj = calendar.create([targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate()])
            calendar
                .set('select', dateObj)
                .set(
                    'highlight',
                    dateObj,
                    { interval: timeChange }
                )
            this.render()
        }
    }


    // Bind some picker events.
    picker.
        on( 'render', function() {
            angular.element(picker.$root[0].querySelectorAll( '.' + settings.klass.selectMonth )).on( 'change', function() {
                var value = this.value;
                if ( value ) {
                    picker.set( 'select', [ picker.get( 'view' ).year, value, picker.get( 'highlight' ).date ] )
                    angular.element(picker.$root[0].querySelectorAll( '.' + settings.klass.selectMonth )).triggerHandler( 'focus' )
                }
            })
            angular.element(picker.$root[0].querySelectorAll( '.' + settings.klass.selectYear )).on( 'change', function() {
                var value = this.value;
                if ( value ) {
                    picker.set( 'select', [ value, picker.get( 'view' ).month, picker.get( 'highlight' ).date ] )
                    angular.element(picker.$root[0].querySelectorAll( '.' + settings.klass.selectYear )).triggerHandler( 'focus' )
                }
            })
        }).
        on( 'open', function() {
            angular.element(picker.$root[0].querySelectorAll( 'button, select' )).attr( 'disabled', false )
        }).
        on( 'close', function() {
            picker.$node[0].blur();
            angular.element(picker.$root[0].querySelectorAll( 'button, select' )).attr( 'disabled', true )
        })

} //DatePicker


/**
 * Set a datepicker item object.
 */
DatePicker.prototype.set = function( type, value, options ) {
    var calendar = this,
        calendarItem = calendar.item

    // If the value is `null` just set it immediately.
    if ( value === null ) {
        calendarItem[ type ] = value
        return calendar
    }

    // Otherwise go through the queue of methods, and invoke the functions.
    // Update this as the time unit, and set the final value as this item.
    // * In the case of `enable`, keep the queue but set `disable` instead.
    //   And in the case of `flip`, keep the queue but set `enable` instead.
    calendarItem[ ( type == 'enable' ? 'disable' : type == 'flip' ? 'enable' : type ) ] = calendar.queue[ type ].split( ' ' ).map( function( method ) {
        value = calendar[ method ]( type, value, options )
        return value
    }).pop();

    // Check if we need to cascade through more updates.
    if ( type == 'select' ) {
        calendar.set( 'highlight', calendarItem.select, options )
    }
    else if ( type == 'highlight' ) {
        calendar.set( 'view', calendarItem.highlight, options )
    }
    else if ( type.match( /^(flip|min|max|disable|enable)$/ ) ) {
        if ( calendarItem.select && calendar.disabled( calendarItem.select ) ) {
            calendar.set( 'select', calendarItem.select, options )
        }
        if ( calendarItem.highlight && calendar.disabled( calendarItem.highlight ) ) {
            calendar.set( 'highlight', calendarItem.highlight, options )
        }
    }

    return calendar
}; //DatePicker.prototype.set


/**
 * Get a datepicker item object.
 */
DatePicker.prototype.get = function( type ) {
    return this.item[ type ]
}; //DatePicker.prototype.get


/**
 * Create a picker date object.
 */
DatePicker.prototype.create = function( type, value, options ) {
    var isInfiniteValue,
        calendar = this;

    // If theres no value, use the type as the value.
    value = value === undefined ? type : value


    // If its infinity, update the value.
    if ( value == -Infinity || value == Infinity ) {
        isInfiniteValue = value
    }

    // If its an object, use the native date object.
    else if ( angular.isObject( value ) && _.isInteger( value.pick ) ) {
        value = value.obj
    }

    // If its an array, convert it into a date and make sure
    // that its a valid date  otherwise default to today.
    else if ( angular.isArray( value ) ) {
        value = new Date( value[ 0 ], value[ 1 ], value[ 2 ] )
        value = _.isDate( value ) ? value : calendar.create().obj
    }

    // If its a number or date object, make a normalized date.
    else if ( _.isInteger( value ) || _.isDate( value ) ) {
        value = calendar.normalize( new Date( value ), options )
    }

    // If its a literal true or any other case, set it to now.
    else /*if ( value === true )*/ {
        value = calendar.now( type, value, options )
    }

    // Return the compiled object.
    return {
        year: isInfiniteValue || value.getFullYear(),
        month: isInfiniteValue || value.getMonth(),
        date: isInfiniteValue || value.getDate(),
        day: isInfiniteValue || value.getDay(),
        obj: isInfiniteValue || value,
        pick: isInfiniteValue || value.getTime()
    }
}; //DatePicker.prototype.create


/**
 * Create a range limit object using an array, date object,
 * literal true, or integer relative to another time.
 */
DatePicker.prototype.createRange = function( from, to ) {

    var calendar = this,
        createDate = function( date ) {
            if ( date === true || angular.isArray( date ) || _.isDate( date ) ) {
                return calendar.create( date )
            }
            return date
        }

    // Create objects if possible.
    if ( !_.isInteger( from ) ) {
        from = createDate( from )
    }
    if ( !_.isInteger( to ) ) {
        to = createDate( to )
    }

    // Create relative dates.
    if ( _.isInteger( from ) && angular.isObject( to ) ) {
        from = [ to.year, to.month, to.date + from ];
    }
    else if ( _.isInteger( to ) && angular.isObject( from ) ) {
        to = [ from.year, from.month, from.date + to ];
    }

    return {
        from: createDate( from ),
        to: createDate( to )
    }
} //DatePicker.prototype.createRange


/**
 * Check if a date unit falls within a date range object.
 */
DatePicker.prototype.withinRange = function( range, dateUnit ) {
    range = this.createRange(range.from, range.to)
    return dateUnit.pick >= range.from.pick && dateUnit.pick <= range.to.pick
}


/**
 * Check if two date range objects overlap.
 */
DatePicker.prototype.overlapRanges = function( one, two ) {

    var calendar = this

    // Convert the ranges into comparable dates.
    one = calendar.createRange( one.from, one.to )
    two = calendar.createRange( two.from, two.to )

    return calendar.withinRange( one, two.from ) ||calendar.withinRange( one, two.to ) ||
        calendar.withinRange( two, one.from ) || calendar.withinRange( two, one.to )
}


/**
 * Get the date today.
 */
DatePicker.prototype.now = function( type, value, options ) {
    value = new Date()
    if ( options && options.rel ) {
        value.setDate( value.getDate() + options.rel )
    }
    return this.normalize( value, options )
}


/**
 * Navigate to next/prev month.
 */
DatePicker.prototype.navigate = function( type, value, options ) {

    var targetDateObject,
        targetYear,
        targetMonth,
        targetDate,
        isTargetArray = angular.isArray( value ),
        isTargetObject = angular.isObject( value ),
        viewsetObject = this.item.view/*,
        safety = 100*/


    if ( isTargetArray || isTargetObject ) {

        if ( isTargetObject ) {
            targetYear = value.year
            targetMonth = value.month
            targetDate = value.date
        }
        else {
            targetYear = +value[0]
            targetMonth = +value[1]
            targetDate = +value[2]
        }

        // If were navigating months but the view is in a different
        // month, navigate to the views year and month.
        if ( options && options.nav && viewsetObject && viewsetObject.month !== targetMonth ) {
            targetYear = viewsetObject.year
            targetMonth = viewsetObject.month
        }

        // Figure out the expected target year and month.
        targetDateObject = new Date( targetYear, targetMonth + ( options && options.nav ? options.nav : 0 ), 1 )
        targetYear = targetDateObject.getFullYear()
        targetMonth = targetDateObject.getMonth()

        // If the month were going to doesnt have enough days,
        // keep decreasing the date until we reach the months last date.
        while ( /*safety &&*/ new Date( targetYear, targetMonth, targetDate ).getMonth() !== targetMonth ) {
            targetDate -= 1
            /*safety -= 1
            if ( !safety ) {
                throw 'Fell into an infinite loop while navigating to ' + new Date( targetYear, targetMonth, targetDate ) + '.'
            }*/
        }

        value = [ targetYear, targetMonth, targetDate ]
    }

    return value
} //DatePicker.prototype.navigate


/**
 * Normalize a date by setting the hours to midnight.
 */
DatePicker.prototype.normalize = function( value/*, options*/ ) {
    value.setHours( 0, 0, 0, 0 )
    return value
}


/**
 * Measure the range of dates.
 */
DatePicker.prototype.measure = function( type, value/*, options*/ ) {

    var calendar = this

    // If it's anything false-y, remove the limits.
    if ( !value ) {
        value = type == 'min' ? -Infinity : Infinity
    }

    // If it's an integer, get a date relative to today.
    else if ( _.isInteger( value ) ) {
        value = calendar.now( type, value, { rel: value } )
    }

    return value
} ///DatePicker.prototype.measure


/**
 * Create a viewset object based on navigation.
 */
DatePicker.prototype.viewset = function( type, dateObject/*, options*/ ) {
    return this.create([ dateObject.year, dateObject.month, 1 ])
}


/**
 * Validate a date as enabled and shift if needed.
 */
DatePicker.prototype.validate = function( type, dateObject, options ) {

    var calendar = this,

        // Keep a reference to the original date.
        originalDateObject = dateObject,

        // Make sure we have an interval.
        interval = options && options.interval ? options.interval : 1,

        // Check if the calendar enabled dates are inverted.
        isFlippedBase = calendar.item.enable === -1,

        // Check if we have any enabled dates after/before now.
        hasEnabledBeforeTarget, hasEnabledAfterTarget,

        // The min & max limits.
        minLimitObject = calendar.item.min,
        maxLimitObject = calendar.item.max,

        // Check if weve reached the limit during shifting.
        reachedMin, reachedMax,

        // Check if the calendar is inverted and at least one weekday is enabled.
        hasEnabledWeekdays = isFlippedBase && calendar.item.disable.filter( function( value ) {

            // If theres a date, check where it is relative to the target.
            if ( angular.isArray( value ) ) {
                var dateTime = calendar.create( value ).pick
                if ( dateTime < dateObject.pick ) hasEnabledBeforeTarget = true
                else if ( dateTime > dateObject.pick ) hasEnabledAfterTarget = true
            }

            // Return only integers for enabled weekdays.
            return _.isInteger( value )
        }).length/*,

        safety = 100*/



    // Cases to validate for:
    // [1] Not inverted and date disabled.
    // [2] Inverted and some dates enabled.
    // [3] Not inverted and out of range.
    //
    // Cases to **not** validate for:
    //  Navigating months.
    //  Not inverted and date enabled.
    //  Inverted and all dates disabled.
    //  ..and anything else.
    if ( !options || !options.nav ) if (
        /* 1 */ ( !isFlippedBase && calendar.disabled( dateObject ) ) ||
        /* 2 */ ( isFlippedBase && calendar.disabled( dateObject ) && ( hasEnabledWeekdays || hasEnabledBeforeTarget || hasEnabledAfterTarget ) ) ||
        /* 3 */ ( !isFlippedBase && (dateObject.pick <= minLimitObject.pick || dateObject.pick >= maxLimitObject.pick) )
    ) {


        // When inverted, flip the direction if there arent any enabled weekdays
        // and there are no enabled dates in the direction of the interval.
        if ( isFlippedBase && !hasEnabledWeekdays && ( ( !hasEnabledAfterTarget && interval > 0 ) || ( !hasEnabledBeforeTarget && interval < 0 ) ) ) {
            interval *= -1
        }


        // Keep looping until we reach an enabled date.
        while ( /*safety &&*/ calendar.disabled( dateObject ) ) {

            /*safety -= 1
            if ( !safety ) {
                throw 'Fell into an infinite loop while validating ' + dateObject.obj + '.'
            }*/


            // If weve looped into the next/prev month with a large interval, return to the original date and flatten the interval.
            if ( Math.abs( interval ) > 1 && ( dateObject.month < originalDateObject.month || dateObject.month > originalDateObject.month ) ) {
                dateObject = originalDateObject
                interval = interval > 0 ? 1 : -1
            }


            // If weve reached the min/max limit, reverse the direction, flatten the interval and set it to the limit.
            if ( dateObject.pick <= minLimitObject.pick ) {
                reachedMin = true
                interval = 1
                dateObject = calendar.create([ minLimitObject.year, minLimitObject.month, minLimitObject.date - 1 ])
            }
            else if ( dateObject.pick >= maxLimitObject.pick ) {
                reachedMax = true
                interval = -1
                dateObject = calendar.create([ maxLimitObject.year, maxLimitObject.month, maxLimitObject.date + 1 ])
            }


            // If weve reached both limits, just break out of the loop.
            if ( reachedMin && reachedMax ) {
                break
            }


            // Finally, create the shifted date using the interval and keep looping.
            dateObject = calendar.create([ dateObject.year, dateObject.month, dateObject.date + interval ])
        }

    } //endif


    // Return the date object settled on.
    return dateObject
} //DatePicker.prototype.validate


/**
 * Check if a date is disabled.
 */
DatePicker.prototype.disabled = function( dateToVerify ) {

    var
        calendar = this,

        // Filter through the disabled dates to check if this is one.
        isDisabledMatch = calendar.item.disable.filter( function( dateToDisable ) {

            // If the date is a number, match the weekday with 0index and `firstDay` check.
            if ( _.isInteger( dateToDisable ) ) {
                return dateToVerify.day === ( calendar.settings.firstDay ? dateToDisable : dateToDisable - 1 ) % 7
            }

            // If its an array or a native JS date, create and match the exact date.
            if ( angular.isArray( dateToDisable ) || _.isDate( dateToDisable ) ) {
                return dateToVerify.pick === calendar.create( dateToDisable ).pick
            }

            // If its an object, match a date within the from and to range.
            if ( angular.isObject( dateToDisable ) ) {
                return calendar.withinRange( dateToDisable, dateToVerify )
            }
        })

    // If this date matches a disabled date, confirm its not inverted.
    isDisabledMatch = isDisabledMatch.length && !isDisabledMatch.filter(function( dateToDisable ) {
        return angular.isArray( dateToDisable ) && dateToDisable[3] == 'inverted' ||
            angular.isObject( dateToDisable ) && dateToDisable.inverted
    }).length

    // Check the calendar enabled flag and respectively flip the
    // disabled state. Then also check if its beyond the min/max limits.
    return calendar.item.enable === -1 ? !isDisabledMatch : isDisabledMatch ||
        dateToVerify.pick < calendar.item.min.pick ||
        dateToVerify.pick > calendar.item.max.pick

} //DatePicker.prototype.disabled


/**
 * Parse a string into a usable type.
 */
DatePicker.prototype.parse = function( type, value, options ) {

    var calendar = this,
        parsingObject = {},
        monthIndex

    if ( !value || _.isInteger( value ) || angular.isArray( value ) || _.isDate( value ) || angular.isObject( value ) && _.isInteger( value.pick ) ) {
        return value
    }

    // We need a `.format` to parse the value with.
    if ( !( options && options.format ) ) {
        options = options || {}
        options.format = calendar.settings.format
    }

    // Calculate the month index to adjust with.
    monthIndex = typeof value == 'string' && !options.fromValue ?1 : 0

    // Convert the format into an array and then map through it.
    calendar.formats.toArray( options.format ).map( function( label ) {

        var
            // Grab the formatting label.
            formattingLabel = calendar.formats[ label ],

            // The format length is from the formatting label function or the
            // label length without the escaping exclamation (!) mark.
            formatLength = formattingLabel ? _.trigger( formattingLabel, calendar, [ value, parsingObject ] ) : label.replace( /^!/, '' ).length

        // If there's a format label, split the value up to the format length.
        // Then add it to the parsing object with appropriate label.
        if ( formattingLabel ) {
            parsingObject[ label ] = value.substr( 0, formatLength )
        }

        // Update the value as the substring from format length to end.
        value = value.substr( formatLength )
    })

    // If its parsing a user provided month value, compensate for month 0index.
    return [
        parsingObject.yyyy || parsingObject.yy,
        +( parsingObject.mm || parsingObject.m ) - monthIndex,
        parsingObject.dd || parsingObject.d
    ]
} //DatePicker.prototype.parse


/**
 * Various formats to display the object in.
 */
DatePicker.prototype.formats = (function() {

    // Return the length of the first word in a collection.
    function getWordLengthFromCollection( string, collection, dateObject ) {

        // Grab the first word from the string.
        var word = string.match( /\w+/ )[ 0 ]

        // If there's no month index, add it to the date object
        if ( !dateObject.mm && !dateObject.m ) {
            dateObject.m = collection.indexOf( word )
        }

        // Return the length of the word.
        return word.length
    }

    // Get the length of the first word in a string.
    function getFirstWordLength( string ) {
        return string.match( /\w+/ )[ 0 ].length
    }

    return {

        d: function( string, dateObject ) {

            // If there's string, then get the digits length.
            // Otherwise return the selected date.
            return string ? _.digits( string ) : dateObject.date
        },
        dd: function( string, dateObject ) {

            // If there's a string, then the length is always 2.
            // Otherwise return the selected date with a leading zero.
            return string ? 2 : _.lead( dateObject.date )
        },
        ddd: function( string, dateObject ) {

            // If there's a string, then get the length of the first word.
            // Otherwise return the short selected weekday.
            return string ? getFirstWordLength( string ) : this.settings.weekdaysShort[ dateObject.day ]
        },
        dddd: function( string, dateObject ) {

            // If there's a string, then get the length of the first word.
            // Otherwise return the full selected weekday.
            return string ? getFirstWordLength( string ) : this.settings.weekdaysFull[ dateObject.day ]
        },
        m: function( string, dateObject ) {

            // If there's a string, then get the length of the digits
            // Otherwise return the selected month with 0index compensation.
            return string ? _.digits( string ) : dateObject.month + 1
        },
        mm: function( string, dateObject ) {

            // If there's a string, then the length is always 2.
            // Otherwise return the selected month with 0index and leading zero.
            return string ? 2 : _.lead( dateObject.month + 1 )
        },
        mmm: function( string, dateObject ) {

            var collection = this.settings.monthsShort

            // If there's a string, get length of the relevant month from the short
            // months collection. Otherwise return the selected month from that collection.
            return string ? getWordLengthFromCollection( string, collection, dateObject ) : collection[ dateObject.month ]
        },
        mmmm: function( string, dateObject ) {

            var collection = this.settings.monthsFull

            // If there's a string, get length of the relevant month from the full
            // months collection. Otherwise return the selected month from that collection.
            return string ? getWordLengthFromCollection( string, collection, dateObject ) : collection[ dateObject.month ]
        },
        yy: function( string, dateObject ) {

            // If there's a string, then the length is always 2.
            // Otherwise return the selected year by slicing out the first 2 digits.
            return string ? 2 : ( '' + dateObject.year ).slice( 2 )
        },
        yyyy: function( string, dateObject ) {


            // If there's a string, then the length is always 4.
            // Otherwise return the selected year.
            return string ? 4 : dateObject.year
        },

        // Create an array by splitting the formatting string passed.
        toArray: function( formatString ) { return formatString.split( /(d{1,4}|m{1,4}|y{4}|yy|!.)/g ) },

        // Format an object into a string using the formatting options.
        toString: function ( formatString, itemObject ) {
            var calendar = this
            if (itemObject == null) return null;
            return calendar.formats.toArray( formatString ).map( function( label ) {
                return _.trigger( calendar.formats[ label ], calendar, [ 0, itemObject ] ) || label.replace( /^!/, '' )
            }).join( '' )
        }
    }
})() //DatePicker.prototype.formats




/**
 * Check if two date units are the exact.
 */
DatePicker.prototype.isDateExact = function( one, two ) {

    var calendar = this

    // When were working with weekdays, do a direct comparison.
    if (
        ( _.isInteger( one ) && _.isInteger( two ) ) ||
        ( typeof one == 'boolean' && typeof two == 'boolean' )
     ) {
        return one === two
    }

    // When were working with date representations, compare the pick value.
    if (
        ( _.isDate( one ) || angular.isArray( one ) ) &&
        ( _.isDate( two ) || angular.isArray( two ) )
    ) {
        return calendar.create( one ).pick === calendar.create( two ).pick
    }

    // When were working with range objects, compare the from and to.
    if ( angular.isObject( one ) && angular.isObject( two ) ) {
        return calendar.isDateExact( one.from, two.from ) && calendar.isDateExact( one.to, two.to )
    }

    return false
}


/**
 * Check if two date units overlap.
 */
DatePicker.prototype.isDateOverlap = function( one, two ) {

    var calendar = this

    // When were working with a weekday index, compare the days.
    if ( _.isInteger( one ) && ( _.isDate( two ) || angular.isArray( two ) ) ) {
        return one === calendar.create( two ).day + 1
    }
    if ( _.isInteger( two ) && ( _.isDate( one ) || angular.isArray( one ) ) ) {
        return two === calendar.create( one ).day + 1
    }

    // When were working with range objects, check if the ranges overlap.
    if ( angular.isObject( one ) && angular.isObject( two ) ) {
        return calendar.overlapRanges( one, two )
    }

    return false
}


/**
 * Flip the enabled state.
 */
DatePicker.prototype.flipEnable = function(val) {
    var itemObject = this.item
    itemObject.enable = val || (itemObject.enable == -1 ? 1 : -1)
}


/**
 * Mark a collection of dates as disabled.
 */
DatePicker.prototype.deactivate = function( type, datesToDisable ) {

    var calendar = this,
        disabledItems = calendar.item.disable.slice(0)


    // If were flipping, thats all we need to do.
    if ( datesToDisable == 'flip' ) {
        calendar.flipEnable()
    }

    else if ( datesToDisable === false ) {
        calendar.flipEnable(1)
        disabledItems = []
    }

    else if ( datesToDisable === true ) {
        calendar.flipEnable(-1)
        disabledItems = []
    }

    // Otherwise go through the dates to disable.
    else {

        datesToDisable.map(function( unitToDisable ) {

            var matchFound

            // When we have disabled items, check for matches.
            // If something is matched, immediately break out.
            for ( var index = 0; index < disabledItems.length; index += 1 ) {
                if ( calendar.isDateExact( unitToDisable, disabledItems[index] ) ) {
                    matchFound = true
                    break
                }
            }

            // If nothing was found, add the validated unit to the collection.
            if ( !matchFound ) {
                if (
                    _.isInteger( unitToDisable ) ||
                    _.isDate( unitToDisable ) ||
                    angular.isArray( unitToDisable ) ||
                    ( angular.isObject( unitToDisable ) && unitToDisable.from && unitToDisable.to )
                ) {
                    disabledItems.push( unitToDisable )
                }
            }
        })
    }

    // Return the updated collection.
    return disabledItems
} //DatePicker.prototype.deactivate


/**
 * Mark a collection of dates as enabled.
 */
DatePicker.prototype.activate = function( type, datesToEnable ) {

    var calendar = this,
        disabledItems = calendar.item.disable,
        disabledItemsCount = disabledItems.length

    // If were flipping, thats all we need to do.
    if ( datesToEnable == 'flip' ) {
        calendar.flipEnable()
    }

    else if ( datesToEnable === true ) {
        calendar.flipEnable(1)
        disabledItems = []
    }

    else if ( datesToEnable === false ) {
        calendar.flipEnable(-1)
        disabledItems = []
    }

    // Otherwise go through the disabled dates.
    else {

        datesToEnable.map(function( unitToEnable ) {

            var matchFound,
                disabledUnit,
                index,
                isExactRange

            // Go through the disabled items and try to find a match.
            for ( index = 0; index < disabledItemsCount; index += 1 ) {

                disabledUnit = disabledItems[index]

                // When an exact match is found, remove it from the collection.
                if ( calendar.isDateExact( disabledUnit, unitToEnable ) ) {
                    matchFound = disabledItems[index] = null
                    isExactRange = true
                    break
                }

                // When an overlapped match is found, add the inverted state to it.
                else if ( calendar.isDateOverlap( disabledUnit, unitToEnable ) ) {
                    if ( angular.isObject( unitToEnable ) ) {
                        unitToEnable.inverted = true
                        matchFound = unitToEnable
                    }
                    else if ( angular.isArray( unitToEnable ) ) {
                        matchFound = unitToEnable
                        if ( !matchFound[3] ) matchFound.push( 'inverted' )
                    }
                    else if ( _.isDate( unitToEnable ) ) {
                        matchFound = [ unitToEnable.getFullYear(), unitToEnable.getMonth(), unitToEnable.getDate(), 'inverted' ]
                    }
                    break
                }
            }

            // If a match was found, remove a previous duplicate entry.
            if ( matchFound ) for ( index = 0; index < disabledItemsCount; index += 1 ) {
                if ( calendar.isDateExact( disabledItems[index], unitToEnable ) ) {
                    disabledItems[index] = null
                    break
                }
            }

            // In the event that were dealing with an exact range of dates,
            // make sure there are no inverted dates because of it.
            if ( isExactRange ) for ( index = 0; index < disabledItemsCount; index += 1 ) {
                if ( calendar.isDateOverlap( disabledItems[index], unitToEnable ) ) {
                    disabledItems[index] = null
                    break
                }
            }

            // If something is still matched, add it into the collection.
            if ( matchFound ) {
                disabledItems.push( matchFound )
            }
        })
    }

    // Return the updated collection.
    return disabledItems.filter(function( val ) { return val != null })
} //DatePicker.prototype.activate


/**
 * Create a string for the nodes in the picker.
 */
DatePicker.prototype.nodes = function( isOpen ) {
	
    var
        calendar = this,
        settings = calendar.settings,
        calendarItem = calendar.item,
        nowObject = calendarItem.now,
        selectedObject = calendarItem.select,
        highlightedObject = calendarItem.highlight,
        viewsetObject = calendarItem.view,
        disabledCollection = calendarItem.disable,
        minLimitObject = calendarItem.min,
        maxLimitObject = calendarItem.max,


        // Create the calendar table head using a copy of weekday labels collection.
        // * We do a copy so we don't mutate the original array.
        tableHead = (function( collection ) {

            // If the first day should be Monday, move Sunday to the end.
            if ( settings.firstDay ) {
                collection.push( collection.shift() )
            }

            // Create and return the table head group.
            return _.node(
                'thead',
                _.node(
                    'tr',
                    _.group({
                        min: 0,
                        max: DAYS_IN_WEEK - 1,
                        i: 1,
                        node: 'th',
                        item: function( counter ) {
                            return [
                                collection[ counter ],
                                settings.klass.weekdays
                            ]
                        }
                    })
                )
            ) //endreturn
        })( ( settings.showWeekdaysFull ? settings.weekdaysFull : settings.weekdaysShort ).slice( 0 ) ), //tableHead


        // Create the nav for next/prev month.
        createMonthNav = function( next ) {

            // Otherwise, return the created month tag.
            return _.node(
                'div',
                ' ',
                settings.klass[ 'nav' + ( next ? 'Next' : 'Prev' ) ] + (

                    // If the focused month is outside the range, disabled the button.
                    ( next && viewsetObject.year >= maxLimitObject.year && viewsetObject.month >= maxLimitObject.month ) ||
                    ( !next && viewsetObject.year <= minLimitObject.year && viewsetObject.month <= minLimitObject.month ) ?
                    ' ' + settings.klass.navDisabled : ''
                ),
                'data-nav=' + ( next || -1 )
            ) //endreturn
        }, //createMonthNav


        // Create the month label.
        createMonthLabel = function( monthsCollection ) {

            // If there are months to select, add a dropdown menu.
            if ( settings.selectMonths ) {

                return _.node( 'select', _.group({
                    min: 0,
                    max: 11,
                    i: 1,
                    node: 'option',
                    item: function( loopedMonth ) {

                        return [

                            // The looped month and no classes.
                            monthsCollection[ loopedMonth ], 0,

                            // Set the value and selected index.
                            'value=' + loopedMonth +
                            ( viewsetObject.month == loopedMonth ? ' selected' : '' ) +
                            (
                                (
                                    ( viewsetObject.year == minLimitObject.year && loopedMonth < minLimitObject.month ) ||
                                    ( viewsetObject.year == maxLimitObject.year && loopedMonth > maxLimitObject.month )
                                ) ?
                                ' disabled' : ''
                            )
                        ]
                    }
                }), settings.klass.selectMonth, isOpen ? '' : 'disabled' )
            }

            // If there's a need for a month selector
            return _.node( 'div', monthsCollection[ viewsetObject.month ], settings.klass.month )
        }, //createMonthLabel


        // Create the year label.
        createYearLabel = function() {

            var focusedYear = viewsetObject.year,

            // If years selector is set to a literal "true", set it to 5. Otherwise
            // divide in half to get half before and half after focused year.
            numberYears = settings.selectYears === true ? 5 : ~~( settings.selectYears / 2 )

            // If there are years to select, add a dropdown menu.
            if ( numberYears ) {

                var
                    minYear = minLimitObject.year,
                    maxYear = maxLimitObject.year,
                    lowestYear = focusedYear - numberYears,
                    highestYear = focusedYear + numberYears

                // If the min year is greater than the lowest year, increase the highest year
                // by the difference and set the lowest year to the min year.
                if ( minYear > lowestYear ) {
                    highestYear += minYear - lowestYear
                    lowestYear = minYear
                }

                // If the max year is less than the highest year, decrease the lowest year
                // by the lower of the two: available and needed years. Then set the
                // highest year to the max year.
                if ( maxYear < highestYear ) {

                    var availableYears = lowestYear - minYear,
                        neededYears = highestYear - maxYear

                    lowestYear -= availableYears > neededYears ? neededYears : availableYears
                    highestYear = maxYear
                }

                return _.node( 'select', _.group({
                    min: lowestYear,
                    max: highestYear,
                    i: 1,
                    node: 'option',
                    item: function( loopedYear ) {
                        return [

                            // The looped year and no classes.
                            loopedYear, 0,

                            // Set the value and selected index.
                            'value=' + loopedYear + ( focusedYear == loopedYear ? ' selected' : '' )
                        ]
                    }
                }), settings.klass.selectYear, isOpen ? '' : 'disabled' )
            }

            // Otherwise just return the year focused
            return _.node( 'div', focusedYear, settings.klass.year )
        } //createYearLabel


    // Create and return the entire calendar.
    return _.node(
        'div',
        createMonthNav() + createMonthNav( 1 ) +
        createMonthLabel( settings.showMonthsShort ? settings.monthsShort : settings.monthsFull ) +
        createYearLabel(),
        settings.klass.header
    ) + _.node(
        'table',
        tableHead +
        _.node(
            'tbody',
            _.group({
                min: 0,
                max: WEEKS_IN_CALENDAR - 1,
                i: 1,
                node: 'tr',
                item: function( rowCounter ) {

                    // If Monday is the first day and the month starts on Sunday, shift the date back a week.
                    var shiftDateBy = settings.firstDay && calendar.create([ viewsetObject.year, viewsetObject.month, 1 ]).day === 0 ? -7 : 0

                    return [
                        _.group({
                            min: DAYS_IN_WEEK * rowCounter - viewsetObject.day + shiftDateBy + 1, // Add 1 for weekday 0index
                            max: function() {
                                return this.min + DAYS_IN_WEEK - 1
                            },
                            i: 1,
                            node: 'td',
                            item: function( targetDate ) {

                                // Convert the time date from a relative date to a target date.
                                targetDate = calendar.create([ viewsetObject.year, viewsetObject.month, targetDate + ( settings.firstDay ? 1 : 0 ) ])

                                var isSelected = selectedObject && selectedObject.pick == targetDate.pick,
                                    isHighlighted = highlightedObject && highlightedObject.pick == targetDate.pick,
                                    isDisabled = disabledCollection && calendar.disabled( targetDate ) || targetDate.pick < minLimitObject.pick || targetDate.pick > maxLimitObject.pick

                                return [
                                    _.node(
                                        'div',
                                        targetDate.date,
                                        (function( klasses ) {

                                            // Add the `infocus` or `outfocus` classes based on month in view.
                                            klasses.push( viewsetObject.month == targetDate.month ? settings.klass.infocus : settings.klass.outfocus )

                                            // Add the `today` class if needed.
                                            if ( nowObject.pick == targetDate.pick ) {
                                                klasses.push( settings.klass.now )
                                            }

                                            // Add the `selected` class if something's selected and the time matches.
                                            if ( isSelected ) {
                                                klasses.push( settings.klass.selected )
                                            }

                                            // Add the `highlighted` class if something's highlighted and the time matches.
                                            if ( isHighlighted ) {
                                                klasses.push( settings.klass.highlighted )
                                            }

                                            // Add the `disabled` class if something's disabled and the object matches.
                                            if ( isDisabled ) {
                                                klasses.push( settings.klass.disabled )
                                            }

                                            return klasses.join( ' ' )
                                        })([ settings.klass.day ]),
                                        'data-pick=' + targetDate.pick + ' ' + _.ariaAttr({
                                            role: 'button',
                                            controls: calendar.$node[0].id,
                                            checked: isSelected && calendar.$node[0].value === _.trigger(
                                                    calendar.formats.toString,
                                                    calendar,
                                                    [ settings.format, targetDate ]
                                                ) ? true : null,
                                            activedescendant: isHighlighted ? true : null,
                                            disabled: isDisabled ? true : null
                                        })
                                    )
                                ] //endreturn
                            }
                        })
                    ] //endreturn
                }
            })
        ),
        settings.klass.table
    ) +

    // * For Firefox forms to submit, make sure to set the buttons `type` attributes as button.
    _.node(
        'div',
        _.node( 'button', settings.today, settings.klass.buttonToday, 'type=button data-pick=' + nowObject.pick + ( isOpen ? '' : ' disabled' ) ) +
        _.node( 'button', settings.clear, settings.klass.buttonClear, 'type=button data-clear=1' + ( isOpen ? '' : ' disabled' ) ) +
        _.node( 'button', settings.close, settings.klass.buttonClose, 'type=button data-close=true ' + ( isOpen ? '' : ' disabled' ) ),
        settings.klass.footer
    ) //endreturn
} //DatePicker.prototype.nodes




/**
 * The date picker defaults.
 */
DatePicker.defaults = (function( prefix ) {

    return {

        // Months and weekdays
        monthsFull: [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ],
        monthsShort: [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ],
        weekdaysFull: [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],
        weekdaysShort: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ],

        // Today and clear
        today: 'Today',
        clear: 'Clear',
        close: 'Close',

        // The format to show on the `input` element
        format: 'd mmmm, yyyy',

        // Classes
        klass: {

            table: prefix + 'table',

            header: prefix + 'header',

            navPrev: prefix + 'nav--prev',
            navNext: prefix + 'nav--next',
            navDisabled: prefix + 'nav--disabled',

            month: prefix + 'month',
            year: prefix + 'year',

            selectMonth: prefix + 'select--month',
            selectYear: prefix + 'select--year',

            weekdays: prefix + 'weekday',

            day: prefix + 'day',
            disabled: prefix + 'day--disabled',
            selected: prefix + 'day--selected',
            highlighted: prefix + 'day--highlighted',
            now: prefix + 'day--today',
            infocus: prefix + 'day--infocus',
            outfocus: prefix + 'day--outfocus',

            footer: prefix + 'footer',

            buttonClear: prefix + 'button--clear',
            buttonClose: prefix + 'button--close',
            buttonToday: prefix + 'button--today'
        }
    }
})( Picker.klasses().picker + '__' )





/**
 * Extend the picker to add the date picker.
 */
Picker.extend( 'pickadate', DatePicker )


}));





/*!
 * Time picker for pickadate.js v3.4.0
 * http://amsul.github.io/pickadate.js/time.htm
 */

(function ( factory ) {

    // Register as an anonymous module.
    if ( typeof define == 'function' && define.amd )
        define( ['picker','angular'], factory )

    // Or using browser globals.
    else factory( Picker, angular )

}(function( Picker, angular ) {


/**
 * Globals and constants
 */
var HOURS_IN_DAY = 24,
    MINUTES_IN_HOUR = 60,
    HOURS_TO_NOON = 12,
    MINUTES_IN_DAY = HOURS_IN_DAY * MINUTES_IN_HOUR,
    _ = Picker._



/**
 * The time picker constructor
 */
function TimePicker( picker, settings ) {

    var clock = this,
        elementValue = picker.$node[ 0 ].value,
        elementDataValue = picker.$node.data( 'value' ),
        valueString = elementDataValue || elementValue,
        formatString = elementDataValue ? settings.formatSubmit : settings.format

    clock.settings = settings
    clock.$node = picker.$node

    // The queue of methods that will be used to build item objects.
    clock.queue = {
        interval: 'i',
        min: 'measure create',
        max: 'measure create',
        now: 'now create',
        select: 'parse create validate',
        highlight: 'parse create validate',
        view: 'parse create validate',
        disable: 'deactivate',
        enable: 'activate'
    }

    // The component's item object.
    clock.item = {}

    clock.item.interval = settings.interval || 30
    clock.item.disable = ( settings.disable || [] ).slice( 0 )
    clock.item.enable = -(function( collectionDisabled ) {
        return collectionDisabled[ 0 ] === true ? collectionDisabled.shift() : -1
    })( clock.item.disable )

    clock.
        set( 'min', settings.min ).
        set( 'max', settings.max ).
        set( 'now' )

    // When theres a value, set the `select`, which in turn
    // also sets the `highlight` and `view`.
    if ( valueString ) {
        clock.set( 'select', valueString, {
            format: formatString,
            fromValue: !!elementValue
        })
    }

    // If theres no value, default to highlighting today.
    else {
        clock.
            set( 'select', null ).
            set( 'highlight', clock.item.now )
    }

    // The keycode to movement mapping.
    clock.key = {
        40: 1, // Down
        38: -1, // Up
        39: 1, // Right
        37: -1, // Left
        go: function( timeChange ) {
            clock.set(
                'highlight',
                clock.item.highlight.pick + timeChange * clock.item.interval,
                { interval: timeChange * clock.item.interval }
            )
            this.render()
        }
    }


    // Bind some picker events.
    picker.
        on( 'render', function() {
            var $pickerHolder = picker.$root.children(),
                $viewset = $pickerHolder.find( '.' + settings.klass.viewset )
            if ( $viewset.length ) {
                $pickerHolder[ 0 ].scrollTop = ~~$viewset.position().top - ( $viewset[ 0 ].clientHeight * 2 )
            }
        }).
        on( 'open', function() {
            picker.$root.find( 'button' ).attr( 'disable', false )
        }).
        on( 'close', function() {
            picker.$root.find( 'button' ).attr( 'disable', true )
        })

} //TimePicker


/**
 * Set a timepicker item object.
 */
TimePicker.prototype.set = function( type, value, options ) {

    var clock = this,
        clockItem = clock.item

    // If the value is `null` just set it immediately.
    if ( value === null ) {
        clockItem[ type ] = value
        return clock
    }

    // Otherwise go through the queue of methods, and invoke the functions.
    // Update this as the time unit, and set the final value as this item.
    // * In the case of `enable`, keep the queue but set `disable` instead.
    //   And in the case of `flip`, keep the queue but set `enable` instead.
    clockItem[ ( type == 'enable' ? 'disable' : type == 'flip' ? 'enable' : type ) ] = clock.queue[ type ].split( ' ' ).map( function( method ) {
        value = clock[ method ]( type, value, options )
        return value
    }).pop()

    // Check if we need to cascade through more updates.
    if ( type == 'select' ) {
        clock.set( 'highlight', clockItem.select, options )
    }
    else if ( type == 'highlight' ) {
        clock.set( 'view', clockItem.highlight, options )
    }
    else if ( type == 'interval' ) {
        clock.
            set( 'min', clockItem.min, options ).
            set( 'max', clockItem.max, options )
    }
    else if ( type.match( /^(flip|min|max|disable|enable)$/ ) ) {
        if ( type == 'min' ) {
            clock.set( 'max', clockItem.max, options )
        }
        if ( clockItem.select && clock.disabled( clockItem.select ) ) {
            clock.set( 'select', clockItem.select, options )
        }
        if ( clockItem.highlight && clock.disabled( clockItem.highlight ) ) {
            clock.set( 'highlight', clockItem.highlight, options )
        }
    }

    return clock
} //TimePicker.prototype.set


/**
 * Get a timepicker item object.
 */
TimePicker.prototype.get = function( type ) {
    return this.item[ type ]
} //TimePicker.prototype.get


/**
 * Create a picker time object.
 */
TimePicker.prototype.create = function( type, value, options ) {

    var clock = this

    // If theres no value, use the type as the value.
    value = value === undefined ? type : value

    // If its a date object, convert it into an array.
    if ( _.isDate( value ) ) {
        value = [ value.getHours(), value.getMinutes() ]
    }

    // If its an object, use the pick value.
    if ( angular.isObject( value ) && _.isInteger( value.pick ) ) {
        value = value.pick
    }

    // If its an array, convert it into minutes.
    else if ( angular.isArray( value ) ) {
        value = +value[ 0 ] * MINUTES_IN_HOUR + (+value[ 1 ])
    }

    // If no valid value is passed, set it to now.
    else if ( !_.isInteger( value ) ) {
        value = clock.now( type, value, options )
    }

    // If were setting the max, make sure its greater than the min.
    if ( type == 'max' && value < clock.item.min.pick ) {
        value += MINUTES_IN_DAY
    }

    // If the value doesnt fall directly on the interval,
    // add one interval to indicate it as passed.
    if ( type != 'min' && type != 'max' && (value - clock.item.min.pick) % clock.item.interval !== 0 ) {
        value += clock.item.interval
    }

    // Normalize it into a reachable interval.
    value = clock.normalize( type, value, options )

    // Return the compiled object.
    return {

        // Divide to get hours from minutes.
        hour: ~~( HOURS_IN_DAY + value / MINUTES_IN_HOUR ) % HOURS_IN_DAY,

        // The remainder is the minutes.
        mins: ( MINUTES_IN_HOUR + value % MINUTES_IN_HOUR ) % MINUTES_IN_HOUR,

        // The time in total minutes.
        time: ( MINUTES_IN_DAY + value ) % MINUTES_IN_DAY,

        // Reference to the relative value to pick.
        pick: value
    }
} //TimePicker.prototype.create


/**
 * Create a range limit object using an array, date object,
 * literal true, or integer relative to another time.
 */
TimePicker.prototype.createRange = function( from, to ) {

    var clock = this,
        createTime = function( time ) {
            if ( time === true || angular.isArray( time ) || _.isDate( time ) ) {
                return clock.create( time )
            }
            return time
        }

    // Create objects if possible.
    if ( !_.isInteger( from ) ) {
        from = createTime( from )
    }
    if ( !_.isInteger( to ) ) {
        to = createTime( to )
    }

    // Create relative times.
    if ( _.isInteger( from ) && angular.isObject( to ) ) {
        from = [ to.hour, to.mins + ( from * clock.settings.interval ) ];
    }
    else if ( _.isInteger( to ) && angular.isObject( from ) ) {
        to = [ from.hour, from.mins + ( to * clock.settings.interval ) ];
    }

    return {
        from: createTime( from ),
        to: createTime( to )
    }
} //TimePicker.prototype.createRange


/**
 * Check if a time unit falls within a time range object.
 */
TimePicker.prototype.withinRange = function( range, timeUnit ) {
    range = this.createRange(range.from, range.to)
    return timeUnit.pick >= range.from.pick && timeUnit.pick <= range.to.pick
}


/**
 * Check if two time range objects overlap.
 */
TimePicker.prototype.overlapRanges = function( one, two ) {

    var clock = this

    // Convert the ranges into comparable times.
    one = clock.createRange( one.from, one.to )
    two = clock.createRange( two.from, two.to )

    return clock.withinRange( one, two.from ) ||clock.withinRange( one, two.to ) ||
        clock.withinRange( two, one.from ) || clock.withinRange( two, one.to )
}


/**
 * Get the time relative to now.
 */
TimePicker.prototype.now = function( type, value/*, options*/ ) {

    var interval = this.item.interval,
        date = new Date(),
        nowMinutes = date.getHours() * MINUTES_IN_HOUR + date.getMinutes(),
        isValueInteger = _.isInteger( value ),
        isBelowInterval

    // Make sure now falls within the interval range.
    nowMinutes -= nowMinutes % interval

    // Check if the difference is less than the interval itself.
    isBelowInterval = value < 0 && interval * value + nowMinutes <= -interval

    // Add an interval because the time has passed.
    nowMinutes += type == 'min' && isBelowInterval ? 0 : interval

    // If the value is a number, adjust by that many intervals.
    if ( isValueInteger ) {
        nowMinutes += interval * (
            isBelowInterval && type != 'max' ?
                value + 1 :
                value
            )
    }

    // Return the final calculation.
    return nowMinutes
} //TimePicker.prototype.now


/**
 * Normalize minutes to be reachable based on the min and interval.
 */
TimePicker.prototype.normalize = function( type, value/*, options*/ ) {

    var interval = this.item.interval,
        minTime = this.item.min && this.item.min.pick || 0

    // If setting min time, dont shift anything.
    // Otherwise get the value and min difference and then
    // normalize the difference with the interval.
    value -= type == 'min' ? 0 : ( value - minTime ) % interval

    // Return the adjusted value.
    return value
} //TimePicker.prototype.normalize


/**
 * Measure the range of minutes.
 */
TimePicker.prototype.measure = function( type, value, options ) {

    var clock = this

    // If its anything false-y, set it to the default.
    if ( !value ) {
        value = type == 'min' ? [ 0, 0 ] : [ HOURS_IN_DAY - 1, MINUTES_IN_HOUR - 1 ]
    }

    // If its a literal true, or an integer, make it relative to now.
    else if ( value === true || _.isInteger( value ) ) {
        value = clock.now( type, value, options )
    }

    // If its an object already, just normalize it.
    else if ( angular.isObject( value ) && _.isInteger( value.pick ) ) {
        value = clock.normalize( type, value.pick, options )
    }

    return value
} ///TimePicker.prototype.measure


/**
 * Validate an object as enabled.
 */
TimePicker.prototype.validate = function( type, timeObject, options ) {

    var clock = this,
        interval = options && options.interval ? options.interval : clock.item.interval

    // Check if the object is disabled.
    if ( clock.disabled( timeObject ) ) {

        // Shift with the interval until we reach an enabled time.
        timeObject = clock.shift( timeObject, interval )
    }

    // Scope the object into range.
    timeObject = clock.scope( timeObject )

    // Do a second check to see if we landed on a disabled min/max.
    // In that case, shift using the opposite interval as before.
    if ( clock.disabled( timeObject ) ) {
        timeObject = clock.shift( timeObject, interval * -1 )
    }

    // Return the final object.
    return timeObject
} //TimePicker.prototype.validate


/**
 * Check if an object is disabled.
 */
TimePicker.prototype.disabled = function( timeToVerify ) {

    var clock = this,

        // Filter through the disabled times to check if this is one.
        isDisabledMatch = clock.item.disable.filter( function( timeToDisable ) {

            // If the time is a number, match the hours.
            if ( _.isInteger( timeToDisable ) ) {
                return timeToVerify.hour == timeToDisable
            }

            // If its an array, create the object and match the times.
            if ( angular.isArray( timeToDisable ) || _.isDate( timeToDisable ) ) {
                return timeToVerify.pick == clock.create( timeToDisable ).pick
            }

            // If its an object, match a time within the from and to range.
            if ( angular.isObject( timeToDisable ) ) {
                return clock.withinRange( timeToDisable, timeToVerify )
            }
        })

    // If this time matches a disabled time, confirm its not inverted.
    isDisabledMatch = isDisabledMatch.length && !isDisabledMatch.filter(function( timeToDisable ) {
        return angular.isArray( timeToDisable ) && timeToDisable[2] == 'inverted' ||
            angular.isObject( timeToDisable ) && timeToDisable.inverted
    }).length

    // If the clock is "enabled" flag is flipped, flip the condition.
    return clock.item.enable === -1 ? !isDisabledMatch : isDisabledMatch ||
        timeToVerify.pick < clock.item.min.pick ||
        timeToVerify.pick > clock.item.max.pick
} //TimePicker.prototype.disabled


/**
 * Shift an object by an interval until we reach an enabled object.
 */
TimePicker.prototype.shift = function( timeObject, interval ) {

    var clock = this,
        minLimit = clock.item.min.pick,
        maxLimit = clock.item.max.pick/*,
        safety = 1000*/

    interval = interval || clock.item.interval

    // Keep looping as long as the time is disabled.
    while ( /*safety &&*/ clock.disabled( timeObject ) ) {

        /*safety -= 1
        if ( !safety ) {
            throw 'Fell into an infinite loop while shifting to ' + timeObject.hour + ':' + timeObject.mins + '.'
        }*/

        // Increase/decrease the time by the interval and keep looping.
        timeObject = clock.create( timeObject.pick += interval )

        // If we've looped beyond the limits, break out of the loop.
        if ( timeObject.pick <= minLimit || timeObject.pick >= maxLimit ) {
            break
        }
    }

    // Return the final object.
    return timeObject
} //TimePicker.prototype.shift


/**
 * Scope an object to be within range of min and max.
 */
TimePicker.prototype.scope = function( timeObject ) {
    var minLimit = this.item.min.pick,
        maxLimit = this.item.max.pick
    return this.create( timeObject.pick > maxLimit ? maxLimit : timeObject.pick < minLimit ? minLimit : timeObject )
} //TimePicker.prototype.scope


/**
 * Parse a string into a usable type.
 */
TimePicker.prototype.parse = function( type, value, options ) {

    var hour, minutes, isPM, item, parseValue,
        clock = this,
        parsingObject = {}

    if ( !value || _.isInteger( value ) || angular.isArray( value ) || _.isDate( value ) || angular.isObject( value ) && _.isInteger( value.pick ) ) {
        return value
    }

    // We need a `.format` to parse the value with.
    if ( !( options && options.format ) ) {
        options = options || {}
        options.format = clock.settings.format
    }

    // Convert the format into an array and then map through it.
    clock.formats.toArray( options.format ).map( function( label ) {

        var
            substring,

            // Grab the formatting label.
            formattingLabel = clock.formats[ label ],

            // The format length is from the formatting label function or the
            // label length without the escaping exclamation (!) mark.
            formatLength = formattingLabel ?
                _.trigger( formattingLabel, clock, [ value, parsingObject ] ) :
                label.replace( /^!/, '' ).length

        // If there's a format label, split the value up to the format length.
        // Then add it to the parsing object with appropriate label.
        if ( formattingLabel ) {
            substring = value.substr( 0, formatLength )
            parsingObject[ label ] = substring.match(/^\d+$/) ? +substring : substring
        }

        // Update the time value as the substring from format length to end.
        value = value.substr( formatLength )
    })

    // Grab the hour and minutes from the parsing object.
    for ( item in parsingObject ) {
        parseValue = parsingObject[item]
        if ( _.isInteger(parseValue) ) {
            if ( item.match(/^(h|hh)$/i) ) {
                hour = parseValue
                if ( item == 'h' || item == 'hh' ) {
                    hour %= 12
                }
            }
            else if ( item == 'i' ) {
                minutes = parseValue
            }
        }
        else if ( item.match(/^a$/i) && parseValue.match(/^p/i) && ('h' in parsingObject || 'hh' in parsingObject) ) {
            isPM = true
        }
    }

    // Calculate it in minutes and return.
    return (isPM ? hour + 12 : hour) * MINUTES_IN_HOUR + minutes
} //TimePicker.prototype.parse


/**
 * Various formats to display the object in.
 */
TimePicker.prototype.formats = {

    h: function( string, timeObject ) {

        // If there's string, then get the digits length.
        // Otherwise return the selected hour in "standard" format.
        return string ? _.digits( string ) : timeObject.hour % HOURS_TO_NOON || HOURS_TO_NOON
    },
    hh: function( string, timeObject ) {

        // If there's a string, then the length is always 2.
        // Otherwise return the selected hour in "standard" format with a leading zero.
        return string ? 2 : _.lead( timeObject.hour % HOURS_TO_NOON || HOURS_TO_NOON )
    },
    H: function( string, timeObject ) {

        // If there's string, then get the digits length.
        // Otherwise return the selected hour in "military" format as a string.
        return string ? _.digits( string ) : '' + ( timeObject.hour % 24 )
    },
    HH: function( string, timeObject ) {

        // If there's string, then get the digits length.
        // Otherwise return the selected hour in "military" format with a leading zero.
        return string ? _.digits( string ) : _.lead( timeObject.hour % 24 )
    },
    i: function( string, timeObject ) {

        // If there's a string, then the length is always 2.
        // Otherwise return the selected minutes.
        return string ? 2 : _.lead( timeObject.mins )
    },
    a: function( string, timeObject ) {

        // If there's a string, then the length is always 4.
        // Otherwise check if it's more than "noon" and return either am/pm.
        return string ? 4 : MINUTES_IN_DAY / 2 > timeObject.time % MINUTES_IN_DAY ? this.settings.amSmall : this.settings.pmSmall
    },
    A: function( string, timeObject ) {

        // If there's a string, then the length is always 2.
        // Otherwise check if it's more than "noon" and return either am/pm.
        return string ? 2 : MINUTES_IN_DAY / 2 > timeObject.time % MINUTES_IN_DAY ? this.settings.amLarge : this.settings.pmLarge
    },

    // Create an array by splitting the formatting string passed.
    toArray: function( formatString ) { return formatString.split( /(h{1,2}|H{1,2}|i|a|A|!.)/g ) },

    // Format an object into a string using the formatting options.
    toString: function ( formatString, itemObject ) {
        var clock = this
        if (itemObject === null) return null;
        return clock.formats.toArray( formatString ).map( function( label ) {
            return _.trigger( clock.formats[ label ], clock, [ 0, itemObject ] ) || label.replace( /^!/, '' )
        }).join( '' )
    }
} //TimePicker.prototype.formats




/**
 * Check if two time units are the exact.
 */
TimePicker.prototype.isTimeExact = function( one, two ) {

    var clock = this

    // When were working with minutes, do a direct comparison.
    if (
        ( _.isInteger( one ) && _.isInteger( two ) ) ||
        ( typeof one == 'boolean' && typeof two == 'boolean' )
     ) {
        return one === two
    }

    // When were working with time representations, compare the pick value.
    if (
        ( _.isDate( one ) || angular.isArray( one ) ) &&
        ( _.isDate( two ) || angular.isArray( two ) )
    ) {
        return clock.create( one ).pick === clock.create( two ).pick
    }

    // When were working with range objects, compare the from and to.
    if ( angular.isObject( one ) && angular.isObject( two ) ) {
        return clock.isTimeExact( one.from, two.from ) && clock.isTimeExact( one.to, two.to )
    }

    return false
}


/**
 * Check if two time units overlap.
 */
TimePicker.prototype.isTimeOverlap = function( one, two ) {

    var clock = this

    // When were working with an integer, compare the hours.
    if ( _.isInteger( one ) && ( _.isDate( two ) || angular.isArray( two ) ) ) {
        return one === clock.create( two ).hour
    }
    if ( _.isInteger( two ) && ( _.isDate( one ) || angular.isArray( one ) ) ) {
        return two === clock.create( one ).hour
    }

    // When were working with range objects, check if the ranges overlap.
    if ( angular.isObject( one ) && angular.isObject( two ) ) {
        return clock.overlapRanges( one, two )
    }

    return false
}


/**
 * Flip the enabled state.
 */
TimePicker.prototype.flipEnable = function(val) {
    var itemObject = this.item
    itemObject.enable = val || (itemObject.enable == -1 ? 1 : -1)
}


/**
 * Mark a collection of times as disabled.
 */
TimePicker.prototype.deactivate = function( type, timesToDisable ) {

    var clock = this,
        disabledItems = clock.item.disable.slice(0)


    // If were flipping, thats all we need to do.
    if ( timesToDisable == 'flip' ) {
        clock.flipEnable()
    }

    else if ( timesToDisable === false ) {
        clock.flipEnable(1)
        disabledItems = []
    }

    else if ( timesToDisable === true ) {
        clock.flipEnable(-1)
        disabledItems = []
    }

    // Otherwise go through the times to disable.
    else {

        timesToDisable.map(function( unitToDisable ) {

            var matchFound

            // When we have disabled items, check for matches.
            // If something is matched, immediately break out.
            for ( var index = 0; index < disabledItems.length; index += 1 ) {
                if ( clock.isTimeExact( unitToDisable, disabledItems[index] ) ) {
                    matchFound = true
                    break
                }
            }

            // If nothing was found, add the validated unit to the collection.
            if ( !matchFound ) {
                if (
                    _.isInteger( unitToDisable ) ||
                    _.isDate( unitToDisable ) ||
                    angular.isArray( unitToDisable ) ||
                    ( angular.isObject( unitToDisable ) && unitToDisable.from && unitToDisable.to )
                ) {
                    disabledItems.push( unitToDisable )
                }
            }
        })
    }

    // Return the updated collection.
    return disabledItems
} //TimePicker.prototype.deactivate


/**
 * Mark a collection of times as enabled.
 */
TimePicker.prototype.activate = function( type, timesToEnable ) {

    var clock = this,
        disabledItems = clock.item.disable,
        disabledItemsCount = disabledItems.length

    // If were flipping, thats all we need to do.
    if ( timesToEnable == 'flip' ) {
        clock.flipEnable()
    }

    else if ( timesToEnable === true ) {
        clock.flipEnable(1)
        disabledItems = []
    }

    else if ( timesToEnable === false ) {
        clock.flipEnable(-1)
        disabledItems = []
    }

    // Otherwise go through the disabled times.
    else {

        timesToEnable.map(function( unitToEnable ) {

            var matchFound,
                disabledUnit,
                index,
                isRangeMatched

            // Go through the disabled items and try to find a match.
            for ( index = 0; index < disabledItemsCount; index += 1 ) {

                disabledUnit = disabledItems[index]

                // When an exact match is found, remove it from the collection.
                if ( clock.isTimeExact( disabledUnit, unitToEnable ) ) {
                    matchFound = disabledItems[index] = null
                    isRangeMatched = true
                    break
                }

                // When an overlapped match is found, add the inverted state to it.
                else if ( clock.isTimeOverlap( disabledUnit, unitToEnable ) ) {
                    if ( angular.isObject( unitToEnable ) ) {
                        unitToEnable.inverted = true
                        matchFound = unitToEnable
                    }
                    else if ( angular.isArray( unitToEnable ) ) {
                        matchFound = unitToEnable
                        if ( !matchFound[2] ) matchFound.push( 'inverted' )
                    }
                    else if ( _.isDate( unitToEnable ) ) {
                        matchFound = [ unitToEnable.getFullYear(), unitToEnable.getMonth(), unitToEnable.getDate(), 'inverted' ]
                    }
                    break
                }
            }

            // If a match was found, remove a previous duplicate entry.
            if ( matchFound ) for ( index = 0; index < disabledItemsCount; index += 1 ) {
                if ( clock.isTimeExact( disabledItems[index], unitToEnable ) ) {
                    disabledItems[index] = null
                    break
                }
            }

            // In the event that were dealing with an overlap of range times,
            // make sure there are no inverted times because of it.
            if ( isRangeMatched ) for ( index = 0; index < disabledItemsCount; index += 1 ) {
                if ( clock.isTimeOverlap( disabledItems[index], unitToEnable ) ) {
                    disabledItems[index] = null
                    break
                }
            }

            // If something is still matched, add it into the collection.
            if ( matchFound ) {
                disabledItems.push( matchFound )
            }
        })
    }

    // Return the updated collection.
    return disabledItems.filter(function( val ) { return val != null })
} //TimePicker.prototype.activate


/**
 * The division to use for the range intervals.
 */
TimePicker.prototype.i = function( type, value/*, options*/ ) {
    return _.isInteger( value ) && value > 0 ? value : this.item.interval
}


/**
 * Create a string for the nodes in the picker.
 */
TimePicker.prototype.nodes = function( isOpen ) {

    var
        clock = this,
        settings = clock.settings,
        selectedObject = clock.item.select,
        highlightedObject = clock.item.highlight,
        viewsetObject = clock.item.view,
        disabledCollection = clock.item.disable

    return _.node(
        'ul',
        _.group({
            min: clock.item.min.pick,
            max: clock.item.max.pick,
            i: clock.item.interval,
            node: 'li',
            item: function( loopedTime ) {
                loopedTime = clock.create( loopedTime )
                var timeMinutes = loopedTime.pick,
                    isSelected = selectedObject && selectedObject.pick == timeMinutes,
                    isHighlighted = highlightedObject && highlightedObject.pick == timeMinutes,
                    isDisabled = disabledCollection && clock.disabled( loopedTime )
                return [
                    _.trigger( clock.formats.toString, clock, [ _.trigger( settings.formatLabel, clock, [ loopedTime ] ) || settings.format, loopedTime ] ),
                    (function( klasses ) {

                        if ( isSelected ) {
                            klasses.push( settings.klass.selected )
                        }

                        if ( isHighlighted ) {
                            klasses.push( settings.klass.highlighted )
                        }

                        if ( viewsetObject && viewsetObject.pick == timeMinutes ) {
                            klasses.push( settings.klass.viewset )
                        }

                        if ( isDisabled ) {
                            klasses.push( settings.klass.disabled )
                        }

                        return klasses.join( ' ' )
                    })( [ settings.klass.listItem ] ),
                    'data-pick=' + loopedTime.pick + ' ' + _.ariaAttr({
                        role: 'button',
                        controls: clock.$node[0].id,
                        checked: isSelected && clock.$node.val() === _.trigger(
                                clock.formats.toString,
                                clock,
                                [ settings.format, loopedTime ]
                            ) ? true : null,
                        activedescendant: isHighlighted ? true : null,
                        disabled: isDisabled ? true : null
                    })
                ]
            }
        }) +

        // * For Firefox forms to submit, make sure to set the buttons `type` attribute as button.
        _.node(
            'li',
            _.node(
                'button',
                settings.clear,
                settings.klass.buttonClear,
                'type=button data-clear=1' + ( isOpen ? '' : ' disable' )
            )
        ),
        settings.klass.list
    )
} //TimePicker.prototype.nodes







/* ==========================================================================
   Extend the picker to add the component with the defaults.
   ========================================================================== */

TimePicker.defaults = (function( prefix ) {

    return {

        amSmall: 'a.m.',
        amLarge: 'AM',
        pmSmall: 'p.m.',
        pmLarge: 'PM',

        // Clear
        clear: 'Clear',

        // The format to show on the `input` element
        format: 'h:i A',

        // The interval between each time
        interval: 30,

        // Classes
        klass: {

            picker: prefix + ' ' + prefix + '--time',
            holder: prefix + '__holder',

            list: prefix + '__list',
            listItem: prefix + '__list-item',

            disabled: prefix + '__list-item--disabled',
            selected: prefix + '__list-item--selected',
            highlighted: prefix + '__list-item--highlighted',
            viewset: prefix + '__list-item--viewset',
            now: prefix + '__list-item--now',

            buttonClear: prefix + '__button--clear'
        }
    }
})( Picker.klasses().picker )





/**
 * Extend the picker to add the time picker.
 */
Picker.extend( 'pickatime', TimePicker )


}));





/*jshint
   asi: true,
   unused: true,
   boss: true,
   loopfunc: true,
   eqnull: true
 */


/*!
 * Legacy browser support
 */


// Map array support
if ( ![].map ) {
    Array.prototype.map = function ( callback, self ) {
        var array = this, len = array.length, newArray = new Array( len )
        for ( var i = 0; i < len; i++ ) {
            if ( i in array ) {
                newArray[ i ] = callback.call( self, array[ i ], i, array )
            }
        }
        return newArray
    }
}


// Filter array support
if ( ![].filter ) {
    Array.prototype.filter = function( callback ) {
        if ( this == null ) throw new TypeError()
        var t = Object( this ), len = t.length >>> 0
        if ( typeof callback != 'function' ) throw new TypeError()
        var newArray = [], thisp = arguments[ 1 ]
        for ( var i = 0; i < len; i++ ) {
          if ( i in t ) {
            var val = t[ i ]
            if ( callback.call( thisp, val, i, t ) ) newArray.push( val )
          }
        }
        return newArray
    }
}


// Index of array support
if ( ![].indexOf ) {
    Array.prototype.indexOf = function( searchElement ) {
        if ( this == null ) throw new TypeError()
        var t = Object( this ), len = t.length >>> 0
        if ( len === 0 ) return -1
        var n = 0
        if ( arguments.length > 1 ) {
            n = Number( arguments[ 1 ] )
            if ( n != n ) {
                n = 0
            }
            else if ( n !== 0 && n != Infinity && n != -Infinity ) {
                n = ( n > 0 || -1 ) * Math.floor( Math.abs( n ) )
            }
        }
        if ( n >= len ) return -1
        var k = n >= 0 ? n : Math.max( len - Math.abs( n ), 0 )
        for ( ; k < len; k++ ) {
            if ( k in t && t[ k ] === searchElement ) return k
        }
        return -1
    }
}


/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * http://blog.stevenlevithan.com/archives/cross-browser-split
 */
var nativeSplit = String.prototype.split, compliantExecNpcg = /()??/.exec('')[1] === undefined
String.prototype.split = function(separator, limit) {
    var str = this
    if (Object.prototype.toString.call(separator) !== '[object RegExp]') {
        return nativeSplit.call(str, separator, limit)
    }
    var output = [],
        flags = (separator.ignoreCase ? 'i' : '') +
                (separator.multiline  ? 'm' : '') +
                (separator.extended   ? 'x' : '') +
                (separator.sticky     ? 'y' : ''),
        lastLastIndex = 0,
        separator2, match, lastIndex, lastLength
    separator = new RegExp(separator.source, flags + 'g')
    str += ''
    if (!compliantExecNpcg) {
        separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags)
    }
    limit = limit === undefined ? -1 >>> 0 : limit >>> 0
    while (match = separator.exec(str)) {
        lastIndex = match.index + match[0].length
        if (lastIndex > lastLastIndex) {
            output.push(str.slice(lastLastIndex, match.index))
            if (!compliantExecNpcg && match.length > 1) {
                match[0].replace(separator2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined) {
                            match[i] = undefined
                        }
                    }
                })
            }
            if (match.length > 1 && match.index < str.length) {
                Array.prototype.push.apply(output, match.slice(1))
            }
            lastLength = match[0].length
            lastLastIndex = lastIndex
            if (output.length >= limit) {
                break
            }
        }
        if (separator.lastIndex === match.index) {
            separator.lastIndex++
        }
    }
    if (lastLastIndex === str.length) {
        if (lastLength || !separator.test('')) {
            output.push('')
        }
    } else {
        output.push(str.slice(lastLastIndex))
    }
    return output.length > limit ? output.slice(0, limit) : output
}

/*
 angular-slider v0.3.2 
 (c) 2013-2014 Venturocket, Inc. http://github.com/Venturocket 
 License: MIT 
*/
window.AngularSlider=function(a,b,c){function d(a){n.cssText=a}function e(a,b){return typeof a===b}function f(){j.inputtypes=function(a){for(var d,e,f,g=0,h=a.length;h>g;g++)o.setAttribute("type",e=a[g]),d="text"!==o.type,d&&(o.value=p,o.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(e)&&o.style.WebkitAppearance!==c?(k.appendChild(o),f=b.defaultView,d=f.getComputedStyle&&"textfield"!==f.getComputedStyle(o,null).WebkitAppearance&&0!==o.offsetHeight,k.removeChild(o)):/^(search|tel)$/.test(e)||(d=/^(url|email)$/.test(e)?o.checkValidity&&o.checkValidity()===!1:o.value!=p)),r[a[g]]=!!d;return r}("search tel url email datetime date month week time datetime-local number range color".split(" "))}var g,h,i="2.7.1",j={},k=b.documentElement,l="modernizr",m=b.createElement(l),n=m.style,o=b.createElement("input"),p=":)",q=({}.toString,{}),r={},s=[],t=s.slice,u={}.hasOwnProperty;h=e(u,"undefined")||e(u.call,"undefined")?function(a,b){return b in a&&e(a.constructor.prototype[b],"undefined")}:function(a,b){return u.call(a,b)},Function.prototype.bind||(Function.prototype.bind=function(a){var b=this;if("function"!=typeof b)throw new TypeError;var c=t.call(arguments,1),d=function(){if(this instanceof d){var e=function(){};e.prototype=b.prototype;var f=new e,g=b.apply(f,c.concat(t.call(arguments)));return Object(g)===g?g:f}return b.apply(a,c.concat(t.call(arguments)))};return d});for(var v in q)h(q,v)&&(g=v.toLowerCase(),j[g]=q[v](),s.push((j[g]?"":"no-")+g));return j.input||f(),j.addTest=function(a,b){if("object"==typeof a)for(var d in a)h(a,d)&&j.addTest(d,a[d]);else{if(a=a.toLowerCase(),j[a]!==c)return j;b="function"==typeof b?b():b,"undefined"!=typeof enableClasses&&enableClasses&&(k.className+=" "+(b?"":"no-")+a),j[a]=b}return j},d(""),m=o=null,j._version=i,j}(this,this.document),function(a,b,c){function d(a){return"[object Function]"==q.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=r.shift();s=1,a?a.t?o(function(){("c"==a.t?m.injectCss:m.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):s=0}function i(a,c,d,e,f,i,j){function k(b){if(!n&&g(l.readyState)&&(t.r=n=1,!s&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&o(function(){v.removeChild(l)},50);for(var d in A[c])A[c].hasOwnProperty(d)&&A[c][d].onload()}}var j=j||m.errorTimeout,l=b.createElement(a),n=0,q=0,t={t:d,s:c,e:f,a:i,x:j};1===A[c]&&(q=1,A[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,q)},r.splice(e,0,t),"img"!=a&&(q||2===A[c]?(v.insertBefore(l,u?null:p),o(k,j)):A[c].push(l))}function j(a,b,c,d,f){return s=0,b=b||"j",e(a)?i("c"==b?x:w,a,b,this.i++,c,d,f):(r.splice(this.i++,0,a),1==r.length&&h()),this}function k(){var a=m;return a.loader={load:j,i:0},a}var l,m,n=b.documentElement,o=a.setTimeout,p=b.getElementsByTagName("script")[0],q={}.toString,r=[],s=0,t="MozAppearance"in n.style,u=t&&!!b.createRange().compareNode,v=u?n:p.parentNode,n=a.opera&&"[object Opera]"==q.call(a.opera),n=!!b.attachEvent&&!n,w=t?"object":n?"script":"img",x=n?"script":w,y=Array.isArray||function(a){return"[object Array]"==q.call(a)},z=[],A={},B={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}};m=function(a){function b(a){var b,c,d,a=a.split("!"),e=z.length,f=a.pop(),g=a.length,f={url:f,origUrl:f,prefixes:a};for(c=0;g>c;c++)d=a[c].split("="),(b=B[d.shift()])&&(f=b(f,d));for(c=0;e>c;c++)f=z[c](f);return f}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(A[i.url]?i.noexec=!0:A[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),A[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(l=function(){var a=[].slice.call(arguments);m.apply(this,a),n()}),g(a,l,b,0,j);else if(Object(a)===a)for(i in h=function(){var b,c=0;for(b in a)a.hasOwnProperty(b)&&c++;return c}(),a)a.hasOwnProperty(i)&&(!c&&!--h&&(d(l)?l=function(){var a=[].slice.call(arguments);m.apply(this,a),n()}:l[i]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),n()}}(m[i])),g(a[i],l,b,i,j))}else!c&&n()}var h,i,j=!!a.test,k=a.load||a.both,l=a.callback||f,m=l,n=a.complete||f;c(j?a.yep:a.nope,!!k),k&&c(k)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(y(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):y(j)?m(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},m.addPrefix=function(a,b){B[a]=b},m.addFilter=function(a){z.push(a)},m.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",l=function(){b.removeEventListener("DOMContentLoaded",l,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k,l,n=b.createElement("script"),e=e||m.errorTimeout;n.src=a;for(l in d)n.setAttribute(l,d[l]);c=j?h:c||f,n.onreadystatechange=n.onload=function(){!k&&g(n.readyState)&&(k=1,c(),n.onload=n.onreadystatechange=null)},o(function(){k||(k=1,c(1))},e),i?n.onload():p.parentNode.insertBefore(n,p)},a.yepnope.injectCss=function(a,c,d,e,g,i){var j,e=b.createElement("link"),c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(p.parentNode.insertBefore(e,p),o(c,0))}}(this,document),AngularSlider.load=function(){yepnope.apply(window,[].slice.call(arguments,0))},angular.module("vr.directives.slider",["ngTouch"]).directive("slider",["$timeout","$document","$interpolate","$swipe",function(a,b,c,d){function e(a){return angular.element(a)}function f(a){return""+a+"px"}function g(a,b){return a.css({opacity:b})}function h(a){return g(a,0)}function i(a){return g(a,1)}function j(a,b){return a.css({left:b})}function k(a){var b=parseFloat(a.css("width"));return isNaN(b)?a[0].offsetWidth:b}function l(a){return k(a)/2}function m(a){try{return a.offset().left}catch(b){}return a[0].getBoundingClientRect().left}function n(a,b){return m(a)>m(b)?m(a)-m(b)-k(b):m(b)-m(a)-k(a)}function o(a,b){return a.attr("ng-bind-template",b)}function p(a,b,c,d,e){(angular.isUndefined(b)||!b)&&(b=0),(angular.isUndefined(c)||!c||0==c)&&(c=1/Math.pow(10,b)),(angular.isUndefined(d)||!d)&&(d=0),(angular.isUndefined(a)||!a)&&(a=0);var f=(a-d)%c,g=f>c/2?a+c-f:a-f;return(angular.isUndefined(e)||!e)&&(e=g),g=Math.min(Math.max(g,d),e),parseFloat(g.toFixed(b))}function q(a,b){return Math.floor(a/b+.5)*b}function r(a,b){return a>0&&!isNaN(b)?Math.ceil(b/a)*a:b}function s(a){return u+" "+a+" "+v}var t=3,u=c.startSymbol(),v=c.endSymbol();return{restrict:"EA",require:"ngModel",scope:{floor:"@",ceiling:"@",step:"@",stepWidth:"@",precision:"@",buffer:"@",stickiness:"@",showSteps:"@",ngModel:"=",ngModelRange:"=",ngDisabled:"=",ngChange:"&",translateFn:"&",translateRangeFn:"&",translateCombinedFn:"&",scaleFn:"&",inverseScaleFn:"&"},template:"<span class='bar full'></span><span class='bar steps'><span class='bubble step' ng-repeat='step in stepBubbles()'></span></span><span class='bar selection'></span><span class='bar unselected low'></span><span class='bar unselected high'></span><span class='pointer low'></span><span class='pointer high'></span><span class='bubble low'></span><span class='bubble high'></span><span class='bubble middle'></span><span class='bubble selection'></span><span class='bubble limit floor'></span><span class='bubble limit ceiling'></span><input type='range' class='input low' /><input type='range' class='input high' /><input type='range' class='input selection' />",compile:function(c,g){function u(a){a||(a=c);var b=[];return angular.forEach(a.children(),function(a){b.push(e(a))}),b}function v(a,b,c){return{fullBar:a[0],stepBubs:a[1],selBar:b?a[2]:null,unSelBarLow:b?a[3]:null,unSelBarHigh:b?a[4]:null,minPtr:b?a[5]:a[2],maxPtr:b?a[6]:null,lowBub:b?a[7]:a[3],highBub:b?a[8]:null,cmbBub:b?a[9]:null,selBub:b?a[10]:null,flrBub:b?a[11]:a[4],ceilBub:b?a[12]:a[5],minInput:c?b?a[13]:a[6]:null,maxInput:c?b?a[14]:null:null,selInput:c?b?a[15]:null:null}}var w=g.showSteps,x=g.stepWidth?"stepWidth":"step",y=null!=g.ngModelRange,z={},A="ngModel",B="ngModelRange",C="selectBar",D=["floor","ceiling","stickiness",A];if(z=function(){for(var a=u(),b=[],c=0,d=a.length;d>c;c++){var f=a[c];f=e(f),f.css({"white-space":"nowrap",position:"absolute",display:"block","z-index":1}),b.push(f)}return b}(),z=v(z,!0,!0),g.translateFn&&g.$set("translateFn",""+g.translateFn+"(value)"),g.translateRangeFn&&g.$set("translateRangeFnFn",""+g.translateRangeFn+"(low,high)"),g.translateCombinedFn&&g.$set("translateCombinedFnFn",""+g.translateCombinedFn+"(low,high)"),g.scaleFn&&g.$set("scaleFn",""+g.scaleFn+"(value)"),g.inverseScaleFn&&g.$set("inverseScaleFn",""+g.inverseScaleFn+"(value)"),z.fullBar.css({left:0,right:0}),AngularSlider.inputtypes.range){var E={position:"absolute",margin:0,padding:0,opacity:0,height:"100%"};z.minInput.attr("step",s("inputSteps()")),z.minInput.attr("min",s("floor")),z.minInput.css(E),z.minInput.css("left",0),y?(z.minInput.attr("max",s("ngModelRange - (buffer / 2)")),z.maxInput.attr("step",s("inputSteps()")),z.maxInput.attr("min",s("ngModel + (buffer / 2)")),z.maxInput.attr("max",s("ceiling")),z.maxInput.css(E),z.selInput.attr("step",s("inputSteps()")),z.selInput.attr("min",s("ngModel")),z.selInput.attr("max",s("ngModelRange")),z.selInput.css(E)):(z.minInput.attr("max",s("ceiling")),z.minInput.css({width:"100%"}),z.maxInput.remove(),z.selInput.remove())}else z.minInput.remove(),z.maxInput.remove(),z.selInput.remove();if(o(z.stepBubs.children().eq(0),s("translation(step)")),o(z.ceilBub,s("translation(ceiling)")),o(z.flrBub,s("translation(floor)")),o(z.selBub,s("rangeTranslation("+A+","+B+")")),o(z.lowBub,s("translation("+A+")")),o(z.highBub,s("translation("+B+")")),o(z.cmbBub,s("combinedTranslation("+A+","+B+")")),y)D.push(B),D.unshift("buffer");else for(var F=[z.selBar,z.unSelBarLow,z.unSelBarHigh,z.maxPtr,z.selBub,z.highBub,z.cmbBub],G=0,H=F.length;H>G;G++)c=F[G],c.remove();return D.unshift("precision",x),w||z.stepBubs.children().remove(),{post:function(c,g,o,s){function w(){if(angular.forEach(D,function(a){c[a]=parseFloat(c[a]),a==A||a==B?c[a]=p(c[a],c.precision,c[x],c.floor,c.ceiling):"buffer"==a?c.buffer=!c.buffer||isNaN(c.buffer)||c.buffer<0?0:r(c[x],c.buffer):"precision"==a?c.precision=!c.precision||isNaN(c.precision)?0:parseInt(c.precision):a==x?c[x]=!c[x]||isNaN(c[x])?1/Math.pow(10,c.precision):parseFloat(c[x].toFixed(c.precision)):"stickiness"==a&&(isNaN(c.stickiness)?c.stickiness=t:c.stickiness<1&&(c.stickiness=1)),c.decodedValues[a]=c.decodeRef(a)}),y){if(c[B]<c[A]){var a=c[B];c[B]=c[A],c[A]=a}var b=p(c[B]-c[A],c.precision,c[x]);if(c.buffer>0&&b<c.buffer){var d=c.encode((c.decodedValues[A]+c.decodedValues[B])/2);c[A]=p(d-c.buffer/2,c.precision,c[x],c.floor,c.ceiling),c[B]=c[A]+c.buffer,c[B]>c.ceiling&&(c[B]=c.ceiling,c[A]=c.ceiling-c.buffer)}}F=k(E.fullBar),G=l(E.minPtr),H=m(E.fullBar),I=H+F-k(E.minPtr),J=I-H,K=c.floor,L=c.decodedValues.floor,M=c.ceiling,N=c.decodedValues.ceiling,O=M-K,P=N-L,Q=q(P,c.decodedValues[x])}function z(){function a(a){return 100*((a-H)/J)}function o(b){return a(b)/100*P+L}function r(a){return c.encode(o(a))}function t(a){var b=a-L;return O==P?b=q(b,c.decodedValues[x])/Q:b/=P,100*b}function u(a){return t(c.decode(a))}function v(a){return f(a*J/100)}function z(a){return Math.min(Math.max(a,H),I)}function D(b){return j(b,v(a(z(m(b)))))}function N(a,b,d){var e=a>0?1:-1;return b=b?b:100,d?(Math.sin(Math.min(Math.abs(a/b),1)*Math.PI-Math.PI/2)+1)*e*b/6:e*Math.pow(Math.min(Math.abs(2*(a/b)),1),c.stickiness)*b/2}function U(){var b=t(c.decodedValues[A]),d=u(c[A]+c[x])-b,e=b-u(c[A]-c[x]),f=u(c[A]+c.buffer)-b,g=a(G+H),h=b+N(R,R>0?d:e);if(j(E.minPtr,v(h)),j(E.lowBub,v(a(m(E.minPtr)-l(E.lowBub)+G))),y){var i=t(c.decodedValues[B]),k=u(c[B]+c[x])-i,n=i-u(c[B]-c[x]),o=i-u(c[B]-c.buffer),p=i+N(S,S>0?k:n);if(h>i-o&&(h=b+N(R,f,!0),j(E.minPtr,v(h)),j(E.lowBub,v(a(m(E.minPtr)-l(E.lowBub)+G)))),b+f>p&&(p=i+N(S,o,!0)),j(E.maxPtr,v(p)),j(E.highBub,v(a(m(E.maxPtr)-l(E.highBub)+G))),j(E.selBar,v(h+g)),E.selBar.css({width:v(p-h)}),j(E.selBub,v((h+p)/2-a(l(E.selBub)+H)+g)),j(E.cmbBub,v((h+p)/2-a(l(E.cmbBub)+H)+g)),E.unSelBarLow.css({left:0,width:v(h+g)}),j(E.unSelBarHigh,v(p+g)),E.unSelBarHigh.css({right:0}),AngularSlider.inputtypes.range){var q=2*g,r=h+f/2,s=100-r;r+=q;var w=p-o/2,z=h+q,C=p-h-q;h+q>=p&&(z=h,C=p+q-h),E.minInput.css({width:v(w)}),E.maxInput.css({left:v(r),width:v(s)}),E.selInput.css({left:v(z),width:v(C)})}}}function V(){var a=E.lowBub;D(E.lowBub),y&&(D(E.highBub),D(E.selBub),n(E.lowBub,E.highBub)<10?(h(E.lowBub),h(E.highBub),i(E.cmbBub),D(E.cmbBub),a=E.cmbBub):(i(E.lowBub),i(E.highBub),h(E.cmbBub),a=E.highBub)),n(E.flrBub,E.lowBub)<5?h(E.flrBub):y?n(E.flrBub,a)<5?h(E.flrBub):i(E.flrBub):i(E.flrBub),n(E.lowBub,E.ceilBub)<5?h(E.ceilBub):y?n(a,E.ceilBub)<5?h(E.ceilBub):i(E.ceilBub):i(E.ceilBub)}function W(){R=0,S=0,bb&&(U(),V(),bb.removeClass("active")),bb=null,cb=null,$=!1}function X(b){bb&&c.$apply(function(){var d=b.clientX||b.x;if($){var e=r(d)-_,f=r(d)+ab;K>e?(f+=K-e,e=K):f>M&&(e-=f-M,f=M);var h=u(e),i=u(f);R=h,S=i,c[A]=e=p(e,c.precision,c[x],c.floor,c.ceiling),c[B]=f=p(f,c.precision,c[x],c.floor,c.ceiling),R-=u(e),S-=u(f)}else{var j=z(d+H-m(g)-l(bb)),k=a(j),n=c.encode(L+P*k/100);if(R=k,y)if(c.buffer>0)cb===A?n>c[B]-c.buffer&&(n=c[B]-c.buffer):n<c[A]+c.buffer&&(n=c[A]+c.buffer);else if(cb===A){if(n>c[B]){c[A]=c[B],c.decodedValues[A]=c.decodeRef(A),cb=B;var o=E.minPtr;E.minPtr=E.maxPtr,E.maxPtr=o,E.maxPtr.removeClass("active").removeClass("high").addClass("low"),E.minPtr.addClass("active").removeClass("low").addClass("high")}}else if(n<c[A]){c[B]=c[A],c.decodedValues[B]=c.decodeRef(B),cb=A;var o=E.minPtr;E.minPtr=E.maxPtr,E.maxPtr=o,E.minPtr.removeClass("active").removeClass("low").addClass("high"),E.maxPtr.addClass("active").removeClass("high").addClass("low")}c[cb]=n=p(n,c.precision,c[x],c.floor,c.ceiling),c.decodedValues[cb]=c.decodeRef(cb),cb===A?(R-=u(n),S=0):(S=R-u(n),R=0)}c.ngChange&&c.ngChange(),s.$setViewValue(c[A]),U(),V()})}function Y(a,b,d){if(!c.ngDisabled||1!=c.ngDisabled){var e=a.clientX||a.x;if(bb=b,cb=d,bb.addClass("active"),cb==C){$=!0;var f=r(e);_=f-c[A],ab=c[B]-f}X(a)}}function Z(){function a(a,b,c){function f(a){Y(a,b,c)}function g(a){X(a),W()}a=e(a),d.bind(a,{start:f,move:X,end:g,cancel:W})}function c(a,b,c){a=e(a),c=angular.isUndefined(c)?a:e(c),d.bind(a,{start:function(a){Y(a,c,b)}})}function f(a){a=e(a),d.bind(a,{move:X,end:function(a){X(a),W()},cancel:W})}AngularSlider.inputtypes.range?(a(E.minInput,E.minPtr,A),y&&(a(E.maxInput,E.maxPtr,B),a(E.selInput,E.selBar,C))):(f(b),c(E.minPtr,A),c(E.lowBub,A),c(E.flrBub,A,E.minPtr),y?(c(E.maxPtr,B),c(E.highBub,B),c(E.ceilBub,B,E.maxPtr),c(E.selBar,C),c(E.selBub,C,E.selBar),c(E.unSelBarLow,A,E.minPtr),c(E.unSelBarHigh,B,E.maxPtr)):(c(E.ceilBub,A,E.minPtr),c(E.fullBar,A,E.minPtr)))}var $,_,ab,bb,cb;w(),j(E.flrBub,0),j(E.ceilBub,f(F-k(E.ceilBub))),U(),V(),T||(Z(),T=!0)}var E=v(u(g),y,AngularSlider.inputtypes.range);c.decodedValues={floor:0,ceiling:0,step:0,stepWidth:0,precision:0,buffer:0,stickiness:0,ngModel:0,ngModelRange:0},c.translation=function(a){return a=parseFloat(a).toFixed(c.precision),angular.isUndefined(o.translateFn)?""+a:c.translateFn({value:a})},c.rangeTranslation=function(a,b){return angular.isUndefined(o.translateRangeFn)?"Range: "+c.translation((b-a).toFixed(c.precision)):c.translateRangeFn({low:a,high:b})},c.combinedTranslation=function(a,b){return angular.isUndefined(o.translateCombinedFn)?c.translation(a)+" - "+c.translation(b):c.translateCombinedFn({low:a,high:b})},c.encode=function(a){return angular.isUndefined(o.scaleFn)||""==o.scaleFn?a:c.scaleFn({value:a})},c.decode=function(a){return angular.isUndefined(o.inverseScaleFn)||""==o.inverseScaleFn?a:c.inverseScaleFn({value:a})},(1!=Math.round(c.encode(c.decode(1)))||100!=Math.round(c.encode(c.decode(100))))&&console.warn("The scale and inverseScale functions are not perfect inverses: 1 = "+c.encode(c.decode(1))+"  100 = "+c.encode(c.decode(100))),c.decodeRef=function(a){return c.decode(c[a])},c.inputSteps=function(){return Math.pow(10,-1*c.precision)};for(var F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=1,R=0,S=0,T=!1,U=0;U<D.length;U++)c.$watch(D[U],function(){z()});e(window).bind("resize",function(){z()}),c.$on("refreshSlider",function(){a(function(){z()})}),a(function(){z()})}}}}}]);
!function(a,b){"function"==typeof define&&define.amd?define([],function(){return a.SignaturePad=b()}):"object"==typeof exports?module.exports=b():a.SignaturePad=b()}(this,function(){/*!
 * Signature Pad v1.5.0 | https://github.com/szimek/signature_pad
 * (c) 2015 Szymon Nowak | Released under the MIT license
 */
var a=function(a){"use strict";var b=function(a,b){var c=this,d=b||{};this.velocityFilterWeight=d.velocityFilterWeight||.7,this.minWidth=d.minWidth||.5,this.maxWidth=d.maxWidth||2.5,this.dotSize=d.dotSize||function(){return(this.minWidth+this.maxWidth)/2},this.penColor=d.penColor||"black",this.backgroundColor=d.backgroundColor||"rgba(0,0,0,0)",this.onEnd=d.onEnd,this.onBegin=d.onBegin,this._canvas=a,this._ctx=a.getContext("2d"),this.clear(),this._handleMouseDown=function(a){1===a.which&&(c._mouseButtonDown=!0,c._strokeBegin(a))},this._handleMouseMove=function(a){c._mouseButtonDown&&c._strokeUpdate(a)},this._handleMouseUp=function(a){1===a.which&&c._mouseButtonDown&&(c._mouseButtonDown=!1,c._strokeEnd(a))},this._handleTouchStart=function(a){var b=a.changedTouches[0];c._strokeBegin(b)},this._handleTouchMove=function(a){a.preventDefault();var b=a.changedTouches[0];c._strokeUpdate(b)},this._handleTouchEnd=function(a){var b=a.target===c._canvas;b&&c._strokeEnd(a)},this._handleMouseEvents(),this._handleTouchEvents()};b.prototype.clear=function(){var a=this._ctx,b=this._canvas;a.fillStyle=this.backgroundColor,a.clearRect(0,0,b.width,b.height),a.fillRect(0,0,b.width,b.height),this._reset()},b.prototype.toDataURL=function(){var a=this._canvas;return a.toDataURL.apply(a,arguments)},b.prototype.fromDataURL=function(a){var b=this,c=new Image,d=window.devicePixelRatio||1,e=this._canvas.width/d,f=this._canvas.height/d;this._reset(),c.src=a,c.onload=function(){b._ctx.drawImage(c,0,0,e,f)},this._isEmpty=!1},b.prototype._strokeUpdate=function(a){var b=this._createPoint(a);this._addPoint(b)},b.prototype._strokeBegin=function(a){this._reset(),this._strokeUpdate(a),"function"==typeof this.onBegin&&this.onBegin(a)},b.prototype._strokeDraw=function(a){var b=this._ctx,c="function"==typeof this.dotSize?this.dotSize():this.dotSize;b.beginPath(),this._drawPoint(a.x,a.y,c),b.closePath(),b.fill()},b.prototype._strokeEnd=function(a){var b=this.points.length>2,c=this.points[0];!b&&c&&this._strokeDraw(c),"function"==typeof this.onEnd&&this.onEnd(a)},b.prototype._handleMouseEvents=function(){this._mouseButtonDown=!1,this._canvas.addEventListener("mousedown",this._handleMouseDown),this._canvas.addEventListener("mousemove",this._handleMouseMove),a.addEventListener("mouseup",this._handleMouseUp)},b.prototype._handleTouchEvents=function(){this._canvas.style.msTouchAction="none",this._canvas.addEventListener("touchstart",this._handleTouchStart),this._canvas.addEventListener("touchmove",this._handleTouchMove),a.addEventListener("touchend",this._handleTouchEnd)},b.prototype.on=function(){this._handleMouseEvents(),this._handleTouchEvents()},b.prototype.off=function(){this._canvas.removeEventListener("mousedown",this._handleMouseDown),this._canvas.removeEventListener("mousemove",this._handleMouseMove),a.removeEventListener("mouseup",this._handleMouseUp),this._canvas.removeEventListener("touchstart",this._handleTouchStart),this._canvas.removeEventListener("touchmove",this._handleTouchMove),a.removeEventListener("touchend",this._handleTouchEnd)},b.prototype.isEmpty=function(){return this._isEmpty},b.prototype._reset=function(){this.points=[],this._lastVelocity=0,this._lastWidth=(this.minWidth+this.maxWidth)/2,this._isEmpty=!0,this._ctx.fillStyle=this.penColor},b.prototype._createPoint=function(a){var b=this._canvas.getBoundingClientRect();return new c(a.clientX-b.left,a.clientY-b.top)},b.prototype._addPoint=function(a){var b,c,e,f,g=this.points;g.push(a),g.length>2&&(3===g.length&&g.unshift(g[0]),f=this._calculateCurveControlPoints(g[0],g[1],g[2]),b=f.c2,f=this._calculateCurveControlPoints(g[1],g[2],g[3]),c=f.c1,e=new d(g[1],b,c,g[2]),this._addCurve(e),g.shift())},b.prototype._calculateCurveControlPoints=function(a,b,d){var e=a.x-b.x,f=a.y-b.y,g=b.x-d.x,h=b.y-d.y,i={x:(a.x+b.x)/2,y:(a.y+b.y)/2},j={x:(b.x+d.x)/2,y:(b.y+d.y)/2},k=Math.sqrt(e*e+f*f),l=Math.sqrt(g*g+h*h),m=i.x-j.x,n=i.y-j.y,o=l/(k+l),p={x:j.x+m*o,y:j.y+n*o},q=b.x-p.x,r=b.y-p.y;return{c1:new c(i.x+q,i.y+r),c2:new c(j.x+q,j.y+r)}},b.prototype._addCurve=function(a){var b,c,d=a.startPoint,e=a.endPoint;b=e.velocityFrom(d),b=this.velocityFilterWeight*b+(1-this.velocityFilterWeight)*this._lastVelocity,c=this._strokeWidth(b),this._drawCurve(a,this._lastWidth,c),this._lastVelocity=b,this._lastWidth=c},b.prototype._drawPoint=function(a,b,c){var d=this._ctx;d.moveTo(a,b),d.arc(a,b,c,0,2*Math.PI,!1),this._isEmpty=!1},b.prototype._drawCurve=function(a,b,c){var d,e,f,g,h,i,j,k,l,m,n,o=this._ctx,p=c-b;for(d=Math.floor(a.length()),o.beginPath(),f=0;d>f;f++)g=f/d,h=g*g,i=h*g,j=1-g,k=j*j,l=k*j,m=l*a.startPoint.x,m+=3*k*g*a.control1.x,m+=3*j*h*a.control2.x,m+=i*a.endPoint.x,n=l*a.startPoint.y,n+=3*k*g*a.control1.y,n+=3*j*h*a.control2.y,n+=i*a.endPoint.y,e=b+i*p,this._drawPoint(m,n,e);o.closePath(),o.fill()},b.prototype._strokeWidth=function(a){return Math.max(this.maxWidth/(a+1),this.minWidth)};var c=function(a,b,c){this.x=a,this.y=b,this.time=c||(new Date).getTime()};c.prototype.velocityFrom=function(a){return this.time!==a.time?this.distanceTo(a)/(this.time-a.time):1},c.prototype.distanceTo=function(a){return Math.sqrt(Math.pow(this.x-a.x,2)+Math.pow(this.y-a.y,2))};var d=function(a,b,c,d){this.startPoint=a,this.control1=b,this.control2=c,this.endPoint=d};return d.prototype.length=function(){var a,b,c,d,e,f,g,h,i=10,j=0;for(a=0;i>=a;a++)b=a/i,c=this._point(b,this.startPoint.x,this.control1.x,this.control2.x,this.endPoint.x),d=this._point(b,this.startPoint.y,this.control1.y,this.control2.y,this.endPoint.y),a>0&&(g=c-e,h=d-f,j+=Math.sqrt(g*g+h*h)),e=c,f=d;return j},d.prototype._point=function(a,b,c,d,e){return b*(1-a)*(1-a)*(1-a)+3*c*(1-a)*(1-a)*a+3*d*(1-a)*a*a+e*a*a*a},b}(document);return a});
/**
 * Angular Dynamic Locale - 0.1.32
 * https://github.com/lgalfaso/angular-dynamic-locale
 * License: MIT
 * Modifications by CommonTime to allow localeLocationPattern to be set via the dynamicLocale instance and not just via the dynamicLocaleProvider
 */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module unless amdModuleId is set
        define([], function () {
            return (factory());
        });
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        factory();
    }
}(this, function () {
    'use strict';
    angular.module('tmh.dynamicLocale', []).config(['$provide', function($provide) {
        function makeStateful($delegate) {
            $delegate.$stateful = true;
            return $delegate;
        }

        $provide.decorator('dateFilter', ['$delegate', makeStateful]);
        $provide.decorator('numberFilter', ['$delegate', makeStateful]);
        $provide.decorator('currencyFilter', ['$delegate', makeStateful]);

    }])
        .constant('tmhDynamicLocale.STORAGE_KEY', 'tmhDynamicLocale.locale')
        .provider('tmhDynamicLocale', ['tmhDynamicLocale.STORAGE_KEY', function(STORAGE_KEY) {

            var defaultLocale,
                localeLocationPattern = 'angular/i18n/angular-locale_{{locale}}.js',
                nodeToAppend,
                storageFactory = 'tmhDynamicLocaleStorageCache',
                storage,
                storageKey = STORAGE_KEY,
                promiseCache = {},
                activeLocale,
                extraProperties = {};

            /**
             * Loads a script asynchronously
             *
             * @param {string} url The url for the script
             @ @param {function} callback A function to be called once the script is loaded
             */
            function loadScript(url, callback, errorCallback, $timeout) {
                var script = document.createElement('script'),
                    element = nodeToAppend ? nodeToAppend : document.getElementsByTagName("body")[0],
                    removed = false;

                script.type = 'text/javascript';
                if (script.readyState) { // IE
                    script.onreadystatechange = function () {
                        if (script.readyState === 'complete' ||
                            script.readyState === 'loaded') {
                            script.onreadystatechange = null;
                            $timeout(
                                function () {
                                    if (removed) return;
                                    removed = true;
                                    element.removeChild(script);
                                    callback();
                                }, 30, false);
                        }
                    };
                } else { // Others
                    script.onload = function () {
                        if (removed) return;
                        removed = true;
                        element.removeChild(script);
                        callback();
                    };
                    script.onerror = function () {
                        if (removed) return;
                        removed = true;
                        element.removeChild(script);
                        errorCallback();
                    };
                }
                script.src = url;
                script.async = true;
                element.appendChild(script);
            }

            /**
             * Loads a locale and replaces the properties from the current locale with the new locale information
             *
             * @param {string} localeUrl The path to the new locale
             * @param {Object} $locale The locale at the curent scope
             * @param {string} localeId The locale id to load
             * @param {Object} $rootScope The application $rootScope
             * @param {Object} $q The application $q
             * @param {Object} localeCache The current locale cache
             * @param {Object} $timeout The application $timeout
             */
            function loadLocale(localeUrl, $locale, localeId, $rootScope, $q, localeCache, $timeout) {

                function overrideValues(oldObject, newObject) {
                    if (activeLocale !== localeId) {
                        return;
                    }
                    angular.forEach(oldObject, function(value, key) {
                        if (!newObject[key]) {
                            delete oldObject[key];
                        } else if (angular.isArray(newObject[key])) {
                            oldObject[key].length = newObject[key].length;
                        }
                    });
                    angular.forEach(newObject, function(value, key) {
                        if (angular.isArray(newObject[key]) || angular.isObject(newObject[key])) {
                            if (!oldObject[key]) {
                                oldObject[key] = angular.isArray(newObject[key]) ? [] : {};
                            }
                            overrideValues(oldObject[key], newObject[key]);
                        } else {
                            oldObject[key] = newObject[key];
                        }
                    });
                }


                if (promiseCache[localeId]) {
                    activeLocale = localeId;
                    return promiseCache[localeId];
                }

                var cachedLocale,
                    deferred = $q.defer();
                if (localeId === activeLocale) {
                    deferred.resolve($locale);
                } else if ((cachedLocale = localeCache.get(localeId))) {
                    activeLocale = localeId;
                    $rootScope.$evalAsync(function() {
                        overrideValues($locale, cachedLocale);
                        storage.put(storageKey, localeId);
                        $rootScope.$broadcast('$localeChangeSuccess', localeId, $locale);
                        deferred.resolve($locale);
                    });
                } else {
                    activeLocale = localeId;
                    promiseCache[localeId] = deferred.promise;
                    loadScript(localeUrl, function() {
                        // Create a new injector with the new locale
                        var localInjector = angular.injector(['ngLocale']),
                            externalLocale = localInjector.get('$locale');

                        overrideValues($locale, externalLocale);
                        localeCache.put(localeId, externalLocale);
                        delete promiseCache[localeId];

                        $rootScope.$applyAsync(function() {
                            storage.put(storageKey, localeId);
                            $rootScope.$broadcast('$localeChangeSuccess', localeId, $locale);
                            deferred.resolve($locale);
                        });
                    }, function() {
                        delete promiseCache[localeId];

                        $rootScope.$applyAsync(function() {
                            if (activeLocale === localeId) {
                                activeLocale = $locale.id;
                            }
                            $rootScope.$broadcast('$localeChangeError', localeId);
                            deferred.reject(localeId);
                        });
                    }, $timeout);
                }
                return deferred.promise;
            }

            this.localeLocationPattern = function(value) {
                if (value) {
                    localeLocationPattern = value;
                    return this;
                } else {
                    return localeLocationPattern;
                }
            };

            this.appendScriptTo = function(nodeElement) {
                nodeToAppend = nodeElement;
            };

            this.useStorage = function(storageName) {
                storageFactory = storageName;
            };

            this.useCookieStorage = function() {
                this.useStorage('$cookieStore');
            };

            this.defaultLocale = function(value) {
                defaultLocale = value;
            };

            this.storageKey = function(value) {
                if (value) {
                    storageKey = value;
                    return this;
                } else {
                    return storageKey;
                }
            };

            this.addLocalePatternValue = function(key, value) {
                extraProperties[key] = value;
            };

            this.$get = ['$rootScope', '$injector', '$interpolate', '$locale', '$q', 'tmhDynamicLocaleCache', '$timeout', function($rootScope, $injector, interpolate, locale, $q, tmhDynamicLocaleCache, $timeout) {
                var localeLocation = interpolate(localeLocationPattern);

                storage = $injector.get(storageFactory);
                $rootScope.$evalAsync(function() {
                    var initialLocale;
                    if ((initialLocale = (storage.get(storageKey) || defaultLocale))) {
                        loadLocaleFn(initialLocale);
                    }
                });
                return {
                    /**
                     * @ngdoc method
                     * @description
                     * @param {string} value Sets the locale location pattern so that setting locales
                     *    knows where to locate the locale files
                     */
                    setLocaleLocationPattern: setLocaleLocationPattern,
                    /**
                     * @ngdoc method
                     * @description
                     * @param {string} value Sets the locale to the new locale. Changing the locale will trigger
                     *    a background task that will retrieve the new locale and configure the current $locale
                     *    instance with the information from the new locale
                     */
                    set: loadLocaleFn,
                    /**
                     * @ngdoc method
                     * @description Returns the configured locale
                     */
                    get: function() {
                        return activeLocale;
                    }
                };

                function setLocaleLocationPattern(value) {
                    localeLocation = interpolate(value);
                }

                function loadLocaleFn(localeId) {
                    var baseProperties = {locale: localeId, angularVersion: angular.version.full};
                    return loadLocale(localeLocation(angular.extend({}, extraProperties, baseProperties)), locale, localeId, $rootScope, $q, tmhDynamicLocaleCache, $timeout);
                }
            }];
        }]).provider('tmhDynamicLocaleCache', function() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
            return $cacheFactory('tmh.dynamicLocales');
        }];
    }).provider('tmhDynamicLocaleStorageCache', function() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
            return $cacheFactory('tmh.dynamicLocales.store');
        }];
    }).run(['tmhDynamicLocale', angular.noop]);

    return 'tmh.dynamicLocale';

}));

/*! showdown 06-01-2015 */
var Showdown={extensions:{}},forEach=Showdown.forEach=function(a,b){if("function"==typeof a.forEach)a.forEach(b);else{var c,d=a.length;for(c=0;d>c;c++)b(a[c],c,a)}},stdExtName=function(a){return a.replace(/[_-]||\s/g,"").toLowerCase()};Showdown.converter=function(a){var b,c,d,e=0,f=[],g=[];if("undefined"!=typeof module&&"undefined"!=typeof exports&&"undefined"!=typeof require){var h=require("fs");if(h){var i=h.readdirSync((__dirname||".")+"/extensions").filter(function(a){return~a.indexOf(".js")}).map(function(a){return a.replace(/\.js$/,"")});Showdown.forEach(i,function(a){var b=stdExtName(a);Showdown.extensions[b]=require("./extensions/"+a)})}}if(this.makeHtml=function(a){return b={},c={},d=[],a=a.replace(/~/g,"~T"),a=a.replace(/\$/g,"~D"),a=a.replace(/\r\n/g,"\n"),a=a.replace(/\r/g,"\n"),a="\n\n"+a+"\n\n",a=M(a),a=a.replace(/^[ \t]+$/gm,""),Showdown.forEach(f,function(b){a=l(b,a)}),a=z(a),a=n(a),a=m(a),a=p(a),a=K(a),a=a.replace(/~D/g,"$$"),a=a.replace(/~T/g,"~"),Showdown.forEach(g,function(b){a=l(b,a)}),a},a&&a.extensions){var j=this;Showdown.forEach(a.extensions,function(a){if("string"==typeof a&&(a=Showdown.extensions[stdExtName(a)]),"function"!=typeof a)throw"Extension '"+a+"' could not be loaded.  It was either not found or is not a valid extension.";Showdown.forEach(a(j),function(a){a.type?"language"===a.type||"lang"===a.type?f.push(a):("output"===a.type||"html"===a.type)&&g.push(a):g.push(a)})})}var k,l=function(a,b){if(a.regex){var c=new RegExp(a.regex,"g");return b.replace(c,a.replace)}return a.filter?a.filter(b):void 0},m=function(a){return a+="~0",a=a.replace(/^[ ]{0,3}\[(.+)\]:[ \t]*\n?[ \t]*<?(\S+?)>?[ \t]*\n?[ \t]*(?:(\n*)["(](.+?)[")][ \t]*)?(?:\n+|(?=~0))/gm,function(a,d,e,f,g){return d=d.toLowerCase(),b[d]=G(e),f?f+g:(g&&(c[d]=g.replace(/"/g,"&quot;")),"")}),a=a.replace(/~0/,"")},n=function(a){a=a.replace(/\n/g,"\n\n");return a=a.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\b[^\r]*?\n<\/\2>[ \t]*(?=\n+))/gm,o),a=a.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside)\b[^\r]*?<\/\2>[ \t]*(?=\n+)\n)/gm,o),a=a.replace(/(\n[ ]{0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,o),a=a.replace(/(\n\n[ ]{0,3}<!(--[^\r]*?--\s*)+>[ \t]*(?=\n{2,}))/g,o),a=a.replace(/(?:\n\n)([ ]{0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,o),a=a.replace(/\n\n/g,"\n")},o=function(a,b){var c=b;return c=c.replace(/\n\n/g,"\n"),c=c.replace(/^\n/,""),c=c.replace(/\n+$/g,""),c="\n\n~K"+(d.push(c)-1)+"K\n\n"},p=function(a){a=w(a);var b=A("<hr />");return a=a.replace(/^[ ]{0,2}([ ]?\*[ ]?){3,}[ \t]*$/gm,b),a=a.replace(/^[ ]{0,2}([ ]?\-[ ]?){3,}[ \t]*$/gm,b),a=a.replace(/^[ ]{0,2}([ ]?\_[ ]?){3,}[ \t]*$/gm,b),a=x(a),a=y(a),a=E(a),a=n(a),a=F(a)},q=function(a){return a=B(a),a=r(a),a=H(a),a=u(a),a=s(a),a=I(a),a=G(a),a=D(a),a=a.replace(/  +\n/g," <br />\n")},r=function(a){var b=/(<[a-z\/!$]("[^"]*"|'[^']*'|[^'">])*>|<!(--.*?--\s*)+>)/gi;return a=a.replace(b,function(a){var b=a.replace(/(.)<\/?code>(?=.)/g,"$1`");return b=N(b,"\\`*_")})},s=function(a){return a=a.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g,t),a=a.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\]\([ \t]*()<?(.*?(?:\(.*?\).*?)?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g,t),a=a.replace(/(\[([^\[\]]+)\])()()()()()/g,t)},t=function(a,d,e,f,g,h,i,j){void 0==j&&(j="");var k=d,l=e,m=f.toLowerCase(),n=g,o=j;if(""==n)if(""==m&&(m=l.toLowerCase().replace(/ ?\n/g," ")),n="#"+m,void 0!=b[m])n=b[m],void 0!=c[m]&&(o=c[m]);else{if(!(k.search(/\(\s*\)$/m)>-1))return k;n=""}n=N(n,"*_");var p='<a href="'+n+'"';return""!=o&&(o=o.replace(/"/g,"&quot;"),o=N(o,"*_"),p+=' title="'+o+'"'),p+=">"+l+"</a>"},u=function(a){return a=a.replace(/(!\[(.*?)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g,v),a=a.replace(/(!\[(.*?)\]\s?\([ \t]*()<?(\S+?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g,v)},v=function(a,d,e,f,g,h,i,j){var k=d,l=e,m=f.toLowerCase(),n=g,o=j;if(o||(o=""),""==n){if(""==m&&(m=l.toLowerCase().replace(/ ?\n/g," ")),n="#"+m,void 0==b[m])return k;n=b[m],void 0!=c[m]&&(o=c[m])}l=l.replace(/"/g,"&quot;"),n=N(n,"*_");var p='<img src="'+n+'" alt="'+l+'"';return o=o.replace(/"/g,"&quot;"),o=N(o,"*_"),p+=' title="'+o+'"',p+=" />"},w=function(a){function b(a){return a.replace(/[^\w]/g,"").toLowerCase()}return a=a.replace(/^(.+)[ \t]*\n=+[ \t]*\n+/gm,function(a,c){return A('<h1 id="'+b(c)+'">'+q(c)+"</h1>")}),a=a.replace(/^(.+)[ \t]*\n-+[ \t]*\n+/gm,function(a,c){return A('<h2 id="'+b(c)+'">'+q(c)+"</h2>")}),a=a.replace(/^(\#{1,6})[ \t]*(.+?)[ \t]*\#*\n+/gm,function(a,c,d){var e=c.length;return A("<h"+e+' id="'+b(d)+'">'+q(d)+"</h"+e+">")})},x=function(a){a+="~0";var b=/^(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm;return e?a=a.replace(b,function(a,b,c){var d=b,e=c.search(/[*+-]/g)>-1?"ul":"ol";d=d.replace(/\n{2,}/g,"\n\n\n");var f=k(d);return f=f.replace(/\s+$/,""),f="<"+e+">"+f+"</"+e+">\n"}):(b=/(\n\n|^\n?)(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/g,a=a.replace(b,function(a,b,c,d){var e=b,f=c,g=d.search(/[*+-]/g)>-1?"ul":"ol",f=f.replace(/\n{2,}/g,"\n\n\n"),h=k(f);return h=e+"<"+g+">\n"+h+"</"+g+">\n"})),a=a.replace(/~0/,"")};k=function(a){return e++,a=a.replace(/\n{2,}$/,"\n"),a+="~0",a=a.replace(/(\n)?(^[ \t]*)([*+-]|\d+[.])[ \t]+([^\r]+?(\n{1,2}))(?=\n*(~0|\2([*+-]|\d+[.])[ \t]+))/gm,function(a,b,c,d,e){var f=e,g=b;return g||f.search(/\n{2,}/)>-1?f=p(L(f)):(f=x(L(f)),f=f.replace(/\n$/,""),f=q(f)),"<li>"+f+"</li>\n"}),a=a.replace(/~0/g,""),e--,a};var y=function(a){return a+="~0",a=a.replace(/(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=~0))/g,function(a,b,c){var d=b,e=c;return d=C(L(d)),d=M(d),d=d.replace(/^\n+/g,""),d=d.replace(/\n+$/g,""),d="<pre><code>"+d+"\n</code></pre>",A(d)+e}),a=a.replace(/~0/,"")},z=function(a){return a+="~0",a=a.replace(/(?:^|\n)```(.*)\n([\s\S]*?)\n```/g,function(a,b,c){var d=b,e=c;return e=C(e),e=M(e),e=e.replace(/^\n+/g,""),e=e.replace(/\n+$/g,""),e="<pre><code"+(d?' class="'+d+'"':"")+">"+e+"\n</code></pre>",A(e)}),a=a.replace(/~0/,"")},A=function(a){return a=a.replace(/(^\n+|\n+$)/g,""),"\n\n~K"+(d.push(a)-1)+"K\n\n"},B=function(a){return a=a.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,function(a,b,c,d){var e=d;return e=e.replace(/^([ \t]*)/g,""),e=e.replace(/[ \t]*$/g,""),e=C(e),b+"<code>"+e+"</code>"})},C=function(a){return a=a.replace(/&/g,"&amp;"),a=a.replace(/</g,"&lt;"),a=a.replace(/>/g,"&gt;"),a=N(a,"*_{}[]\\",!1)},D=function(a){return a=a.replace(/(\*\*|__)(?=\S)([^\r]*?\S[*_]*)\1/g,"<strong>$2</strong>"),a=a.replace(/(\*|_)(?=\S)([^\r]*?\S)\1/g,"<em>$2</em>")},E=function(a){return a=a.replace(/((^[ \t]*>[ \t]?.+\n(.+\n)*\n*)+)/gm,function(a,b){var c=b;return c=c.replace(/^[ \t]*>[ \t]?/gm,"~0"),c=c.replace(/~0/g,""),c=c.replace(/^[ \t]+$/gm,""),c=p(c),c=c.replace(/(^|\n)/g,"$1  "),c=c.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm,function(a,b){var c=b;return c=c.replace(/^  /gm,"~0"),c=c.replace(/~0/g,"")}),A("<blockquote>\n"+c+"\n</blockquote>")})},F=function(a){a=a.replace(/^\n+/g,""),a=a.replace(/\n+$/g,"");for(var b=a.split(/\n{2,}/g),c=[],e=b.length,f=0;e>f;f++){var g=b[f];g.search(/~K(\d+)K/g)>=0?c.push(g):g.search(/\S/)>=0&&(g=q(g),g=g.replace(/^([ \t]*)/g,"<p>"),g+="</p>",c.push(g))}e=c.length;for(var f=0;e>f;f++)for(;c[f].search(/~K(\d+)K/)>=0;){var h=d[RegExp.$1];h=h.replace(/\$/g,"$$$$"),c[f]=c[f].replace(/~K\d+K/,h)}return c.join("\n\n")},G=function(a){return a=a.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g,"&amp;"),a=a.replace(/<(?![a-z\/?\$!])/gi,"&lt;")},H=function(a){return a=a.replace(/\\(\\)/g,O),a=a.replace(/\\([`*_{}\[\]()>#+-.!])/g,O)},I=function(a){return a=a.replace(/<((https?|ftp|dict):[^'">\s]+)>/gi,'<a href="$1">$1</a>'),a=a.replace(/<(?:mailto:)?([-.\w]+\@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,function(a,b){return J(K(b))})},J=function(a){var b=[function(a){return"&#"+a.charCodeAt(0)+";"},function(a){return"&#x"+a.charCodeAt(0).toString(16)+";"},function(a){return a}];return a="mailto:"+a,a=a.replace(/./g,function(a){if("@"==a)a=b[Math.floor(2*Math.random())](a);else if(":"!=a){var c=Math.random();a=c>.9?b[2](a):c>.45?b[1](a):b[0](a)}return a}),a='<a href="'+a+'">'+a+"</a>",a=a.replace(/">.+:/g,'">')},K=function(a){return a=a.replace(/~E(\d+)E/g,function(a,b){var c=parseInt(b);return String.fromCharCode(c)})},L=function(a){return a=a.replace(/^(\t|[ ]{1,4})/gm,"~0"),a=a.replace(/~0/g,"")},M=function(a){return a=a.replace(/\t(?=\t)/g,"    "),a=a.replace(/\t/g,"~A~B"),a=a.replace(/~B(.+?)~A/g,function(a,b){for(var c=b,d=4-c.length%4,e=0;d>e;e++)c+=" ";return c}),a=a.replace(/~A/g,"    "),a=a.replace(/~B/g,"")},N=function(a,b,c){var d="(["+b.replace(/([\[\]\\])/g,"\\$1")+"])";c&&(d="\\\\"+d);var e=new RegExp(d,"g");return a=a.replace(e,O)},O=function(a,b){var c=b.charCodeAt(0);return"~E"+c+"E"}},"undefined"!=typeof module&&(module.exports=Showdown),"function"==typeof define&&define.amd&&define("showdown",function(){return Showdown}),"undefined"!=typeof angular&&"undefined"!=typeof Showdown&&!function(a,b){function c(){function a(){var a=new b.converter(c);this.makeHtml=function(b){return a.makeHtml(b)},this.stripHtml=function(a){return String(a).replace(/<[^>]+>/gm,"")}}var c={extensions:[],stripHtml:!0};this.setOption=function(a,b){return c.key=b,this},this.getOption=function(a){return c.hasOwnProperty(a)?c.key:null},this.loadExtension=function(a){return c.extensions.push(a),this},this.$get=function(){return new a}}function d(a){var b=function(b,c){b.$watch("model",function(b){var d;d="string"==typeof b?a.makeHtml(b):typeof b,c.html(d)})};return{restrict:"A",link:b,scope:{model:"=sdModelToHtml"}}}function e(){return function(a){return String(a).replace(/<[^>]+>/gm,"")}}a.provider("$Showdown",c).directive("sdModelToHtml",["$Showdown",d]).filter("sdStripHtml",e)}(angular.module("Showdown",[]),Showdown);
/* angular-load.js / v0.2.0 / (c) 2014 Uri Shaked / MIT Licence */

(function () {
	'use strict';

	angular.module('angularLoad', [])
		.service('angularLoad', ['$document', '$q', '$timeout', function ($document, $q, $timeout) {

			/**
			 * Dynamically loads the given script
			 * @param src The url of the script to load dynamically
			 * @returns {*} Promise that will be resolved once the script has been loaded.
			 */
			this.loadScript = function (src) {
				var deferred = $q.defer();
				var script = $document[0].createElement('script');
				script.onload = script.onreadystatechange = function (e) {
					$timeout(function () {
						deferred.resolve(e);
					});
				};
				script.onerror = function (e) {
					$timeout(function () {
						deferred.reject(e);
					});
				};
				script.src = src;
				$document[0].body.appendChild(script);
				return deferred.promise;
			};

			/**
			 * Dynamically loads the given CSS file
			 * @param href The url of the CSS to load dynamically
			 * @returns {*} Promise that will be resolved once the CSS file has been loaded.
			 */
			this.loadCSS = function (href) {
				var deferred = $q.defer();
				var style = $document[0].createElement('link');
				style.rel = 'stylesheet';
				style.type = 'text/css';
				style.href = href;
				style.onload = style.onreadystatechange = function (e) {
					$timeout(function () {
						deferred.resolve(e);
					});
				};
				style.onerror = function (e) {
					$timeout(function () {
						deferred.reject(e);
					});
				};
				$document[0].head.appendChild(style);
				return deferred.promise;
			};
		}]);
})();

/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 1.0.1-beta.3
 *
 * Copyright 2014 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */
(function(){"use strict";var t=this,i=t.Chart,e=function(t){this.canvas=t.canvas,this.ctx=t;this.width=t.canvas.width,this.height=t.canvas.height;return this.aspectRatio=this.width/this.height,s.retinaScale(this),this};e.defaults={global:{animation:!0,animationSteps:60,animationEasing:"easeOutQuart",showScale:!0,scaleOverride:!1,scaleSteps:null,scaleStepWidth:null,scaleStartValue:null,scaleLineColor:"rgba(0,0,0,.1)",scaleLineWidth:1,scaleShowLabels:!0,scaleLabel:"<%=value%>",scaleIntegersOnly:!0,scaleBeginAtZero:!1,scaleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",scaleFontSize:12,scaleFontStyle:"normal",scaleFontColor:"#666",responsive:!1,maintainAspectRatio:!0,showTooltips:!0,tooltipEvents:["mousemove","touchstart","touchmove","mouseout"],tooltipFillColor:"rgba(0,0,0,0.8)",tooltipFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipFontSize:14,tooltipFontStyle:"normal",tooltipFontColor:"#fff",tooltipTitleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipTitleFontSize:14,tooltipTitleFontStyle:"bold",tooltipTitleFontColor:"#fff",tooltipYPadding:6,tooltipXPadding:6,tooltipCaretSize:8,tooltipCornerRadius:6,tooltipXOffset:10,tooltipTemplate:"<%if (label){%><%=label%>: <%}%><%= value %>",multiTooltipTemplate:"<%= value %>",multiTooltipKeyBackground:"#fff",onAnimationProgress:function(){},onAnimationComplete:function(){}}},e.types={};var s=e.helpers={},n=s.each=function(t,i,e){var s=Array.prototype.slice.call(arguments,3);if(t)if(t.length===+t.length){var n;for(n=0;n<t.length;n++)i.apply(e,[t[n],n].concat(s))}else for(var o in t)i.apply(e,[t[o],o].concat(s))},o=s.clone=function(t){var i={};return n(t,function(e,s){t.hasOwnProperty(s)&&(i[s]=e)}),i},a=s.extend=function(t){return n(Array.prototype.slice.call(arguments,1),function(i){n(i,function(e,s){i.hasOwnProperty(s)&&(t[s]=e)})}),t},h=s.merge=function(){var t=Array.prototype.slice.call(arguments,0);return t.unshift({}),a.apply(null,t)},l=s.indexOf=function(t,i){if(Array.prototype.indexOf)return t.indexOf(i);for(var e=0;e<t.length;e++)if(t[e]===i)return e;return-1},r=s.inherits=function(t){var i=this,e=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return i.apply(this,arguments)},s=function(){this.constructor=e};return s.prototype=i.prototype,e.prototype=new s,e.extend=r,t&&a(e.prototype,t),e.__super__=i.prototype,e},c=s.noop=function(){},u=s.uid=function(){var t=0;return function(){return"chart-"+t++}}(),d=s.warn=function(t){window.console&&"function"==typeof window.console.warn&&console.warn(t)},p=s.amd="function"==typeof t.define&&t.define.amd,f=s.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},g=s.max=function(t){return Math.max.apply(Math,t)},m=s.min=function(t){return Math.min.apply(Math,t)},v=(s.cap=function(t,i,e){if(f(i)){if(t>i)return i}else if(f(e)&&e>t)return e;return t},s.getDecimalPlaces=function(t){return t%1!==0&&f(t)?t.toString().split(".")[1].length:0}),x=s.radians=function(t){return t*(Math.PI/180)},S=(s.getAngleFromPoint=function(t,i){var e=i.x-t.x,s=i.y-t.y,n=Math.sqrt(e*e+s*s),o=2*Math.PI+Math.atan2(s,e);return 0>e&&0>s&&(o+=2*Math.PI),{angle:o,distance:n}},s.aliasPixel=function(t){return t%2===0?0:.5}),C=(s.splineCurve=function(t,i,e,s){var n=Math.sqrt(Math.pow(i.x-t.x,2)+Math.pow(i.y-t.y,2)),o=Math.sqrt(Math.pow(e.x-i.x,2)+Math.pow(e.y-i.y,2)),a=s*n/(n+o),h=s*o/(n+o);return{inner:{x:i.x-a*(e.x-t.x),y:i.y-a*(e.y-t.y)},outer:{x:i.x+h*(e.x-t.x),y:i.y+h*(e.y-t.y)}}},s.calculateOrderOfMagnitude=function(t){return Math.floor(Math.log(t)/Math.LN10)}),y=(s.calculateScaleRange=function(t,i,e,s,n){var o=2,a=Math.floor(i/(1.5*e)),h=o>=a,l=g(t),r=m(t);l===r&&(l+=.5,r>=.5&&!s?r-=.5:l+=.5);for(var c=Math.abs(l-r),u=C(c),d=Math.ceil(l/(1*Math.pow(10,u)))*Math.pow(10,u),p=s?0:Math.floor(r/(1*Math.pow(10,u)))*Math.pow(10,u),f=d-p,v=Math.pow(10,u),x=Math.round(f/v);(x>a||a>2*x)&&!h;)if(x>a)v*=2,x=Math.round(f/v),x%1!==0&&(h=!0);else if(n&&u>=0){if(v/2%1!==0)break;v/=2,x=Math.round(f/v)}else v/=2,x=Math.round(f/v);return h&&(x=o,v=f/x),{steps:x,stepValue:v,min:p,max:p+x*v}},s.template=function(t,i){function e(t,i){var e=/\W/.test(t)?new Function("obj","var p=[],print=function(){p.push.apply(p,arguments);};with(obj){p.push('"+t.replace(/[\r\t\n]/g," ").split("<%").join("	").replace(/((^|%>)[^\t]*)'/g,"$1\r").replace(/\t=(.*?)%>/g,"',$1,'").split("	").join("');").split("%>").join("p.push('").split("\r").join("\\'")+"');}return p.join('');"):s[t]=s[t];return i?e(i):e}if(t instanceof Function)return t(i);var s={};return e(t,i)}),b=(s.generateLabels=function(t,i,e,s){var o=new Array(i);return labelTemplateString&&n(o,function(i,n){o[n]=y(t,{value:e+s*(n+1)})}),o},s.easingEffects={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-1*t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-0.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return 1*((t=t/1-1)*t*t+1)},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-1*((t=t/1-1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-0.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return 1*(t/=1)*t*t*t*t},easeOutQuint:function(t){return 1*((t=t/1-1)*t*t*t*t+1)},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return-1*Math.cos(t/1*(Math.PI/2))+1},easeOutSine:function(t){return 1*Math.sin(t/1*(Math.PI/2))},easeInOutSine:function(t){return-0.5*(Math.cos(Math.PI*t/1)-1)},easeInExpo:function(t){return 0===t?1:1*Math.pow(2,10*(t/1-1))},easeOutExpo:function(t){return 1===t?1:1*(-Math.pow(2,-10*t/1)+1)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(-Math.pow(2,-10*--t)+2)},easeInCirc:function(t){return t>=1?t:-1*(Math.sqrt(1-(t/=1)*t)-1)},easeOutCirc:function(t){return 1*Math.sqrt(1-(t=t/1-1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-0.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),-(s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)))},easeOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),s*Math.pow(2,-10*t)*Math.sin(2*(1*t-i)*Math.PI/e)+1)},easeInOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:2==(t/=.5)?1:(e||(e=.3*1.5),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),1>t?-.5*s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e):s*Math.pow(2,-10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)*.5+1)},easeInBack:function(t){var i=1.70158;return 1*(t/=1)*t*((i+1)*t-i)},easeOutBack:function(t){var i=1.70158;return 1*((t=t/1-1)*t*((i+1)*t+i)+1)},easeInOutBack:function(t){var i=1.70158;return(t/=.5)<1?.5*t*t*(((i*=1.525)+1)*t-i):.5*((t-=2)*t*(((i*=1.525)+1)*t+i)+2)},easeInBounce:function(t){return 1-b.easeOutBounce(1-t)},easeOutBounce:function(t){return(t/=1)<1/2.75?7.5625*t*t:2/2.75>t?1*(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?1*(7.5625*(t-=2.25/2.75)*t+.9375):1*(7.5625*(t-=2.625/2.75)*t+.984375)},easeInOutBounce:function(t){return.5>t?.5*b.easeInBounce(2*t):.5*b.easeOutBounce(2*t-1)+.5}}),w=s.requestAnimFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)}}(),P=(s.cancelAnimFrame=function(){return window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame||window.msCancelAnimationFrame||function(t){return window.clearTimeout(t,1e3/60)}}(),s.animationLoop=function(t,i,e,s,n,o){var a=0,h=b[e]||b.linear,l=function(){a++;var e=a/i,r=h(e);t.call(o,r,e,a),s.call(o,r,e),i>a?o.animationFrame=w(l):n.apply(o)};w(l)},s.getRelativePosition=function(t){var i,e,s=t.originalEvent||t,n=t.currentTarget||t.srcElement,o=n.getBoundingClientRect();return s.touches?(i=s.touches[0].clientX-o.left,e=s.touches[0].clientY-o.top):(i=s.clientX-o.left,e=s.clientY-o.top),{x:i,y:e}},s.addEvent=function(t,i,e){t.addEventListener?t.addEventListener(i,e):t.attachEvent?t.attachEvent("on"+i,e):t["on"+i]=e}),L=s.removeEvent=function(t,i,e){t.removeEventListener?t.removeEventListener(i,e,!1):t.detachEvent?t.detachEvent("on"+i,e):t["on"+i]=c},k=(s.bindEvents=function(t,i,e){t.events||(t.events={}),n(i,function(i){t.events[i]=function(){e.apply(t,arguments)},P(t.chart.canvas,i,t.events[i])})},s.unbindEvents=function(t,i){n(i,function(i,e){L(t.chart.canvas,e,i)})}),F=s.getMaximumWidth=function(t){var i=t.parentNode;return i.clientWidth},R=s.getMaximumHeight=function(t){var i=t.parentNode;return i.clientHeight},A=(s.getMaximumSize=s.getMaximumWidth,s.retinaScale=function(t){var i=t.ctx,e=t.canvas.width,s=t.canvas.height;window.devicePixelRatio&&(i.canvas.style.width=e+"px",i.canvas.style.height=s+"px",i.canvas.height=s*window.devicePixelRatio,i.canvas.width=e*window.devicePixelRatio,i.scale(window.devicePixelRatio,window.devicePixelRatio))}),T=s.clear=function(t){t.ctx.clearRect(0,0,t.width,t.height)},M=s.fontString=function(t,i,e){return i+" "+t+"px "+e},W=s.longestText=function(t,i,e){t.font=i;var s=0;return n(e,function(i){var e=t.measureText(i).width;s=e>s?e:s}),s},z=s.drawRoundedRectangle=function(t,i,e,s,n,o){t.beginPath(),t.moveTo(i+o,e),t.lineTo(i+s-o,e),t.quadraticCurveTo(i+s,e,i+s,e+o),t.lineTo(i+s,e+n-o),t.quadraticCurveTo(i+s,e+n,i+s-o,e+n),t.lineTo(i+o,e+n),t.quadraticCurveTo(i,e+n,i,e+n-o),t.lineTo(i,e+o),t.quadraticCurveTo(i,e,i+o,e),t.closePath()};e.instances={},e.Type=function(t,i,s){this.options=i,this.chart=s,this.id=u(),e.instances[this.id]=this,i.responsive&&this.resize(),this.initialize.call(this,t)},a(e.Type.prototype,{initialize:function(){return this},clear:function(){return T(this.chart),this},stop:function(){return s.cancelAnimFrame.call(t,this.animationFrame),this},resize:function(t){this.stop();var i=this.chart.canvas,e=F(this.chart.canvas),s=this.options.maintainAspectRatio?e/this.chart.aspectRatio:R(this.chart.canvas);return i.width=this.chart.width=e,i.height=this.chart.height=s,A(this.chart),"function"==typeof t&&t.apply(this,Array.prototype.slice.call(arguments,1)),this},reflow:c,render:function(t){return t&&this.reflow(),this.options.animation&&!t?s.animationLoop(this.draw,this.options.animationSteps,this.options.animationEasing,this.options.onAnimationProgress,this.options.onAnimationComplete,this):(this.draw(),this.options.onAnimationComplete.call(this)),this},generateLegend:function(){return y(this.options.legendTemplate,this)},destroy:function(){this.clear(),k(this,this.events),delete e.instances[this.id]},showTooltip:function(t,i){"undefined"==typeof this.activeElements&&(this.activeElements=[]);var o=function(t){var i=!1;return t.length!==this.activeElements.length?i=!0:(n(t,function(t,e){t!==this.activeElements[e]&&(i=!0)},this),i)}.call(this,t);if(o||i){if(this.activeElements=t,this.draw(),t.length>0)if(this.datasets&&this.datasets.length>1){for(var a,h,r=this.datasets.length-1;r>=0&&(a=this.datasets[r].points||this.datasets[r].bars||this.datasets[r].segments,h=l(a,t[0]),-1===h);r--);var c=[],u=[],d=function(){var t,i,e,n,o,a=[],l=[],r=[];return s.each(this.datasets,function(i){t=i.points||i.bars||i.segments,t[h]&&a.push(t[h])}),s.each(a,function(t){l.push(t.x),r.push(t.y),c.push(s.template(this.options.multiTooltipTemplate,t)),u.push({fill:t._saved.fillColor||t.fillColor,stroke:t._saved.strokeColor||t.strokeColor})},this),o=m(r),e=g(r),n=m(l),i=g(l),{x:n>this.chart.width/2?n:i,y:(o+e)/2}}.call(this,h);new e.MultiTooltip({x:d.x,y:d.y,xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,xOffset:this.options.tooltipXOffset,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,titleTextColor:this.options.tooltipTitleFontColor,titleFontFamily:this.options.tooltipTitleFontFamily,titleFontStyle:this.options.tooltipTitleFontStyle,titleFontSize:this.options.tooltipTitleFontSize,cornerRadius:this.options.tooltipCornerRadius,labels:c,legendColors:u,legendColorBackground:this.options.multiTooltipKeyBackground,title:t[0].label,chart:this.chart,ctx:this.chart.ctx}).draw()}else n(t,function(t){var i=t.tooltipPosition();new e.Tooltip({x:Math.round(i.x),y:Math.round(i.y),xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,caretHeight:this.options.tooltipCaretSize,cornerRadius:this.options.tooltipCornerRadius,text:y(this.options.tooltipTemplate,t),chart:this.chart}).draw()},this);return this}},toBase64Image:function(){return this.chart.canvas.toDataURL.apply(this.chart.canvas,arguments)}}),e.Type.extend=function(t){var i=this,s=function(){return i.apply(this,arguments)};if(s.prototype=o(i.prototype),a(s.prototype,t),s.extend=e.Type.extend,t.name||i.prototype.name){var n=t.name||i.prototype.name,l=e.defaults[i.prototype.name]?o(e.defaults[i.prototype.name]):{};e.defaults[n]=a(l,t.defaults),e.types[n]=s,e.prototype[n]=function(t,i){var o=h(e.defaults.global,e.defaults[n],i||{});return new s(t,o,this)}}else d("Name not provided for this chart, so it hasn't been registered");return i},e.Element=function(t){a(this,t),this.initialize.apply(this,arguments),this.save()},a(e.Element.prototype,{initialize:function(){},restore:function(t){return t?n(t,function(t){this[t]=this._saved[t]},this):a(this,this._saved),this},save:function(){return this._saved=o(this),delete this._saved._saved,this},update:function(t){return n(t,function(t,i){this._saved[i]=this[i],this[i]=t},this),this},transition:function(t,i){return n(t,function(t,e){this[e]=(t-this._saved[e])*i+this._saved[e]},this),this},tooltipPosition:function(){return{x:this.x,y:this.y}}}),e.Element.extend=r,e.Point=e.Element.extend({display:!0,inRange:function(t,i){var e=this.hitDetectionRadius+this.radius;return Math.pow(t-this.x,2)+Math.pow(i-this.y,2)<Math.pow(e,2)},draw:function(){if(this.display){var t=this.ctx;t.beginPath(),t.arc(this.x,this.y,this.radius,0,2*Math.PI),t.closePath(),t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.fillStyle=this.fillColor,t.fill(),t.stroke()}}}),e.Arc=e.Element.extend({inRange:function(t,i){var e=s.getAngleFromPoint(this,{x:t,y:i}),n=e.angle>=this.startAngle&&e.angle<=this.endAngle,o=e.distance>=this.innerRadius&&e.distance<=this.outerRadius;return n&&o},tooltipPosition:function(){var t=this.startAngle+(this.endAngle-this.startAngle)/2,i=(this.outerRadius-this.innerRadius)/2+this.innerRadius;return{x:this.x+Math.cos(t)*i,y:this.y+Math.sin(t)*i}},draw:function(t){var i=this.ctx;i.beginPath(),i.arc(this.x,this.y,this.outerRadius,this.startAngle,this.endAngle),i.arc(this.x,this.y,this.innerRadius,this.endAngle,this.startAngle,!0),i.closePath(),i.strokeStyle=this.strokeColor,i.lineWidth=this.strokeWidth,i.fillStyle=this.fillColor,i.fill(),i.lineJoin="bevel",this.showStroke&&i.stroke()}}),e.Rectangle=e.Element.extend({draw:function(){var t=this.ctx,i=this.width/2,e=this.x-i,s=this.x+i,n=this.base-(this.base-this.y),o=this.strokeWidth/2;this.showStroke&&(e+=o,s-=o,n+=o),t.beginPath(),t.fillStyle=this.fillColor,t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.moveTo(e,this.base),t.lineTo(e,n),t.lineTo(s,n),t.lineTo(s,this.base),t.fill(),this.showStroke&&t.stroke()},height:function(){return this.base-this.y},inRange:function(t,i){return t>=this.x-this.width/2&&t<=this.x+this.width/2&&i>=this.y&&i<=this.base}}),e.Tooltip=e.Element.extend({draw:function(){var t=this.chart.ctx;t.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.xAlign="center",this.yAlign="above";var i=2,e=t.measureText(this.text).width+2*this.xPadding,s=this.fontSize+2*this.yPadding,n=s+this.caretHeight+i;this.x+e/2>this.chart.width?this.xAlign="left":this.x-e/2<0&&(this.xAlign="right"),this.y-n<0&&(this.yAlign="below");var o=this.x-e/2,a=this.y-n;switch(t.fillStyle=this.fillColor,this.yAlign){case"above":t.beginPath(),t.moveTo(this.x,this.y-i),t.lineTo(this.x+this.caretHeight,this.y-(i+this.caretHeight)),t.lineTo(this.x-this.caretHeight,this.y-(i+this.caretHeight)),t.closePath(),t.fill();break;case"below":a=this.y+i+this.caretHeight,t.beginPath(),t.moveTo(this.x,this.y+i),t.lineTo(this.x+this.caretHeight,this.y+i+this.caretHeight),t.lineTo(this.x-this.caretHeight,this.y+i+this.caretHeight),t.closePath(),t.fill()}switch(this.xAlign){case"left":o=this.x-e+(this.cornerRadius+this.caretHeight);break;case"right":o=this.x-(this.cornerRadius+this.caretHeight)}z(t,o,a,e,s,this.cornerRadius),t.fill(),t.fillStyle=this.textColor,t.textAlign="center",t.textBaseline="middle",t.fillText(this.text,o+e/2,a+s/2)}}),e.MultiTooltip=e.Element.extend({initialize:function(){this.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.titleFont=M(this.titleFontSize,this.titleFontStyle,this.titleFontFamily),this.height=this.labels.length*this.fontSize+(this.labels.length-1)*(this.fontSize/2)+2*this.yPadding+1.5*this.titleFontSize,this.ctx.font=this.titleFont;var t=this.ctx.measureText(this.title).width,i=W(this.ctx,this.font,this.labels)+this.fontSize+3,e=g([i,t]);this.width=e+2*this.xPadding;var s=this.height/2;this.y-s<0?this.y=s:this.y+s>this.chart.height&&(this.y=this.chart.height-s),this.x>this.chart.width/2?this.x-=this.xOffset+this.width:this.x+=this.xOffset},getLineHeight:function(t){var i=this.y-this.height/2+this.yPadding,e=t-1;return 0===t?i+this.titleFontSize/2:i+(1.5*this.fontSize*e+this.fontSize/2)+1.5*this.titleFontSize},draw:function(){z(this.ctx,this.x,this.y-this.height/2,this.width,this.height,this.cornerRadius);var t=this.ctx;t.fillStyle=this.fillColor,t.fill(),t.closePath(),t.textAlign="left",t.textBaseline="middle",t.fillStyle=this.titleTextColor,t.font=this.titleFont,t.fillText(this.title,this.x+this.xPadding,this.getLineHeight(0)),t.font=this.font,s.each(this.labels,function(i,e){t.fillStyle=this.textColor,t.fillText(i,this.x+this.xPadding+this.fontSize+3,this.getLineHeight(e+1)),t.fillStyle=this.legendColorBackground,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize),t.fillStyle=this.legendColors[e].fill,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize)},this)}}),e.Scale=e.Element.extend({initialize:function(){this.fit()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(y(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}));this.yLabelWidth=this.display&&this.showLabels?W(this.ctx,this.font,this.yLabels):0},addXLabel:function(t){this.xLabels.push(t),this.valuesCount++,this.fit()},removeXLabel:function(){this.xLabels.shift(),this.valuesCount--,this.fit()},fit:function(){this.startPoint=this.display?this.fontSize:0,this.endPoint=this.display?this.height-1.5*this.fontSize-5:this.height,this.startPoint+=this.padding,this.endPoint-=this.padding;var t,i=this.endPoint-this.startPoint;for(this.calculateYRange(i),this.buildYLabels(),this.calculateXLabelRotation();i>this.endPoint-this.startPoint;)i=this.endPoint-this.startPoint,t=this.yLabelWidth,this.calculateYRange(i),this.buildYLabels(),t<this.yLabelWidth&&this.calculateXLabelRotation()},calculateXLabelRotation:function(){this.ctx.font=this.font;var t,i,e=this.ctx.measureText(this.xLabels[0]).width,s=this.ctx.measureText(this.xLabels[this.xLabels.length-1]).width;if(this.xScalePaddingRight=s/2+3,this.xScalePaddingLeft=e/2>this.yLabelWidth+10?e/2:this.yLabelWidth+10,this.xLabelRotation=0,this.display){var n,o=W(this.ctx,this.font,this.xLabels);this.xLabelWidth=o;for(var a=Math.floor(this.calculateX(1)-this.calculateX(0))-6;this.xLabelWidth>a&&0===this.xLabelRotation||this.xLabelWidth>a&&this.xLabelRotation<=90&&this.xLabelRotation>0;)n=Math.cos(x(this.xLabelRotation)),t=n*e,i=n*s,t+this.fontSize/2>this.yLabelWidth+8&&(this.xScalePaddingLeft=t+this.fontSize/2),this.xScalePaddingRight=this.fontSize/2,this.xLabelRotation++,this.xLabelWidth=n*o;this.xLabelRotation>0&&(this.endPoint-=Math.sin(x(this.xLabelRotation))*o+3)}else this.xLabelWidth=0,this.xScalePaddingRight=this.padding,this.xScalePaddingLeft=this.padding},calculateYRange:c,drawingArea:function(){return this.startPoint-this.endPoint},calculateY:function(t){var i=this.drawingArea()/(this.min-this.max);return this.endPoint-i*(t-this.min)},calculateX:function(t){var i=(this.xLabelRotation>0,this.width-(this.xScalePaddingLeft+this.xScalePaddingRight)),e=i/(this.valuesCount-(this.offsetGridLines?0:1)),s=e*t+this.xScalePaddingLeft;return this.offsetGridLines&&(s+=e/2),Math.round(s)},update:function(t){s.extend(this,t),this.fit()},draw:function(){var t=this.ctx,i=(this.endPoint-this.startPoint)/this.steps,e=Math.round(this.xScalePaddingLeft);this.display&&(t.fillStyle=this.textColor,t.font=this.font,n(this.yLabels,function(n,o){var a=this.endPoint-i*o,h=Math.round(a);t.textAlign="right",t.textBaseline="middle",this.showLabels&&t.fillText(n,e-10,a),t.beginPath(),o>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),h+=s.aliasPixel(t.lineWidth),t.moveTo(e,h),t.lineTo(this.width,h),t.stroke(),t.closePath(),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(e-5,h),t.lineTo(e,h),t.stroke(),t.closePath()},this),n(this.xLabels,function(i,e){var s=this.calculateX(e)+S(this.lineWidth),n=this.calculateX(e-(this.offsetGridLines?.5:0))+S(this.lineWidth),o=this.xLabelRotation>0;t.beginPath(),e>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),t.moveTo(n,this.endPoint),t.lineTo(n,this.startPoint-3),t.stroke(),t.closePath(),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(n,this.endPoint),t.lineTo(n,this.endPoint+5),t.stroke(),t.closePath(),t.save(),t.translate(s,o?this.endPoint+12:this.endPoint+8),t.rotate(-1*x(this.xLabelRotation)),t.font=this.font,t.textAlign=o?"right":"center",t.textBaseline=o?"middle":"top",t.fillText(i,0,0),t.restore()},this))}}),e.RadialScale=e.Element.extend({initialize:function(){this.size=m([this.height,this.width]),this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2},calculateCenterOffset:function(t){var i=this.drawingArea/(this.max-this.min);return(t-this.min)*i},update:function(){this.lineArc?this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2:this.setScaleSize(),this.buildYLabels()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(y(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}))},getCircumference:function(){return 2*Math.PI/this.valuesCount},setScaleSize:function(){var t,i,e,s,n,o,a,h,l,r,c,u,d=m([this.height/2-this.pointLabelFontSize-5,this.width/2]),p=this.width,g=0;for(this.ctx.font=M(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),i=0;i<this.valuesCount;i++)t=this.getPointPosition(i,d),e=this.ctx.measureText(y(this.templateString,{value:this.labels[i]})).width+5,0===i||i===this.valuesCount/2?(s=e/2,t.x+s>p&&(p=t.x+s,n=i),t.x-s<g&&(g=t.x-s,a=i)):i<this.valuesCount/2?t.x+e>p&&(p=t.x+e,n=i):i>this.valuesCount/2&&t.x-e<g&&(g=t.x-e,a=i);l=g,r=Math.ceil(p-this.width),o=this.getIndexAngle(n),h=this.getIndexAngle(a),c=r/Math.sin(o+Math.PI/2),u=l/Math.sin(h+Math.PI/2),c=f(c)?c:0,u=f(u)?u:0,this.drawingArea=d-(u+c)/2,this.setCenterPoint(u,c)},setCenterPoint:function(t,i){var e=this.width-i-this.drawingArea,s=t+this.drawingArea;this.xCenter=(s+e)/2,this.yCenter=this.height/2},getIndexAngle:function(t){var i=2*Math.PI/this.valuesCount;return t*i-Math.PI/2},getPointPosition:function(t,i){var e=this.getIndexAngle(t);return{x:Math.cos(e)*i+this.xCenter,y:Math.sin(e)*i+this.yCenter}},draw:function(){if(this.display){var t=this.ctx;if(n(this.yLabels,function(i,e){if(e>0){var s,n=e*(this.drawingArea/this.steps),o=this.yCenter-n;if(this.lineWidth>0)if(t.strokeStyle=this.lineColor,t.lineWidth=this.lineWidth,this.lineArc)t.beginPath(),t.arc(this.xCenter,this.yCenter,n,0,2*Math.PI),t.closePath(),t.stroke();else{t.beginPath();for(var a=0;a<this.valuesCount;a++)s=this.getPointPosition(a,this.calculateCenterOffset(this.min+e*this.stepValue)),0===a?t.moveTo(s.x,s.y):t.lineTo(s.x,s.y);t.closePath(),t.stroke()}if(this.showLabels){if(t.font=M(this.fontSize,this.fontStyle,this.fontFamily),this.showLabelBackdrop){var h=t.measureText(i).width;t.fillStyle=this.backdropColor,t.fillRect(this.xCenter-h/2-this.backdropPaddingX,o-this.fontSize/2-this.backdropPaddingY,h+2*this.backdropPaddingX,this.fontSize+2*this.backdropPaddingY)}t.textAlign="center",t.textBaseline="middle",t.fillStyle=this.fontColor,t.fillText(i,this.xCenter,o)}}},this),!this.lineArc){t.lineWidth=this.angleLineWidth,t.strokeStyle=this.angleLineColor;for(var i=this.valuesCount-1;i>=0;i--){if(this.angleLineWidth>0){var e=this.getPointPosition(i,this.calculateCenterOffset(this.max));t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(e.x,e.y),t.stroke(),t.closePath()}var s=this.getPointPosition(i,this.calculateCenterOffset(this.max)+5);t.font=M(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),t.fillStyle=this.pointLabelFontColor;var o=this.labels.length,a=this.labels.length/2,h=a/2,l=h>i||i>o-h,r=i===h||i===o-h;t.textAlign=0===i?"center":i===a?"center":a>i?"left":"right",t.textBaseline=r?"middle":l?"bottom":"top",t.fillText(this.labels[i],s.x,s.y)}}}}}),s.addEvent(window,"resize",function(){var t;return function(){clearTimeout(t),t=setTimeout(function(){n(e.instances,function(t){t.options.responsive&&t.resize(t.render,!0)})},50)}}()),p?define(function(){return e}):"object"==typeof module&&module.exports&&(module.exports=e),t.Chart=e,e.noConflict=function(){return t.Chart=i,e}}).call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleBeginAtZero:!0,scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,barShowStroke:!0,barStrokeWidth:2,barValueSpacing:5,barDatasetSpacing:1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].fillColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Bar",defaults:s,initialize:function(t){var s=this.options;this.ScaleClass=i.Scale.extend({offsetGridLines:!0,calculateBarX:function(t,i,e){var n=this.calculateBaseWidth(),o=this.calculateX(e)-n/2,a=this.calculateBarWidth(t);return o+a*i+i*s.barDatasetSpacing+a/2},calculateBaseWidth:function(){return this.calculateX(1)-this.calculateX(0)-2*s.barValueSpacing},calculateBarWidth:function(t){var i=this.calculateBaseWidth()-(t-1)*s.barDatasetSpacing;return i/t}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getBarsAtEvent(t):[];this.eachBars(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),this.BarClass=i.Rectangle.extend({strokeWidth:this.options.barStrokeWidth,showStroke:this.options.barShowStroke,ctx:this.chart.ctx}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,bars:[]};this.datasets.push(s),e.each(i.data,function(n,o){e.isNumber(n)&&s.bars.push(new this.BarClass({value:n,label:t.labels[o],datasetLabel:i.label,strokeColor:i.strokeColor,fillColor:i.fillColor,highlightFill:i.highlightFill||i.fillColor,highlightStroke:i.highlightStroke||i.strokeColor}))},this)},this),this.buildScale(t.labels),this.BarClass.prototype.base=this.scale.endPoint,this.eachBars(function(t,i,s){e.extend(t,{width:this.scale.calculateBarWidth(this.datasets.length),x:this.scale.calculateBarX(this.datasets.length,s,i),y:this.scale.endPoint}),t.save()},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachBars(function(t){t.save()}),this.render()},eachBars:function(t){e.each(this.datasets,function(i,s){e.each(i.bars,t,this,s)},this)},getBarsAtEvent:function(t){for(var i,s=[],n=e.getRelativePosition(t),o=function(t){s.push(t.bars[i])},a=0;a<this.datasets.length;a++)for(i=0;i<this.datasets[a].bars.length;i++)if(this.datasets[a].bars[i].inRange(n.x,n.y))return e.each(this.datasets,o),s;return s},buildScale:function(t){var i=this,s=function(){var t=[];return i.eachBars(function(i){t.push(i.value)}),t},n={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(s(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.barShowStroke?this.options.barStrokeWidth:0,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(n,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new this.ScaleClass(n)},addData:function(t,i){e.each(t,function(t,s){e.isNumber(t)&&this.datasets[s].bars.push(new this.BarClass({value:t,label:i,x:this.scale.calculateBarX(this.datasets.length,s,this.scale.valuesCount+1),y:this.scale.endPoint,width:this.scale.calculateBarWidth(this.datasets.length),base:this.scale.endPoint,strokeColor:this.datasets[s].strokeColor,fillColor:this.datasets[s].fillColor}))},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.bars.shift()},this),this.update()},reflow:function(){e.extend(this.BarClass.prototype,{y:this.scale.endPoint,base:this.scale.endPoint});var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();this.chart.ctx;this.scale.draw(i),e.each(this.datasets,function(t,s){e.each(t.bars,function(t,e){t.base=this.scale.endPoint,t.transition({x:this.scale.calculateBarX(this.datasets.length,s,e),y:this.scale.calculateY(t.value),width:this.scale.calculateBarWidth(this.datasets.length)},i).draw()},this)},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,percentageInnerCutout:50,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Doughnut",defaults:s,initialize:function(t){this.segments=[],this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,this.SegmentArc=i.Arc.extend({ctx:this.chart.ctx,x:this.chart.width/2,y:this.chart.height/2}),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];
e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.calculateTotal(t),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({value:t.value,outerRadius:this.options.animateScale?0:this.outerRadius,innerRadius:this.options.animateScale?0:this.outerRadius/100*this.options.percentageInnerCutout,fillColor:t.color,highlightColor:t.highlight||t.color,showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,startAngle:1.5*Math.PI,circumference:this.options.animateRotate?0:this.calculateCircumference(t.value),label:t.label})),e||(this.reflow(),this.update())},calculateCircumference:function(t){return 2*Math.PI*(t/this.total)},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=t.value},this)},update:function(){this.calculateTotal(this.segments),e.each(this.activeElements,function(t){t.restore(["fillColor"])}),e.each(this.segments,function(t){t.save()}),this.render()},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,e.each(this.segments,function(t){t.update({outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout})},this)},draw:function(t){var i=t?t:1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.calculateCircumference(t.value),outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout},i),t.endAngle=t.startAngle+t.circumference,t.draw(),0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle)},this)}}),i.types.Doughnut.extend({name:"Pie",defaults:e.merge(s,{percentageInnerCutout:0})})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,bezierCurve:!0,bezierCurveTension:.4,pointDot:!0,pointDotRadius:4,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Line",defaults:s,initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx,inRange:function(t){return Math.pow(t-this.x,2)<Math.pow(this.radius+this.hitDetectionRadius,2)}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(n,o){e.isNumber(n)&&s.points.push(new this.PointClass({value:n,label:t.labels[o],datasetLabel:i.label,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))},this),this.buildScale(t.labels),this.eachPoints(function(t,i){e.extend(t,{x:this.scale.calculateX(i),y:this.scale.endPoint}),t.save()},this)},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachPoints(function(t){t.save()}),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.datasets,function(t){e.each(t.points,function(t){t.inRange(s.x,s.y)&&i.push(t)})},this),i},buildScale:function(t){var s=this,n=function(){var t=[];return s.eachPoints(function(i){t.push(i.value)}),t},o={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(n(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.pointDotRadius+this.options.pointDotStrokeWidth,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(o,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new i.Scale(o)},addData:function(t,i){e.each(t,function(t,s){e.isNumber(t)&&this.datasets[s].points.push(new this.PointClass({value:t,label:i,x:this.scale.calculateX(this.scale.valuesCount+1),y:this.scale.endPoint,strokeColor:this.datasets[s].pointStrokeColor,fillColor:this.datasets[s].pointColor}))},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.points.shift()},this),this.update()},reflow:function(){var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();var s=this.chart.ctx;this.scale.draw(i),e.each(this.datasets,function(t){e.each(t.points,function(t,e){t.transition({y:this.scale.calculateY(t.value),x:this.scale.calculateX(e)},i)},this),this.options.bezierCurve&&e.each(t.points,function(i,s){i.controlPoints=0===s?e.splineCurve(i,i,t.points[s+1],0):s>=t.points.length-1?e.splineCurve(t.points[s-1],i,i,0):e.splineCurve(t.points[s-1],i,t.points[s+1],this.options.bezierCurveTension)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(t.points,function(i,e){e>0?this.options.bezierCurve?s.bezierCurveTo(t.points[e-1].controlPoints.outer.x,t.points[e-1].controlPoints.outer.y,i.controlPoints.inner.x,i.controlPoints.inner.y,i.x,i.y):s.lineTo(i.x,i.y):s.moveTo(i.x,i.y)},this),s.stroke(),this.options.datasetFill&&(s.lineTo(t.points[t.points.length-1].x,this.scale.endPoint),s.lineTo(this.scale.calculateX(0),this.scale.endPoint),s.fillStyle=t.fillColor,s.closePath(),s.fill()),e.each(t.points,function(t){t.draw()})},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowLabelBackdrop:!0,scaleBackdropColor:"rgba(255,255,255,0.75)",scaleBeginAtZero:!0,scaleBackdropPaddingY:2,scaleBackdropPaddingX:2,scaleShowLine:!0,segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"PolarArea",defaults:s,initialize:function(t){this.segments=[],this.SegmentArc=i.Arc.extend({showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,ctx:this.chart.ctx,innerRadius:0,x:this.chart.width/2,y:this.chart.height/2}),this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,lineArc:!0,width:this.chart.width,height:this.chart.height,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,valuesCount:t.length}),this.updateScaleRange(t),this.scale.update(),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({fillColor:t.color,highlightColor:t.highlight||t.color,label:t.label,value:t.value,outerRadius:this.options.animateScale?0:this.scale.calculateCenterOffset(t.value),circumference:this.options.animateRotate?0:this.scale.getCircumference(),startAngle:1.5*Math.PI})),e||(this.reflow(),this.update())},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=t.value},this),this.scale.valuesCount=this.segments.length},updateScaleRange:function(t){var i=[];e.each(t,function(t){i.push(t.value)});var s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s,{size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2})},update:function(){this.calculateTotal(this.segments),e.each(this.segments,function(t){t.save()}),this.render()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.updateScaleRange(this.segments),this.scale.update(),e.extend(this.scale,{xCenter:this.chart.width/2,yCenter:this.chart.height/2}),e.each(this.segments,function(t){t.update({outerRadius:this.scale.calculateCenterOffset(t.value)})},this)},draw:function(t){var i=t||1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.scale.getCircumference(),outerRadius:this.scale.calculateCenterOffset(t.value)},i),t.endAngle=t.startAngle+t.circumference,0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle),t.draw()},this),this.scale.draw()}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers;i.Type.extend({name:"Radar",defaults:{scaleShowLine:!0,angleShowLineOut:!0,scaleShowLabels:!1,scaleBeginAtZero:!0,angleLineColor:"rgba(0,0,0,.1)",angleLineWidth:1,pointLabelFontFamily:"'Arial'",pointLabelFontStyle:"normal",pointLabelFontSize:10,pointLabelFontColor:"#666",pointDot:!0,pointDotRadius:3,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'},initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx}),this.datasets=[],this.buildScale(t),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(n,o){if(e.isNumber(n)){var a;this.scale.animation||(a=this.scale.getPointPosition(o,this.scale.calculateCenterOffset(n))),s.points.push(new this.PointClass({value:n,label:t.labels[o],datasetLabel:i.label,x:this.options.animation?this.scale.xCenter:a.x,y:this.options.animation?this.scale.yCenter:a.y,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))}},this)},this),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=e.getRelativePosition(t),s=e.getAngleFromPoint({x:this.scale.xCenter,y:this.scale.yCenter},i),n=2*Math.PI/this.scale.valuesCount,o=Math.round((s.angle-1.5*Math.PI)/n),a=[];return(o>=this.scale.valuesCount||0>o)&&(o=0),s.distance<=this.scale.drawingArea&&e.each(this.datasets,function(t){a.push(t.points[o])}),a},buildScale:function(t){this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,angleLineColor:this.options.angleLineColor,angleLineWidth:this.options.angleShowLineOut?this.options.angleLineWidth:0,pointLabelFontColor:this.options.pointLabelFontColor,pointLabelFontSize:this.options.pointLabelFontSize,pointLabelFontFamily:this.options.pointLabelFontFamily,pointLabelFontStyle:this.options.pointLabelFontStyle,height:this.chart.height,width:this.chart.width,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,labels:t.labels,valuesCount:t.datasets[0].data.length}),this.scale.setScaleSize(),this.updateScaleRange(t.datasets),this.scale.buildYLabels()},updateScaleRange:function(t){var i=function(){var i=[];return e.each(t,function(t){t.data?i=i.concat(t.data):e.each(t.points,function(t){i.push(t.value)})}),i}(),s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s)},addData:function(t,i){this.scale.valuesCount++,e.each(t,function(t,s){if(e.isNumber(t)){var n=this.scale.getPointPosition(this.scale.valuesCount,this.scale.calculateCenterOffset(t));this.datasets[s].points.push(new this.PointClass({value:t,label:i,x:n.x,y:n.y,strokeColor:this.datasets[s].pointStrokeColor,fillColor:this.datasets[s].pointColor}))}},this),this.scale.labels.push(i),this.reflow(),this.update()},removeData:function(){this.scale.valuesCount--,this.scale.labels.shift(),e.each(this.datasets,function(t){t.points.shift()},this),this.reflow(),this.update()},update:function(){this.eachPoints(function(t){t.save()}),this.reflow(),this.render()},reflow:function(){e.extend(this.scale,{width:this.chart.width,height:this.chart.height,size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2}),this.updateScaleRange(this.datasets),this.scale.setScaleSize(),this.scale.buildYLabels()},draw:function(t){var i=t||1,s=this.chart.ctx;this.clear(),this.scale.draw(),e.each(this.datasets,function(t){e.each(t.points,function(t,e){t.transition(this.scale.getPointPosition(e,this.scale.calculateCenterOffset(t.value)),i)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(t.points,function(t,i){0===i?s.moveTo(t.x,t.y):s.lineTo(t.x,t.y)},this),s.closePath(),s.stroke(),s.fillStyle=t.fillColor,s.fill(),e.each(t.points,function(t){t.draw()})},this)}})}.call(this);
var angles = angular.module("angles", []);

angles.chart = function (type) {
    return { 
        restrict: "A",
        scope: {
            data: "=",
            options: "=",
            id: "@",
            width: "=",
            height: "=",
            resize: "=",
            chart: "@",
            segments: "@",
            responsive: "=",
            tooltip: "=",
            legend: "="
        },
        link: function ($scope, $elem) {
            var ctx = $elem[0].getContext("2d");
            var autosize = false;

			$scope.size = function () {
	            if ($scope.width <= 0) {
	                $elem.width($elem.parent().width());
	                ctx.canvas.width = $elem.width();
	            } else {
	                ctx.canvas.width = $scope.width || ctx.canvas.width;
	                autosize = true;
	            }

                if($scope.height <= 0){
                    $elem.height($elem.parent().height());
                    ctx.canvas.height = ctx.canvas.width / 2;
                } else {
                    ctx.canvas.height = $scope.height || ctx.canvas.height;
                    autosize = true;
                }
			}

            $scope.$watch("data", function (newVal, oldVal) {

                if(chartCreated)
                    chartCreated.destroy();
                   
                $scope.options = $scope.options || {};
                    
                // if data not defined, exit
                if (!newVal) {
                    return;
                }
                if ($scope.chart) { type = $scope.chart; }
                
                if(autosize){
                    $scope.size();
                    chart = new Chart(ctx);
                };

                if($scope.responsive || $scope.resize)
                    $scope.options.responsive = true;

                if($scope.responsive !== undefined)
                    $scope.options.responsive = $scope.responsive;

                chartCreated = chart[type]($scope.data, $scope.options);
                chartCreated.update();
                if($scope.legend)
                    angular.element($elem[0]).parent().after( chartCreated.generateLegend() );
            }, true);

            $scope.$watch("tooltip", function (newVal, oldVal) {
                if (chartCreated)
                    chartCreated.draw();
                if(newVal===undefined || !chartCreated.segments)
                    return;
                if(!isFinite(newVal) || newVal >= chartCreated.segments.length || newVal < 0)
                    return;
                var activeSegment = chartCreated.segments[newVal];
                activeSegment.save();
                activeSegment.fillColor = activeSegment.highlightColor;
                chartCreated.showTooltip([activeSegment]);
                activeSegment.restore();
            }, true);

            $scope.size();
            var chart = new Chart(ctx);
            var chartCreated;
        }
    }
}


/* Aliases for various chart types */
angles.directive("chart", function () { return angles.chart(); });
angles.directive("linechart", function () { return angles.chart("Line"); });
angles.directive("barchart", function () { return angles.chart("Bar"); });
angles.directive("radarchart", function () { return angles.chart("Radar"); });
angles.directive("polarchart", function () { return angles.chart("PolarArea"); });
angles.directive("piechart", function () { return angles.chart("Pie"); });
angles.directive("doughnutchart", function () { return angles.chart("Doughnut"); });
angles.directive("donutchart", function () { return angles.chart("Doughnut"); });

//! Copyright (c) Microsoft Corporation. All rights reserved.
(function(n){function require(n){var i,r;if(n&&n.length>2&&n[0]=="."&&n[1]=="/"&&(n=n.slice(2)),i=t[n],typeof i=="function")return r={},t[n]=r,i(r),r;if(typeof i=="object")return i;throw"Unknown module "+n;}var t={},i="1.2.21003.0";t.Resources={},t.Resources["en-US"]={Validate_NotNullError:"{0} cannot be null.",Validate_NotNullOrEmptyError:"{0} cannot be null or empty.",Validate_InvalidId:"{0} is not valid.",Validate_TypeCheckError:"{0} is expected to be a value of type {1}, not {2}.",Validate_LengthUnexpected:"{0} is expected to have length {1}, not {2}.",Validate_InvalidUserParameter:"{0} contains an invalid user-defined query string parameter: {1}. User-defined query string parameters must not begin with a '$'.",Extensions_DefaultErrorMessage:"Unexpected failure.",Extensions_ConnectionFailureMessage:"Unexpected connection failure.",MobileServiceTable_ReadMismatchedQueryTables:"Cannot get the results of a query for table '{1}' via table '{0}'.",MobileServiceTable_InsertIdAlreadySet:"Cannot insert if the {0} member is already set.",MobileServiceLogin_AuthenticationProviderNotSupported:"Unsupported authentication provider name. Please specify one of {0}.",MobileServiceLogin_LoginErrorResponse:"Cannot start a login operation because login is already in progress.",MobileServiceLogin_InvalidResponseFormat:"Invalid format of the authentication response.",MobileServiceLogin_InvalidProvider:"The first parameter must be the name of the autentication provider or a Microsoft Account authentication token.",MobileServiceTable_NotSingleObject:"Could not get object from response {0}.",Push_ConflictWithReservedName:"Template name conflicts with reserved name '{0}'.",Push_InvalidTemplateName:"Template name can't contain ';' or ':'.",Push_NotSupportedXMLFormatAsBodyTemplateWin8:"The bodyTemplate is not in accepted XML format. The first node of the bodyTemplate should be Badge/Tile/Toast, except for the wns/raw template, which need to be a valid XML.",Push_BodyTemplateMustBeXml:"Valid XML is required for any template without a raw header.",Push_TagNoCommas:"Tags must not contain ','."},t.MobileServiceClient=function(n){function MobileServiceClient(n,t){i.isString(n,"applicationUrl"),i.notNullOrEmpty(n,"applicationUrl"),i.isString(t,"applicationKey"),this.applicationUrl=n,this.applicationKey=t||null;var u=r.getSdkInfo(),e=r.getOperatingSystemInfo(),h=u.fileVersion.split(".").slice(0,2).join(".");this.version="ZUMO/"+h+" (lang="+u.language+"; os="+e.name+"; os_version="+e.version+"; arch="+e.architecture+"; version="+u.fileVersion+")",this.currentUser=null,this._serviceFilter=null,this._login=new s(this),this.getTable=function(n){return i.isString(n,"tableName"),i.notNullOrEmpty(n,"tableName"),new o(n,this)},f&&(this.push=new f(this))}function getApplicationInstallationId(){var n=null,i="MobileServices.Installation.config",u=r.readSetting(i),f,e;if(!t.isNull(u))try{f=t.fromJson(u),n=f.applicationInstallationId}catch(o){}return t.isNullOrEmpty(n)&&(n=t.createUniqueInstallationId(),e=t.toJson({applicationInstallationId:n}),r.writeSetting(i,e)),n}var t=require("Extensions"),i=require("Validate"),r=require("Platform"),o=require("MobileServiceTable").MobileServiceTable,s=require("MobileServiceLogin").MobileServiceLogin,f,u,e;try{f=require("Push").Push}catch(h){}u={JsonApiCall:"AJ",GenericApiCall:"AG",AdditionalQueryParameters:"QS",OptimisticConcurrency:"OC",TableRefreshCall:"RF",TableReadRaw:"TR",TableReadQuery:"TQ"},e="X-ZUMO-FEATURES",n.MobileServiceClient=MobileServiceClient,r.addToMobileServicesClientNamespace({MobileServiceClient:MobileServiceClient}),MobileServiceClient.prototype.withFilter=function(n){var r,u;return i.notNull(n,"serviceFilter"),r=new MobileServiceClient(this.applicationUrl,this.applicationKey),r.currentUser=this.currentUser,u=this._serviceFilter,r._serviceFilter=t.isNull(u)?n:function(t,i,r){var f=function(n,t){u(n,i,t)};n(t,f,r)},r},MobileServiceClient.prototype._request=function(n,u,f,o,s,h,c){var l,a;t.isNull(c)&&typeof h=="function"&&(c=h,h=null),t.isNull(c)&&typeof s=="function"&&(c=s,s=null),t.isNull(c)&&typeof o=="function"&&(c=o,o=!1),t.isNull(c)&&typeof f=="function"&&(c=f,f=null),i.isString(n,"method"),i.notNullOrEmpty(n,"method"),i.isString(u,"uriFragment"),i.notNull(u,"uriFragment"),i.notNull(c,"callback"),l={type:n.toUpperCase()},l.url=t.url.isAbsoluteUrl(u)?u:t.url.combinePathSegments(this.applicationUrl,u),l.headers={},t.isNull(s)||t.extend(l.headers,s),l.headers["X-ZUMO-INSTALLATION-ID"]=MobileServiceClient._applicationInstallationId,t.isNullOrEmpty(this.applicationKey)||(l.headers["X-ZUMO-APPLICATION"]=this.applicationKey),this.currentUser&&!t.isNullOrEmpty(this.currentUser.mobileServiceAuthenticationToken)&&(l.headers["X-ZUMO-AUTH"]=this.currentUser.mobileServiceAuthenticationToken),t.isNull(MobileServiceClient._userAgent)||(l.headers["User-Agent"]=MobileServiceClient._userAgent),t.isNullOrEmpty["X-ZUMO-VERSION"]||(l.headers["X-ZUMO-VERSION"]=this.version),t.isNull(l.headers[e])&&h&&h.length&&(l.headers[e]=h.join(",")),t.isNull(f)?l.data=null:(l.data=t.isString(f)?f:t.toJson(f),t.hasProperty(l.headers,["Content-Type","content-type","CONTENT-TYPE","Content-type"])||(l.headers["Content-Type"]="application/json")),a=function(n,i){t.isNull(n)?!t.isNull(i)&&(i.status>=400||i.status===0)&&(n=t.createError(null,i),i=null):n=t.createError(n),c(n,i)},t.isNull(this._serviceFilter)||o?r.webRequest(l,a):this._serviceFilter(l,r.webRequest,a)},MobileServiceClient.prototype.loginWithOptions=r.async(function(n,t,i){this._login.loginWithOptions(n,t,i)}),MobileServiceClient.prototype.login=r.async(function(n,t,i,r){this._login.login(n,t,i,r)}),MobileServiceClient.prototype.logout=function(){this.currentUser=null},MobileServiceClient.prototype.invokeApi=r.async(function(n,r,f){var e,o,s,l,h,a,c;i.isString(n,"apiName"),t.isNull(f)&&typeof r=="function"&&(f=r,r=null),i.notNull(f,"callback"),t.isNull(r)||(e=r.parameters,t.isNull(e)||i.isValidParametersObject(r.parameters),o=r.method,s=r.body,l=r.headers),t.isNull(o)&&(o="POST"),h=t.url.combinePathSegments("api",n),t.isNull(e)||(a=t.url.getQueryString(e),h=t.url.combinePathAndQuery(h,a)),c=[],t.isNullOrEmpty(s)||c.push(t.isString(s)?u.GenericApiCall:u.JsonApiCall),t.isNull(e)||c.push(u.AdditionalQueryParameters),this._request(o,h,s,null,l,c,function(n,i){if(t.isNull(n)){var r;if(typeof i.getResponseHeader!="undefined"&&(r=i.getResponseHeader("Content-Type")),r)r.toLowerCase().indexOf("json")!==-1&&(i.result=t.fromJson(i.responseText));else try{i.result=t.fromJson(i.responseText)}catch(u){}f(null,i)}else f(n,null)})}),MobileServiceClient._applicationInstallationId=getApplicationInstallationId(),MobileServiceClient._userAgent=r.getUserAgent(),MobileServiceClient._zumoFeatures=u},t.MobileServiceTable=function(n){function MobileServiceTable(n,t){this.getTableName=function(){return n},this.getMobileServiceClient=function(){return t},this.systemProperties=0}function removeSystemProperties(n){var i={},t;for(t in n)t.substr(0,2)!=="__"&&(i[t]=n[t]);return i}function addSystemProperties(n,i,r){if(i===e.None||typeof r=="string"&&r.toLowerCase().indexOf("__systemproperties")>=0||(n=n||{},!t.isNull(n.__systemProperties)))return n;if(i===e.All)n.__systemProperties="*";else{var u=[];e.CreatedAt&i&&u.push(s.CreatedAt),e.UpdatedAt&i&&u.push(s.UpdatedAt),e.Version&i&&u.push(s.Version),n.__systemProperties=u.join(",")}return n}function getItemFromResponse(n){var r=t.fromJson(n.responseText),i;return n.getResponseHeader&&(i=n.getResponseHeader("ETag"),t.isNullOrEmpty(i)||(r.__version=getVersionFromEtag(i))),r}function setServerItemIfPreconditionFailed(n){n.request&&n.request.status===412&&(n.serverInstance=t.fromJson(n.request.responseText))}function getEtagFromVersion(n){var t=n.replace(/\"/g,'\\"');return'"'+t+'"'}function getVersionFromEtag(n){var t=n.length,i=n;return t>1&&n[0]==='"'&&n[t-1]==='"'&&(i=n.substr(1,t-2)),i.replace(/\\\"/g,'"')}function addQueryParametersFeaturesIfApplicable(n,i){var r=!1,u;if(i)if(Array.isArray(i))r=i.length>0;else if(t.isObject(i))for(u in i){r=!0;break}return r&&n.push(WindowsAzure.MobileServiceClient._zumoFeatures.AdditionalQueryParameters),n}var t=require("Extensions"),r=require("Validate"),u=require("Platform"),l=require("Query").Query,i="id",f="tables",o=["ID","Id","id","iD"],a=/^(.*?);\s*rel\s*=\s*(\w+)\s*$/,e={None:0,CreatedAt:1,UpdatedAt:2,Version:4,All:65535},s={CreatedAt:"__createdAt",UpdatedAt:"__updatedAt",Version:"__version"};u.addToMobileServicesClientNamespace({MobileServiceTable:{SystemProperties:e}}),n.MobileServiceTable=MobileServiceTable,MobileServiceTable.prototype._read=function(n,i,e){var s,p,w,y,h;t.isNull(e)&&(t.isNull(i)&&typeof n=="function"?(e=n,n=null,i=null):typeof i=="function"&&(e=i,i=null,!t.isNull(n)&&t.isObject(n)&&!t.isString(n)&&t.isNull(n.toOData)&&(i=n,n=null))),n&&t.isString(n)&&r.notNullOrEmpty(n,"query"),t.isNull(i)||r.isValidParametersObject(i,"parameters"),r.notNull(e,"callback");var l=this.getTableName(),o=null,v=null,c=[];if(t.isString(n))o=n,t.isNullOrEmpty(n)||c.push(WindowsAzure.MobileServiceClient._zumoFeatures.TableReadRaw);else if(t.isObject(n)&&!t.isNull(n.toOData)&&n.getComponents&&(c.push(WindowsAzure.MobileServiceClient._zumoFeatures.TableReadQuery),s=n.getComponents(),v=s.projection,s.table)){if(l!==s.table){p=t.format(u.getResourceString("MobileServiceTable_ReadMismatchedQueryTables"),l,s.table),e(t.createError(p),null);return}w=n.toOData(),o=w.replace(new RegExp("^/"+s.table),"")}addQueryParametersFeaturesIfApplicable(c,i),i=addSystemProperties(i,this.systemProperties,o),t.isNull(i)||(y=t.url.getQueryString(i),t.isNullOrEmpty(o)?o=y:o+="&"+y),h=o,t.url.isAbsoluteUrl(h)||(h=t.url.combinePathSegments(f,l),t.isNull(o)||(h=t.url.combinePathAndQuery(h,o))),this.getMobileServiceClient()._request("GET",h,null,!1,null,c,function(n,i){var r=null,u,o,f;if(t.isNull(n)){if(r=t.fromJson(i.responseText),r&&!Array.isArray(r)&&typeof r.count!="undefined"&&typeof r.results!="undefined"&&(r.results.totalCount=r.count,r=r.results),v!==null)for(u=0,u=0;u<r.length;u++)r[u]=v.call(r[u]);Array.isArray(r)&&i.getResponseHeader&&t.isNull(r.nextLink)&&(o=i.getResponseHeader("Link"),t.isNullOrEmpty(o)||(f=a.exec(o),f&&f.length===3&&f[2]=="next"&&(r.nextLink=f[1])))}e(n,r)})},MobileServiceTable.prototype.read=u.async(MobileServiceTable.prototype._read),MobileServiceTable.prototype.insert=u.async(function(n,e,s){var l,h,a,c,v;t.isNull(s)&&typeof e=="function"&&(s=e,e=null),r.notNull(n,"instance"),t.isNull(e)||r.isValidParametersObject(e),r.notNull(s,"callback");for(l in o)if(h=n[o[l]],!t.isNullOrZero(h))if(t.isString(h))if(o[l]!==i)throw t.format(u.getResourceString("MobileServiceTable_InsertIdAlreadySet"),i);else r.isValidId(h,i);else throw t.format(u.getResourceString("MobileServiceTable_InsertIdAlreadySet"),i);a=addQueryParametersFeaturesIfApplicable([],e),c=t.url.combinePathSegments(f,this.getTableName()),e=addSystemProperties(e,this.systemProperties),t.isNull(e)||(v=t.url.getQueryString(e),c=t.url.combinePathAndQuery(c,v)),this.getMobileServiceClient()._request("POST",c,n,!1,null,a,function(i,r){if(t.isNull(i)){var f=getItemFromResponse(r);f=u.allowPlatformToMutateOriginal(n,f),s(null,f)}else s(i,null)})}),MobileServiceTable.prototype.update=u.async(function(n,e,o){var c,a={},s=[],l,h,v;t.isNull(o)&&typeof e=="function"&&(o=e,e=null),r.notNull(n,"instance"),r.isValidId(n[i],"instance."+i),t.isNull(e)||r.isValidParametersObject(e,"parameters"),r.notNull(o,"callback"),t.isString(n[i])?(c=n.__version,l=removeSystemProperties(n)):l=n,t.isNullOrEmpty(c)||(a["If-Match"]=getEtagFromVersion(c),s.push(WindowsAzure.MobileServiceClient._zumoFeatures.OptimisticConcurrency)),s=addQueryParametersFeaturesIfApplicable(s,e),e=addSystemProperties(e,this.systemProperties),h=t.url.combinePathSegments(f,this.getTableName(),encodeURIComponent(n[i].toString())),t.isNull(e)||(v=t.url.getQueryString(e),h=t.url.combinePathAndQuery(h,v)),this.getMobileServiceClient()._request("PATCH",h,l,!1,a,s,function(i,r){if(t.isNull(i)){var f=getItemFromResponse(r);f=u.allowPlatformToMutateOriginal(n,f),o(null,f)}else setServerItemIfPreconditionFailed(i),o(i)})}),MobileServiceTable.prototype.refresh=u.async(function(n,e,o){var s,c,l,h;if(t.isNull(o)&&typeof e=="function"&&(o=e,e=null),r.notNull(n,"instance"),!t.isValidId(n[i],i)){if(typeof n[i]=="string"&&n[i]!=="")throw t.format(u.getResourceString("Validate_InvalidId"),i);else o(null,n);return}t.isNull(e)||r.isValidParametersObject(e,"parameters"),r.notNull(o,"callback"),s=t.url.combinePathSegments(f,this.getTableName()),typeof n[i]=="string"?(c=encodeURIComponent(n[i]).replace(/\'/g,"%27%27"),s=t.url.combinePathAndQuery(s,"?$filter=id eq '"+c+"'")):s=t.url.combinePathAndQuery(s,"?$filter=id eq "+encodeURIComponent(n[i].toString())),t.isNull(e)||(l=t.url.getQueryString(e),s=t.url.combinePathAndQuery(s,l)),h=[WindowsAzure.MobileServiceClient._zumoFeatures.TableRefreshCall],h=addQueryParametersFeaturesIfApplicable(h,e),this.getMobileServiceClient()._request("GET",s,n,!1,null,h,function(r,f){var e,s;t.isNull(r)?(e=t.fromJson(f.responseText),Array.isArray(e)&&(e=e[0]),e||(s=t.format(u.getResourceString("MobileServiceTable_NotSingleObject"),i),o(t.createError(s),null)),e=u.allowPlatformToMutateOriginal(n,e),o(null,e)):o(r,null)})}),MobileServiceTable.prototype.lookup=u.async(function(n,u,e){var o,s,h;t.isNull(e)&&typeof u=="function"&&(e=u,u=null),r.isValidId(n,i),t.isNull(u)||r.isValidParametersObject(u),r.notNull(e,"callback"),o=t.url.combinePathSegments(f,this.getTableName(),encodeURIComponent(n.toString())),s=addQueryParametersFeaturesIfApplicable([],u),u=addSystemProperties(u,this.systemProperties),t.isNull(u)||(h=t.url.getQueryString(u),o=t.url.combinePathAndQuery(o,h)),this.getMobileServiceClient()._request("GET",o,null,!1,null,s,function(n,i){if(t.isNull(n)){var r=getItemFromResponse(i);e(null,r)}else e(n,null)})}),MobileServiceTable.prototype.del=u.async(function(n,u,e){var h,o,s,c;t.isNull(e)&&typeof u=="function"&&(e=u,u=null),r.notNull(n,"instance"),r.isValidId(n[i],"instance."+i),r.notNull(e,"callback"),h={},o=[],t.isString(n[i])&&(t.isNullOrEmpty(n.__version)||(h["If-Match"]=getEtagFromVersion(n.__version),o.push(WindowsAzure.MobileServiceClient._zumoFeatures.OptimisticConcurrency))),o=addQueryParametersFeaturesIfApplicable(o,u),u=addSystemProperties(u,this.systemProperties),t.isNull(u)||r.isValidParametersObject(u),s=t.url.combinePathSegments(f,this.getTableName(),encodeURIComponent(n[i].toString())),t.isNull(u)||(c=t.url.getQueryString(u),s=t.url.combinePathAndQuery(s,c)),this.getMobileServiceClient()._request("DELETE",s,null,!1,h,o,function(n){t.isNull(n)||setServerItemIfPreconditionFailed(n),e(n)})});for(var c=["where","select","orderBy","orderByDescending","skip","take","includeTotalCount"],v=function(n){MobileServiceTable.prototype[n]=function(){var i=this,t=new l(i.getTableName());return t.read=u.async(function(n,r){i._read(t,n,r)}),t[n].apply(t,arguments)}},h=0;h<c.length;h++)v(c[h])},t.MobileServiceLogin=function(n){function MobileServiceLogin(n,r){t.isNull(r)&&(r=!0),i.notNull(n),i.isObject(n,"client"),this._loginState={inProcess:!1,cancelCallback:null},this.ignoreFilters=r,this.getMobileServiceClient=function(){return n},this.getLoginInProcess=function(){return this._loginState.inProcess}}function onLoginComplete(n,i,u,f){var e=null;t.isNull(n)&&(!t.isNull(i)&&t.isObject(i)&&t.isObject(i.user)&&t.isString(i.authenticationToken)?(u.currentUser=i.user,u.currentUser.mobileServiceAuthenticationToken=i.authenticationToken,e=u.currentUser):n=r.getResourceString("MobileServiceLogin_InvalidResponseFormat")),t.isNull(f)||f(n,e)}function onLoginResponse(n,i,r,u){var f=null;if(t.isNull(n))try{f=t.fromJson(i.responseText)}catch(e){n=e}onLoginComplete(n,f,r,u)}function loginWithProviderAndToken(n,i,r,f,e){var s=n.getMobileServiceClient(),o,h;n._loginState={inProcess:!0,cancelCallback:null},o=u+"/"+i,t.isNull(f)||(h=t.url.getQueryString(f),o=t.url.combinePathAndQuery(o,h)),s._request("POST",o,r,n.ignoreFilters,function(t,i){n._loginState={inProcess:!1,cancelCallback:null},onLoginResponse(t,i,s,e)})}function loginWithLoginControl(n,i,e,o,s){var c=n.getMobileServiceClient(),l=t.url.combinePathSegments(c.applicationUrl,u,i),a=null,v,h;t.isNull(o)||(v=t.url.getQueryString(o),l=t.url.combinePathAndQuery(l,v)),e||(a=t.url.combinePathSegments(c.applicationUrl,u,f)),n._loginState={inProcess:!0,cancelCallback:null},h=r.login(l,a,function(t,i){n._loginState={inProcess:!1,cancelCallback:null},onLoginComplete(t,i,c,s)}),n._loginState.inProcess&&h&&h.cancelCallback&&(n._loginState.cancelCallback=h.cancelCallback)}var t=require("Extensions"),i=require("Validate"),r=require("Platform"),u="login",f="done";n.MobileServiceLogin=MobileServiceLogin,r.addToMobileServicesClientNamespace({MobileServiceLogin:MobileServiceLogin}),MobileServiceLogin.prototype.loginWithOptions=function(n,r,u){i.isString(n,"provider"),i.notNull(n,"provider"),t.isNull(u)&&(t.isNull(r)||typeof r!="function"?i.notNull(null,"callback"):(u=r,r=null)),!r&&this._isAuthToken(n)?this.loginWithMobileServiceToken(n,u):(r=r||{},this.loginWithProvider(n,r.token,r.useSingleSignOn,r.parameters,u))},MobileServiceLogin.prototype.login=function(n,r,u,f){t.isNull(f)&&(t.isNull(u)||typeof u!="function"?t.isNull(r)||typeof r!="function"||(f=r,u=null,r=null):(f=u,u=null)),t.isNull(u)&&(t.isBool(r)?(u=r,r=null):u=!1),t.isNull(r)&&this._isAuthToken(n)&&(r=n,n=null),t.isNull(n)&&(i.notNull(r),i.isString(r)),t.isNull(r)&&(i.notNull(n),i.isString(n),n=n.toLowerCase()),t.isNull(n)?this.loginWithMobileServiceToken(r,f):(n.toLowerCase()==="windowsazureactivedirectory"&&(n="aad"),this.loginWithProvider(n,r,u,{},f))},MobileServiceLogin.prototype._isAuthToken=function(n){return n&&t.isString(n)&&n.split(".").length===3},MobileServiceLogin.prototype.loginWithMobileServiceToken=function(n,t){var r=this,f=r.getMobileServiceClient();i.isString(n,"authenticationToken"),i.notNullOrEmpty(n,"authenticationToken"),f._request("POST",u,{authenticationToken:n},r.ignoreFilters,function(n,i){onLoginResponse(n,i,f,t)})},MobileServiceLogin.prototype.loginWithProvider=function(n,u,f,e,o){if(i.isString(n,"provider"),t.isNull(u)||i.isObject(u,"token"),this._loginState.inProcess){var s=this._loginState.cancelCallback&&this._loginState.cancelCallback();if(!s)throw r.getResourceString("MobileServiceLogin_LoginErrorResponse");}n=n.toLowerCase(),t.isNull(u)?loginWithLoginControl(this,n,f,e,o):loginWithProviderAndToken(this,n,u,e,o)}},t.Push=function(n){function Push(n){this._apns=null,this._gcm=null,this._registrationManager=null,Object.defineProperties(this,{apns:{get:function(){if(!this._apns){var t=u.format("MS-PushContainer-apns-{0}",n.applicationUrl);this._registrationManager=new f(n,"apns",t),this._apns=new i(this)}return this._apns}},gcm:{get:function(){if(!this._gcm){var t=u.format("MS-PushContainer-gcm-{0}",n.applicationUrl);this._registrationManager=new f(n,"apns",t),this._gcm=new r(this)}return this._gcm}}})}function makeCoreRegistration(n,i,r){t.notNullOrEmpty(n,"pushHandle"),t.isString(n,"pushHandle"),i=="apns"&&(n=n.toUpperCase());var u={platform:i,deviceId:n};return r&&(t.isArray(r,"tags"),u.tags=r),u}var u=require("Extensions"),t=require("Validate"),e=require("Platform"),f=require("RegistrationManager").RegistrationManager,i=function(n){this._push=n},r=function(n){this._push=n};n.Push=Push,Push.prototype._register=function(n,t,i){var r=makeCoreRegistration(t,n,i);return this._registrationManager.upsertRegistration(r)},Push.prototype._registerTemplate=function(n,i,r,f,e,o){t.notNullOrEmpty(r,"name"),t.notNullOrEmpty(f,"bodyTemplate");var s=f,h=makeCoreRegistration(i,n,o);return u.isString(s)||(s=JSON.stringify(s)),h.templateName=r,h.templateBody=s,e&&(h.expiry=e),this._registrationManager.upsertRegistration(h)},Push.prototype._unregister=function(n){return t.notNullOrEmpty(n,"templateName"),this._registrationManager.deleteRegistrationWithName(n)},Push.prototype._unregisterAll=function(n){return t.notNullOrEmpty(n,"pushHandle"),this._registrationManager.deleteAllRegistrations(n)},i.prototype.registerNative=function(n,t){return this._push._register("apns",n,t)},i.prototype.registerTemplate=function(n,t,i,r,f){return u.isNull(f)&&!u.isNull(r)&&Array.isArray(r)&&(f=r,r=null),this._push._registerTemplate("apns",n,t,i,r,f)},i.prototype.unregisterNative=function(){return this._push._unregister(f.NativeRegistrationName)},i.prototype.unregisterTemplate=function(n){return this._push._unregister(n)},i.prototype.unregisterAll=function(n){return this._push._unregisterAll(n)},r.prototype.registerNative=function(n,t){return this._push._register("gcm",n,t)},r.prototype.registerTemplate=function(n,t,i,r){return this._push._registerTemplate("gcm",n,t,i,null,r)},r.prototype.unregisterNative=function(){return this._push._unregister(f.NativeRegistrationName)},r.prototype.unregisterTemplate=function(n){return this._push._unregister(n)},r.prototype.unregisterAll=function(n){return this._push._unregisterAll(n)}},t.RegistrationManager=function(n){function RegistrationManager(n,i,r){t.notNull(n,"mobileServicesClient"),this._platform=i||"wns",this._pushHttpClient=new f(n),this._storageManager=new u(r||n.applicationUrl)}var i=require("Extensions"),t=require("Validate"),r=require("Platform"),u=require("LocalStorageManager").LocalStorageManager,f=require("PushHttpClient").PushHttpClient;n.RegistrationManager=RegistrationManager,RegistrationManager.NativeRegistrationName=u.NativeRegistrationName,RegistrationManager.prototype.upsertRegistration=r.async(function(n,r){t.notNull(n,"registration"),t.notNull(r,"callback");var f=this,h=function(n){o(function(t){if(t){n(t);return}e(!1,n)})},e=function(t,i){f._pushHttpClient.upsertRegistration(n,function(r){if(t&&r&&r.request&&r.request.status===410){h(i);return}r||(f._storageManager.pushHandle=n.deviceId),i(r)})},o=function(t){f._pushHttpClient.createRegistrationId(function(i,r){if(i){t(i);return}n.registrationId=r,f._storageManager.updateRegistrationWithName(n.templateName||u.NativeRegistrationName,n.registrationId,n.deviceId),t()})},s=function(t){var s=n.templateName||u.NativeRegistrationName,r=f._storageManager.getRegistrationIdWithName(s);i.isNullOrEmpty(r)?o(function(n){if(n){t(n);return}e(!0,t)}):(n.registrationId=r,e(!0,t))};this._storageManager.isRefreshNeeded?this._refreshRegistrations(this._storageManager.pushHandle||n.deviceId,function(n){if(n){r(n);return}s(r)}):s(r)}),RegistrationManager.prototype.deleteRegistrationWithName=r.async(function(n,t){var r=this._storageManager.getRegistrationIdWithName(n),u=this;if(i.isNullOrEmpty(r)){t();return}this._pushHttpClient.unregister(r,function(i){i||u._storageManager.deleteRegistrationWithName(n),t(i)})}),RegistrationManager.prototype.deleteAllRegistrations=r.async(function(n,r){var u=this,f=this._storageManager.pushHandle,e=function(t,r){if(t){r(t);return}var e=u._storageManager.getRegistrationIds(),f=e.length,o=[];if(f===0){u._storageManager.deleteAllRegistrations(),r();return}e.map(function(t){u._pushHttpClient.unregister(t,function(t){f--,t&&o.push(t),f<=0&&(o.length===0?(u._storageManager.deleteAllRegistrations(),r()):r(i.createError("Failed to delete registrations for "+n)))})})};t.notNull(n,"pushHandle"),this._refreshRegistrations(f||n,function(t){i.isNullOrEmpty(f)||n===f?e(t,r):e(t,function(){u._refreshRegistrations(n,function(n){e(n,r)})})})}),RegistrationManager.prototype.listRegistrations=r.async(function(n,i){t.notNullOrEmpty(n),this._pushHttpClient.listRegistrations(n,this._platform,i)}),RegistrationManager.prototype._refreshRegistrations=function(n,i){var r=this;t.notNull(n,"pushHandle"),t.notNull(i,"callback"),this._pushHttpClient.listRegistrations(n,this._platform,function(t,u){t||r._storageManager.updateAllRegistrations(u,n),i(t)})}},t.LocalStorageManager=function(n){function LocalStorageManager(n){this._registrations={},this._storageKey="MobileServices.Push."+n,this._isRefreshNeeded=!1,Object.defineProperty(this,"isRefreshNeeded",{get:function(){return this._isRefreshNeeded}}),this._pushHandle=null,Object.defineProperty(this,"pushHandle",{get:function(){return r.isNull(this._pushHandle)?"":this._pushHandle},set:function(n){i.notNullOrEmpty(n,"pushHandle"),this._pushHandle!==n&&(this._pushHandle=n,this._flushToSettings())}}),this._initializeRegistrationInfoFromStorage()}var r=require("Extensions"),i=require("Validate"),u=require("Platform"),t={Version:"v1.1.0",Keys:{Version:"Version",PushHandle:"ChannelUri",Registrations:"Registrations",NativeRegistration:"$Default"}};n.LocalStorageManager=LocalStorageManager,LocalStorageManager.NativeRegistrationName=t.Keys.NativeRegistration,LocalStorageManager.prototype.getRegistrationIds=function(){var t=[],n;for(n in this._registrations)this._registrations.hasOwnProperty(n)&&t.push(this._registrations[n]);return t},LocalStorageManager.prototype.getRegistrationIdWithName=function(n){return i.notNullOrEmpty(n,"registrationName"),this._registrations[n]},LocalStorageManager.prototype.updateAllRegistrations=function(n,u){var f,e;for(i.notNull(u,"pushHandle"),n||(n=[]),this._registrations={},f=0;f<n.length;f++)e=n[f].templateName,r.isNullOrEmpty(e)&&(e=t.Keys.NativeRegistration),this._registrations[e]=n[f].registrationId;this._pushHandle=u,this._flushToSettings(),this._isRefreshNeeded=!1},LocalStorageManager.prototype.updateRegistrationWithName=function(n,t,r){i.notNullOrEmpty(n,"registrationName"),i.notNullOrEmpty(t,"registrationId"),i.notNullOrEmpty(r,"pushHandle"),this._registrations[n]=t,this._pushHandle=r,this._flushToSettings()},LocalStorageManager.prototype.deleteRegistrationWithName=function(n){i.notNullOrEmpty(n,"registrationName"),this._registrations.hasOwnProperty(n)&&(delete this._registrations[n],this._flushToSettings())},LocalStorageManager.prototype.deleteAllRegistrations=function(){this._registrations={},this._flushToSettings()},LocalStorageManager.prototype._flushToSettings=function(){var n={};n[t.Keys.Version]=t.Version,n[t.Keys.PushHandle]=this._pushHandle,n[t.Keys.Registrations]=this._registrations,u.writeSetting(this._storageKey,JSON.stringify(n))},LocalStorageManager.prototype._initializeRegistrationInfoFromStorage=function(){var n,i;this._registrations={};try{if(n=JSON.parse(u.readSetting(this._storageKey)),this._pushHandle=n[t.Keys.PushHandle],!this._pushHandle){this._isRefreshNeeded=!0;return}if(i=n[t.Keys.Version]||"",this._isRefreshNeeded=t.Version!==i.toLowerCase(),this._isRefreshNeeded)return;this._registrations=n[t.Keys.Registrations]}catch(r){this._isRefreshNeeded=!0}}},t.PushHttpClient=function(n){function PushHttpClient(n){this.mobileServicesClient=n}var i=require("Platform"),t={"If-Modified-Since":"Mon, 27 Mar 1972 00:00:00 GMT"};n.PushHttpClient=PushHttpClient,PushHttpClient.prototype.listRegistrations=function(n,i,r){this.mobileServicesClient._request("GET","/push/registrations?platform="+encodeURIComponent(i)+"&deviceId="+encodeURIComponent(n),null,null,t,function(n,t){n?r(n):r(null,JSON.parse(t.responseText))})},PushHttpClient.prototype.unregister=function(n,i){this.mobileServicesClient._request("DELETE","/push/registrations/"+encodeURIComponent(n),null,null,t,function(n){if(n&&n.request&&n.request.status===404){i();return}i(n)})},PushHttpClient.prototype.createRegistrationId=function(n){this.mobileServicesClient._request("POST","/push/registrationIds",null,null,t,function(t,i){if(t){n(t);return}var r=i.getResponseHeader("Location");n(null,r.slice(r.lastIndexOf("/")+1))})},PushHttpClient.prototype.upsertRegistration=function(n,i){this.mobileServicesClient._request("PUT","/push/registrations/"+encodeURIComponent(n.registrationId),n,null,t,i)}},t.Platform=function(t){function getBestTransport(){return e||(e=getBestProvider(l)),e}function getBestProvider(n){for(var t=0;t<n.length;t++)if(n[t].supportsCurrentRuntime())return n[t];throw new Error("Unsupported browser - no suitable providers are available.");}var u=require("Extensions"),s=require("Validate"),h=require("Promises"),c=require("Resources"),f={},r;try{r="___z",localStorage.setItem(r,r),localStorage.removeItem(r),f=localStorage}catch(y){}var e=null,l=[require("DirectAjaxTransport"),require("IframeTransport")],a=[require("CordovaPopup"),require("BrowserPopup")],o=/^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})(?:\.(\d*))?Z$/,v=!JSON.stringify(new Date(100)).match(/\.100Z"$/);t.async=function(n){return function(){var i=this,t=arguments;return new h.Promise(function(r,f){var e=function(n){u.isNull(n)?r.apply(null,Array.prototype.slice.call(arguments,1)):f(n)};Array.prototype.push.call(t,e);try{n.apply(i,t)}catch(o){e(u.createError(o))}})}},t.addToMobileServicesClientNamespace=function(t){var r=n.WindowsAzure=n.WindowsAzure||{},i;for(i in t)t.hasOwnProperty(i)&&(r[i]=t[i])},t.readSetting=function(n){return f[n]},t.writeSetting=function(n,t){f[n]=t},t.webRequest=function(n,t){return getBestTransport().performRequest(n,t)},t.getUserAgent=function(){return null},t.getOperatingSystemInfo=function(){return{name:"--",version:"--",architecture:"--"}},t.getSdkInfo=function(){return{language:"Web",fileVersion:i}},t.login=function(n,t,i){var r=/^[a-z]+:/,u="https:";return n=n.replace(r,u),t=t.replace(r,u),getBestProvider(a).login(n,t,i)},t.toJson=function(n){return JSON.stringify(n,function(n,t){if(v&&this&&u.isDate(this[n])){var i=this[n].getMilliseconds(),r=String(i+1e3).substring(1);return t.replace(o,function(n,t){return t+"."+r+"Z"})}return t})},t.tryParseIsoDateString=function(n){var t,r;if(s.isString(n),t=o.exec(n),t){var i=t[1],u=t[2]||"0",f=Math.round(1e3*Number("0."+u));if(i=i.replace(/\-/g,"/").replace("T"," "),r=Date.parse(i+" UTC"),!isNaN(r))return new Date(r+f)}return null},t.getResourceString=function(n){return c["en-US"][n]},t.allowPlatformToMutateOriginal=function(n,t){return t}},t.DirectAjaxTransport=function(t){t.name="DirectAjaxTransport",t.supportsCurrentRuntime=function(){return typeof n.XMLHttpRequest!="undefined"&&"withCredentials"in new n.XMLHttpRequest},t.performRequest=function(t,i){var f=t.headers||{},e=t.url.replace(/#.*$/,""),o=t.type?t.type.toUpperCase():"GET",r=new n.XMLHttpRequest,u;r.onreadystatechange=function(){r.readyState===4&&i(null,r)},r.open(o,e);for(u in f)t.headers.hasOwnProperty(u)&&r.setRequestHeader(u,t.headers[u]);r.send(t.data)}},t.IframeTransport=function(t){function fixupAjax(n){n&&n.status===1223&&(n.status=204)}function whenBridgeLoaded(t,f){var e=r[t];e||(e=r[t]=new u.Promise(function(r){var u=document.createElement("iframe"),e=i.getOriginRoot(window.location.href),f=function(){r(u)};u.addEventListener?u.addEventListener("load",f,!1):u.attachEvent("onload",f),u.src=t+"/crossdomain/bridge?origin="+encodeURIComponent(e),u.setAttribute("width",0),u.setAttribute("height",0),u.style.display="none",n.document.body.appendChild(u)})),e.then(f)}var u=require("Promises"),i=require("PostMessageExchange"),r=[],f=i.instance;t.name="IframeTransport",t.supportsCurrentRuntime=function(){return typeof n.postMessage!="undefined"},t.performRequest=function(n,t){var r=i.getOriginRoot(n.url);whenBridgeLoaded(r,function(i){var u={type:n.type,url:n.url,headers:n.headers,data:n.data};f.request(i.contentWindow,u,r).then(function(n){fixupAjax(n),t(null,n)},function(n){t(n,null)})})}},t.BrowserPopup=function(n){function createIntermediateIframeForLogin(n,t){var i=document.createElement("iframe");return i.name="zumo-login-receiver",i.src=n+"/crossdomain/loginreceiver?completion_origin="+encodeURIComponent(t),i.setAttribute("width",0),i.setAttribute("height",0),i.style.display="none",document.body.appendChild(i),i}var t=require("PostMessageExchange");n.supportsCurrentRuntime=function(){return!0},n.login=function(n,i,r){var u=t.getOriginRoot(window.location.href),l=t.getOriginRoot(n),s=window.navigator.userAgent.indexOf("MSIE")>=0||window.navigator.userAgent.indexOf("Trident")>=0,f=s&&createIntermediateIframeForLogin(l,u),a=s?"iframe":"postMessage",c;if(n+="?completion_type="+a+"&completion_origin="+encodeURIComponent(u),!(u&&(u.indexOf("http:")===0||u.indexOf("https:")===0))){c="Login is only supported from http:// or https:// URLs. Please host your page in a web server.",r(c,null);return}var e=window.open(n,"_blank","location=no"),h=function(n,t){window.clearInterval(v),e.close(),window.removeEventListener?window.removeEventListener("message",o):window.detachEvent("onmessage",o),f&&f.parentNode.removeChild(f),r(n,t)},o=function(n){var i=s?f.contentWindow:e,t;if(n.source===i){try{t=JSON.parse(n.data)}catch(r){return}t&&t.type==="LoginCompleted"&&(t.oauth||t.error)&&h(t.error,t.oauth)}},v=window.setInterval(function(){e&&e.closed===!0&&h("canceled",null)},250);return window.addEventListener?window.addEventListener("message",o,!1):window.attachEvent("onmessage",o),{cancelCallback:function(){return h("canceled",null),!0}}}},t.CordovaPopup=function(n){function currentCordovaVersion(){return window.cordova&&window.cordova.version}function isSupportedCordovaVersion(){var n=currentCordovaVersion().match(/^(\d+).(\d+)./);if(n){var r=Number(n[1]),u=Number(n[2]),i=t;return r>i.major||r===i.major&&u>=i.minor}return!1}function hasInAppBrowser(){return!window.open}function parseOAuthResultFromDoneUrl(n){var t=extractMessageFromUrl(n,"#token="),i=extractMessageFromUrl(n,"#error=");return{oAuthToken:t?JSON.parse(t):null,error:i}}function extractMessageFromUrl(n,t){var i=n.indexOf(t);return i<0?null:decodeURIComponent(n.substring(i+t.length))}function getSpinnerMarkup(){for(var r=("webkitTransform"in document.documentElement.style)?"-webkit-":"",t=12,i="",n=0;n<t;n++)i+="<div style='-prefix-transform: rotateZ("+(180+n*360/t)+"deg);-prefix-animation-delay: "+.75*n/t+"s;'><\/div>";return["<!DOCTYPE html><html>","<head><meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1'><\/head>","<body><div id='spinner'>"+i+"<\/div>","<style type='text/css'>","    #spinner { position: absolute; top: 50%; left: 50%; -prefix-animation: spinner 10s linear infinite; }","    #spinner > div {","        background: #333; opacity: 0; position: absolute; top: 11px; left: -2px; width: 4px; height: 21px; border-radius: 2px;","        -prefix-transform-origin: 50% -11px; -prefix-animation: spinner-spoke 0.75s linear infinite;","    }","    @-prefix-keyframes spinner { 0% { -prefix-transform: rotateZ(0deg); } 100% { -prefix-transform: rotateZ(-360deg); } }","    @-prefix-keyframes spinner-spoke { 0% { opacity: 0; } 5% { opacity: 1; } 70% { opacity: 0; } 100% { opacity: 0; } }","<\/style>","<\/body><\/html>"].join("").replace(/-prefix-/g,r)}var t={major:3,minor:0};n.supportsCurrentRuntime=function(){return!!currentCordovaVersion()},n.login=function(n,i,r){var f=currentCordovaVersion(),u,e,o;if(!isSupportedCordovaVersion(f)){u="Not a supported version of Cordova. Detected: "+f+". Required: "+t.major+"."+t.minor;throw new Error(u);}if(!hasInAppBrowser){u='A required plugin: "org.apache.cordova.inappbrowser" was not detected.';throw new Error(u);}e="<script>location.href = unescape('"+window.escape(n)+"')<\/script>",o="data:text/html,"+encodeURIComponent(getSpinnerMarkup()+e),setTimeout(function(){var n=window.open(o,"_blank","location=no"),t=!1,u=function(u){if(!t&&u.url.indexOf(i)===0){t=!0,setTimeout(function(){n.close()},500);var f=parseOAuthResultFromDoneUrl(u.url);r(f.error,f.oAuthToken)}};n.addEventListener("loadstart",u),n.addEventListener("loadstop",u),n.addEventListener("exit",function(){t||(t=!0,r("UserCancelled",null))})},500)}},t.Extensions=function(n){function classOf(n){return Object.prototype.toString.call(n).slice(8,-1).toLowerCase()}var i=require("Validate"),r=require("Platform"),t=n;n.isNull=function(n){return n===null||n===undefined},n.isNullOrZero=function(n){return n===null||n===undefined||n===0||n===""},n.isNullOrEmpty=function(n){return t.isNull(n)||n.length===0},n.format=function(n){var r,u;if(i.isString(n,"message"),!t.isNullOrEmpty(n)&&arguments.length>1)for(r=1;r<arguments.length;r++)for(u="{"+(r-1)+"}";n.indexOf(u)!==-1;)n=n.replace(u,arguments[r]);return n},n.has=function(n,r){return i.notNull(r,"key"),i.isString(r,"key"),!t.isNull(n)&&n.hasOwnProperty(r)},n.hasProperty=function(n,i){for(var r=0;r<i.length;r++)if(t.has(n,i[r]))return!0;return!1},n.extend=function(n,t){for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);return n},n.isObject=function(n){return t.isNull(n)||typeof n=="object"&&!t.isDate(n)},n.isValidId=function(n){if(t.isNullOrZero(n))return!1;if(t.isString(n)){if(n.length===0||n.length>255||n.trim().length===0)return!1;return n.match(/[+"\/?`\\]|[\u0000-\u001F]|[\u007F-\u009F]|^\.{1,2}$/)!==null?!1:!0}return t.isNumber(n)?n>0:!1},n.isString=function(n){return t.isNull(n)||typeof n=="string"},n.isNumber=function(n){return!t.isNull(n)&&typeof n=="number"},n.isBool=function(n){return!t.isNull(n)&&typeof n=="boolean"},n.isDate=function(n){return!t.isNull(n)&&classOf(n)=="date"},n.toJson=function(n){return r.toJson(n)},n.fromJson=function(i){var r=null;return t.isNullOrEmpty(i)||(r=JSON.parse(i,function(i,r){if(t.isString(r)&&!t.isNullOrEmpty(r)){var u=n.tryParseIsoDateString(r);if(!t.isNull(u))return u}return r})),r},n.createUniqueInstallationId=function(){var t=function(n){return"0000".substring(n.length)+n},n=function(){return t(Math.floor(Math.random()*65536).toString(16))};return n()+n()+"-"+n()+"-"+n()+"-"+n()+"-"+n()+n()+n()},n.mapProperties=function(n,i){var u=[],r;if(!t.isNull(n)){r=null;for(r in n)u.push(i(r,n[r]))}return u},n.pad=function(n,t,r){i.notNull(n,"value"),i.isInteger(t,"length"),i.isString(r,"ch"),i.notNullOrEmpty(r,"ch"),i.length(r,1,"ch");for(var u=n.toString();u.length<t;)u=r+u;return u},n.trimEnd=function(n,t){i.isString(n,"text"),i.notNull(n,"text"),i.isString(t,"ch"),i.notNullOrEmpty("ch","ch"),i.length(t,1,"ch");for(var r=n.length-1;r>=0&&n[r]===t;)r--;return r>=0?n.substr(0,r+1):""},n.trimStart=function(n,t){i.isString(n,"text"),i.notNull(n,"text"),i.isString(t,"ch"),i.notNullOrEmpty(t,"ch"),i.length(t,1,"ch");for(var r=0;r<n.length&&n[r]===t;)r++;return r<n.length?n.substr(r,n.length-r):""},n.compareCaseInsensitive=function(n,i){return t.isString(n)&&!t.isNullOrEmpty(n)&&(n=n.toUpperCase()),t.isString(n)&&!t.isNullOrEmpty(i)&&(i=i.toUpperCase()),n===i},n.url={separator:"/",combinePathSegments:function(){var u=[],n=0,r;for(i.notNullOrEmpty(arguments,"arguments"),n=0;n<arguments.length;n++)r=arguments[n],i.isString(r,t.format("argument[{0}]",n)),n!==0&&(r=t.trimStart(r||"",t.url.separator)),n<arguments.length-1&&(r=t.trimEnd(r||"",t.url.separator)),u.push(r);return u.reduce(function(n,i){return n+t.url.separator+i})},getQueryString:function(t){var u,f,r;i.notNull(t,"parameters"),i.isObject(t,"parameters"),u=[];for(f in t)r=t[f],n.isObject(r)&&(r=n.toJson(r)),u.push(encodeURIComponent(f)+"="+encodeURIComponent(r));return u.join("&")},combinePathAndQuery:function(r,u){return(i.notNullOrEmpty(r,"path"),i.isString(r,"path"),t.isNullOrEmpty(u))?r:(i.isString(u,"queryString"),r.indexOf("?")>=0?r+"&"+n.trimStart(u,"?"):r+"?"+n.trimStart(u,"?"))},isAbsoluteUrl:function(n){if(t.isNullOrEmpty(n))return!1;var i=n.substring(0,7).toLowerCase();return i=="http://"||i=="https:/"}},n.tryParseIsoDateString=function(n){return r.tryParseIsoDateString(n)},n.createError=function(n,i){var u={message:r.getResourceString("Extensions_DefaultErrorMessage")},e,o,f;if(u.toString=function(){return u.message},i)if(u.request=i,i.status===0)u.message=r.getResourceString("Extensions_ConnectionFailureMessage");else{e=!1,i.getResponseHeader&&(o=i.getResponseHeader("Content-Type"),o&&(e=o.toLowerCase().indexOf("text")>=0));try{f=JSON.parse(i.responseText),u.message=typeof f=="string"?f:f.error||f.description||i.statusText||r.getResourceString("Extensions_DefaultErrorMessage")}catch(s){u.message=e?i.responseText:i.statusText||r.getResourceString("Extensions_DefaultErrorMessage")}}else t.isString(n)&&!t.isNullOrEmpty(n)?u.message=n:t.isNull(n)||(u.exception=n);return u}},t.PostMessageExchange=function(t){function PostMessageExchange(){var n=this;n._lastMessageId=0,n._hasListener=!1,n._pendingMessages={}}function getOriginRoot(n){var t=parseUrl(n),i=t.port?t.port.toString():null,r=t.protocol==="http:"&&i==="80"||t.protocol==="https:"&&i==="443",u=i&&!r?":"+i:"";return t.protocol+"//"+t.hostname+u}function parseUrl(t){var i=n.document.createElement("a");return i.href=t,i}var i=require("Promises"),r=3e5;PostMessageExchange.prototype.request=function(t,u,f){var e=this,o=++e._lastMessageId,s={messageId:o,contents:u};return e._ensureHasListener(),new i.Promise(function(i,u){e._pendingMessages[o]={messageId:o,complete:i,error:u,targetWindow:t,origin:f},e._pendingMessages[o].timeoutId=n.setTimeout(function(){var n=e._pendingMessages[o];n&&(delete e._pendingMessages[o],n.error({status:0,statusText:"Timeout",responseText:null}))},r),t.postMessage(JSON.stringify(s),f)})},PostMessageExchange.prototype._ensureHasListener=function(){if(!this._hasListener){this._hasListener=!0;var n=this,t=function(){n._handleMessage.apply(n,arguments)};window.addEventListener?window.addEventListener("message",t,!1):window.attachEvent("onmessage",t)}},PostMessageExchange.prototype._handleMessage=function(t){var r=this._tryDeserializeMessage(t.data),u=r&&r.messageId,i=u&&this._pendingMessages[u],f=i&&i.targetWindow===t.source&&i.origin===getOriginRoot(t.origin);f&&(n.clearTimeout(i.timeoutId),delete this._pendingMessages[u],i.complete(r.contents))},PostMessageExchange.prototype._tryDeserializeMessage=function(n){if(!n||typeof n!="string")return null;try{return JSON.parse(n)}catch(t){return null}},t.instance=new PostMessageExchange,t.getOriginRoot=getOriginRoot},t.Promises=function(n){(function(n){"use strict";function Promise(n){this._callbackFrames=[],this._resolutionState=null,this._resolutionValueOrError=null,this._resolveSuccess=i(this._resolveSuccess,this),this._resolveError=i(this._resolveError,this),n&&n(this._resolveSuccess,this._resolveError)}var t={success:{},error:{}},i=function(n,t){return function(){n.apply(t,arguments)}},r=function(n){return n&&typeof n.then=="function"};Promise.prototype.then=function(n,t){var i={success:n,error:t,chainedPromise:new Promise};return this._resolutionState?this._invokeCallback(i):this._callbackFrames.push(i),i.chainedPromise},Promise.prototype._resolveSuccess=function(n){this._resolve(t.success,n)},Promise.prototype._resolveError=function(n){this._resolve(t.error,n)},Promise.prototype._resolve=function(n,t){if(!this._resolutionState){this._resolutionState=n,this._resolutionValueOrError=t;for(var i=0,r=this._callbackFrames.length;i<r;i++)this._invokeCallback(this._callbackFrames[i])}},Promise.prototype._invokeCallback=function(n){var u=this._resolutionState===t.success?n.success:n.error;typeof u=="function"?setTimeout(i(function(){var i,f,e=!0;try{i=u(this._resolutionValueOrError),f=t.success}catch(o){e=!1,i=o,f=t.error}e&&r(i)?i.then(n.chainedPromise._resolveSuccess,n.chainedPromise._resolveError):n.chainedPromise._resolve(f,i)},this),1):n.chainedPromise._resolve(this._resolutionState,this._resolutionValueOrError)},Promise.prototype.done=function(n,t){return this.then(n,t).then(null,function(n){setTimeout(function(){throw new Error(n);},1)}),undefined},n.Promise=Promise})(n)},t.Validate=function(n){var t=require("Extensions"),i=require("Platform");n.notNull=function(n,r){if(t.isNull(n))throw t.format(i.getResourceString("Validate_NotNullError"),r||"Value");},n.notNullOrEmpty=function(n,r){if(t.isNullOrEmpty(n))throw t.format(i.getResourceString("Validate_NotNullOrEmptyError"),r||"Value");},n.notNullOrZero=function(n,r){if(t.isNullOrZero(n))throw t.format(i.getResourceString("Validate_NotNullOrEmptyError"),r||"Value");},n.isValidId=function(n,r){if(!t.isValidId(n))throw t.format(i.getResourceString("Validate_InvalidId"),r||"id");},n.isDate=function(r,u){if(n.notNull(r,u),!t.isDate(r))throw t.format(i.getResourceString("Validate_TypeCheckError"),u||"Value","Date",typeof r);},n.isNumber=function(r,u){if(n.notNull(r,u),!t.isNumber(r))throw t.format(i.getResourceString("Validate_TypeCheckError"),u||"Value","Number",typeof r);},n.isValidParametersObject=function(r,u){n.notNull(r,u),n.isObject(r,u);for(var f in r)if(f.indexOf("$")===0)throw t.format(i.getResourceString("Validate_InvalidUserParameter"),u,f);},n.isInteger=function(r,u){if(n.notNull(r,u),n.isNumber(r,u),parseInt(r,10)!==parseFloat(r))throw t.format(i.getResourceString("Validate_TypeCheckError"),u||"Value","number",typeof r);},n.isString=function(n,r){if(!t.isString(n))throw t.format(i.getResourceString("Validate_TypeCheckError"),r||"Value","string",typeof n);},n.isObject=function(n,r){if(!t.isObject(n))throw t.format(i.getResourceString("Validate_TypeCheckError"),r||"Value","object",typeof n);},n.isArray=function(n,r){if(!Array.isArray(n))throw t.format(i.getResourceString("Validate_TypeCheckError"),r||"Value","array",typeof n);},n.length=function(r,u,f){if(n.notNull(r,f),n.isInteger(u,"length"),r.length!==u)throw t.format(i.getResourceString("Validate_LengthUnexpected"),f||"Value",u,r.length);}},t.JavaScript=function(n){(function(){var u,f,t,i,r;r=require("esprima"),u=require("./JavaScriptNodes"),i=require("./PartialEvaluator").PartialEvaluator,t=require("./JavaScriptToQueryVisitor").JavaScriptToQueryVisitor,n.JavaScript=f=function(){function JavaScript(){}return JavaScript.transformConstraint=function(n,r){var u,f;return u=JavaScript.getExpression(n,r),u.expression=i.evaluate(u),f=new t(u),f.visit(u.expression)},JavaScript.getProjectedFields=function(){return[]},JavaScript.getExpression=function(n,t){var e,o,f,c,u,i,s,h,l,a,v,y,p,w,b,k,d,g,nt,tt,it,rt,ut;if(s="var _$$_stmt_$$_ = "+n+";",i=r.parse(s,{range:!0}),o=(i!=null?i.type:void 0)==="Program"&&(i!=null?(a=i.body)!=null?a.length:void 0:void 0)===1&&((v=i.body[0])!=null?v.type:void 0)==="VariableDeclaration"&&((k=i.body[0])!=null?(d=k.declarations)!=null?d.length:void 0:void 0)===1&&((g=i.body[0].declarations[0])!=null?g.type:void 0)==="VariableDeclarator"&&((nt=i.body[0].declarations[0])!=null?(tt=nt.init)!=null?tt.type:void 0:void 0)==="FunctionExpression"&&((it=i.body[0].declarations[0].init)!=null?(rt=it.body)!=null?rt.type:void 0:void 0)==="BlockStatement"&&((ut=i.body[0].declarations[0].init.body)!=null?(y=ut.body)!=null?y.length:void 0:void 0)===1&&((p=i.body[0].declarations[0].init.body.body[0])!=null?p.type:void 0)==="ReturnStatement"&&((w=i.body[0].declarations[0].init.body.body[0])!=null?w.argument:void 0),!o)throw"Expected a predicate with a single return statement, not "+n;if(u=(b=i.body[0].declarations[0].init.params)!=null?b.map(function(n){return n.name}):void 0,u.length>t.length)throw"Expected value(s) for parameter(s) "+u.slice(t.length);else if(t.length>u.length)throw"Expected parameter(s) for value(s) "+t.slice(u.length);for(e={},f=h=0,l=u.length;h<l;f=++h)c=u[f],e[c]=t[f];return{source:s,expression:o,environment:e}},JavaScript}()}).call(this)},t.JavaScriptNodes=function(n){(function(){var l,a,v,y,p,w,b,k,d,g,nt,e,tt,it,u,rt,ut,ft,et,ot,st,ht,ct,f,i,lt,at,vt,yt,pt,h,wt,bt,o,kt,dt,gt,r,ni,ti,ii,ri,ui,fi,ei,oi,si,c,hi,ci,s,li={}.hasOwnProperty,t=function(n,t){function ctor(){this.constructor=n}for(var i in t)li.call(t,i)&&(n[i]=t[i]);return ctor.prototype=t.prototype,n.prototype=new ctor,n.__super__=t.prototype,n};s=require("./Node"),h=s.Node,c=s.Visitor,n.JavaScriptNode=f=function(n){function JavaScriptNode(){JavaScriptNode.__super__.constructor.call(this)}return t(JavaScriptNode,n),JavaScriptNode}(h),n.JavaScriptVisitor=i=function(n){function JavaScriptVisitor(){JavaScriptVisitor.__super__.constructor.call(this)}return t(JavaScriptVisitor,n),JavaScriptVisitor.prototype.JavaScriptNode=function(n){return n},JavaScriptVisitor}(c),n.Program=kt=function(n){function Program(n){this.elements=n,Program.__super__.constructor.call(this)}return t(Program,n),Program}(f),i.prototype.Program=function(n){return n=this.JavaScriptNode(n),n.elements=this.visit(n.elements),n},n.Function=et=function(n){function Function(n,t,i){this.id=n,this.params=t,this.body=i,Function.__super__.constructor.call(this)}return t(Function,n),Function}(f),i.prototype.Function=function(n){return n=this.JavaScriptNode(n),n.id=this.visit(n.id),n.params=this.visit(n.params),n.body=this.visit(n.body),n},n.Statement=r=function(n){function Statement(){Statement.__super__.constructor.call(this)}return t(Statement,n),Statement}(f),i.prototype.Statement=function(n){return this.JavaScriptNode(n)},n.EmptyStatement=it=function(n){function EmptyStatement(){EmptyStatement.__super__.constructor.call(this)}return t(EmptyStatement,n),EmptyStatement}(f),i.prototype.EmptyStatement=function(n){return this.JavaScriptNode(n)},n.BlockStatement=p=function(n){function BlockStatement(n){this.body=n,BlockStatement.__super__.constructor.call(this)}return t(BlockStatement,n),BlockStatement}(r),i.prototype.BlockStatement=function(n){return n=this.Statement(n),n.body=this.visit(n.body),n},n.ExpressionStatement=rt=function(n){function ExpressionStatement(){ExpressionStatement.__super__.constructor.call(this)}return t(ExpressionStatement,n),ExpressionStatement}(r),i.prototype.ExpressionStatement=function(n){return this.Statement(n)},n.IfStatement=ct=function(n){function IfStatement(n,t,i){this.test=n,this.consequent=t,this.alternate=i,IfStatement.__super__.constructor.call(this)}return t(IfStatement,n),IfStatement}(r),i.prototype.IfStatement=function(n){return n=this.Statement(n),n.test=this.visit(n.test),n.consequent=this.visit(n.consequent),n.alternate=this.visit(n.alternate),n},n.LabeledStatement=lt=function(n){function LabeledStatement(n,t){this.label=n,this.body=t,LabeledStatement.__super__.constructor.call(this)}return t(LabeledStatement,n),LabeledStatement}(r),i.prototype.LabeledStatement=function(n){return n=this.Statement(n),n.label=this.visit(n.label),n.body=this.visit(n.body),n},n.BreakStatement=w=function(n){function BreakStatement(n){this.label=n,BreakStatement.__super__.constructor.call(this)}return t(BreakStatement,n),BreakStatement}(r),i.prototype.BreakStatement=function(n){return n=this.Statement(n),n.label=this.visit(n.label),n},n.ContinueStatement=g=function(n){function ContinueStatement(n){this.label=n,ContinueStatement.__super__.constructor.call(this)}return t(ContinueStatement,n),ContinueStatement}(r),i.prototype.ContinueStatement=function(n){return n=this.Statement(n),n.label=this.visit(n.label),n},n.WithStatement=ci=function(n){function WithStatement(n,t){this.object=n,this.body=t,WithStatement.__super__.constructor.call(this)}return t(WithStatement,n),WithStatement}(r),i.prototype.WithStatement=function(n){return n=this.Statement(n),n.object=this.visit(n.object),n.body=this.visit(n.body),n},n.SwitchStatement=ti=function(n){function SwitchStatement(n,t){this.discriminant=n,this.cases=t,SwitchStatement.__super__.constructor.call(this)}return t(SwitchStatement,n),SwitchStatement}(r),i.prototype.SwitchStatement=function(n){return n=this.Statement(n),n.discriminant=this.visit(n.discriminant),n.cases=this.visit(n.cases),n},n.ReturnStatement=dt=function(n){function ReturnStatement(n){this.argument=n,ReturnStatement.__super__.constructor.call(this)}return t(ReturnStatement,n),ReturnStatement}(r),i.prototype.ReturnStatement=function(n){return n=this.Statement(n),n.argument=this.visit(n.argument),n},n.ThrowStatement=ri=function(n){function ThrowStatement(n){this.argument=n,ThrowStatement.__super__.constructor.call(this)}return t(ThrowStatement,n),ThrowStatement}(r),i.prototype.ThrowStatement=function(n){return n=this.Statement(n),n.argument=this.visit(n.argument),n},n.TryStatement=ui=function(n){function TryStatement(n,t,i){this.block=n,this.handlers=t,this.finalizer=i,TryStatement.__super__.constructor.call(this)}return t(TryStatement,n),TryStatement}(r),i.prototype.TryStatement=function(n){return n=this.Statement(n),n.block=this.visit(n.block),n.handlers=this.visit(n.handlers),n.finalizer=this.visit(n.finalizer),n},n.WhileStatement=hi=function(n){function WhileStatement(n,t){this.test=n,this.body=t,WhileStatement.__super__.constructor.call(this)}return t(WhileStatement,n),WhileStatement}(r),i.prototype.WhileStatement=function(n){return n=this.Statement(n),n.test=this.visit(n.test),n.body=this.visit(n.body),n},n.DoWhileStatement=tt=function(n){function DoWhileStatement(n,t){this.body=n,this.test=t,DoWhileStatement.__super__.constructor.call(this)}return t(DoWhileStatement,n),DoWhileStatement}(r),i.prototype.DoWhileStatement=function(n){return n=this.Statement(n),n.body=this.visit(n.body),n.test=this.visit(n.test),n},n.ForStatement=ft=function(n){function ForStatement(n,t,i,r){this.init=n,this.test=t,this.update=i,this.body=r,ForStatement.__super__.constructor.call(this)}return t(ForStatement,n),ForStatement}(r),i.prototype.ForStatement=function(n){return n=this.Statement(n),n.init=this.visit(n.init),n.test=this.visit(n.test),n.update=this.visit(n.update),n.body=this.visit(n.body),n},n.ForInStatement=ut=function(n){function ForInStatement(n,t,i){this.left=n,this.right=t,this.body=i,ForInStatement.__super__.constructor.call(this)}return t(ForInStatement,n),ForInStatement}(r),i.prototype.ForInStatement=function(n){return n=this.Statement(n),n.left=this.visit(n.left),n.right=this.visit(n.right),n.body=this.visit(n.body),n},n.DebuggerStatement=nt=function(n){function DebuggerStatement(){DebuggerStatement.__super__.constructor.call(this)}return t(DebuggerStatement,n),DebuggerStatement}(r),i.prototype.DebuggerStatement=function(n){return this.Statement(n)},n.Declaration=e=function(n){function Declaration(){Declaration.__super__.constructor.call(this)}return t(Declaration,n),Declaration}(r),i.prototype.Declaration=function(n){return this.Statement(n)},n.FunctionDeclaration=ot=function(n){function FunctionDeclaration(n,t,i){this.id=n,this.params=t,this.body=i,FunctionDeclaration.__super__.constructor.call(this)}return t(FunctionDeclaration,n),FunctionDeclaration}(e),i.prototype.FunctionDeclaration=function(n){return n=this.Declaration(n),n.id=this.visit(n.id),n.params=this.visit(n.params),n.body=this.visit(n.body),n},n.VariableDeclaration=oi=function(n){function VariableDeclaration(n,t){this.declarations=n,this.kind=t,VariableDeclaration.__super__.constructor.call(this)}return t(VariableDeclaration,n),VariableDeclaration}(e),i.prototype.VariableDeclaration=function(n){return n=this.Declaration(n),n.declarations=this.visit(n.declarations),n},n.VariableDeclarator=si=function(n){function VariableDeclarator(n,t){this.id=n,this.init=t,VariableDeclarator.__super__.constructor.call(this)}return t(VariableDeclarator,n),VariableDeclarator}(f),i.prototype.VariableDeclarator=function(n){return n=this.JavaScriptNode(n),n.id=this.visit(n.id),n.init=this.visit(n.init),n},n.Expression=u=function(n){function Expression(){return Expression.__super__.constructor.apply(this,arguments)}return t(Expression,n),Expression.prototype.constuctor=function(){return Expression.__super__.constuctor.call(this)},Expression}(f),i.prototype.Expression=function(n){return this.JavaScriptNode(n)},n.ThisExpression=ii=function(n){function ThisExpression(){ThisExpression.__super__.constructor.call(this)}return t(ThisExpression,n),ThisExpression}(u),i.prototype.ThisExpression=function(n){return this.Expression(n)},n.ArrayExpression=l=function(n){function ArrayExpression(n){this.elements=n,ArrayExpression.__super__.constructor.call(this)}return t(ArrayExpression,n),ArrayExpression}(u),i.prototype.ArrayExpression=function(n){return n=this.Expression(n),n.elements=this.visit(n.elements),n},n.ObjectExpression=wt=function(n){function ObjectExpression(n){this.properties=n,ObjectExpression.__super__.constructor.call(this)}return t(ObjectExpression,n),ObjectExpression}(u),i.prototype.ObjectExpression=function(n){var t,i,u,r;for(n=this.Expression(n),r=n.properties,i=0,u=r.length;i<u;i++)t=r[i],t.key=this.visit(t.key),t.value=this.visit(t.value);return n},n.FunctionExpression=st=function(n){function FunctionExpression(n,t,i){this.id=n,this.params=t,this.body=i,FunctionExpression.__super__.constructor.call(this)}return t(FunctionExpression,n),FunctionExpression}(u),i.prototype.FunctionExpression=function(n){return n=this.Expression(n),n.id=this.visit(n.id),n.params=this.visit(n.params),n.body=this.visit(n.body),n},n.SequenceExpression=gt=function(n){function SequenceExpression(n){this.expressions=n,SequenceExpression.__super__.constructor.call(this)}return t(SequenceExpression,n),SequenceExpression}(u),i.prototype.SequenceExpression=function(n){return n=this.Expression(n),n.expressions=this.visit(n.expressions),n},n.UnaryExpression=fi=function(n){function UnaryExpression(n,t,i){this.operator=n,this.prefix=t,this.argument=i,UnaryExpression.__super__.constructor.call(this)}return t(UnaryExpression,n),UnaryExpression}(u),i.prototype.UnaryExpression=function(n){return n=this.Expression(n),n.argument=this.visit(n.argument),n},n.BinaryExpression=y=function(n){function BinaryExpression(n,t,i){this.operator=n,this.left=t,this.right=i,BinaryExpression.__super__.constructor.call(this)}return t(BinaryExpression,n),BinaryExpression}(u),i.prototype.BinaryExpression=function(n){return n=this.Expression(n),n.left=this.visit(n.left),n.right=this.visit(n.right),n},n.AssignmentExpression=v=function(n){function AssignmentExpression(n,t,i){this.operator=n,this.left=t,this.right=i,AssignmentExpression.__super__.constructor.call(this)}return t(AssignmentExpression,n),AssignmentExpression}(u),i.prototype.AssignmentExpression=function(n){return n=this.Expression(n),n.left=this.visit(n.left),n.right=this.visit(n.right),n},n.UpdateExpression=ei=function(n){function UpdateExpression(n,t,i){this.operator=n,this.argument=t,this.prefix=i,UpdateExpression.__super__.constructor.call(this)}return t(UpdateExpression,n),UpdateExpression}(u),i.prototype.UpdateExpression=function(n){return n=this.Expression(n),n.argument=this.visit(n.argument),n},n.LogicalExpression=vt=function(n){function LogicalExpression(n,t,i){this.operator=n,this.left=t,this.right=i,LogicalExpression.__super__.constructor.call(this)}return t(LogicalExpression,n),LogicalExpression}(u),i.prototype.LogicalExpression=function(n){return n=this.Expression(n),n.left=this.visit(n.left),n.right=this.visit(n.right),n},n.ConditionalExpression=d=function(n){function ConditionalExpression(n,t,i){this.test=n,this.alternate=t,this.consequent=i,ConditionalExpression.__super__.constructor.call(this)}return t(ConditionalExpression,n),ConditionalExpression}(u),i.prototype.ConditionalExpression=function(n){return n=this.Expression(n),n.test=this.visit(n.test),n.alternate=this.visit(n.alternate),n.consequent=this.visit(n.consequent),n},n.NewExpression=pt=function(n){function NewExpression(n,t){this.callee=n,this.arguments=t,NewExpression.__super__.constructor.call(this)}return t(NewExpression,n),NewExpression}(u),i.prototype.NewExpression=function(n){return n=this.Expression(n),n.callee=this.visit(n.callee),n.arguments=this.visit(n.arguments),n},n.CallExpression=b=function(n){function CallExpression(n,t){this.callee=n,this.arguments=t,CallExpression.__super__.constructor.call(this)}return t(CallExpression,n),CallExpression}(u),i.prototype.CallExpression=function(n){return n=this.Expression(n),n.callee=this.visit(n.callee),n.arguments=this.visit(n.arguments),n},n.MemberExpression=yt=function(n){function MemberExpression(n,t,i){this.object=n,this.property=t,this.computed=i,MemberExpression.__super__.constructor.call(this)}return t(MemberExpression,n),MemberExpression}(u),i.prototype.MemberExpression=function(n){return n=this.Expression(n),n.object=this.visit(n.object),n.property=this.visit(n.property),n},n.Pattern=o=function(n){function Pattern(){Pattern.__super__.constructor.call(this)}return t(Pattern,n),Pattern}(f),i.prototype.Pattern=function(n){return this.JavaScriptNode(n)},n.ObjectPattern=bt=function(n){function ObjectPattern(n){this.properties=n,ObjectPattern.__super__.constructor.call(this)}return t(ObjectPattern,n),ObjectPattern}(o),i.prototype.ObjectPattern=function(n){var t,i,u,r;for(n=this.Pattern(n),r=n.properties,i=0,u=r.length;i<u;i++)t=r[i],t.key=this.visit(t.key),t.value=this.visit(t.value);return n},n.ArrayPattern=a=function(n){function ArrayPattern(n){this.elements=n,ArrayPattern.__super__.constructor.call(this)}return t(ArrayPattern,n),ArrayPattern}(o),i.prototype.ArrayPattern=function(n){return n=this.Pattern(n),n.elements=this.visit(n.elements),n},n.SwitchCase=ni=function(n){function SwitchCase(n,t){this.test=n,this.consequent=t,SwitchCase.__super__.constructor.call(this)}return t(SwitchCase,n),SwitchCase}(f),i.prototype.SwitchCase=function(n){return n=this.JavaScriptNode(n),n.test=this.visit(n.test),n.consequent=this.visit(n.consequent),n},n.CatchClause=k=function(n){function CatchClause(n,t){this.param=n,this.body=t,CatchClause.__super__.constructor.call(this)}return t(CatchClause,n),CatchClause}(f),i.prototype.CatchClause=function(n){return n=this.JavaScriptNode(n),n.param=this.visit(n.param),n.body=this.visit(n.body),n},n.Identifier=ht=function(n){function Identifier(n){this.name=n,Identifier.__super__.constructor.call(this)}return t(Identifier,n),Identifier}(f),i.prototype.Identifier=function(n){return this.JavaScriptNode(n)},n.Literal=at=function(n){function Literal(n){this.value=n,Literal.__super__.constructor.call(this)}return t(Literal,n),Literal}(u),i.prototype.Literal=function(n){return this.Expression(n)}}).call(this)},t.JavaScriptToQueryVisitor=function(n){(function(){var r,u,t,i,f={}.hasOwnProperty,e=function(n,t){function ctor(){this.constructor=n}for(var i in t)f.call(t,i)&&(n[i]=t[i]);return ctor.prototype=t.prototype,n.prototype=new ctor,n.__super__=t.prototype,n};i=require("./Utilities"),r=require("./JavaScriptNodes"),t=require("./QueryNodes"),n.JavaScriptToQueryVisitor=u=function(n){function JavaScriptToQueryVisitor(n){this.context=n}return e(JavaScriptToQueryVisitor,n),JavaScriptToQueryVisitor.prototype.getSource=function(n){var t,i;return this.context.source.slice(n!=null?(t=n.range)!=null?t[0]:void 0:void 0,+((n!=null?(i=n.range)!=null?i[1]:void 0:void 0)-1)+1||9e9)},JavaScriptToQueryVisitor.prototype.invalid=function(n){throw"The expression '"+this.getSource(n)+"'' is not supported.";},JavaScriptToQueryVisitor.prototype.translateUnary=function(n,i){var r,u;return r=i[n.operator],r?(u=this.visit(n.argument),new t.UnaryExpression(r,u)):null},JavaScriptToQueryVisitor.prototype.translateBinary=function(n,i){var u,r,f;return r=i[n.operator],r?(u=this.visit(n.left),f=this.visit(n.right),new t.BinaryExpression(r,u,f)):null},JavaScriptToQueryVisitor.prototype.visit=function(n){var t;return t=JavaScriptToQueryVisitor.__super__.visit.call(this,n),n===t&&this.invalid(n),t},JavaScriptToQueryVisitor.prototype.MemberExpression=function(n){var i;return i=function(){var i,r,u,f;return(n!=null?(i=n.object)!=null?i.type:void 0:void 0)==="ThisExpression"&&(n!=null?(r=n.property)!=null?r.type:void 0:void 0)==="Identifier"?new t.MemberExpression(n.property.name):(n!=null?(u=n.object)!=null?u.type:void 0:void 0)==="MemberExpression"&&((f=n.object.object)!=null?f.type:void 0)==="ThisExpression"&&n.property.type==="Identifier"&&n.property.name==="length"?new t.InvocationExpression(t.Methods.Length,new t.MemberExpression(n.object.property.name)):void 0}(),i!=null?i:JavaScriptToQueryVisitor.__super__.MemberExpression.call(this,n)},JavaScriptToQueryVisitor.prototype.Literal=function(n){return new t.ConstantExpression(n.value)},JavaScriptToQueryVisitor.prototype.UnaryExpression=function(n){var i,r;return n.operator==="+"?this.visit(n.argument):(i={"!":t.UnaryOperators.Not,"-":t.UnaryOperators.Negate},(r=this.translateUnary(n,i))!=null?r:JavaScriptToQueryVisitor.__super__.UnaryExpression.call(this,n))},JavaScriptToQueryVisitor.prototype.UpdateExpression=function(n){var i,r;return i={"++":t.UnaryOperators.Increment,"--":t.UnaryOperators.Decrement},(r=this.translateUnary(n,i))!=null?r:JavaScriptToQueryVisitor.__super__.UpdateExpression.call(this,n)},JavaScriptToQueryVisitor.prototype.LogicalExpression=function(n){var i,r;return i={"&&":t.BinaryOperators.And,"||":t.BinaryOperators.Or},(r=this.translateBinary(n,i))!=null?r:JavaScriptToQueryVisitor.__super__.LogicalExpression.call(this,n)},JavaScriptToQueryVisitor.prototype.BinaryExpression=function(n){var f,e,o,u,s,r,h;return o={"+":t.BinaryOperators.Add,"-":t.BinaryOperators.Subtract,"*":t.BinaryOperators.Multiply,"/":t.BinaryOperators.Divide,"%":t.BinaryOperators.Modulo,">":t.BinaryOperators.GreaterThan,">=":t.BinaryOperators.GreaterThanOrEqual,"<":t.BinaryOperators.LessThan,"<=":t.BinaryOperators.LessThanOrEqual,"!=":t.BinaryOperators.NotEqual,"!==":t.BinaryOperators.NotEqual,"==":t.BinaryOperators.Equal,"===":t.BinaryOperators.Equal},function(){var c,l;return(h=this.translateBinary(n,o))!=null?h:n.operator==="in"&&((c=n.right)!=null?c.type:void 0)==="Literal"&&i.isArray((l=n.right)!=null?l.value:void 0)?n.right.value.length>0?(e=this.visit(n.left),t.QueryExpression.groupClauses(t.BinaryOperators.Or,function(){var o,l,h,c;for(h=n.right.value,c=[],o=0,l=h.length;o<l;o++){if(r=h[o],i.isObject(r)){if(u=function(){var n=[];for(f in r)s=r[f],n.push(s);return n}(),(u!=null?u.length:void 0)!==1)throw"in operator requires comparison objects with a single field, not "+r+" ("+JSON.stringify(r)+"), for expression '"+this.getSource(n)+"'";r=u[0]}c.push(new t.BinaryExpression(t.BinaryOperators.Equal,e,new t.ConstantExpression(r)))}return c}.call(this))):new t.BinaryExpression(t.BinaryOperators.Equal,new t.ConstantExpression(!0),new t.ConstantExpression(!1)):JavaScriptToQueryVisitor.__super__.BinaryExpression.call(this,n)}.call(this)},JavaScriptToQueryVisitor.prototype.CallExpression=function(n){var e,f,u,o,r,i,s;return u=function(t){return function(i){var r;if(((r=n.arguments)!=null?r.length:void 0)!==1)throw"Function "+i+" expects one argument in expression '"+t.getSource(n)+"'";return t.visit(n.arguments[0])}}(this),o=function(t){return function(i,r){var u;if(((u=n.arguments)!=null?u.length:void 0)!==2)throw"Function "+r+" expects two arguments in expression '"+t.getSource(n)+"'";return[i,t.visit(n.arguments[0]),t.visit(n.arguments[1])]}}(this),f=n!=null?(s=n.callee)!=null?s.value:void 0:void 0,e=function(){var e,s,h,c,l,a,v;if(f===Math.floor)return new t.InvocationExpression(t.Methods.Floor,[u("floor")]);if(f===Math.ceil)return new t.InvocationExpression(t.Methods.Ceiling,[u("ceil")]);if(f===Math.round)return new t.InvocationExpression(t.Methods.Round,[u("round")]);if(n.callee.type==="MemberExpression"&&((e=n.callee.object)!=null?e.__hasThisExp:void 0)===!0){if(r=(n!=null?(s=n.callee)!=null?(h=s.object)!=null?h.type:void 0:void 0:void 0)==="CallExpression"?this.visit(n.callee.object):new t.MemberExpression((c=n.callee.object)!=null?(l=c.property)!=null?l.name:void 0:void 0),i=(a=n.callee)!=null?(v=a.property)!=null?v.name:void 0:void 0,i==="toUpperCase")return new t.InvocationExpression(t.Methods.ToUpperCase,[r]);if(i==="toLowerCase")return new t.InvocationExpression(t.Methods.ToLowerCase,[r]);if(i==="trim")return new t.InvocationExpression(t.Methods.Trim,[r]);if(i==="indexOf")return new t.InvocationExpression(t.Methods.IndexOf,[r,u("indexOf")]);if(i==="concat")return new t.InvocationExpression(t.Methods.Concat,[r,u("concat")]);if(i==="substring"||i==="substr")return new t.InvocationExpression(t.Methods.Substring,o(r,"substring"));if(i==="replace")return new t.InvocationExpression(t.Methods.Replace,o(r,"replace"));if(i==="getFullYear"||i==="getUTCFullYear")return new t.InvocationExpression(t.Methods.Year,[r]);if(i==="getYear")return new t.BinaryExpression(t.BinaryOperators.Subtract,new t.InvocationExpression(t.Methods.Year,[r]),new t.ConstantExpression(1900));if(i==="getMonth"||i==="getUTCMonth")return new t.BinaryExpression(t.BinaryOperators.Subtract,new t.InvocationExpression(t.Methods.Month,[r]),new t.ConstantExpression(1));if(i==="getDate"||i==="getUTCDate")return new t.InvocationExpression(t.Methods.Day,[r])}}.call(this),e!=null?e:JavaScriptToQueryVisitor.__super__.CallExpression.call(this,n)},JavaScriptToQueryVisitor}(r.JavaScriptVisitor)}).call(this)},t.Node=function(n){(function(){var i,r,t;t=require("./Utilities"),n.Node=i=function(){function Node(){this.type=t.functionName(this.constructor)}return Node.prototype.type="Node",Node}(),n.Visitor=r=function(){function Visitor(){}return Visitor.prototype.visit=function(n){var u,i,f,r;if(t.isArray(n)){for(r=[],i=0,f=n.length;i<f;i++)u=n[i],r.push(this.visit(u));return r}if(n!=null?n.type:void 0){if(t.isFunction(this[n.type]))return this[n.type](n);throw"Unsupported expression "+this.getSource(n);}else return n},Visitor.prototype.getSource=function(){return null},Visitor}()}).call(this)},t.ODataProvider=function(n){(function(){var r,f,i,u,t,e={}.hasOwnProperty,o=function(n,t){function ctor(){this.constructor=n}for(var i in t)e.call(t,i)&&(n[i]=t[i]);return ctor.prototype=t.prototype,n.prototype=new ctor,n.__super__=t.prototype,n};t=require("./Utilities"),i=require("./QueryNodes"),u=require("./Query").Query,n.ODataProvider=f=function(){function ODataProvider(){}return ODataProvider.prototype.toQuery=function(n){var t,i,r;return t=this.toOData(n,!0),r="/"+t.table,i="?",t.filters&&(r+=""+i+"$filter="+t.filters,i="&"),t.ordering&&(r+=""+i+"$orderby="+t.ordering,i="&"),t.skip&&(r+=""+i+"$skip="+t.skip,i="&"),(t.take||t.take===0)&&(r+=""+i+"$top="+t.take,i="&"),t.selections&&(r+=""+i+"$select="+t.selections,i="&"),t.includeTotalCount&&(r+=""+i+"$inlinecount=allpages"),r},ODataProvider.prototype.toOData=function(n,t){var e,i,u,f,o,s;return t==null&&(t=!1),i=(o=n!=null?n.getComponents():void 0)!=null?o:{},f=function(){var n,t;n=i!=null?i.ordering:void 0,t=[];for(u in n)e=n[u],t.push(e?u:""+u+" desc");return t}(),{table:i!=null?i.table:void 0,filters:r.convert(i.filters,t),ordering:f!=null?f.toString():void 0,skip:i!=null?i.skip:void 0,take:i!=null?i.take:void 0,selections:i!=null?(s=i.selections)!=null?s.toString():void 0:void 0,includeTotalCount:i!=null?i.includeTotalCount:void 0}},ODataProvider.prototype.fromOData=function(n,t,i,r,f,e,o){var a,h,w,s,c,l,b,k,d,v,y,p;for(s=new u(n),t&&s.where(t),(r||r===0)&&s.skip(r),(f||f===0)&&s.take(f),o&&s.includeTotalCount(),v=(d=e!=null?e.split(","):void 0)!=null?d:[],c=0,b=v.length;c<b;c++)h=v[c],s.select(h.trim());for(y=function(){var n,u,f,t,r;for(t=(f=i!=null?i.split(","):void 0)!=null?f:[],r=[],n=0,u=t.length;n<u;n++)w=t[n],r.push(w.trim().split(" "));return r}(),l=0,k=y.length;l<k;l++)p=y[l],h=p[0],a=p[1],(a!=null?a.toUpperCase():void 0)!=="DESC"?s.orderBy(h):s.orderByDescending(h);return s},ODataProvider}(),r=function(n){function ODataFilterQueryVisitor(n){this.encodeForUri=n}return o(ODataFilterQueryVisitor,n),ODataFilterQueryVisitor.convert=function(n,t){var i,r;return i=new ODataFilterQueryVisitor(t),(r=n?i.visit(n):void 0)!=null?r:null},ODataFilterQueryVisitor.prototype.toOData=function(n){var i;if(t.isNumber(n)||t.isBoolean(n))return n.toString();if(t.isString(n))return n=n.replace(/'/g,"''"),this.encodeForUri!=null&&this.encodeForUri===!0&&(n=encodeURIComponent(n)),"'"+n+"'";if(t.isDate(n))return i=JSON.stringify(n),i.length>2&&(i=i.slice(1,+(i.length-2)+1||9e9)),i=i.replace(/(T\d{2}:\d{2}:\d{2})Z$/,function(t,i){var r;return r=String(n.getMilliseconds()+1e3).substring(1),""+i+"."+r+"Z"}),"datetime'"+i+"'";if(n)throw"Unsupported literal value "+n;else return"null"},ODataFilterQueryVisitor.prototype.ConstantExpression=function(n){return this.toOData(n.value)},ODataFilterQueryVisitor.prototype.MemberExpression=function(n){return n.member},ODataFilterQueryVisitor.prototype.UnaryExpression=function(n){if(n.operator===i.UnaryOperators.Not)return"not "+this.visit(n.operand);if(n.operator===i.UnaryOperators.Negate)return"(0 sub "+this.visit(n.operand)+")";throw"Unsupported operator "+n.operator;},ODataFilterQueryVisitor.prototype.BinaryExpression=function(n){var i,t;if(i={And:"and",Or:"or",Add:"add",Subtract:"sub",Multiply:"mul",Divide:"div",Modulo:"mod",GreaterThan:"gt",GreaterThanOrEqual:"ge",LessThan:"lt",LessThanOrEqual:"le",NotEqual:"ne",Equal:"eq"},t=i[n.operator],t)return"("+this.visit(n.left)+" "+t+" "+this.visit(n.right)+")";throw"Unsupported operator "+n.operator;},ODataFilterQueryVisitor.prototype.InvocationExpression=function(n){var i,t;if(i={Length:"length",ToUpperCase:"toupper",ToLowerCase:"tolower",Trim:"trim",IndexOf:"indexof",Replace:"replace",Substring:"substring",Concat:"concat",Day:"day",Month:"month",Year:"year",Floor:"floor",Ceiling:"ceiling",Round:"round"},t=i[n.method],t)return""+t+"("+this.visit(n.args)+")";throw"Invocation of unsupported method "+n.method;},ODataFilterQueryVisitor.prototype.LiteralExpression=function(n){var t,r,i,u,e,f;for(i="",r=!1,f=n.queryString,u=0,e=f.length;u<e;u++)if(t=f[u],r)i+=t,r=t!=="'";else if(t==="?"){if(!n.args||n.args.length<=0)throw"Too few arguments for "+n.queryString+".";i+=this.toOData(n.args.shift())}else t==="'"?(i+=t,r=!0):i+=t;if(n.args&&n.args.length>0)throw"Too many arguments for "+n.queryString;return i},ODataFilterQueryVisitor}(i.QueryExpressionVisitor)}).call(this)},t.PartialEvaluator=function(n){(function(){var r,t,f,i,e={}.hasOwnProperty,u=function(n,t){function ctor(){this.constructor=n}for(var i in t)e.call(t,i)&&(n[i]=t[i]);return ctor.prototype=t.prototype,n.prototype=new ctor,n.__super__=t.prototype,n};i=require("./Utilities"),t=require("./JavaScriptNodes"),n.PartialEvaluator=f=function(n){function PartialEvaluator(n){this.context=n}return u(PartialEvaluator,n),PartialEvaluator.prototype.visit=function(n){var i,u,f,e,r,o,s,h,c,l;return n.__independent&&n.type!=="Literal"&&n.type?n.type==="Identifier"&&this.context.environment[n.name]?new t.Literal(this.context.environment[n.name]):(f=this.context.source.slice(n!=null?(s=n.range)!=null?s[0]:void 0:void 0,+((n!=null?(h=n.range)!=null?h[1]:void 0:void 0)-1)+1||9e9),u=(c=function(){var n,t;n=this.context.environment,t=[];for(i in n)r=n[i],t.push(i);return t}.call(this))!=null?c:[],o=(l=function(){var n,t;n=this.context.environment,t=[];for(i in n)r=n[i],t.push(JSON.stringify(r));return t}.call(this))!=null?l:[],e="(function("+u+") { return "+f+"; })("+o+")",r=eval(e),new t.Literal(r)):PartialEvaluator.__super__.visit.call(this,n)},PartialEvaluator.evaluate=function(n){var t,i;return i=new r(n),i.visit(n.expression),t=new PartialEvaluator(n),t.visit(n.expression)},PartialEvaluator}(t.JavaScriptVisitor),n.IndependenceNominator=r=function(n){function IndependenceNominator(n){this.context=n}return u(IndependenceNominator,n),IndependenceNominator.prototype.Literal=function(n){return IndependenceNominator.__super__.Literal.call(this,n),n.__independent=!0,n.__hasThisExp=!1,n},IndependenceNominator.prototype.ThisExpression=function(n){return IndependenceNominator.__super__.ThisExpression.call(this,n),n.__independent=!1,n.__hasThisExp=!0,n},IndependenceNominator.prototype.Identifier=function(n){return IndependenceNominator.__super__.Identifier.call(this,n),n.__independent=!0,n.__hasThisExp=!1,n},IndependenceNominator.prototype.MemberExpression=function(n){var t;return IndependenceNominator.__super__.MemberExpression.call(this,n),n.__hasThisExp=(t=n.object)!=null?t.__hasThisExp:void 0,n.__hasThisExp&&(n.__independent=!1,n!=null&&(n.property.__independent=!1)),n},IndependenceNominator.prototype.CallExpression=function(n){return IndependenceNominator.__super__.CallExpression.call(this,n),n.__hasThisExp=n.callee.__hasThisExp,n},IndependenceNominator.prototype.ObjectExpression=function(n){var u,t,i,r,o,s,f,e;for(IndependenceNominator.__super__.ObjectExpression.call(this,n),f=n.properties,i=0,o=f.length;i<o;i++)t=f[i],t.key.__independent=!1;for(u=!0,e=n.properties,r=0,s=e.length;r<s;r++)t=e[r],u&=t.value.__independent;return n.__independent=u?!0:!1,n},IndependenceNominator.prototype.visit=function(n){var r,f,e,o,t,u,s;if(IndependenceNominator.__super__.visit.call(this,n),!Object.prototype.hasOwnProperty.call(n,"__independent")){r=!0,f=function(n){var r;return i.isObject(n)?(r=t.__independent)!=null?r:!1:!0};for(e in n)if(t=n[e],i.isArray(t))for(u=0,s=t.length;u<s;u++)o=t[u],r&=f(o);else i.isObject(t)&&(r&=f(t));n.__independent=r?!0:!1}return n},IndependenceNominator}(t.JavaScriptVisitor)}).call(this)},t.Query=function(n){(function(){var u,f,i,e,t,r=[].slice;t=require("./Utilities"),i=require("./QueryNodes"),u=require("./JavaScript").JavaScript,n.Query=e=function(){function Query(n,f){var y,s,l,h,c,o,a,p,v,e;if(!n||!t.isString(n))throw"Expected the name of a table!";p=n,y=f,s=null,c=null,o=[],h={},a=null,v=null,l=!1,e=0,this.getComponents=function(){return{filters:s,selections:o,projection:c,ordering:h,skip:a,take:v,table:p,context:y,includeTotalCount:l,version:e}},this.setComponents=function(n){var t,i,r,u,f,w,b,k,d;return e++,s=(t=n!=null?n.filters:void 0)!=null?t:null,o=(i=n!=null?n.selections:void 0)!=null?i:[],c=(r=n!=null?n.projection:void 0)!=null?r:null,h=(u=n!=null?n.ordering:void 0)!=null?u:{},a=(f=n!=null?n.skip:void 0)!=null?f:null,v=(w=n!=null?n.take:void 0)!=null?w:null,l=(b=n!=null?n.includeTotalCount:void 0)!=null?b:!1,p=(k=n!=null?n.table:void 0)!=null?k:null,y=(d=n!=null?n.context:void 0)!=null?d:null,this},this.where=function(){var f,n,o,h,c;return n=arguments[0],f=2<=arguments.length?r.call(arguments,1):[],e++,o=function(){if(t.isFunction(n))return u.transformConstraint(n,f);if(t.isObject(n))return i.QueryExpression.groupClauses(i.BinaryOperators.And,function(){var t=[];for(h in n)c=n[h],t.push(o=new i.BinaryExpression(i.BinaryOperators.Equal,new i.MemberExpression(h),new i.ConstantExpression(c)));return t}());if(t.isString(n))return new i.LiteralExpression(n,f);throw"Expected a function, object, or string, not "+n;}(),s=i.QueryExpression.groupClauses(i.BinaryOperators.And,[s,o]),this},this.select=function(){var i,s,n,f,h;if(n=arguments[0],s=2<=arguments.length?r.call(arguments,1):[],e++,t.isString(n))for(o.push(n),f=0,h=s.length;f<h;f++){if(i=s[f],!t.isString(i))throw"Expected string parameters, not "+i;o.push(i)}else if(t.isFunction(n))c=n,o=u.getProjectedFields(c);else throw"Expected a string or a function, not "+n;return this},this.orderBy=function(){var n,u,i,f;for(u=1<=arguments.length?r.call(arguments,0):[],e++,i=0,f=u.length;i<f;i++){if(n=u[i],!t.isString(n))throw"Expected string parameters, not "+n;h[n]=!0}return this},this.orderByDescending=function(){var n,u,i,f;for(u=1<=arguments.length?r.call(arguments,0):[],e++,i=0,f=u.length;i<f;i++){if(n=u[i],!t.isString(n))throw"Expected string parameters, not "+n;h[n]=!1}return this},this.skip=function(n){if(e++,!t.isNumber(n))throw"Expected a number, not "+n;return a=n,this},this.take=function(n){if(e++,!t.isNumber(n))throw"Expected a number, not "+n;return v=n,this},this.includeTotalCount=function(){return e++,l=!0,this}}return Query.registerProvider=function(n,t){return Query.Providers[n]=t,Query.prototype["to"+n]=function(){if(t!=null)return typeof t.toQuery=="function"?t.toQuery(this):void 0}},Query.Providers={},Query.Expressions=i,Query}(),f=require("./ODataProvider").ODataProvider,e.registerProvider("OData",new f)}).call(this)},t.QueryNodes=function(n){(function(){var f,s,h,c,l,e,i,r,a,o,u,v={}.hasOwnProperty,t=function(n,t){function ctor(){this.constructor=n}for(var i in t)v.call(t,i)&&(n[i]=t[i]);return ctor.prototype=t.prototype,n.prototype=new ctor,n.__super__=t.prototype,n};u=require("./Node"),e=u.Node,o=u.Visitor,n.QueryExpression=i=function(n){function QueryExpression(){QueryExpression.__super__.constructor.call(this)}return t(QueryExpression,n),QueryExpression.groupClauses=function(n,t){var i;return i=function(t,i){return t?i?new f(n,t,i):t:i},t.reduce(i,null)},QueryExpression}(e),n.QueryExpressionVisitor=r=function(n){function QueryExpressionVisitor(){QueryExpressionVisitor.__super__.constructor.call(this)}return t(QueryExpressionVisitor,n),QueryExpressionVisitor.prototype.QueryExpression=function(n){return n},QueryExpressionVisitor}(o),n.ConstantExpression=s=function(n){function ConstantExpression(n){this.value=n,ConstantExpression.__super__.constructor.call(this)}return t(ConstantExpression,n),ConstantExpression}(i),r.prototype.ConstantExpression=function(n){return this.QueryExpression(n)},n.MemberExpression=l=function(n){function MemberExpression(n){this.member=n,MemberExpression.__super__.constructor.call(this)}return t(MemberExpression,n),MemberExpression}(i),r.prototype.MemberExpression=function(n){return this.QueryExpression(n)},n.BinaryExpression=f=function(n){function BinaryExpression(n,t,i){this.operator=n,this.left=t,this.right=i,BinaryExpression.__super__.constructor.call(this)}return t(BinaryExpression,n),BinaryExpression}(i),r.prototype.BinaryExpression=function(n){return n=this.QueryExpression(n),n.left=this.visit(n.left),n.right=this.visit(n.right),n},n.BinaryOperators={And:"And",Or:"Or",Add:"Add",Subtract:"Subtract",Multiply:"Multiply",Divide:"Divide",Modulo:"Modulo",GreaterThan:"GreaterThan",GreaterThanOrEqual:"GreaterThanOrEqual",LessThan:"LessThan",LessThanOrEqual:"LessThanOrEqual",NotEqual:"NotEqual",Equal:"Equal"},n.UnaryExpression=a=function(n){function UnaryExpression(n,t){this.operator=n,this.operand=t,UnaryExpression.__super__.constructor.call(this)}return t(UnaryExpression,n),UnaryExpression}(i),r.prototype.UnaryExpression=function(n){return n=this.QueryExpression(n),n.operand=this.visit(n.operand),n},n.UnaryOperators={Not:"Not",Negate:"Negate",Increment:"Increment",Decrement:"Decrement"},n.InvocationExpression=h=function(n){function InvocationExpression(n,t){this.method=n,this.args=t,InvocationExpression.__super__.constructor.call(this)}return t(InvocationExpression,n),InvocationExpression}(i),r.prototype.InvocationExpression=function(n){return n=this.QueryExpression(n),n.args=this.visit(n.args),n},n.Methods={Length:"Length",ToUpperCase:"ToUpperCase",ToLowerCase:"ToLowerCase",Trim:"Trim",IndexOf:"IndexOf",Replace:"Replace",Substring:"Substring",Concat:"Concat",Day:"Day",Month:"Month",Year:"Year",Floor:"Floor",Ceiling:"Ceiling",Round:"Round"},n.LiteralExpression=c=function(n){function LiteralExpression(n,t){this.queryString=n,this.args=t!=null?t:[],LiteralExpression.__super__.constructor.call(this)}return t(LiteralExpression,n),LiteralExpression}(i),r.prototype.LiteralExpression=function(n){return this.QueryExpression(n)}}).call(this)},t.Utilities=function(n){(function(){var t,i=[].slice;t=function(n){return Object.prototype.toString.call(n).slice(8,-1).toLowerCase()},Array.prototype.reduce==null&&(Array.prototype.reduce=function(){var u,n,f,t,r,e;if(u=arguments[0],e=2<=arguments.length?i.call(arguments,1):[],n=this,f=n.length,t=0,r=void 0,n==null)throw new TypeError("Object is null or undefined");if(typeof u!="function")throw new TypeError("First argument is not callable");if(e.length===0)if(f===0)throw new TypeError("Array length is 0 and no second argument");else r=n[0],t=1;else r=e[0];while(t<f)t in n&&(r=u.call(void 0,r,n[t],n)),++t;return r}),Array.prototype.map==null&&(Array.prototype.map=function(n,t){var e,i,r,o,u,f,s;if(typeof this=="undefined"||this===null)throw new TypeError("this is null or not defined");if(typeof n!="function")throw new TypeError(n+" is not a function");for(t=t?t:void 0,r=Object(this),o=r.length>>>0,u=new Array(o),i=f=0,s=r.length;f<s;i=++f)e=r[i],i in r&&(u[i]=n.call(t,e,i,r));return u}),Array.isArray==null&&(Array.isArray=function(n){return Object.prototype.toString.call(n)==="[object Array]"}),n.isObject=function(n){return Object.prototype.toString.call(n).slice(8,-1).toLowerCase()==="object"},n.isString=function(n){return typeof n=="string"},n.isFunction=function(n){return typeof n=="function"},n.isArray=Array.isArray,n.isNumber=function(n){return typeof n=="number"},n.isBoolean=function(n){return typeof n=="boolean"},n.isDate=function(n){return t(n)==="date"},n.functionName=function(n){var r,t,i;return typeof Function.prototype.name=="function"?Function.prototype.name.call(n):(i=n.toString(),t="function ",i.slice(0,+(t.length-1)+1||9e9)===t&&(r=i.indexOf("(",t.length),r>t.length))?i.slice(t.length,+(r-1)+1||9e9):null}}).call(this)},t.esprima=function(n){(function(t,i){"use strict";typeof define=="function"&&define.amd?define(["exports"],i):typeof n!="undefined"?i(n):i(t.esprima={})})(this,function(n){"use strict";function assert(n,t){if(!n)throw new Error("ASSERT: "+t);}function isDecimalDigit(n){return n>=48&&n<=57}function isHexDigit(n){return"0123456789abcdefABCDEF".indexOf(n)>=0}function isOctalDigit(n){return"01234567".indexOf(n)>=0}function isWhiteSpace(n){return n===32||n===9||n===11||n===12||n===160||n>=5760&&[5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279].indexOf(n)>=0}function isLineTerminator(n){return n===10||n===13||n===8232||n===8233}function isIdentifierStart(n){return n===36||n===95||n>=65&&n<=90||n>=97&&n<=122||n===92||n>=128&&w.NonAsciiIdentifierStart.test(String.fromCharCode(n))}function isIdentifierPart(n){return n===36||n===95||n>=65&&n<=90||n>=97&&n<=122||n>=48&&n<=57||n===92||n>=128&&w.NonAsciiIdentifierPart.test(String.fromCharCode(n))}function isFutureReservedWord(n){switch(n){case"class":case"enum":case"export":case"extends":case"import":case"super":return!0;default:return!1}}function isStrictModeReservedWord(n){switch(n){case"implements":case"interface":case"package":case"private":case"protected":case"public":case"static":case"yield":case"let":return!0;default:return!1}}function isRestrictedWord(n){return n==="eval"||n==="arguments"}function isKeyword(n){if(l&&isStrictModeReservedWord(n))return!0;switch(n.length){case 2:return n==="if"||n==="in"||n==="do";case 3:return n==="var"||n==="for"||n==="new"||n==="try"||n==="let";case 4:return n==="this"||n==="else"||n==="case"||n==="void"||n==="with"||n==="enum";case 5:return n==="while"||n==="break"||n==="catch"||n==="throw"||n==="const"||n==="yield"||n==="class"||n==="super";case 6:return n==="return"||n==="typeof"||n==="delete"||n==="switch"||n==="export"||n==="import";case 7:return n==="default"||n==="finally"||n==="extends";case 8:return n==="function"||n==="continue"||n==="debugger";case 10:return n==="instanceof";default:return!1}}function addComment(n,t,r,u,f){var e;(assert(typeof r=="number","Comment must have valid position"),o.lastCommentStart>=r)||(o.lastCommentStart=r,e={type:n,value:t},i.range&&(e.range=[r,u]),i.loc&&(e.loc=f),i.comments.push(e),i.attachComment&&(i.leadingComments.push(e),i.trailingComments.push(e)))}function skipSingleLineComment(n){for(var o,e,u=t-n,f={start:{line:h,column:t-c-n}};t<a;)if(o=r.charCodeAt(t),++t,isLineTerminator(o)){i.comments&&(e=r.slice(u+n,t-1),f.end={line:h,column:t-c-1},addComment("Line",e,u,t-1,f)),o===13&&r.charCodeAt(t)===10&&++t,++h,c=t;return}i.comments&&(e=r.slice(u+n,t),f.end={line:h,column:t-c},addComment("Line",e,u,t,f))}function skipMultiLineComment(){var u,e,n,o;for(i.comments&&(u=t-2,e={start:{line:h,column:t-c-2}});t<a;)if(n=r.charCodeAt(t),isLineTerminator(n))n===13&&r.charCodeAt(t+1)===10&&++t,++h,++t,c=t,t>=a&&throwError({},f.UnexpectedToken,"ILLEGAL");else if(n===42){if(r.charCodeAt(t+1)===47){++t,++t,i.comments&&(o=r.slice(u+2,t-2),e.end={line:h,column:t-c},addComment("Block",o,u,t,e));return}++t}else++t;throwError({},f.UnexpectedToken,"ILLEGAL")}function skipComment(){for(var n,i=t===0;t<a;)if(n=r.charCodeAt(t),isWhiteSpace(n))++t;else if(isLineTerminator(n))++t,n===13&&r.charCodeAt(t)===10&&++t,++h,c=t,i=!0;else if(n===47)if(n=r.charCodeAt(t+1),n===47)++t,++t,skipSingleLineComment(2),i=!0;else if(n===42)++t,++t,skipMultiLineComment();else break;else if(i&&n===45)if(r.charCodeAt(t+1)===45&&r.charCodeAt(t+2)===62)t+=3,skipSingleLineComment(3);else break;else if(n===60)if(r.slice(t+1,t+4)==="!--")++t,++t,++t,++t,skipSingleLineComment(4);else break;else break}function scanHexEscape(n){for(var e,u=0,f=n==="u"?4:2,i=0;i<f;++i)if(t<a&&isHexDigit(r[t]))e=r[t++],u=u*16+"0123456789abcdef".indexOf(e.toLowerCase());else return"";return String.fromCharCode(u)}function scanUnicodeCodePointEscape(){var i,n,u,e;for(i=r[t],n=0,i==="}"&&throwError({},f.UnexpectedToken,"ILLEGAL");t<a;){if(i=r[t++],!isHexDigit(i))break;n=n*16+"0123456789abcdef".indexOf(i.toLowerCase())}return((n>1114111||i!=="}")&&throwError({},f.UnexpectedToken,"ILLEGAL"),n<=65535)?String.fromCharCode(n):(u=(n-65536>>10)+55296,e=(n-65536&1023)+56320,String.fromCharCode(u,e))}function getEscapedIdentifier(){var n,i;for(n=r.charCodeAt(t++),i=String.fromCharCode(n),n===92&&(r.charCodeAt(t)!==117&&throwError({},f.UnexpectedToken,"ILLEGAL"),++t,n=scanHexEscape("u"),n&&n!=="\\"&&isIdentifierStart(n.charCodeAt(0))||throwError({},f.UnexpectedToken,"ILLEGAL"),i=n);t<a;){if(n=r.charCodeAt(t),!isIdentifierPart(n))break;++t,i+=String.fromCharCode(n),n===92&&(i=i.substr(0,i.length-1),r.charCodeAt(t)!==117&&throwError({},f.UnexpectedToken,"ILLEGAL"),++t,n=scanHexEscape("u"),n&&n!=="\\"&&isIdentifierPart(n.charCodeAt(0))||throwError({},f.UnexpectedToken,"ILLEGAL"),i+=n)}return i}function getIdentifier(){for(var i,n=t++;t<a;){if(i=r.charCodeAt(t),i===92)return t=n,getEscapedIdentifier();if(isIdentifierPart(i))++t;else break}return r.slice(n,t)}function scanIdentifier(){var i,n,f;return i=t,n=r.charCodeAt(t)===92?getEscapedIdentifier():getIdentifier(),f=n.length===1?u.Identifier:isKeyword(n)?u.Keyword:n==="null"?u.NullLiteral:n==="true"||n==="false"?u.BooleanLiteral:u.Identifier,{type:f,value:n,lineNumber:h,lineStart:c,start:i,end:t}}function scanPunctuator(){var n=t,e=r.charCodeAt(t),v,s=r[t],l,o,a;switch(e){case 46:case 40:case 41:case 59:case 44:case 123:case 125:case 91:case 93:case 58:case 63:case 126:return++t,i.tokenize&&(e===40?i.openParenToken=i.tokens.length:e===123&&(i.openCurlyToken=i.tokens.length)),{type:u.Punctuator,value:String.fromCharCode(e),lineNumber:h,lineStart:c,start:n,end:t};default:if(v=r.charCodeAt(t+1),v===61)switch(e){case 43:case 45:case 47:case 60:case 62:case 94:case 124:case 37:case 38:case 42:return t+=2,{type:u.Punctuator,value:String.fromCharCode(e)+String.fromCharCode(v),lineNumber:h,lineStart:c,start:n,end:t};case 33:case 61:return t+=2,r.charCodeAt(t)===61&&++t,{type:u.Punctuator,value:r.slice(n,t),lineNumber:h,lineStart:c,start:n,end:t}}}if(a=r.substr(t,4),a===">>>=")return t+=4,{type:u.Punctuator,value:a,lineNumber:h,lineStart:c,start:n,end:t};if(o=a.substr(0,3),o===">>>"||o==="<<="||o===">>=")return t+=3,{type:u.Punctuator,value:o,lineNumber:h,lineStart:c,start:n,end:t};if(l=o.substr(0,2),s===l[1]&&"+-<>&|".indexOf(s)>=0||l==="=>")return t+=2,{type:u.Punctuator,value:l,lineNumber:h,lineStart:c,start:n,end:t};if("<>=!+-*%&|^/".indexOf(s)>=0)return++t,{type:u.Punctuator,value:s,lineNumber:h,lineStart:c,start:n,end:t};throwError({},f.UnexpectedToken,"ILLEGAL")}function scanHexLiteral(n){for(var i="";t<a;){if(!isHexDigit(r[t]))break;i+=r[t++]}return i.length===0&&throwError({},f.UnexpectedToken,"ILLEGAL"),isIdentifierStart(r.charCodeAt(t))&&throwError({},f.UnexpectedToken,"ILLEGAL"),{type:u.NumericLiteral,value:parseInt("0x"+i,16),lineNumber:h,lineStart:c,start:n,end:t}}function scanOctalLiteral(n){for(var i="0"+r[t++];t<a;){if(!isOctalDigit(r[t]))break;i+=r[t++]}return(isIdentifierStart(r.charCodeAt(t))||isDecimalDigit(r.charCodeAt(t)))&&throwError({},f.UnexpectedToken,"ILLEGAL"),{type:u.NumericLiteral,value:parseInt(i,8),octal:!0,lineNumber:h,lineStart:c,start:n,end:t}}function scanNumericLiteral(){var i,e,n;if(n=r[t],assert(isDecimalDigit(n.charCodeAt(0))||n===".","Numeric literal must start with a decimal digit or a decimal point"),e=t,i="",n!=="."){if(i=r[t++],n=r[t],i==="0"){if(n==="x"||n==="X")return++t,scanHexLiteral(e);if(isOctalDigit(n))return scanOctalLiteral(e);n&&isDecimalDigit(n.charCodeAt(0))&&throwError({},f.UnexpectedToken,"ILLEGAL")}while(isDecimalDigit(r.charCodeAt(t)))i+=r[t++];n=r[t]}if(n==="."){for(i+=r[t++];isDecimalDigit(r.charCodeAt(t));)i+=r[t++];n=r[t]}if(n==="e"||n==="E")if(i+=r[t++],n=r[t],(n==="+"||n==="-")&&(i+=r[t++]),isDecimalDigit(r.charCodeAt(t)))while(isDecimalDigit(r.charCodeAt(t)))i+=r[t++];else throwError({},f.UnexpectedToken,"ILLEGAL");return isIdentifierStart(r.charCodeAt(t))&&throwError({},f.UnexpectedToken,"ILLEGAL"),{type:u.NumericLiteral,value:parseFloat(i),lineNumber:h,lineStart:c,start:e,end:t}}function scanStringLiteral(){var i="",o,v,n,e,s,y,l=!1,p,w;for(p=h,w=c,o=r[t],assert(o==="'"||o==='"',"String literal must starts with a quote"),v=t,++t;t<a;)if(n=r[t++],n===o){o="";break}else if(n==="\\")if(n=r[t++],n&&isLineTerminator(n.charCodeAt(0)))++h,n==="\r"&&r[t]==="\n"&&++t,c=t;else switch(n){case"u":case"x":r[t]==="{"?(++t,i+=scanUnicodeCodePointEscape()):(y=t,s=scanHexEscape(n),s?i+=s:(t=y,i+=n));break;case"n":i+="\n";break;case"r":i+="\r";break;case"t":i+="\t";break;case"b":i+="\b";break;case"f":i+="\f";break;case"v":i+="\x0b";break;default:isOctalDigit(n)?(e="01234567".indexOf(n),e!==0&&(l=!0),t<a&&isOctalDigit(r[t])&&(l=!0,e=e*8+"01234567".indexOf(r[t++]),"0123".indexOf(n)>=0&&t<a&&isOctalDigit(r[t])&&(e=e*8+"01234567".indexOf(r[t++]))),i+=String.fromCharCode(e)):i+=n}else if(isLineTerminator(n.charCodeAt(0)))break;else i+=n;return o!==""&&throwError({},f.UnexpectedToken,"ILLEGAL"),{type:u.StringLiteral,value:i,octal:l,startLineNumber:p,startLineStart:w,lineNumber:h,lineStart:c,start:v,end:t}}function testRegExp(n,t){var i;try{i=new RegExp(n,t)}catch(r){throwError({},f.InvalidRegExp)}return i}function scanRegExpBody(){var n,i,u,e,o;for(n=r[t],assert(n==="/","Regular expression literal must start with a slash"),i=r[t++],u=!1,e=!1;t<a;)if(n=r[t++],i+=n,n==="\\")n=r[t++],isLineTerminator(n.charCodeAt(0))&&throwError({},f.UnterminatedRegExp),i+=n;else if(isLineTerminator(n.charCodeAt(0)))throwError({},f.UnterminatedRegExp);else if(u)n==="]"&&(u=!1);else if(n==="/"){e=!0;break}else n==="["&&(u=!0);return e||throwError({},f.UnterminatedRegExp),o=i.substr(1,i.length-2),{value:o,literal:i}}function scanRegExpFlags(){for(var n,e,i="",u="";t<a;){if(n=r[t],!isIdentifierPart(n.charCodeAt(0)))break;if(++t,n==="\\"&&t<a)if(n=r[t],n==="u"){if(++t,e=t,n=scanHexEscape("u"),n)for(u+=n,i+="\\u";e<t;++e)i+=r[e];else t=e,u+="u",i+="\\u";throwErrorTolerant({},f.UnexpectedToken,"ILLEGAL")}else i+="\\",throwErrorTolerant({},f.UnexpectedToken,"ILLEGAL");else u+=n,i+=n}return{value:u,literal:i}}function scanRegExp(){var n,r,f,o;return(e=null,skipComment(),n=t,r=scanRegExpBody(),f=scanRegExpFlags(),o=testRegExp(r.value,f.value),i.tokenize)?{type:u.RegularExpression,value:o,lineNumber:h,lineStart:c,start:n,end:t}:{literal:r.literal+f.literal,value:o,start:n,end:t}}function collectRegex(){var r,u,f,n;return skipComment(),r=t,u={start:{line:h,column:t-c}},f=scanRegExp(),u.end={line:h,column:t-c},i.tokenize||(i.tokens.length>0&&(n=i.tokens[i.tokens.length-1],n.range[0]===r&&n.type==="Punctuator"&&(n.value==="/"||n.value==="/=")&&i.tokens.pop()),i.tokens.push({type:"RegularExpression",value:f.literal,range:[r,t],loc:u})),f}function isIdentifierName(n){return n.type===u.Identifier||n.type===u.Keyword||n.type===u.BooleanLiteral||n.type===u.NullLiteral}function advanceSlash(){var t,n;if(t=i.tokens[i.tokens.length-1],!t)return collectRegex();if(t.type==="Punctuator"){if(t.value==="]")return scanPunctuator();if(t.value===")")return(n=i.tokens[i.openParenToken-1],n&&n.type==="Keyword"&&(n.value==="if"||n.value==="while"||n.value==="for"||n.value==="with"))?collectRegex():scanPunctuator();if(t.value==="}"){if(i.tokens[i.openCurlyToken-3]&&i.tokens[i.openCurlyToken-3].type==="Keyword"){if(n=i.tokens[i.openCurlyToken-4],!n)return scanPunctuator()}else if(i.tokens[i.openCurlyToken-4]&&i.tokens[i.openCurlyToken-4].type==="Keyword"){if(n=i.tokens[i.openCurlyToken-5],!n)return collectRegex()}else return scanPunctuator();return b.indexOf(n.value)>=0?scanPunctuator():collectRegex()}return collectRegex()}return t.type==="Keyword"?collectRegex():scanPunctuator()}function advance(){var n;return(skipComment(),t>=a)?{type:u.EOF,lineNumber:h,lineStart:c,start:t,end:t}:(n=r.charCodeAt(t),isIdentifierStart(n))?scanIdentifier():n===40||n===41||n===59?scanPunctuator():n===39||n===34?scanStringLiteral():n===46?isDecimalDigit(r.charCodeAt(t+1))?scanNumericLiteral():scanPunctuator():isDecimalDigit(n)?scanNumericLiteral():i.tokenize&&n===47?advanceSlash():scanPunctuator()}function collectToken(){var f,n,e;return skipComment(),f={start:{line:h,column:t-c}},n=advance(),f.end={line:h,column:t-c},n.type!==u.EOF&&(e=r.slice(n.start,n.end),i.tokens.push({type:v[n.type],value:e,range:[n.start,n.end],loc:f})),n}function lex(){var n;return n=e,t=n.end,h=n.lineNumber,c=n.lineStart,e=typeof i.tokens!="undefined"?collectToken():advance(),t=n.end,h=n.lineNumber,c=n.lineStart,n}function peek(){var n,r,u;n=t,r=h,u=c,e=typeof i.tokens!="undefined"?collectToken():advance(),t=n,h=r,c=u}function Position(){this.line=h,this.column=t-c}function SourceLocation(){this.start=new Position,this.end=null}function WrappingSourceLocation(n){this.start=n.type===u.StringLiteral?{line:n.startLineNumber,column:n.start-n.startLineStart}:{line:n.lineNumber,column:n.start-n.lineStart},this.end=null}function Node(){t=e.start,e.type===u.StringLiteral?(h=e.startLineNumber,c=e.startLineStart):(h=e.lineNumber,c=e.lineStart),i.range&&(this.range=[t,0]),i.loc&&(this.loc=new SourceLocation)}function WrappingNode(n){i.range&&(this.range=[n.start,0]),i.loc&&(this.loc=new WrappingSourceLocation(n))}function peekLineTerminator(){var i,n,r,u;return i=t,n=h,r=c,skipComment(),u=h!==n,t=i,h=n,c=r,u}function throwError(n,i){var r,f=Array.prototype.slice.call(arguments,2),u=i.replace(/%(\d)/g,function(n,t){return assert(t<f.length,"Message reference must be in range"),f[t]});typeof n.lineNumber=="number"?(r=new Error("Line "+n.lineNumber+": "+u),r.index=n.start,r.lineNumber=n.lineNumber,r.column=n.start-c+1):(r=new Error("Line "+h+": "+u),r.index=t,r.lineNumber=h,r.column=t-c+1),r.description=u;throw r;}function throwErrorTolerant(){try{throwError.apply(null,arguments)}catch(n){if(i.errors)i.errors.push(n);else throw n;}}function throwUnexpected(n){if(n.type===u.EOF&&throwError(n,f.UnexpectedEOS),n.type===u.NumericLiteral&&throwError(n,f.UnexpectedNumber),n.type===u.StringLiteral&&throwError(n,f.UnexpectedString),n.type===u.Identifier&&throwError(n,f.UnexpectedIdentifier),n.type===u.Keyword){if(isFutureReservedWord(n.value))throwError(n,f.UnexpectedReserved);else if(l&&isStrictModeReservedWord(n.value)){throwErrorTolerant(n,f.StrictReservedWord);return}throwError(n,f.UnexpectedToken,n.value)}throwError(n,f.UnexpectedToken,n.value)}function expect(n){var t=lex();(t.type!==u.Punctuator||t.value!==n)&&throwUnexpected(t)}function expectTolerant(n){if(i.errors){var t=e;t.type!==u.Punctuator&&t.value!==n?throwErrorTolerant(t,f.UnexpectedToken,t.value):lex()}else expect(n)}function expectKeyword(n){var t=lex();(t.type!==u.Keyword||t.value!==n)&&throwUnexpected(t)}function match(n){return e.type===u.Punctuator&&e.value===n}function matchKeyword(n){return e.type===u.Keyword&&e.value===n}function matchAssign(){var n;return e.type!==u.Punctuator?!1:(n=e.value,n==="="||n==="*="||n==="/="||n==="%="||n==="+="||n==="-="||n==="<<="||n===">>="||n===">>>="||n==="&="||n==="^="||n==="|=")}function consumeSemicolon(){var n;if(r.charCodeAt(t)===59||match(";")){lex();return}(n=h,skipComment(),h===n)&&(e.type===u.EOF||match("}")||throwUnexpected(e))}function isLeftHandSide(n){return n.type===s.Identifier||n.type===s.MemberExpression}function parseArrayInitialiser(){var n=[],t=new Node;for(expect("[");!match("]");)match(",")?(lex(),n.push(null)):(n.push(parseAssignmentExpression()),match("]")||expect(","));return lex(),t.finishArrayExpression(n)}function parsePropertyFunction(n,t){var i,r,u=new Node;return i=l,r=parseFunctionSourceElements(),t&&l&&isRestrictedWord(n[0].name)&&throwErrorTolerant(t,f.StrictParamName),l=i,u.finishFunctionExpression(null,n,[],r)}function parseObjectPropertyKey(){var n,t=new Node;return(n=lex(),n.type===u.StringLiteral||n.type===u.NumericLiteral)?(l&&n.octal&&throwErrorTolerant(n,f.StrictOctalLiteral),t.finishLiteral(n)):t.finishIdentifier(n.value)}function parseObjectProperty(){var n,i,o,t,s,r=new Node;if(n=e,n.type===u.Identifier)return(o=parseObjectPropertyKey(),n.value==="get"&&!match(":"))?(i=parseObjectPropertyKey(),expect("("),expect(")"),t=parsePropertyFunction([]),r.finishProperty("get",i,t)):n.value==="set"&&!match(":")?(i=parseObjectPropertyKey(),expect("("),n=e,n.type!==u.Identifier?(expect(")"),throwErrorTolerant(n,f.UnexpectedToken,n.value),t=parsePropertyFunction([])):(s=[parseVariableIdentifier()],expect(")"),t=parsePropertyFunction(s,n)),r.finishProperty("set",i,t)):(expect(":"),t=parseAssignmentExpression(),r.finishProperty("init",o,t));if(n.type===u.EOF||n.type===u.Punctuator)throwUnexpected(n);else return i=parseObjectPropertyKey(),expect(":"),t=parseAssignmentExpression(),r.finishProperty("init",i,t)}function parseObjectInitialiser(){var u=[],n,e,i,t,r={},o=String,h=new Node;for(expect("{");!match("}");)n=parseObjectProperty(),e=n.key.type===s.Identifier?n.key.name:o(n.key.value),t=n.kind==="init"?y.Data:n.kind==="get"?y.Get:y.Set,i="$"+e,Object.prototype.hasOwnProperty.call(r,i)?(r[i]===y.Data?l&&t===y.Data?throwErrorTolerant({},f.StrictDuplicateProperty):t!==y.Data&&throwErrorTolerant({},f.AccessorDataProperty):t===y.Data?throwErrorTolerant({},f.AccessorDataProperty):r[i]&t&&throwErrorTolerant({},f.AccessorGetSet),r[i]|=t):r[i]=t,u.push(n),match("}")||expectTolerant(",");return expect("}"),h.finishObjectExpression(u)}function parseGroupExpression(){var n;return(expect("("),match(")"))?(lex(),p.ArrowParameterPlaceHolder):(++o.parenthesisCount,n=parseExpression(),expect(")"),n)}function parsePrimaryExpression(){var t,r,o,n;if(match("("))return parseGroupExpression();if(match("["))return parseArrayInitialiser();if(match("{"))return parseObjectInitialiser();if(t=e.type,n=new Node,t===u.Identifier)o=n.finishIdentifier(lex().value);else if(t===u.StringLiteral||t===u.NumericLiteral)l&&e.octal&&throwErrorTolerant(e,f.StrictOctalLiteral),o=n.finishLiteral(lex());else if(t===u.Keyword){if(matchKeyword("function"))return parseFunctionExpression();matchKeyword("this")?(lex(),o=n.finishThisExpression()):throwUnexpected(lex())}else t===u.BooleanLiteral?(r=lex(),r.value=r.value==="true",o=n.finishLiteral(r)):t===u.NullLiteral?(r=lex(),r.value=null,o=n.finishLiteral(r)):match("/")||match("/=")?(o=typeof i.tokens!="undefined"?n.finishLiteral(collectRegex()):n.finishLiteral(scanRegExp()),peek()):throwUnexpected(lex());return o}function parseArguments(){var n=[];if(expect("("),!match(")"))while(t<a){if(n.push(parseAssignmentExpression()),match(")"))break;expectTolerant(",")}return expect(")"),n}function parseNonComputedProperty(){var n,t=new Node;return n=lex(),isIdentifierName(n)||throwUnexpected(n),t.finishIdentifier(n.value)}function parseNonComputedMember(){return expect("."),parseNonComputedProperty()}function parseComputedMember(){var n;return expect("["),n=parseExpression(),expect("]"),n}function parseNewExpression(){var n,t,i=new Node;return expectKeyword("new"),n=parseLeftHandSideExpression(),t=match("(")?parseArguments():[],i.finishNewExpression(n,t)}function parseLeftHandSideExpressionAllowCall(){var n,r,t,i,u=o.allowIn;for(i=e,o.allowIn=!0,n=matchKeyword("new")?parseNewExpression():parsePrimaryExpression();;)if(match("."))t=parseNonComputedMember(),n=new WrappingNode(i).finishMemberExpression(".",n,t);else if(match("("))r=parseArguments(),n=new WrappingNode(i).finishCallExpression(n,r);else if(match("["))t=parseComputedMember(),n=new WrappingNode(i).finishMemberExpression("[",n,t);else break;return o.allowIn=u,n}function parseLeftHandSideExpression(){var n,t,i;for(assert(o.allowIn,"callee of new expression always allow in keyword."),i=e,n=matchKeyword("new")?parseNewExpression():parsePrimaryExpression();;)if(match("["))t=parseComputedMember(),n=new WrappingNode(i).finishMemberExpression("[",n,t);else if(match("."))t=parseNonComputedMember(),n=new WrappingNode(i).finishMemberExpression(".",n,t);else break;return n}function parsePostfixExpression(){var n,t,i=e;return n=parseLeftHandSideExpressionAllowCall(),e.type===u.Punctuator&&(match("++")||match("--"))&&!peekLineTerminator()&&(l&&n.type===s.Identifier&&isRestrictedWord(n.name)&&throwErrorTolerant({},f.StrictLHSPostfix),isLeftHandSide(n)||throwErrorTolerant({},f.InvalidLHSInAssignment),t=lex(),n=new WrappingNode(i).finishPostfixExpression(t.value,n)),n}function parseUnaryExpression(){var t,n,i;return e.type!==u.Punctuator&&e.type!==u.Keyword?n=parsePostfixExpression():match("++")||match("--")?(i=e,t=lex(),n=parseUnaryExpression(),l&&n.type===s.Identifier&&isRestrictedWord(n.name)&&throwErrorTolerant({},f.StrictLHSPrefix),isLeftHandSide(n)||throwErrorTolerant({},f.InvalidLHSInAssignment),n=new WrappingNode(i).finishUnaryExpression(t.value,n)):match("+")||match("-")||match("~")||match("!")?(i=e,t=lex(),n=parseUnaryExpression(),n=new WrappingNode(i).finishUnaryExpression(t.value,n)):matchKeyword("delete")||matchKeyword("void")||matchKeyword("typeof")?(i=e,t=lex(),n=parseUnaryExpression(),n=new WrappingNode(i).finishUnaryExpression(t.value,n),l&&n.operator==="delete"&&n.argument.type===s.Identifier&&throwErrorTolerant({},f.StrictDelete)):n=parsePostfixExpression(),n}function binaryPrecedence(n,t){var i=0;if(n.type!==u.Punctuator&&n.type!==u.Keyword)return 0;switch(n.value){case"||":i=1;break;case"&&":i=2;break;case"|":i=3;break;case"^":i=4;break;case"&":i=5;break;case"==":case"!=":case"===":case"!==":i=6;break;case"<":case">":case"<=":case">=":case"instanceof":i=7;break;case"in":i=t?7:0;break;case"<<":case">>":case">>>":i=8;break;case"+":case"-":i=9;break;case"*":case"/":case"%":i=11}return i}function parseBinaryExpression(){var c,i,t,r,u,n,h,l,f,s;if((c=e,f=parseUnaryExpression(),f===p.ArrowParameterPlaceHolder)||(r=e,u=binaryPrecedence(r,o.allowIn),u===0))return f;for(r.prec=u,lex(),i=[c,e],h=parseUnaryExpression(),n=[f,r,h];(u=binaryPrecedence(e,o.allowIn))>0;){while(n.length>2&&u<=n[n.length-2].prec)h=n.pop(),l=n.pop().value,f=n.pop(),i.pop(),t=new WrappingNode(i[i.length-1]).finishBinaryExpression(l,f,h),n.push(t);r=lex(),r.prec=u,n.push(r),i.push(e),t=parseUnaryExpression(),n.push(t)}for(s=n.length-1,t=n[s],i.pop();s>1;)t=new WrappingNode(i.pop()).finishBinaryExpression(n[s-1].value,n[s-2],t),s-=2;return t}function parseConditionalExpression(){var n,t,i,r,u;return(u=e,n=parseBinaryExpression(),n===p.ArrowParameterPlaceHolder)?n:(match("?")&&(lex(),t=o.allowIn,o.allowIn=!0,i=parseAssignmentExpression(),o.allowIn=t,expect(":"),r=parseAssignmentExpression(),n=new WrappingNode(u).finishConditionalExpression(n,i,r)),n)}function parseConciseBody(){return match("{")?parseFunctionSourceElements():parseAssignmentExpression()}function reinterpretAsCoverFormalsList(n){var u,h,t,e,r,o,i,c;for(e=[],r=[],o=0,c=null,i={paramSet:{}},u=0,h=n.length;u<h;u+=1)if(t=n[u],t.type===s.Identifier)e.push(t),r.push(null),validateParam(i,t,t.name);else if(t.type===s.AssignmentExpression)e.push(t.left),r.push(t.right),++o,validateParam(i,t.left,t.left.name);else return null;return i.message===f.StrictParamDupe&&throwError(l?i.stricted:i.firstRestricted,i.message),o===0&&(r=[]),{params:e,defaults:r,rest:c,stricted:i.stricted,firstRestricted:i.firstRestricted,message:i.message}}function parseArrowFunctionExpression(n,t){var r,i;return expect("=>"),r=l,i=parseConciseBody(),l&&n.firstRestricted&&throwError(n.firstRestricted,n.message),l&&n.stricted&&throwErrorTolerant(n.stricted,n.message),l=r,t.finishArrowFunctionExpression(n.params,n.defaults,i,i.type!==s.BlockStatement)}function parseAssignmentExpression(){var r,i,n,h,t,u;return(r=o.parenthesisCount,u=e,i=e,n=parseConditionalExpression(),(n===p.ArrowParameterPlaceHolder||match("=>"))&&(o.parenthesisCount===r||o.parenthesisCount===r+1)&&(n.type===s.Identifier?t=reinterpretAsCoverFormalsList([n]):n.type===s.AssignmentExpression?t=reinterpretAsCoverFormalsList([n]):n.type===s.SequenceExpression?t=reinterpretAsCoverFormalsList(n.expressions):n===p.ArrowParameterPlaceHolder&&(t=reinterpretAsCoverFormalsList([])),t))?parseArrowFunctionExpression(t,new WrappingNode(u)):(matchAssign()&&(isLeftHandSide(n)||throwErrorTolerant({},f.InvalidLHSInAssignment),l&&n.type===s.Identifier&&isRestrictedWord(n.name)&&throwErrorTolerant(i,f.StrictLHSAssignment),i=lex(),h=parseAssignmentExpression(),n=new WrappingNode(u).finishAssignmentExpression(i.value,n,h)),n)}function parseExpression(){var n,r=e,i;if(n=parseAssignmentExpression(),match(",")){for(i=[n];t<a;){if(!match(","))break;lex(),i.push(parseAssignmentExpression())}n=new WrappingNode(r).finishSequenceExpression(i)}return n}function parseStatementList(){for(var i=[],n;t<a;){if(match("}"))break;if(n=parseSourceElement(),typeof n=="undefined")break;i.push(n)}return i}function parseBlock(){var n,t=new Node;return expect("{"),n=parseStatementList(),expect("}"),t.finishBlockStatement(n)}function parseVariableIdentifier(){var n,t=new Node;return n=lex(),n.type!==u.Identifier&&throwUnexpected(n),t.finishIdentifier(n.value)}function parseVariableDeclaration(n){var t=null,i,r=new Node;return i=parseVariableIdentifier(),l&&isRestrictedWord(i.name)&&throwErrorTolerant({},f.StrictVarName),n==="const"?(expect("="),t=parseAssignmentExpression()):match("=")&&(lex(),t=parseAssignmentExpression()),r.finishVariableDeclarator(i,t)}function parseVariableDeclarationList(n){var i=[];do{if(i.push(parseVariableDeclaration(n)),!match(","))break;lex()}while(t<a);return i}function parseVariableStatement(n){var t;return expectKeyword("var"),t=parseVariableDeclarationList(),consumeSemicolon(),n.finishVariableDeclaration(t,"var")}function parseConstLetDeclaration(n){var t,i=new Node;return expectKeyword(n),t=parseVariableDeclarationList(n),consumeSemicolon(),i.finishVariableDeclaration(t,n)}function parseEmptyStatement(){var n=new Node;return expect(";"),n.finishEmptyStatement()}function parseExpressionStatement(n){var t=parseExpression();return consumeSemicolon(),n.finishExpressionStatement(t)}function parseIfStatement(n){var i,r,t;return expectKeyword("if"),expect("("),i=parseExpression(),expect(")"),r=parseStatement(),matchKeyword("else")?(lex(),t=parseStatement()):t=null,n.finishIfStatement(i,r,t)}function parseDoWhileStatement(n){var t,i,r;return expectKeyword("do"),r=o.inIteration,o.inIteration=!0,t=parseStatement(),o.inIteration=r,expectKeyword("while"),expect("("),i=parseExpression(),expect(")"),match(";")&&lex(),n.finishDoWhileStatement(t,i)}function parseWhileStatement(n){var t,i,r;return expectKeyword("while"),expect("("),t=parseExpression(),expect(")"),r=o.inIteration,o.inIteration=!0,i=parseStatement(),o.inIteration=r,n.finishWhileStatement(t,i)}function parseForVariableDeclaration(){var n,t,i=new Node;return n=lex(),t=parseVariableDeclarationList(),i.finishVariableDeclaration(t,n.value)}function parseForStatement(n){var t,r,u,i,e,s,h,c=o.allowIn;return t=r=u=null,expectKeyword("for"),expect("("),match(";")?lex():(matchKeyword("var")||matchKeyword("let")?(o.allowIn=!1,t=parseForVariableDeclaration(),o.allowIn=c,t.declarations.length===1&&matchKeyword("in")&&(lex(),i=t,e=parseExpression(),t=null)):(o.allowIn=!1,t=parseExpression(),o.allowIn=c,matchKeyword("in")&&(isLeftHandSide(t)||throwErrorTolerant({},f.InvalidLHSInForIn),lex(),i=t,e=parseExpression(),t=null)),typeof i=="undefined"&&expect(";")),typeof i=="undefined"&&(match(";")||(r=parseExpression()),expect(";"),match(")")||(u=parseExpression())),expect(")"),h=o.inIteration,o.inIteration=!0,s=parseStatement(),o.inIteration=h,typeof i=="undefined"?n.finishForStatement(t,r,u,s):n.finishForInStatement(i,e,s)}function parseContinueStatement(n){var i=null,s;return(expectKeyword("continue"),r.charCodeAt(t)===59)?(lex(),o.inIteration||throwError({},f.IllegalContinue),n.finishContinueStatement(null)):peekLineTerminator()?(o.inIteration||throwError({},f.IllegalContinue),n.finishContinueStatement(null)):(e.type===u.Identifier&&(i=parseVariableIdentifier(),s="$"+i.name,Object.prototype.hasOwnProperty.call(o.labelSet,s)||throwError({},f.UnknownLabel,i.name)),consumeSemicolon(),i!==null||o.inIteration||throwError({},f.IllegalContinue),n.finishContinueStatement(i))}function parseBreakStatement(n){var i=null,s;return(expectKeyword("break"),r.charCodeAt(t)===59)?(lex(),o.inIteration||o.inSwitch||throwError({},f.IllegalBreak),n.finishBreakStatement(null)):peekLineTerminator()?(o.inIteration||o.inSwitch||throwError({},f.IllegalBreak),n.finishBreakStatement(null)):(e.type===u.Identifier&&(i=parseVariableIdentifier(),s="$"+i.name,Object.prototype.hasOwnProperty.call(o.labelSet,s)||throwError({},f.UnknownLabel,i.name)),consumeSemicolon(),i!==null||o.inIteration||o.inSwitch||throwError({},f.IllegalBreak),n.finishBreakStatement(i))}function parseReturnStatement(n){var i=null;return(expectKeyword("return"),o.inFunctionBody||throwErrorTolerant({},f.IllegalReturn),r.charCodeAt(t)===32&&isIdentifierStart(r.charCodeAt(t+1)))?(i=parseExpression(),consumeSemicolon(),n.finishReturnStatement(i)):peekLineTerminator()?n.finishReturnStatement(null):(match(";")||match("}")||e.type===u.EOF||(i=parseExpression()),consumeSemicolon(),n.finishReturnStatement(i))}function parseWithStatement(n){var t,i;return l&&(skipComment(),throwErrorTolerant({},f.StrictModeWith)),expectKeyword("with"),expect("("),t=parseExpression(),expect(")"),i=parseStatement(),n.finishWithStatement(t,i)}function parseSwitchCase(){var n,i=[],r,u=new Node;for(matchKeyword("default")?(lex(),n=null):(expectKeyword("case"),n=parseExpression()),expect(":");t<a;){if(match("}")||matchKeyword("default")||matchKeyword("case"))break;r=parseStatement(),i.push(r)}return u.finishSwitchCase(n,i)}function parseSwitchStatement(n){var r,i,u,s,e;if(expectKeyword("switch"),expect("("),r=parseExpression(),expect(")"),expect("{"),i=[],match("}"))return lex(),n.finishSwitchStatement(r,i);for(s=o.inSwitch,o.inSwitch=!0,e=!1;t<a;){if(match("}"))break;u=parseSwitchCase(),u.test===null&&(e&&throwError({},f.MultipleDefaultsInSwitch),e=!0),i.push(u)}return o.inSwitch=s,expect("}"),n.finishSwitchStatement(r,i)}function parseThrowStatement(n){var t;return expectKeyword("throw"),peekLineTerminator()&&throwError({},f.NewlineAfterThrow),t=parseExpression(),consumeSemicolon(),n.finishThrowStatement(t)}function parseCatchClause(){var n,t,i=new Node;return expectKeyword("catch"),expect("("),match(")")&&throwUnexpected(e),n=parseVariableIdentifier(),l&&isRestrictedWord(n.name)&&throwErrorTolerant({},f.StrictCatchVariable),expect(")"),t=parseBlock(),i.finishCatchClause(n,t)}function parseTryStatement(n){var r,t=[],i=null;return expectKeyword("try"),r=parseBlock(),matchKeyword("catch")&&t.push(parseCatchClause()),matchKeyword("finally")&&(lex(),i=parseBlock()),t.length!==0||i||throwError({},f.NoCatchOrFinally),n.finishTryStatement(r,[],t,i)}function parseDebuggerStatement(n){return expectKeyword("debugger"),consumeSemicolon(),n.finishDebuggerStatement()}function parseStatement(){var i=e.type,t,h,r,n;if(i===u.EOF&&throwUnexpected(e),i===u.Punctuator&&e.value==="{")return parseBlock();if(n=new Node,i===u.Punctuator)switch(e.value){case";":return parseEmptyStatement(n);case"(":return parseExpressionStatement(n)}else if(i===u.Keyword)switch(e.value){case"break":return parseBreakStatement(n);case"continue":return parseContinueStatement(n);case"debugger":return parseDebuggerStatement(n);case"do":return parseDoWhileStatement(n);case"for":return parseForStatement(n);case"function":return parseFunctionDeclaration(n);case"if":return parseIfStatement(n);case"return":return parseReturnStatement(n);case"switch":return parseSwitchStatement(n);case"throw":return parseThrowStatement(n);case"try":return parseTryStatement(n);case"var":return parseVariableStatement(n);case"while":return parseWhileStatement(n);case"with":return parseWithStatement(n)}return(t=parseExpression(),t.type===s.Identifier&&match(":"))?(lex(),r="$"+t.name,Object.prototype.hasOwnProperty.call(o.labelSet,r)&&throwError({},f.Redeclaration,"Label",t.name),o.labelSet[r]=!0,h=parseStatement(),delete o.labelSet[r],n.finishLabeledStatement(t,h)):(consumeSemicolon(),n.finishExpressionStatement(t))}function parseFunctionSourceElements(){var n,c=[],i,v,h,y,p,w,b,k,d=new Node;for(expect("{");t<a;){if(e.type!==u.StringLiteral)break;if(i=e,n=parseSourceElement(),c.push(n),n.expression.type!==s.Literal)break;v=r.slice(i.start+1,i.end-1),v==="use strict"?(l=!0,h&&throwErrorTolerant(h,f.StrictOctalLiteral)):!h&&i.octal&&(h=i)}for(y=o.labelSet,p=o.inIteration,w=o.inSwitch,b=o.inFunctionBody,k=o.parenthesizedCount,o.labelSet={},o.inIteration=!1,o.inSwitch=!1,o.inFunctionBody=!0,o.parenthesizedCount=0;t<a;){if(match("}"))break;if(n=parseSourceElement(),typeof n=="undefined")break;c.push(n)}return expect("}"),o.labelSet=y,o.inIteration=p,o.inSwitch=w,o.inFunctionBody=b,o.parenthesizedCount=k,d.finishBlockStatement(c)}function validateParam(n,t,i){var r="$"+i;l?(isRestrictedWord(i)&&(n.stricted=t,n.message=f.StrictParamName),Object.prototype.hasOwnProperty.call(n.paramSet,r)&&(n.stricted=t,n.message=f.StrictParamDupe)):n.firstRestricted||(isRestrictedWord(i)?(n.firstRestricted=t,n.message=f.StrictParamName):isStrictModeReservedWord(i)?(n.firstRestricted=t,n.message=f.StrictReservedWord):Object.prototype.hasOwnProperty.call(n.paramSet,r)&&(n.firstRestricted=t,n.message=f.StrictParamDupe)),n.paramSet[r]=!0}function parseParam(n){var t,i,r;return t=e,i=parseVariableIdentifier(),validateParam(n,t,t.value),match("=")&&(lex(),r=parseAssignmentExpression(),++n.defaultCount),n.params.push(i),n.defaults.push(r),!match(")")}function parseParams(n){var i;if(i={params:[],defaultCount:0,defaults:[],firstRestricted:n},expect("("),!match(")"))for(i.paramSet={};t<a;){if(!parseParam(i))break;expect(",")}return expect(")"),i.defaultCount===0&&(i.defaults=[]),{params:i.params,defaults:i.defaults,stricted:i.stricted,firstRestricted:i.firstRestricted,message:i.message}}function parseFunctionDeclaration(){var o,s=[],h=[],c,n,u,t,i,r,a,v=new Node;return expectKeyword("function"),n=e,o=parseVariableIdentifier(),l?isRestrictedWord(n.value)&&throwErrorTolerant(n,f.StrictFunctionName):isRestrictedWord(n.value)?(i=n,r=f.StrictFunctionName):isStrictModeReservedWord(n.value)&&(i=n,r=f.StrictReservedWord),t=parseParams(i),s=t.params,h=t.defaults,u=t.stricted,i=t.firstRestricted,t.message&&(r=t.message),a=l,c=parseFunctionSourceElements(),l&&i&&throwError(i,r),l&&u&&throwErrorTolerant(u,r),l=a,v.finishFunctionDeclaration(o,s,h,c)}function parseFunctionExpression(){var n,o=null,u,i,r,t,s=[],h=[],c,a,v=new Node;return expectKeyword("function"),match("(")||(n=e,o=parseVariableIdentifier(),l?isRestrictedWord(n.value)&&throwErrorTolerant(n,f.StrictFunctionName):isRestrictedWord(n.value)?(i=n,r=f.StrictFunctionName):isStrictModeReservedWord(n.value)&&(i=n,r=f.StrictReservedWord)),t=parseParams(i),s=t.params,h=t.defaults,u=t.stricted,i=t.firstRestricted,t.message&&(r=t.message),a=l,c=parseFunctionSourceElements(),l&&i&&throwError(i,r),l&&u&&throwErrorTolerant(u,r),l=a,v.finishFunctionExpression(o,s,h,c)}function parseSourceElement(){if(e.type===u.Keyword)switch(e.value){case"const":case"let":return parseConstLetDeclaration(e.value);case"function":return parseFunctionDeclaration();default:return parseStatement()}if(e.type!==u.EOF)return parseStatement()}function parseSourceElements(){for(var n,h=[],i,c,o;t<a;){if(i=e,i.type!==u.StringLiteral)break;if(n=parseSourceElement(),h.push(n),n.expression.type!==s.Literal)break;c=r.slice(i.start+1,i.end-1),c==="use strict"?(l=!0,o&&throwErrorTolerant(o,f.StrictOctalLiteral)):!o&&i.octal&&(o=i)}while(t<a){if(n=parseSourceElement(),typeof n=="undefined")break;h.push(n)}return h}function parseProgram(){var n,t;return skipComment(),peek(),t=new Node,l=!1,n=parseSourceElements(),t.finishProgram(n)}function filterTokenLocation(){for(var n,r,u=[],t=0;t<i.tokens.length;++t)n=i.tokens[t],r={type:n.type,value:n.value},i.range&&(r.range=n.range),i.loc&&(r.loc=n.loc),u.push(r);i.tokens=u}function tokenize(n,f){var l,s;l=String,typeof n=="string"||n instanceof String||(n=l(n)),r=n,t=0,h=r.length>0?1:0,c=0,a=r.length,e=null,o={allowIn:!0,labelSet:{},inFunctionBody:!1,inIteration:!1,inSwitch:!1,lastCommentStart:-1},i={},f=f||{},f.tokens=!0,i.tokens=[],i.tokenize=!0,i.openParenToken=-1,i.openCurlyToken=-1,i.range=typeof f.range=="boolean"&&f.range,i.loc=typeof f.loc=="boolean"&&f.loc,typeof f.comment=="boolean"&&f.comment&&(i.comments=[]),typeof f.tolerant=="boolean"&&f.tolerant&&(i.errors=[]);try{if(peek(),e.type===u.EOF)return i.tokens;for(lex();e.type!==u.EOF;)try{lex()}catch(v){if(i.errors){i.errors.push(v);break}else throw v;}filterTokenLocation(),s=i.tokens,typeof i.comments!="undefined"&&(s.comments=i.comments),typeof i.errors!="undefined"&&(s.errors=i.errors)}catch(y){throw y;}finally{i={}}return s}function parse(n,u){var f,s;s=String,typeof n=="string"||n instanceof String||(n=s(n)),r=n,t=0,h=r.length>0?1:0,c=0,a=r.length,e=null,o={allowIn:!0,labelSet:{},parenthesisCount:0,inFunctionBody:!1,inIteration:!1,inSwitch:!1,lastCommentStart:-1},i={},typeof u!="undefined"&&(i.range=typeof u.range=="boolean"&&u.range,i.loc=typeof u.loc=="boolean"&&u.loc,i.attachComment=typeof u.attachComment=="boolean"&&u.attachComment,i.loc&&u.source!==null&&u.source!==undefined&&(i.source=s(u.source)),typeof u.tokens=="boolean"&&u.tokens&&(i.tokens=[]),typeof u.comment=="boolean"&&u.comment&&(i.comments=[]),typeof u.tolerant=="boolean"&&u.tolerant&&(i.errors=[]),i.attachComment&&(i.range=!0,i.comments=[],i.bottomRightStack=[],i.trailingComments=[],i.leadingComments=[]));try{f=parseProgram(),typeof i.comments!="undefined"&&(f.comments=i.comments),typeof i.tokens!="undefined"&&(filterTokenLocation(),f.tokens=i.tokens),typeof i.errors!="undefined"&&(f.errors=i.errors)}catch(l){throw l;}finally{i={}}return f}var u,v,b,s,p,y,f,w,r,l,t,h,c,a,e,o,i;u={BooleanLiteral:1,EOF:2,Identifier:3,Keyword:4,NullLiteral:5,NumericLiteral:6,Punctuator:7,StringLiteral:8,RegularExpression:9},v={},v[u.BooleanLiteral]="Boolean",v[u.EOF]="<end>",v[u.Identifier]="Identifier",v[u.Keyword]="Keyword",v[u.NullLiteral]="Null",v[u.NumericLiteral]="Numeric",v[u.Punctuator]="Punctuator",v[u.StringLiteral]="String",v[u.RegularExpression]="RegularExpression",b=["(","{","[","in","typeof","instanceof","new","return","case","delete","throw","void","=","+=","-=","*=","/=","%=","<<=",">>=",">>>=","&=","|=","^=",",","+","-","*","/","%","++","--","<<",">>",">>>","&","|","^","!","~","&&","||","?",":","===","==",">=","<=","<",">","!=","!=="],s={AssignmentExpression:"AssignmentExpression",ArrayExpression:"ArrayExpression",ArrowFunctionExpression:"ArrowFunctionExpression",BlockStatement:"BlockStatement",BinaryExpression:"BinaryExpression",BreakStatement:"BreakStatement",CallExpression:"CallExpression",CatchClause:"CatchClause",ConditionalExpression:"ConditionalExpression",ContinueStatement:"ContinueStatement",DoWhileStatement:"DoWhileStatement",DebuggerStatement:"DebuggerStatement",EmptyStatement:"EmptyStatement",ExpressionStatement:"ExpressionStatement",ForStatement:"ForStatement",ForInStatement:"ForInStatement",FunctionDeclaration:"FunctionDeclaration",FunctionExpression:"FunctionExpression",Identifier:"Identifier",IfStatement:"IfStatement",Literal:"Literal",LabeledStatement:"LabeledStatement",LogicalExpression:"LogicalExpression",MemberExpression:"MemberExpression",NewExpression:"NewExpression",ObjectExpression:"ObjectExpression",Program:"Program",Property:"Property",ReturnStatement:"ReturnStatement",SequenceExpression:"SequenceExpression",SwitchStatement:"SwitchStatement",SwitchCase:"SwitchCase",ThisExpression:"ThisExpression",ThrowStatement:"ThrowStatement",TryStatement:"TryStatement",UnaryExpression:"UnaryExpression",UpdateExpression:"UpdateExpression",VariableDeclaration:"VariableDeclaration",VariableDeclarator:"VariableDeclarator",WhileStatement:"WhileStatement",WithStatement:"WithStatement"},p={ArrowParameterPlaceHolder:{type:"ArrowParameterPlaceHolder"}},y={Data:1,Get:2,Set:4},f={UnexpectedToken:"Unexpected token %0",UnexpectedNumber:"Unexpected number",UnexpectedString:"Unexpected string",UnexpectedIdentifier:"Unexpected identifier",UnexpectedReserved:"Unexpected reserved word",UnexpectedEOS:"Unexpected end of input",NewlineAfterThrow:"Illegal newline after throw",InvalidRegExp:"Invalid regular expression",UnterminatedRegExp:"Invalid regular expression: missing /",InvalidLHSInAssignment:"Invalid left-hand side in assignment",InvalidLHSInForIn:"Invalid left-hand side in for-in",MultipleDefaultsInSwitch:"More than one default clause in switch statement",NoCatchOrFinally:"Missing catch or finally after try",UnknownLabel:"Undefined label '%0'",Redeclaration:"%0 '%1' has already been declared",IllegalContinue:"Illegal continue statement",IllegalBreak:"Illegal break statement",IllegalReturn:"Illegal return statement",StrictModeWith:"Strict mode code may not include a with statement",StrictCatchVariable:"Catch variable may not be eval or arguments in strict mode",StrictVarName:"Variable name may not be eval or arguments in strict mode",StrictParamName:"Parameter name eval or arguments is not allowed in strict mode",StrictParamDupe:"Strict mode function may not have duplicate parameter names",StrictFunctionName:"Function name may not be eval or arguments in strict mode",StrictOctalLiteral:"Octal literals are not allowed in strict mode.",StrictDelete:"Delete of an unqualified identifier in strict mode.",StrictDuplicateProperty:"Duplicate data property in object literal not allowed in strict mode",AccessorDataProperty:"Object literal may not have data and accessor property with the same name",AccessorGetSet:"Object literal may not have multiple get/set accessors with the same name",StrictLHSAssignment:"Assignment to eval or arguments is not allowed in strict mode",StrictLHSPostfix:"Postfix increment/decrement may not have eval or arguments operand in strict mode",StrictLHSPrefix:"Prefix increment/decrement may not have eval or arguments operand in strict mode",StrictReservedWord:"Use of future reserved word in strict mode"},w={NonAsciiIdentifierStart:new RegExp("[--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),NonAsciiIdentifierPart:new RegExp("[--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")},WrappingNode.prototype=Node.prototype={processComment:function(){var t,r,u=i.bottomRightStack,n=u[u.length-1];if(this.type!==s.Program||!(this.body.length>0)){if(i.trailingComments.length>0?i.trailingComments[0].range[0]>=this.range[1]?(r=i.trailingComments,i.trailingComments=[]):i.trailingComments.length=0:n&&n.trailingComments&&n.trailingComments[0].range[0]>=this.range[1]&&(r=n.trailingComments,delete n.trailingComments),n)while(n&&n.range[0]>=this.range[0])t=n,n=u.pop();t?t.leadingComments&&t.leadingComments[t.leadingComments.length-1].range[1]<=this.range[0]&&(this.leadingComments=t.leadingComments,t.leadingComments=undefined):i.leadingComments.length>0&&i.leadingComments[i.leadingComments.length-1].range[1]<=this.range[0]&&(this.leadingComments=i.leadingComments,i.leadingComments=[]),r&&(this.trailingComments=r),u.push(this)}},finish:function(){i.range&&(this.range[1]=t),i.loc&&(this.loc.end=new Position,i.source&&(this.loc.source=i.source)),i.attachComment&&this.processComment()},finishArrayExpression:function(n){return this.type=s.ArrayExpression,this.elements=n,this.finish(),this},finishArrowFunctionExpression:function(n,t,i,r){return this.type=s.ArrowFunctionExpression,this.id=null,this.params=n,this.defaults=t,this.body=i,this.rest=null,this.generator=!1,this.expression=r,this.finish(),this},finishAssignmentExpression:function(n,t,i){return this.type=s.AssignmentExpression,this.operator=n,this.left=t,this.right=i,this.finish(),this},finishBinaryExpression:function(n,t,i){return this.type=n==="||"||n==="&&"?s.LogicalExpression:s.BinaryExpression,this.operator=n,this.left=t,this.right=i,this.finish(),this},finishBlockStatement:function(n){return this.type=s.BlockStatement,this.body=n,this.finish(),this},finishBreakStatement:function(n){return this.type=s.BreakStatement,this.label=n,this.finish(),this},finishCallExpression:function(n,t){return this.type=s.CallExpression,this.callee=n,this.arguments=t,this.finish(),this},finishCatchClause:function(n,t){return this.type=s.CatchClause,this.param=n,this.body=t,this.finish(),this},finishConditionalExpression:function(n,t,i){return this.type=s.ConditionalExpression,this.test=n,this.consequent=t,this.alternate=i,this.finish(),this},finishContinueStatement:function(n){return this.type=s.ContinueStatement,this.label=n,this.finish(),this},finishDebuggerStatement:function(){return this.type=s.DebuggerStatement,this.finish(),this},finishDoWhileStatement:function(n,t){return this.type=s.DoWhileStatement,this.body=n,this.test=t,this.finish(),this},finishEmptyStatement:function(){return this.type=s.EmptyStatement,this.finish(),this},finishExpressionStatement:function(n){return this.type=s.ExpressionStatement,this.expression=n,this.finish(),this},finishForStatement:function(n,t,i,r){return this.type=s.ForStatement,this.init=n,this.test=t,this.update=i,this.body=r,this.finish(),this},finishForInStatement:function(n,t,i){return this.type=s.ForInStatement,this.left=n,this.right=t,this.body=i,this.each=!1,this.finish(),this},finishFunctionDeclaration:function(n,t,i,r){return this.type=s.FunctionDeclaration,this.id=n,this.params=t,this.defaults=i,this.body=r,this.rest=null,this.generator=!1,this.expression=!1,this.finish(),this},finishFunctionExpression:function(n,t,i,r){return this.type=s.FunctionExpression,this.id=n,this.params=t,this.defaults=i,this.body=r,this.rest=null,this.generator=!1,this.expression=!1,this.finish(),this},finishIdentifier:function(n){return this.type=s.Identifier,this.name=n,this.finish(),this},finishIfStatement:function(n,t,i){return this.type=s.IfStatement,this.test=n,this.consequent=t,this.alternate=i,this.finish(),this},finishLabeledStatement:function(n,t){return this.type=s.LabeledStatement,this.label=n,this.body=t,this.finish(),this},finishLiteral:function(n){return this.type=s.Literal,this.value=n.value,this.raw=r.slice(n.start,n.end),this.finish(),this},finishMemberExpression:function(n,t,i){return this.type=s.MemberExpression,this.computed=n==="[",this.object=t,this.property=i,this.finish(),this},finishNewExpression:function(n,t){return this.type=s.NewExpression,this.callee=n,this.arguments=t,this.finish(),this},finishObjectExpression:function(n){return this.type=s.ObjectExpression,this.properties=n,this.finish(),this},finishPostfixExpression:function(n,t){return this.type=s.UpdateExpression,this.operator=n,this.argument=t,this.prefix=!1,this.finish(),this},finishProgram:function(n){return this.type=s.Program,this.body=n,this.finish(),this},finishProperty:function(n,t,i){return this.type=s.Property,this.key=t,this.value=i,this.kind=n,this.finish(),this},finishReturnStatement:function(n){return this.type=s.ReturnStatement,this.argument=n,this.finish(),this},finishSequenceExpression:function(n){return this.type=s.SequenceExpression,this.expressions=n,this.finish(),this},finishSwitchCase:function(n,t){return this.type=s.SwitchCase,this.test=n,this.consequent=t,this.finish(),this},finishSwitchStatement:function(n,t){return this.type=s.SwitchStatement,this.discriminant=n,this.cases=t,this.finish(),this},finishThisExpression:function(){return this.type=s.ThisExpression,this.finish(),this},finishThrowStatement:function(n){return this.type=s.ThrowStatement,this.argument=n,this.finish(),this},finishTryStatement:function(n,t,i,r){return this.type=s.TryStatement,this.block=n,this.guardedHandlers=t,this.handlers=i,this.finalizer=r,this.finish(),this},finishUnaryExpression:function(n,t){return this.type=n==="++"||n==="--"?s.UpdateExpression:s.UnaryExpression,this.operator=n,this.argument=t,this.prefix=!0,this.finish(),this},finishVariableDeclaration:function(n,t){return this.type=s.VariableDeclaration,this.declarations=n,this.kind=t,this.finish(),this},finishVariableDeclarator:function(n,t){return this.type=s.VariableDeclarator,this.id=n,this.init=t,this.finish(),this},finishWhileStatement:function(n,t){return this.type=s.WhileStatement,this.test=n,this.body=t,this.finish(),this},finishWithStatement:function(n,t){return this.type=s.WithStatement,this.object=n,this.body=t,this.finish(),this}},n.version="2.0.0-dev",n.tokenize=tokenize,n.parse=parse,n.Syntax=function(){var n,t={};typeof Object.create=="function"&&(t=Object.create(null));for(n in s)s.hasOwnProperty(n)&&(t[n]=s[n]);return typeof Object.freeze=="function"&&Object.freeze(t),t}()})},require("MobileServiceClient")})(this||exports);
!function(){"use strict";function t(t,e,s,n,o,r,a){function i(t){if(t)m(t.toastId);else for(var e=0;e<O.length;e++)m(O[e].toastId)}function l(t,e,s){var n=g().iconClasses.error;return d(n,t,e,s)}function c(t,e,s){var n=g().iconClasses.info;return d(n,t,e,s)}function u(t,e,s){var n=g().iconClasses.success;return d(n,t,e,s)}function p(t,e,s){var n=g().iconClasses.warning;return d(n,t,e,s)}function m(e,s){function n(t){for(var e=0;e<O.length;e++)if(O[e].toastId===t)return O[e]}function o(){return!O.length}var i=n(e);i&&!i.deleting&&(i.deleting=!0,i.isOpened=!1,t.leave(i.el).then(function(){i.scope.options.onHidden&&i.scope.options.onHidden(s),i.scope.$destroy();var t=O.indexOf(i);delete w[i.scope.message],O.splice(t,1);var e=r.maxOpened;e&&O.length>=e&&O[e-1].open.resolve(),o()&&(C.remove(),C=null,T=a.defer())}))}function d(t,e,s,n){return angular.isObject(s)&&(n=s,s=null),v({iconClass:t,message:e,optionsOverride:n,title:s})}function g(){return angular.extend({},r)}function f(e){if(C)return T.promise;C=angular.element("<div></div>"),C.attr("id",e.containerId),C.addClass(e.positionClass),C.css({"pointer-events":"auto"});var s=angular.element(document.querySelector(e.target));if(!s||!s.length)throw"Target for toasts doesn't exist";return t.enter(C,s).then(function(){T.resolve()}),T.promise}function v(s){function r(t,e,s){s.allowHtml?(t.scope.allowHtml=!0,t.scope.title=o.trustAsHtml(e.title),t.scope.message=o.trustAsHtml(e.message)):(t.scope.title=e.title,t.scope.message=e.message),t.scope.toastType=t.iconClass,t.scope.toastId=t.toastId,t.scope.options={extendedTimeOut:s.extendedTimeOut,messageClass:s.messageClass,onHidden:s.onHidden,onShown:s.onShown,progressBar:s.progressBar,tapToDismiss:s.tapToDismiss,timeOut:s.timeOut,titleClass:s.titleClass,toastClass:s.toastClass},s.closeButton&&(t.scope.options.closeHtml=s.closeHtml)}function i(){function t(t){for(var e=["containerId","iconClasses","maxOpened","newestOnTop","positionClass","preventDuplicates","preventOpenDuplicates","templates"],s=0,n=e.length;n>s;s++)delete t[e[s]];return t}var e={toastId:h++,isOpened:!1,scope:n.$new(),open:a.defer()};return e.iconClass=s.iconClass,s.optionsOverride&&(p=angular.extend(p,t(s.optionsOverride)),e.iconClass=s.optionsOverride.iconClass||e.iconClass),r(e,s,p),e.el=l(e.scope),e}function l(t){var s=angular.element("<div toast></div>"),n=e.get("$compile");return n(s)(t)}function c(){return p.maxOpened&&O.length<=p.maxOpened||!p.maxOpened}function u(){var t=p.preventDuplicates&&s.message===B,e=p.preventOpenDuplicates&&w[s.message];return t||e?!0:(B=s.message,w[s.message]=!0,!1)}var p=g();if(!u()){var d=i();if(O.push(d),p.autoDismiss&&p.maxOpened>0)for(var v=O.slice(0,O.length-p.maxOpened),T=0,$=v.length;$>T;T++)m(v[T].toastId);return c()&&d.open.resolve(),d.open.promise.then(function(){f(p).then(function(){if(d.isOpened=!0,p.newestOnTop)t.enter(d.el,C).then(function(){d.scope.init()});else{var e=C[0].lastChild?angular.element(C[0].lastChild):null;t.enter(d.el,C,e).then(function(){d.scope.init()})}})}),d}}var C,h=0,O=[],B="",w={},T=a.defer(),$={clear:i,error:l,info:c,remove:m,success:u,warning:p};return $}angular.module("toastr",[]).factory("toastr",t),t.$inject=["$animate","$injector","$document","$rootScope","$sce","toastrConfig","$q"]}(),function(){"use strict";angular.module("toastr").constant("toastrConfig",{allowHtml:!1,autoDismiss:!1,closeButton:!1,closeHtml:"<button>&times;</button>",containerId:"toast-container",extendedTimeOut:1e3,iconClasses:{error:"toast-error",info:"toast-info",success:"toast-success",warning:"toast-warning"},maxOpened:0,messageClass:"toast-message",newestOnTop:!0,onHidden:null,onShown:null,positionClass:"toast-top-right",preventDuplicates:!1,preventOpenDuplicates:!1,progressBar:!1,tapToDismiss:!0,target:"body",templates:{toast:"directives/toast/toast.html",progressbar:"directives/progressbar/progressbar.html"},timeOut:5e3,titleClass:"toast-title",toastClass:"toast"})}(),function(){"use strict";function t(t){function e(t,e,s,n){function o(){var t=(i-(new Date).getTime())/a*100;e.css("width",t+"%")}var r,a,i;n.progressBar=t,t.start=function(t){r&&clearInterval(r),a=parseFloat(t),i=(new Date).getTime()+a,r=setInterval(o,10)},t.stop=function(){r&&clearInterval(r)},t.$on("$destroy",function(){clearInterval(r)})}return{replace:!0,require:"^toast",templateUrl:function(){return t.templates.progressbar},link:e}}angular.module("toastr").directive("progressBar",t),t.$inject=["toastrConfig"]}(),function(){"use strict";function t(){this.progressBar=null,this.startProgressBar=function(t){this.progressBar&&this.progressBar.start(t)},this.stopProgressBar=function(){this.progressBar&&this.progressBar.stop()}}angular.module("toastr").controller("ToastController",t)}(),function(){"use strict";function t(t,e,s,n){function o(s,o,r,a){function i(t){return a.startProgressBar(t),e(function(){a.stopProgressBar(),n.remove(s.toastId)},t,1)}function l(){s.progressBar=!1,a.stopProgressBar()}function c(){return s.options.closeHtml}var u;if(s.toastClass=s.options.toastClass,s.titleClass=s.options.titleClass,s.messageClass=s.options.messageClass,s.progressBar=s.options.progressBar,c()){var p=angular.element(s.options.closeHtml),m=t.get("$compile");p.addClass("toast-close-button"),p.attr("ng-click","close()"),m(p)(s),o.prepend(p)}s.init=function(){s.options.timeOut&&(u=i(s.options.timeOut)),s.options.onShown&&s.options.onShown()},o.on("mouseenter",function(){l(),u&&e.cancel(u)}),s.tapToast=function(){s.options.tapToDismiss&&s.close(!0)},s.close=function(t){n.remove(s.toastId,t)},o.on("mouseleave",function(){(0!==s.options.timeOut||0!==s.options.extendedTimeOut)&&(s.$apply(function(){s.progressBar=s.options.progressBar}),u=i(s.options.extendedTimeOut))})}return{replace:!0,templateUrl:function(){return s.templates.toast},controller:"ToastController",link:o}}angular.module("toastr").directive("toast",t),t.$inject=["$injector","$interval","toastrConfig","toastr"]}();
!function(){"use strict";function t(t,e,s,n,o,r,a){function i(t){if(t)d(t.toastId);else for(var e=0;e<O.length;e++)d(O[e].toastId)}function l(t,e,s){var n=m().iconClasses.error;return g(n,t,e,s)}function c(t,e,s){var n=m().iconClasses.info;return g(n,t,e,s)}function u(t,e,s){var n=m().iconClasses.success;return g(n,t,e,s)}function p(t,e,s){var n=m().iconClasses.warning;return g(n,t,e,s)}function d(e,s){function n(t){for(var e=0;e<O.length;e++)if(O[e].toastId===t)return O[e]}function o(){return!O.length}var i=n(e);i&&!i.deleting&&(i.deleting=!0,i.isOpened=!1,t.leave(i.el).then(function(){i.scope.options.onHidden&&i.scope.options.onHidden(s),i.scope.$destroy();var t=O.indexOf(i);delete B[i.scope.message],O.splice(t,1);var e=r.maxOpened;e&&O.length>=e&&O[e-1].open.resolve(),o()&&(h.remove(),h=null,T=a.defer())}))}function g(t,e,s,n){return angular.isObject(s)&&(n=s,s=null),v({iconClass:t,message:e,optionsOverride:n,title:s})}function m(){return angular.extend({},r)}function f(e){if(h)return T.promise;h=angular.element("<div></div>"),h.attr("id",e.containerId),h.addClass(e.positionClass),h.css({"pointer-events":"auto"});var s=angular.element(document.querySelector(e.target));if(!s||!s.length)throw"Target for toasts doesn't exist";return t.enter(h,s).then(function(){T.resolve()}),T.promise}function v(s){function r(t,e,s){s.allowHtml?(t.scope.allowHtml=!0,t.scope.title=o.trustAsHtml(e.title),t.scope.message=o.trustAsHtml(e.message)):(t.scope.title=e.title,t.scope.message=e.message),t.scope.toastType=t.iconClass,t.scope.toastId=t.toastId,t.scope.options={extendedTimeOut:s.extendedTimeOut,messageClass:s.messageClass,onHidden:s.onHidden,onShown:s.onShown,progressBar:s.progressBar,tapToDismiss:s.tapToDismiss,timeOut:s.timeOut,titleClass:s.titleClass,toastClass:s.toastClass},s.closeButton&&(t.scope.options.closeHtml=s.closeHtml)}function i(){function t(t){for(var e=["containerId","iconClasses","maxOpened","newestOnTop","positionClass","preventDuplicates","preventOpenDuplicates","templates"],s=0,n=e.length;n>s;s++)delete t[e[s]];return t}var e={toastId:C++,isOpened:!1,scope:n.$new(),open:a.defer()};return e.iconClass=s.iconClass,s.optionsOverride&&(p=angular.extend(p,t(s.optionsOverride)),e.iconClass=s.optionsOverride.iconClass||e.iconClass),r(e,s,p),e.el=l(e.scope),e}function l(t){var s=angular.element("<div toast></div>"),n=e.get("$compile");return n(s)(t)}function c(){return p.maxOpened&&O.length<=p.maxOpened||!p.maxOpened}function u(){var t=p.preventDuplicates&&s.message===w,e=p.preventOpenDuplicates&&B[s.message];return t||e?!0:(w=s.message,B[s.message]=!0,!1)}var p=m();if(!u()){var g=i();if(O.push(g),p.autoDismiss&&p.maxOpened>0)for(var v=O.slice(0,O.length-p.maxOpened),T=0,$=v.length;$>T;T++)d(v[T].toastId);return c()&&g.open.resolve(),g.open.promise.then(function(){f(p).then(function(){if(g.isOpened=!0,p.newestOnTop)t.enter(g.el,h).then(function(){g.scope.init()});else{var e=h[0].lastChild?angular.element(h[0].lastChild):null;t.enter(g.el,h,e).then(function(){g.scope.init()})}})}),g}}var h,C=0,O=[],w="",B={},T=a.defer(),$={clear:i,error:l,info:c,remove:d,success:u,warning:p};return $}angular.module("toastr",[]).factory("toastr",t),t.$inject=["$animate","$injector","$document","$rootScope","$sce","toastrConfig","$q"]}(),function(){"use strict";angular.module("toastr").constant("toastrConfig",{allowHtml:!1,autoDismiss:!1,closeButton:!1,closeHtml:"<button>&times;</button>",containerId:"toast-container",extendedTimeOut:1e3,iconClasses:{error:"toast-error",info:"toast-info",success:"toast-success",warning:"toast-warning"},maxOpened:0,messageClass:"toast-message",newestOnTop:!0,onHidden:null,onShown:null,positionClass:"toast-top-right",preventDuplicates:!1,preventOpenDuplicates:!1,progressBar:!1,tapToDismiss:!0,target:"body",templates:{toast:"directives/toast/toast.html",progressbar:"directives/progressbar/progressbar.html"},timeOut:5e3,titleClass:"toast-title",toastClass:"toast"})}(),function(){"use strict";function t(t){function e(t,e,s,n){function o(){var t=(i-(new Date).getTime())/a*100;e.css("width",t+"%")}var r,a,i;n.progressBar=t,t.start=function(t){r&&clearInterval(r),a=parseFloat(t),i=(new Date).getTime()+a,r=setInterval(o,10)},t.stop=function(){r&&clearInterval(r)},t.$on("$destroy",function(){clearInterval(r)})}return{replace:!0,require:"^toast",templateUrl:function(){return t.templates.progressbar},link:e}}angular.module("toastr").directive("progressBar",t),t.$inject=["toastrConfig"]}(),function(){"use strict";function t(){this.progressBar=null,this.startProgressBar=function(t){this.progressBar&&this.progressBar.start(t)},this.stopProgressBar=function(){this.progressBar&&this.progressBar.stop()}}angular.module("toastr").controller("ToastController",t)}(),function(){"use strict";function t(t,e,s,n){function o(s,o,r,a){function i(t){return a.startProgressBar(t),e(function(){a.stopProgressBar(),n.remove(s.toastId)},t,1)}function l(){s.progressBar=!1,a.stopProgressBar()}function c(){return s.options.closeHtml}var u;if(s.toastClass=s.options.toastClass,s.titleClass=s.options.titleClass,s.messageClass=s.options.messageClass,s.progressBar=s.options.progressBar,c()){var p=angular.element(s.options.closeHtml),d=t.get("$compile");p.addClass("toast-close-button"),p.attr("ng-click","close()"),d(p)(s),o.prepend(p)}s.init=function(){s.options.timeOut&&(u=i(s.options.timeOut)),s.options.onShown&&s.options.onShown()},o.on("mouseenter",function(){l(),u&&e.cancel(u)}),s.tapToast=function(){s.options.tapToDismiss&&s.close(!0)},s.close=function(t){n.remove(s.toastId,t)},o.on("mouseleave",function(){(0!==s.options.timeOut||0!==s.options.extendedTimeOut)&&(s.$apply(function(){s.progressBar=s.options.progressBar}),u=i(s.options.extendedTimeOut))})}return{replace:!0,templateUrl:function(){return s.templates.toast},controller:"ToastController",link:o}}angular.module("toastr").directive("toast",t),t.$inject=["$injector","$interval","toastrConfig","toastr"]}(),angular.module("toastr").run(["$templateCache",function(t){t.put("directives/progressbar/progressbar.html",'<div class="toast-progress"></div>\n'),t.put("directives/toast/toast.html",'<div class="{{toastClass}} {{toastType}}" ng-click="tapToast()">\n  <div ng-switch on="allowHtml">\n    <div ng-switch-default ng-if="title" class="{{titleClass}}">{{title}}</div>\n    <div ng-switch-default class="{{messageClass}}">{{message}}</div>\n    <div ng-switch-when="true" ng-if="title" class="{{titleClass}}" ng-bind-html="title"></div>\n    <div ng-switch-when="true" class="{{messageClass}}" ng-bind-html="message"></div>\n  </div>\n  <progress-bar ng-if="progressBar"></progress-bar>\n</div>\n')}]);
!function(){"use strict";angular.module("base64",[]).constant("$base64",function(){function a(a,b){var c=f.indexOf(a.charAt(b));if(-1==c)throw"Cannot decode base64";return c}function b(b){b=""+b;var c,d,f,g=b.length;if(0==g)return b;if(0!=g%4)throw"Cannot decode base64";c=0,b.charAt(g-1)==e&&(c=1,b.charAt(g-2)==e&&(c=2),g-=4);var h=[];for(d=0;g>d;d+=4)f=a(b,d)<<18|a(b,d+1)<<12|a(b,d+2)<<6|a(b,d+3),h.push(String.fromCharCode(f>>16,255&f>>8,255&f));switch(c){case 1:f=a(b,d)<<18|a(b,d+1)<<12|a(b,d+2)<<6,h.push(String.fromCharCode(f>>16,255&f>>8));break;case 2:f=a(b,d)<<18|a(b,d+1)<<12,h.push(String.fromCharCode(f>>16))}return h.join("")}function c(a,b){var c=a.charCodeAt(b);if(c>255)throw"INVALID_CHARACTER_ERR: DOM Exception 5";return c}function d(a){if(1!=arguments.length)throw"SyntaxError: Not enough arguments";var b,d,g=[];a=""+a;var h=a.length-a.length%3;if(0==a.length)return a;for(b=0;h>b;b+=3)d=c(a,b)<<16|c(a,b+1)<<8|c(a,b+2),g.push(f.charAt(d>>18)),g.push(f.charAt(63&d>>12)),g.push(f.charAt(63&d>>6)),g.push(f.charAt(63&d));switch(a.length-h){case 1:d=c(a,b)<<16,g.push(f.charAt(d>>18)+f.charAt(63&d>>12)+e+e);break;case 2:d=c(a,b)<<16|c(a,b+1)<<8,g.push(f.charAt(d>>18)+f.charAt(63&d>>12)+f.charAt(63&d>>6)+e)}return g.join("")}var e="=",f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";return{encode:d,decode:b}}())}();
/*! jQuery v2.1.4 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.4",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b="length"in a&&a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler("ready"),n(l).off("ready"))))}});function I(){l.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),"complete"===l.readyState?setTimeout(n.ready):(l.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+K.uid++}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){
return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement("div")),c=l.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";k.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ba=/<([\w:]+)/,ca=/<|&#?\w+;/,da=/<(?:script|style|link)/i,ea=/checked\s*(?:[^=]|=\s*.checked.)/i,fa=/^$|\/(?:java|ecma)script/i,ga=/^true\/(.*)/,ha=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ia={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ia.optgroup=ia.option,ia.tbody=ia.tfoot=ia.colgroup=ia.caption=ia.thead,ia.th=ia.td;function ja(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function ka(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function la(a){var b=ga.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function ma(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function na(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function oa(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pa(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=oa(h),f=oa(a),d=0,e=f.length;e>d;d++)pa(f[d],g[d]);if(b)if(c)for(f=f||oa(a),g=g||oa(h),d=0,e=f.length;e>d;d++)na(f[d],g[d]);else na(a,h);return g=oa(h,"script"),g.length>0&&ma(g,!i&&oa(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if("object"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(ca.test(e)){f=f||k.appendChild(b.createElement("div")),g=(ba.exec(e)||["",""])[1].toLowerCase(),h=ia[g]||ia._default,f.innerHTML=h[1]+e.replace(aa,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=oa(k.appendChild(e),"script"),i&&ma(f),c)){j=0;while(e=f[j++])fa.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(oa(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&ma(oa(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(oa(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!da.test(a)&&!ia[(ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(aa,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(oa(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(oa(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&ea.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(oa(c,"script"),ka),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,oa(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,la),j=0;g>j;j++)h=f[j],fa.test(h.type||"")&&!L.access(h,"globalEval")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(ha,"")))}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qa,ra={};function sa(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],"display");return e.detach(),f}function ta(a){var b=l,c=ra[a];return c||(c=sa(a,b),"none"!==c&&c||(qa=(qa||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qa[0].contentDocument,b.write(),b.close(),c=sa(a,b),qa.detach()),ra[a]=c),c}var ua=/^margin/,va=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wa=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)};function xa(a,b,c){var d,e,f,g,h=a.style;return c=c||wa(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),va.test(g)&&ua.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function ya(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement("div"),f=l.createElement("div");if(f.style){f.style.backgroundClip="content-box",f.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===f.style.backgroundClip,e.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",e.appendChild(f);function g(){f.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",f.innerHTML="",d.appendChild(e);var g=a.getComputedStyle(f,null);b="1%"!==g.top,c="4px"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement("div"));return c.style.cssText=f.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",f.style.width="1px",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),f.removeChild(c),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var za=/^(none|table(?!-c[ea]).+)/,Aa=new RegExp("^("+Q+")(.*)$","i"),Ba=new RegExp("^([+-])=("+Q+")","i"),Ca={position:"absolute",visibility:"hidden",display:"block"},Da={letterSpacing:"0",fontWeight:"400"},Ea=["Webkit","O","Moz","ms"];function Fa(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Ea.length;while(e--)if(b=Ea[e]+c,b in a)return b;return d}function Ga(a,b,c){var d=Aa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Ha(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+R[f]+"Width",!0,e))):(g+=n.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ia(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wa(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xa(a,b,f),(0>e||null==e)&&(e=a.style[b]),va.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Ha(a,b,c||(g?"border":"content"),d,f)+"px"}function Ja(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",ta(d.nodeName)))):(e=S(d),"none"===c&&e||L.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xa(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fa(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Ba.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fa(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xa(a,b,d)),"normal"===e&&b in Da&&(e=Da[b]),""===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?za.test(n.css(a,"display"))&&0===a.offsetWidth?n.swap(a,Ca,function(){return Ia(a,b,d)}):Ia(a,b,d):void 0},set:function(a,c,d){var e=d&&wa(a);return Ga(a,c,d?Ha(a,b,d,"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),n.cssHooks.marginRight=ya(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},xa,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ua.test(a)||(n.cssHooks[a+b].set=Ga)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wa(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Ja(this,!0)},hide:function(){return Ja(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Ka(a,b,c,d,e){return new Ka.prototype.init(a,b,c,d,e)}n.Tween=Ka,Ka.prototype={constructor:Ka,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Ka.propHooks[this.prop];return a&&a.get?a.get(this):Ka.propHooks._default.get(this)},run:function(a){var b,c=Ka.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ka.propHooks._default.set(this),this}},Ka.prototype.init.prototype=Ka.prototype,Ka.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Ka.propHooks.scrollTop=Ka.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Ka.prototype.init,n.fx.step={};var La,Ma,Na=/^(?:toggle|show|hide)$/,Oa=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pa=/queueHooks$/,Qa=[Va],Ra={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Oa.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&Oa.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sa(){return setTimeout(function(){La=void 0}),La=n.now()}function Ta(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ua(a,b,c){for(var d,e=(Ra[b]||[]).concat(Ra["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Va(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?L.get(a,"olddisplay")||ta(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Na.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?ta(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=L.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ua(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wa(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xa(a,b,c){var d,e,f=0,g=Qa.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=La||Sa(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:La||Sa(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wa(k,j.opts.specialEasing);g>f;f++)if(d=Qa[f].call(j,a,k,j.opts))return d;return n.map(k,Ua,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xa,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Ra[c]=Ra[c]||[],Ra[c].unshift(b)},prefilter:function(a,b){b?Qa.unshift(a):Qa.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xa(this,n.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pa.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Ta(b,!0),a,d,e)}}),n.each({slideDown:Ta("show"),slideUp:Ta("hide"),slideToggle:Ta("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(La=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),La=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Ma||(Ma=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Ma),Ma=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement("input"),b=l.createElement("select"),c=b.appendChild(l.createElement("option"));a.type="checkbox",k.checkOn=""!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement("input"),a.value="t",a.type="radio",k.radioValue="t"===a.value}();var Ya,Za,$a=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Za:Ya)),
void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Za={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$a[b]||n.find.attr;$a[b]=function(a,b,d){var e,f;return d||(f=$a[b],$a[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$a[b]=f),e}});var _a=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_a.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var ab=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ab," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ab," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ab," ").indexOf(b)>=0)return!0;return!1}});var bb=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bb,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cb=n.now(),db=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&n.error("Invalid XML: "+a),b};var eb=/#.*$/,fb=/([?&])_=[^&]*/,gb=/^(.*?):[ \t]*([^\r\n]*)$/gm,hb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,ib=/^(?:GET|HEAD)$/,jb=/^\/\//,kb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,lb={},mb={},nb="*/".concat("*"),ob=a.location.href,pb=kb.exec(ob.toLowerCase())||[];function qb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function rb(a,b,c,d){var e={},f=a===mb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function sb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function tb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function ub(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:ob,type:"GET",isLocal:hb.test(pb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":nb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?sb(sb(a,n.ajaxSettings),b):sb(n.ajaxSettings,a)},ajaxPrefilter:qb(lb),ajaxTransport:qb(mb),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=gb.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||ob)+"").replace(eb,"").replace(jb,pb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=kb.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===pb[1]&&h[2]===pb[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(pb[3]||("http:"===pb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),rb(lb,k,b,v),2===t)return v;i=n.event&&k.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!ib.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(db.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=fb.test(d)?d.replace(fb,"$1_="+cb++):d+(db.test(d)?"&":"?")+"_="+cb++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader("If-Modified-Since",n.lastModified[d]),n.etag[d]&&v.setRequestHeader("If-None-Match",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+nb+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=rb(mb,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=tb(k,v,f)),u=ub(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(n.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var vb=/%20/g,wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&").replace(vb,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Bb=0,Cb={},Db={0:200,1223:204},Eb=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Cb)Cb[a]()}),k.cors=!!Eb&&"withCredentials"in Eb,k.ajax=Eb=!!Eb,n.ajaxTransport(function(a){var b;return k.cors||Eb&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Bb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Cb[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Db[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Cb[g]=b("abort");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Fb=[],Gb=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Fb.pop()||n.expando+"_"+cb++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Gb.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Gb.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Gb,"$1"+e):b.jsonp!==!1&&(b.url+=(db.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Fb.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Hb=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Hb)return Hb.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Ib=a.document.documentElement;function Jb(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Jb(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Ib;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Ib})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Jb(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=ya(k.pixelPosition,function(a,c){return c?(c=xa(a,b),va.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Kb=a.jQuery,Lb=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Lb),b&&a.jQuery===n&&(a.jQuery=Kb),n},typeof b===U&&(a.jQuery=a.$=n),n});
//# sourceMappingURL=jquery.min.map
try {

    // workaround to ensure that desktop live preview uses node_modules from studio shell
    if (module && module.paths && location.search.indexOf('?npmpath=') === 0) {
        var npmPath = /\?npmpath=(.*?)$/.exec(location.search)[1];
        if (npmPath) {
            module.paths.push(decodeURIComponent(npmPath));
        }
    }

    var electron_client = 'ELECTRON_CTI_CLIENT';
    var db_silo = 'client/data';
    var ipc = require('electron').ipcRenderer;

    angular
        .module('ngElectron', [])
        .factory('electron', function () {

            var o = {};

            // for sending messages up to the electron shell
            o.send = function (data) {
                ipc.send(electron_client, data);
            };

            // diskdb
            var diskdb = require('diskdb');
            o.db = function (collection) {
                if (diskdb) {
                    var collection_arr = [];
                    if (typeof collection == 'object') {
                        collection_arr = collection;
                    } else if (typeof collection == 'string') {
                        collection_arr.push(collection);
                    }

                    return diskdb.connect(db_silo, collection_arr);
                }

                return 'diskdb is not installed and/or configured.'
            };

            // remote require
            o.require = require('remote').require;

            // useful node modules and electron shell utilities
            o.app = o.require('app');
            o.fsplus = o.require('fs-plus');
            o.path = o.require('path');
            o.shell = o.require('shell');
            o.dialog = o.require('dialog');

            return o;
        })
        .run(['$rootScope', 'electron', function ($rootScope, electron) {

            // listen to messages from electron shell for the client
            ipc.on(electron_client, function (event, args) {

                switch (args.action || '') {

                    case 'pong':
                        console.info('[electron] Connected to electron shell (client)');
                        break;

                    case 'console-log':
                        console.info('[electron]', args.data);
                        break;

                    default:
                        break;
                }
            });

            // send a ping to the electron shell
            electron.send({ action: 'ping' });

            $rootScope.$electron = electron;
        }]);

} catch (e) {

    angular
        .module('ngElectron', [])
        .factory('electron', function () {

            return {};
        });
}

/** File: strophe.js
 *  A JavaScript library for XMPP BOSH/XMPP over Websocket.
 *
 *  This is the JavaScript version of the Strophe library.  Since JavaScript
 *  had no facilities for persistent TCP connections, this library uses
 *  Bidirectional-streams Over Synchronous HTTP (BOSH) to emulate
 *  a persistent, stateful, two-way connection to an XMPP server.  More
 *  information on BOSH can be found in XEP 124.
 *
 *  This version of Strophe also works with WebSockets.
 *  For more information on XMPP-over WebSocket see this RFC:
 *  http://tools.ietf.org/html/rfc7395
 */

/*
 * NOTE: Contains CommonTime alterations - all WebSocket event handlers are neutered when resetting a connection.
 *       This prevents onclose and onerror events from previous websockets interfering with the application flow
 */

/* All of the Strophe globals are defined in this special function below so
 * that references to the globals become closures.  This will ensure that
 * on page reload, these references will still be available to callbacks
 * that are still executing.
 */

/* jshint ignore:start */
(function (callback) {
    /* jshint ignore:end */

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

    (function (root, factory) {
        if (typeof define === 'function' && define.amd) {
            define('strophe-base64', function () {
                return factory();
            });
        } else {
            // Browser globals
            root.Base64 = factory();
        }
    }(this, function () {
        var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

        var obj = {
            /**
             * Encodes a string in base64
             * @param {String} input The string to encode in base64.
             */
            encode: function (input) {
                var output = "";
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;

                do {
                    chr1 = input.charCodeAt(i++);
                    chr2 = input.charCodeAt(i++);
                    chr3 = input.charCodeAt(i++);

                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;

                    if (isNaN(chr2)) {
                        enc2 = ((chr1 & 3) << 4);
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }

                    output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                        keyStr.charAt(enc3) + keyStr.charAt(enc4);
                } while (i < input.length);

                return output;
            },

            /**
             * Decodes a base64 string.
             * @param {String} input The string to decode.
             */
            decode: function (input) {
                var output = "";
                var chr1, chr2, chr3;
                var enc1, enc2, enc3, enc4;
                var i = 0;

                // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

                do {
                    enc1 = keyStr.indexOf(input.charAt(i++));
                    enc2 = keyStr.indexOf(input.charAt(i++));
                    enc3 = keyStr.indexOf(input.charAt(i++));
                    enc4 = keyStr.indexOf(input.charAt(i++));

                    chr1 = (enc1 << 2) | (enc2 >> 4);
                    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                    chr3 = ((enc3 & 3) << 6) | enc4;

                    output = output + String.fromCharCode(chr1);

                    if (enc3 != 64) {
                        output = output + String.fromCharCode(chr2);
                    }
                    if (enc4 != 64) {
                        output = output + String.fromCharCode(chr3);
                    }
                } while (i < input.length);

                return output;
            }
        };
        return obj;
    }));

    /*
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
     * in FIPS PUB 180-1
     * Version 2.1a Copyright Paul Johnston 2000 - 2002.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for details.
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /* global define */

    /* Some functions and variables have been stripped for use with Strophe */

    (function (root, factory) {
        if (typeof define === 'function' && define.amd) {
            define('strophe-sha1', function () {
                return factory();
            });
        } else {
            // Browser globals
            root.SHA1 = factory();
        }
    }(this, function () {

        /*
         * Calculate the SHA-1 of an array of big-endian words, and a bit length
         */
        function core_sha1(x, len)
        {
            /* append padding */
            x[len >> 5] |= 0x80 << (24 - len % 32);
            x[((len + 64 >> 9) << 4) + 15] = len;

            var w = new Array(80);
            var a =  1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d =  271733878;
            var e = -1009589776;

            var i, j, t, olda, oldb, oldc, oldd, olde;
            for (i = 0; i < x.length; i += 16)
            {
                olda = a;
                oldb = b;
                oldc = c;
                oldd = d;
                olde = e;

                for (j = 0; j < 80; j++)
                {
                    if (j < 16) { w[j] = x[i + j]; }
                    else { w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1); }
                    t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                        safe_add(safe_add(e, w[j]), sha1_kt(j)));
                    e = d;
                    d = c;
                    c = rol(b, 30);
                    b = a;
                    a = t;
                }

                a = safe_add(a, olda);
                b = safe_add(b, oldb);
                c = safe_add(c, oldc);
                d = safe_add(d, oldd);
                e = safe_add(e, olde);
            }
            return [a, b, c, d, e];
        }

        /*
         * Perform the appropriate triplet combination function for the current
         * iteration
         */
        function sha1_ft(t, b, c, d)
        {
            if (t < 20) { return (b & c) | ((~b) & d); }
            if (t < 40) { return b ^ c ^ d; }
            if (t < 60) { return (b & c) | (b & d) | (c & d); }
            return b ^ c ^ d;
        }

        /*
         * Determine the appropriate additive constant for the current iteration
         */
        function sha1_kt(t)
        {
            return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
                (t < 60) ? -1894007588 : -899497514;
        }

        /*
         * Calculate the HMAC-SHA1 of a key and some data
         */
        function core_hmac_sha1(key, data)
        {
            var bkey = str2binb(key);
            if (bkey.length > 16) { bkey = core_sha1(bkey, key.length * 8); }

            var ipad = new Array(16), opad = new Array(16);
            for (var i = 0; i < 16; i++)
            {
                ipad[i] = bkey[i] ^ 0x36363636;
                opad[i] = bkey[i] ^ 0x5C5C5C5C;
            }

            var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
            return core_sha1(opad.concat(hash), 512 + 160);
        }

        /*
         * Add integers, wrapping at 2^32. This uses 16-bit operations internally
         * to work around bugs in some JS interpreters.
         */
        function safe_add(x, y)
        {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        }

        /*
         * Bitwise rotate a 32-bit number to the left.
         */
        function rol(num, cnt)
        {
            return (num << cnt) | (num >>> (32 - cnt));
        }

        /*
         * Convert an 8-bit or 16-bit string to an array of big-endian words
         * In 8-bit function, characters >255 have their hi-byte silently ignored.
         */
        function str2binb(str)
        {
            var bin = [];
            var mask = 255;
            for (var i = 0; i < str.length * 8; i += 8)
            {
                bin[i>>5] |= (str.charCodeAt(i / 8) & mask) << (24 - i%32);
            }
            return bin;
        }

        /*
         * Convert an array of big-endian words to a string
         */
        function binb2str(bin)
        {
            var str = "";
            var mask = 255;
            for (var i = 0; i < bin.length * 32; i += 8)
            {
                str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);
            }
            return str;
        }

        /*
         * Convert an array of big-endian words to a base-64 string
         */
        function binb2b64(binarray)
        {
            var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var str = "";
            var triplet, j;
            for (var i = 0; i < binarray.length * 4; i += 3)
            {
                triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |
                    (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |
                    ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
                for (j = 0; j < 4; j++)
                {
                    if (i * 8 + j * 6 > binarray.length * 32) { str += "="; }
                    else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
                }
            }
            return str;
        }

        /*
         * These are the functions you'll usually want to call
         * They take string arguments and return either hex or base-64 encoded strings
         */
        return {
            b64_hmac_sha1:  function (key, data){ return binb2b64(core_hmac_sha1(key, data)); },
            b64_sha1:       function (s) { return binb2b64(core_sha1(str2binb(s),s.length * 8)); },
            binb2str:       binb2str,
            core_hmac_sha1: core_hmac_sha1,
            str_hmac_sha1:  function (key, data){ return binb2str(core_hmac_sha1(key, data)); },
            str_sha1:       function (s) { return binb2str(core_sha1(str2binb(s),s.length * 8)); },
        };
    }));

    /*
     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
     * Digest Algorithm, as defined in RFC 1321.
     * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for more info.
     */

    /*
     * Everything that isn't used by Strophe has been stripped here!
     */

    (function (root, factory) {
        if (typeof define === 'function' && define.amd) {
            define('strophe-md5', function () {
                return factory();
            });
        } else {
            // Browser globals
            root.MD5 = factory();
        }
    }(this, function (b) {
        /*
         * Add integers, wrapping at 2^32. This uses 16-bit operations internally
         * to work around bugs in some JS interpreters.
         */
        var safe_add = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };

        /*
         * Bitwise rotate a 32-bit number to the left.
         */
        var bit_rol = function (num, cnt) {
            return (num << cnt) | (num >>> (32 - cnt));
        };

        /*
         * Convert a string to an array of little-endian words
         */
        var str2binl = function (str) {
            var bin = [];
            for(var i = 0; i < str.length * 8; i += 8)
            {
                bin[i>>5] |= (str.charCodeAt(i / 8) & 255) << (i%32);
            }
            return bin;
        };

        /*
         * Convert an array of little-endian words to a string
         */
        var binl2str = function (bin) {
            var str = "";
            for(var i = 0; i < bin.length * 32; i += 8)
            {
                str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & 255);
            }
            return str;
        };

        /*
         * Convert an array of little-endian words to a hex string.
         */
        var binl2hex = function (binarray) {
            var hex_tab = "0123456789abcdef";
            var str = "";
            for(var i = 0; i < binarray.length * 4; i++)
            {
                str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
                    hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
            }
            return str;
        };

        /*
         * These functions implement the four basic operations the algorithm uses.
         */
        var md5_cmn = function (q, a, b, x, s, t) {
            return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);
        };

        var md5_ff = function (a, b, c, d, x, s, t) {
            return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
        };

        var md5_gg = function (a, b, c, d, x, s, t) {
            return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
        };

        var md5_hh = function (a, b, c, d, x, s, t) {
            return md5_cmn(b ^ c ^ d, a, b, x, s, t);
        };

        var md5_ii = function (a, b, c, d, x, s, t) {
            return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
        };

        /*
         * Calculate the MD5 of an array of little-endian words, and a bit length
         */
        var core_md5 = function (x, len) {
            /* append padding */
            x[len >> 5] |= 0x80 << ((len) % 32);
            x[(((len + 64) >>> 9) << 4) + 14] = len;

            var a =  1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d =  271733878;

            var olda, oldb, oldc, oldd;
            for (var i = 0; i < x.length; i += 16)
            {
                olda = a;
                oldb = b;
                oldc = c;
                oldd = d;

                a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
                d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
                c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
                b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
                a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
                d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
                c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
                b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
                a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
                d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
                c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
                b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
                a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
                d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
                c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
                b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

                a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
                d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
                c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
                b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
                a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
                d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
                c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
                b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
                a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
                d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
                c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
                b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
                a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
                d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
                c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
                b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

                a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
                d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
                c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
                b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
                a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
                d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
                c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
                b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
                a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
                d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
                c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
                b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
                a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
                d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
                c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
                b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

                a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
                d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
                c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
                b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
                a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
                d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
                c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
                b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
                a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
                d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
                c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
                b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
                a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
                d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
                c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
                b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

                a = safe_add(a, olda);
                b = safe_add(b, oldb);
                c = safe_add(c, oldc);
                d = safe_add(d, oldd);
            }
            return [a, b, c, d];
        };

        var obj = {
            /*
             * These are the functions you'll usually want to call.
             * They take string arguments and return either hex or base-64 encoded
             * strings.
             */
            hexdigest: function (s) {
                return binl2hex(core_md5(str2binl(s), s.length * 8));
            },

            hash: function (s) {
                return binl2str(core_md5(str2binl(s), s.length * 8));
            }
        };
        return obj;
    }));

    (function (root, factory) {
        if (typeof define === 'function' && define.amd) {
            define('strophe-utils', function () {
                return factory();
            });
        } else {
            // Browser globals
            root.stropheUtils = factory();
        }
    }(this, function () {

        var utils = {

            utf16to8: function (str) {
                var i, c;
                var out = "";
                var len = str.length;
                for (i = 0; i < len; i++) {
                    c = str.charCodeAt(i);
                    if ((c >= 0x0000) && (c <= 0x007F)) {
                        out += str.charAt(i);
                    } else if (c > 0x07FF) {
                        out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));
                        out += String.fromCharCode(0x80 | ((c >>  6) & 0x3F));
                        out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));
                    } else {
                        out += String.fromCharCode(0xC0 | ((c >>  6) & 0x1F));
                        out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));
                    }
                }
                return out;
            }

        };
        return utils;
    }));

    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /* global define */

    (function (root, factory) {
        if (typeof define === 'function' && define.amd) {
            define('strophe-polyfill', [], function () {
                return factory();
            });
        } else {
            // Browser globals
            return factory();
        }
    }(this, function () {

        /** PrivateFunction: Function.prototype.bind
         *  Bind a function to an instance.
         *
         *  This Function object extension method creates a bound method similar
         *  to those in Python.  This means that the 'this' object will point
         *  to the instance you want.  See
         *  <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind'>MDC's bind() documentation</a> and
         *  <a href='http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/'>Bound Functions and Function Imports in JavaScript</a>
         *  for a complete explanation.
         *
         *  This extension already exists in some browsers (namely, Firefox 3), but
         *  we provide it to support those that don't.
         *
         *  Parameters:
         *    (Object) obj - The object that will become 'this' in the bound function.
         *    (Object) argN - An option argument that will be prepended to the
         *      arguments given for the function call
         *
         *  Returns:
         *    The bound function.
         */
        if (!Function.prototype.bind) {
            Function.prototype.bind = function (obj /*, arg1, arg2, ... */)
            {
                var func = this;
                var _slice = Array.prototype.slice;
                var _concat = Array.prototype.concat;
                var _args = _slice.call(arguments, 1);

                return function () {
                    return func.apply(obj ? obj : this,
                        _concat.call(_args,
                            _slice.call(arguments, 0)));
                };
            };
        }

        /** PrivateFunction: Array.isArray
         *  This is a polyfill for the ES5 Array.isArray method.
         */
        if (!Array.isArray) {
            Array.isArray = function(arg) {
                return Object.prototype.toString.call(arg) === '[object Array]';
            };
        }

        /** PrivateFunction: Array.prototype.indexOf
         *  Return the index of an object in an array.
         *
         *  This function is not supplied by some JavaScript implementations, so
         *  we provide it if it is missing.  This code is from:
         *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf
         *
         *  Parameters:
         *    (Object) elt - The object to look for.
         *    (Integer) from - The index from which to start looking. (optional).
         *
         *  Returns:
         *    The index of elt in the array or -1 if not found.
         */
        if (!Array.prototype.indexOf)
        {
            Array.prototype.indexOf = function(elt /*, from*/)
            {
                var len = this.length;

                var from = Number(arguments[1]) || 0;
                from = (from < 0) ? Math.ceil(from) : Math.floor(from);
                if (from < 0) {
                    from += len;
                }

                for (; from < len; from++) {
                    if (from in this && this[from] === elt) {
                        return from;
                    }
                }

                return -1;
            };
        }
    }));
    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /*global define, document, window, setTimeout, clearTimeout, console, ActiveXObject, DOMParser */

    (function (root, factory) {
        if (typeof define === 'function' && define.amd) {
            define('strophe-core', [
                'strophe-sha1',
                'strophe-base64',
                'strophe-md5',
                'strophe-utils',
                "strophe-polyfill"
            ], function () {
                return factory.apply(this, arguments);
            });
        } else {
            // Browser globals
            var o = factory(root.SHA1, root.Base64, root.MD5, root.stropheUtils);
            window.Strophe =        o.Strophe;
            window.$build =         o.$build;
            window.$iq =            o.$iq;
            window.$msg =           o.$msg;
            window.$pres =          o.$pres;
            window.SHA1 =           o.SHA1;
            window.Base64 =         o.Base64;
            window.MD5 =            o.MD5;
            window.b64_hmac_sha1 =  o.SHA1.b64_hmac_sha1;
            window.b64_sha1 =       o.SHA1.b64_sha1;
            window.str_hmac_sha1 =  o.SHA1.str_hmac_sha1;
            window.str_sha1 =       o.SHA1.str_sha1;
        }
    }(this, function (SHA1, Base64, MD5, utils) {

        var Strophe;

        /** Function: $build
         *  Create a Strophe.Builder.
         *  This is an alias for 'new Strophe.Builder(name, attrs)'.
         *
         *  Parameters:
         *    (String) name - The root element name.
         *    (Object) attrs - The attributes for the root element in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $build(name, attrs) { return new Strophe.Builder(name, attrs); }

        /** Function: $msg
         *  Create a Strophe.Builder with a <message/> element as the root.
         *
         *  Parameters:
         *    (Object) attrs - The <message/> element attributes in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $msg(attrs) { return new Strophe.Builder("message", attrs); }

        /** Function: $iq
         *  Create a Strophe.Builder with an <iq/> element as the root.
         *
         *  Parameters:
         *    (Object) attrs - The <iq/> element attributes in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $iq(attrs) { return new Strophe.Builder("iq", attrs); }

        /** Function: $pres
         *  Create a Strophe.Builder with a <presence/> element as the root.
         *
         *  Parameters:
         *    (Object) attrs - The <presence/> element attributes in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder object.
         */
        function $pres(attrs) { return new Strophe.Builder("presence", attrs); }

        /** Class: Strophe
         *  An object container for all Strophe library functions.
         *
         *  This class is just a container for all the objects and constants
         *  used in the library.  It is not meant to be instantiated, but to
         *  provide a namespace for library objects, constants, and functions.
         */
        Strophe = {
            /** Constant: VERSION
             *  The version of the Strophe library. Unreleased builds will have
             *  a version of head-HASH where HASH is a partial revision.
             */
            VERSION: "1.2.4",

            /** Constants: XMPP Namespace Constants
             *  Common namespace constants from the XMPP RFCs and XEPs.
             *
             *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.
             *  NS.BOSH - BOSH namespace from XEP 206.
             *  NS.CLIENT - Main XMPP client namespace.
             *  NS.AUTH - Legacy authentication namespace.
             *  NS.ROSTER - Roster operations namespace.
             *  NS.PROFILE - Profile namespace.
             *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.
             *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.
             *  NS.MUC - Multi-User Chat namespace from XEP 45.
             *  NS.SASL - XMPP SASL namespace from RFC 3920.
             *  NS.STREAM - XMPP Streams namespace from RFC 3920.
             *  NS.BIND - XMPP Binding namespace from RFC 3920.
             *  NS.SESSION - XMPP Session namespace from RFC 3920.
             *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.
             *  NS.XHTML - XHTML body namespace from XEP 71.
             */
            NS: {
                HTTPBIND: "http://jabber.org/protocol/httpbind",
                BOSH: "urn:xmpp:xbosh",
                CLIENT: "jabber:client",
                AUTH: "jabber:iq:auth",
                ROSTER: "jabber:iq:roster",
                PROFILE: "jabber:iq:profile",
                DISCO_INFO: "http://jabber.org/protocol/disco#info",
                DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                MUC: "http://jabber.org/protocol/muc",
                SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                STREAM: "http://etherx.jabber.org/streams",
                FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                VERSION: "jabber:iq:version",
                STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                XHTML: "http://www.w3.org/1999/xhtml"
            },


            /** Constants: XHTML_IM Namespace
             *  contains allowed tags, tag attributes, and css properties.
             *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.
             *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended
             *  allowed tags and their attributes.
             */
            XHTML: {
                tags: ['a','blockquote','br','cite','em','img','li','ol','p','span','strong','ul','body'],
                attributes: {
                    'a':          ['href'],
                    'blockquote': ['style'],
                    'br':         [],
                    'cite':       ['style'],
                    'em':         [],
                    'img':        ['src', 'alt', 'style', 'height', 'width'],
                    'li':         ['style'],
                    'ol':         ['style'],
                    'p':          ['style'],
                    'span':       ['style'],
                    'strong':     [],
                    'ul':         ['style'],
                    'body':       []
                },
                css: ['background-color','color','font-family','font-size','font-style','font-weight','margin-left','margin-right','text-align','text-decoration'],
                /** Function: XHTML.validTag
                 *
                 * Utility method to determine whether a tag is allowed
                 * in the XHTML_IM namespace.
                 *
                 * XHTML tag names are case sensitive and must be lower case.
                 */
                validTag: function(tag) {
                    for (var i = 0; i < Strophe.XHTML.tags.length; i++) {
                        if (tag == Strophe.XHTML.tags[i]) {
                            return true;
                        }
                    }
                    return false;
                },
                /** Function: XHTML.validAttribute
                 *
                 * Utility method to determine whether an attribute is allowed
                 * as recommended per XEP-0071
                 *
                 * XHTML attribute names are case sensitive and must be lower case.
                 */
                validAttribute: function(tag, attribute) {
                    if(typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {
                        for(var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                            if(attribute == Strophe.XHTML.attributes[tag][i]) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                validCSS: function(style)
                {
                    for(var i = 0; i < Strophe.XHTML.css.length; i++) {
                        if(style == Strophe.XHTML.css[i]) {
                            return true;
                        }
                    }
                    return false;
                }
            },

            /** Constants: Connection Status Constants
             *  Connection status constants for use by the connection handler
             *  callback.
             *
             *  Status.ERROR - An error has occurred
             *  Status.CONNECTING - The connection is currently being made
             *  Status.CONNFAIL - The connection attempt failed
             *  Status.AUTHENTICATING - The connection is authenticating
             *  Status.AUTHFAIL - The authentication attempt failed
             *  Status.CONNECTED - The connection has succeeded
             *  Status.DISCONNECTED - The connection has been terminated
             *  Status.DISCONNECTING - The connection is currently being terminated
             *  Status.ATTACHED - The connection has been attached
             */
            Status: {
                ERROR: 0,
                CONNECTING: 1,
                CONNFAIL: 2,
                AUTHENTICATING: 3,
                AUTHFAIL: 4,
                CONNECTED: 5,
                DISCONNECTED: 6,
                DISCONNECTING: 7,
                ATTACHED: 8,
                REDIRECT: 9
            },

            /** Constants: Log Level Constants
             *  Logging level indicators.
             *
             *  LogLevel.DEBUG - Debug output
             *  LogLevel.INFO - Informational output
             *  LogLevel.WARN - Warnings
             *  LogLevel.ERROR - Errors
             *  LogLevel.FATAL - Fatal errors
             */
            LogLevel: {
                DEBUG: 0,
                INFO: 1,
                WARN: 2,
                ERROR: 3,
                FATAL: 4
            },

            /** PrivateConstants: DOM Element Type Constants
             *  DOM element types.
             *
             *  ElementType.NORMAL - Normal element.
             *  ElementType.TEXT - Text data element.
             *  ElementType.FRAGMENT - XHTML fragment element.
             */
            ElementType: {
                NORMAL: 1,
                TEXT: 3,
                CDATA: 4,
                FRAGMENT: 11
            },

            /** PrivateConstants: Timeout Values
             *  Timeout values for error states.  These values are in seconds.
             *  These should not be changed unless you know exactly what you are
             *  doing.
             *
             *  TIMEOUT - Timeout multiplier. A waiting request will be considered
             *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.
             *      This defaults to 1.1, and with default wait, 66 seconds.
             *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where
             *      Strophe can detect early failure, it will consider the request
             *      failed if it doesn't return after
             *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.
             *      This defaults to 0.1, and with default wait, 6 seconds.
             */
            TIMEOUT: 1.1,
            SECONDARY_TIMEOUT: 0.1,

            /** Function: addNamespace
             *  This function is used to extend the current namespaces in
             *  Strophe.NS.  It takes a key and a value with the key being the
             *  name of the new namespace, with its actual value.
             *  For example:
             *  Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
             *
             *  Parameters:
             *    (String) name - The name under which the namespace will be
             *      referenced under Strophe.NS
             *    (String) value - The actual namespace.
             */
            addNamespace: function (name, value)
            {
                Strophe.NS[name] = value;
            },

            /** Function: forEachChild
             *  Map a function over some or all child elements of a given element.
             *
             *  This is a small convenience function for mapping a function over
             *  some or all of the children of an element.  If elemName is null, all
             *  children will be passed to the function, otherwise only children
             *  whose tag names match elemName will be passed.
             *
             *  Parameters:
             *    (XMLElement) elem - The element to operate on.
             *    (String) elemName - The child element tag name filter.
             *    (Function) func - The function to apply to each child.  This
             *      function should take a single argument, a DOM element.
             */
            forEachChild: function (elem, elemName, func)
            {
                var i, childNode;

                for (i = 0; i < elem.childNodes.length; i++) {
                    childNode = elem.childNodes[i];
                    if (childNode.nodeType == Strophe.ElementType.NORMAL &&
                        (!elemName || this.isTagEqual(childNode, elemName))) {
                        func(childNode);
                    }
                }
            },

            /** Function: isTagEqual
             *  Compare an element's tag name with a string.
             *
             *  This function is case sensitive.
             *
             *  Parameters:
             *    (XMLElement) el - A DOM element.
             *    (String) name - The element name.
             *
             *  Returns:
             *    true if the element's tag name matches _el_, and false
             *    otherwise.
             */
            isTagEqual: function (el, name)
            {
                return el.tagName == name;
            },

            /** PrivateVariable: _xmlGenerator
             *  _Private_ variable that caches a DOM document to
             *  generate elements.
             */
            _xmlGenerator: null,

            /** PrivateFunction: _makeGenerator
             *  _Private_ function that creates a dummy XML DOM document to serve as
             *  an element and text node generator.
             */
            _makeGenerator: function () {
                var doc;

                // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.
                // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be
                // less than 10 in the case of IE9 and below.
                if (document.implementation.createDocument === undefined ||
                    document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
                    doc = this._getIEXmlDom();
                    doc.appendChild(doc.createElement('strophe'));
                } else {
                    doc = document.implementation
                        .createDocument('jabber:client', 'strophe', null);
                }

                return doc;
            },

            /** Function: xmlGenerator
             *  Get the DOM document to generate elements.
             *
             *  Returns:
             *    The currently used DOM document.
             */
            xmlGenerator: function () {
                if (!Strophe._xmlGenerator) {
                    Strophe._xmlGenerator = Strophe._makeGenerator();
                }
                return Strophe._xmlGenerator;
            },

            /** PrivateFunction: _getIEXmlDom
             *  Gets IE xml doc object
             *
             *  Returns:
             *    A Microsoft XML DOM Object
             *  See Also:
             *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx
             */
            _getIEXmlDom : function() {
                var doc = null;
                var docStrings = [
                    "Msxml2.DOMDocument.6.0",
                    "Msxml2.DOMDocument.5.0",
                    "Msxml2.DOMDocument.4.0",
                    "MSXML2.DOMDocument.3.0",
                    "MSXML2.DOMDocument",
                    "MSXML.DOMDocument",
                    "Microsoft.XMLDOM"
                ];

                for (var d = 0; d < docStrings.length; d++) {
                    if (doc === null) {
                        try {
                            doc = new ActiveXObject(docStrings[d]);
                        } catch (e) {
                            doc = null;
                        }
                    } else {
                        break;
                    }
                }

                return doc;
            },

            /** Function: xmlElement
             *  Create an XML DOM element.
             *
             *  This function creates an XML DOM element correctly across all
             *  implementations. Note that these are not HTML DOM elements, which
             *  aren't appropriate for XMPP stanzas.
             *
             *  Parameters:
             *    (String) name - The name for the element.
             *    (Array|Object) attrs - An optional array or object containing
             *      key/value pairs to use as element attributes. The object should
             *      be in the format {'key': 'value'} or {key: 'value'}. The array
             *      should have the format [['key1', 'value1'], ['key2', 'value2']].
             *    (String) text - The text child data for the element.
             *
             *  Returns:
             *    A new XML DOM element.
             */
            xmlElement: function (name)
            {
                if (!name) { return null; }

                var node = Strophe.xmlGenerator().createElement(name);

                // FIXME: this should throw errors if args are the wrong type or
                // there are more than two optional args
                var a, i, k;
                for (a = 1; a < arguments.length; a++) {
                    var arg = arguments[a];
                    if (!arg) { continue; }
                    if (typeof(arg) == "string" ||
                        typeof(arg) == "number") {
                        node.appendChild(Strophe.xmlTextNode(arg));
                    } else if (typeof(arg) == "object" &&
                        typeof(arg.sort) == "function") {
                        for (i = 0; i < arg.length; i++) {
                            var attr = arg[i];
                            if (typeof(attr) == "object" &&
                                typeof(attr.sort) == "function" &&
                                attr[1] !== undefined &&
                                attr[1] !== null) {
                                node.setAttribute(attr[0], attr[1]);
                            }
                        }
                    } else if (typeof(arg) == "object") {
                        for (k in arg) {
                            if (arg.hasOwnProperty(k)) {
                                if (arg[k] !== undefined &&
                                    arg[k] !== null) {
                                    node.setAttribute(k, arg[k]);
                                }
                            }
                        }
                    }
                }

                return node;
            },

            /*  Function: xmlescape
             *  Excapes invalid xml characters.
             *
             *  Parameters:
             *     (String) text - text to escape.
             *
             *  Returns:
             *      Escaped text.
             */
            xmlescape: function(text)
            {
                text = text.replace(/\&/g, "&amp;");
                text = text.replace(/</g,  "&lt;");
                text = text.replace(/>/g,  "&gt;");
                text = text.replace(/'/g,  "&apos;");
                text = text.replace(/"/g,  "&quot;");
                return text;
            },

            /*  Function: xmlunescape
             *  Unexcapes invalid xml characters.
             *
             *  Parameters:
             *     (String) text - text to unescape.
             *
             *  Returns:
             *      Unescaped text.
             */
            xmlunescape: function(text)
            {
                text = text.replace(/\&amp;/g, "&");
                text = text.replace(/&lt;/g,  "<");
                text = text.replace(/&gt;/g,  ">");
                text = text.replace(/&apos;/g,  "'");
                text = text.replace(/&quot;/g,  "\"");
                return text;
            },

            /** Function: xmlTextNode
             *  Creates an XML DOM text node.
             *
             *  Provides a cross implementation version of document.createTextNode.
             *
             *  Parameters:
             *    (String) text - The content of the text node.
             *
             *  Returns:
             *    A new XML DOM text node.
             */
            xmlTextNode: function (text)
            {
                return Strophe.xmlGenerator().createTextNode(text);
            },

            /** Function: xmlHtmlNode
             *  Creates an XML DOM html node.
             *
             *  Parameters:
             *    (String) html - The content of the html node.
             *
             *  Returns:
             *    A new XML DOM text node.
             */
            xmlHtmlNode: function (html)
            {
                var node;
                //ensure text is escaped
                if (window.DOMParser) {
                    var parser = new DOMParser();
                    node = parser.parseFromString(html, "text/xml");
                } else {
                    node = new ActiveXObject("Microsoft.XMLDOM");
                    node.async="false";
                    node.loadXML(html);
                }
                return node;
            },

            /** Function: getText
             *  Get the concatenation of all text children of an element.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    A String with the concatenated text of all text element children.
             */
            getText: function (elem)
            {
                if (!elem) { return null; }

                var str = "";
                if (elem.childNodes.length === 0 && elem.nodeType ==
                    Strophe.ElementType.TEXT) {
                    str += elem.nodeValue;
                }

                for (var i = 0; i < elem.childNodes.length; i++) {
                    if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
                        str += elem.childNodes[i].nodeValue;
                    }
                }

                return Strophe.xmlescape(str);
            },

            /** Function: copyElement
             *  Copy an XML DOM element.
             *
             *  This function copies a DOM element and all its descendants and returns
             *  the new copy.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    A new, copied DOM element tree.
             */
            copyElement: function (elem)
            {
                var i, el;
                if (elem.nodeType == Strophe.ElementType.NORMAL) {
                    el = Strophe.xmlElement(elem.tagName);

                    for (i = 0; i < elem.attributes.length; i++) {
                        el.setAttribute(elem.attributes[i].nodeName,
                            elem.attributes[i].value);
                    }

                    for (i = 0; i < elem.childNodes.length; i++) {
                        el.appendChild(Strophe.copyElement(elem.childNodes[i]));
                    }
                } else if (elem.nodeType == Strophe.ElementType.TEXT) {
                    el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);
                }

                return el;
            },


            /** Function: createHtml
             *  Copy an HTML DOM element into an XML DOM.
             *
             *  This function copies a DOM element and all its descendants and returns
             *  the new copy.
             *
             *  Parameters:
             *    (HTMLElement) elem - A DOM element.
             *
             *  Returns:
             *    A new, copied DOM element tree.
             */
            createHtml: function (elem)
            {
                var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;
                if (elem.nodeType == Strophe.ElementType.NORMAL) {
                    tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.
                    if(Strophe.XHTML.validTag(tag)) {
                        try {
                            el = Strophe.xmlElement(tag);
                            for(i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                                attribute = Strophe.XHTML.attributes[tag][i];
                                value = elem.getAttribute(attribute);
                                if(typeof value == 'undefined' || value === null || value === '' || value === false || value === 0) {
                                    continue;
                                }
                                if(attribute == 'style' && typeof value == 'object') {
                                    if(typeof value.cssText != 'undefined') {
                                        value = value.cssText; // we're dealing with IE, need to get CSS out
                                    }
                                }
                                // filter out invalid css styles
                                if(attribute == 'style') {
                                    css = [];
                                    cssAttrs = value.split(';');
                                    for(j = 0; j < cssAttrs.length; j++) {
                                        attr = cssAttrs[j].split(':');
                                        cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                        if(Strophe.XHTML.validCSS(cssName)) {
                                            cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                            css.push(cssName + ': ' + cssValue);
                                        }
                                    }
                                    if(css.length > 0) {
                                        value = css.join('; ');
                                        el.setAttribute(attribute, value);
                                    }
                                } else {
                                    el.setAttribute(attribute, value);
                                }
                            }

                            for (i = 0; i < elem.childNodes.length; i++) {
                                el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                            }
                        } catch(e) { // invalid elements
                            el = Strophe.xmlTextNode('');
                        }
                    } else {
                        el = Strophe.xmlGenerator().createDocumentFragment();
                        for (i = 0; i < elem.childNodes.length; i++) {
                            el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                        }
                    }
                } else if (elem.nodeType == Strophe.ElementType.FRAGMENT) {
                    el = Strophe.xmlGenerator().createDocumentFragment();
                    for (i = 0; i < elem.childNodes.length; i++) {
                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                    }
                } else if (elem.nodeType == Strophe.ElementType.TEXT) {
                    el = Strophe.xmlTextNode(elem.nodeValue);
                }

                return el;
            },

            /** Function: escapeNode
             *  Escape the node part (also called local part) of a JID.
             *
             *  Parameters:
             *    (String) node - A node (or local part).
             *
             *  Returns:
             *    An escaped node (or local part).
             */
            escapeNode: function (node)
            {
                if (typeof node !== "string") { return node; }
                return node.replace(/^\s+|\s+$/g, '')
                    .replace(/\\/g,  "\\5c")
                    .replace(/ /g,   "\\20")
                    .replace(/\"/g,  "\\22")
                    .replace(/\&/g,  "\\26")
                    .replace(/\'/g,  "\\27")
                    .replace(/\//g,  "\\2f")
                    .replace(/:/g,   "\\3a")
                    .replace(/</g,   "\\3c")
                    .replace(/>/g,   "\\3e")
                    .replace(/@/g,   "\\40");
            },

            /** Function: unescapeNode
             *  Unescape a node part (also called local part) of a JID.
             *
             *  Parameters:
             *    (String) node - A node (or local part).
             *
             *  Returns:
             *    An unescaped node (or local part).
             */
            unescapeNode: function (node)
            {
                if (typeof node !== "string") { return node; }
                return node.replace(/\\20/g, " ")
                    .replace(/\\22/g, '"')
                    .replace(/\\26/g, "&")
                    .replace(/\\27/g, "'")
                    .replace(/\\2f/g, "/")
                    .replace(/\\3a/g, ":")
                    .replace(/\\3c/g, "<")
                    .replace(/\\3e/g, ">")
                    .replace(/\\40/g, "@")
                    .replace(/\\5c/g, "\\");
            },

            /** Function: getNodeFromJid
             *  Get the node portion of a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the node.
             */
            getNodeFromJid: function (jid)
            {
                if (jid.indexOf("@") < 0) { return null; }
                return jid.split("@")[0];
            },

            /** Function: getDomainFromJid
             *  Get the domain portion of a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the domain.
             */
            getDomainFromJid: function (jid)
            {
                var bare = Strophe.getBareJidFromJid(jid);
                if (bare.indexOf("@") < 0) {
                    return bare;
                } else {
                    var parts = bare.split("@");
                    parts.splice(0, 1);
                    return parts.join('@');
                }
            },

            /** Function: getResourceFromJid
             *  Get the resource portion of a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the resource.
             */
            getResourceFromJid: function (jid)
            {
                var s = jid.split("/");
                if (s.length < 2) { return null; }
                s.splice(0, 1);
                return s.join('/');
            },

            /** Function: getBareJidFromJid
             *  Get the bare JID from a JID String.
             *
             *  Parameters:
             *    (String) jid - A JID.
             *
             *  Returns:
             *    A String containing the bare JID.
             */
            getBareJidFromJid: function (jid)
            {
                return jid ? jid.split("/")[0] : null;
            },

            /** Function: log
             *  User overrideable logging function.
             *
             *  This function is called whenever the Strophe library calls any
             *  of the logging functions.  The default implementation of this
             *  function does nothing.  If client code wishes to handle the logging
             *  messages, it should override this with
             *  > Strophe.log = function (level, msg) {
     *  >   (user code here)
     *  > };
             *
             *  Please note that data sent and received over the wire is logged
             *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
             *
             *  The different levels and their meanings are
             *
             *    DEBUG - Messages useful for debugging purposes.
             *    INFO - Informational messages.  This is mostly information like
             *      'disconnect was called' or 'SASL auth succeeded'.
             *    WARN - Warnings about potential problems.  This is mostly used
             *      to report transient connection errors like request timeouts.
             *    ERROR - Some error occurred.
             *    FATAL - A non-recoverable fatal error occurred.
             *
             *  Parameters:
             *    (Integer) level - The log level of the log message.  This will
             *      be one of the values in Strophe.LogLevel.
             *    (String) msg - The log message.
             */
            /* jshint ignore:start */
            log: function (level, msg)
            {
                return;
            },
            /* jshint ignore:end */

            /** Function: debug
             *  Log a message at the Strophe.LogLevel.DEBUG level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            debug: function(msg)
            {
                this.log(this.LogLevel.DEBUG, msg);
            },

            /** Function: info
             *  Log a message at the Strophe.LogLevel.INFO level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            info: function (msg)
            {
                this.log(this.LogLevel.INFO, msg);
            },

            /** Function: warn
             *  Log a message at the Strophe.LogLevel.WARN level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            warn: function (msg)
            {
                this.log(this.LogLevel.WARN, msg);
            },

            /** Function: error
             *  Log a message at the Strophe.LogLevel.ERROR level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            error: function (msg)
            {
                this.log(this.LogLevel.ERROR, msg);
            },

            /** Function: fatal
             *  Log a message at the Strophe.LogLevel.FATAL level.
             *
             *  Parameters:
             *    (String) msg - The log message.
             */
            fatal: function (msg)
            {
                this.log(this.LogLevel.FATAL, msg);
            },

            /** Function: serialize
             *  Render a DOM element and all descendants to a String.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    The serialized element tree as a String.
             */
            serialize: function (elem)
            {
                var result;

                if (!elem) { return null; }

                if (typeof(elem.tree) === "function") {
                    elem = elem.tree();
                }

                var nodeName = elem.nodeName;
                var i, child;

                if (elem.getAttribute("_realname")) {
                    nodeName = elem.getAttribute("_realname");
                }

                result = "<" + nodeName;
                for (i = 0; i < elem.attributes.length; i++) {
                    if(elem.attributes[i].nodeName != "_realname") {
                        result += " " + elem.attributes[i].nodeName +
                            "='" + elem.attributes[i].value
                                .replace(/&/g, "&amp;")
                                .replace(/\'/g, "&apos;")
                                .replace(/>/g, "&gt;")
                                .replace(/</g, "&lt;") + "'";
                    }
                }

                if (elem.childNodes.length > 0) {
                    result += ">";
                    for (i = 0; i < elem.childNodes.length; i++) {
                        child = elem.childNodes[i];
                        switch( child.nodeType ){
                            case Strophe.ElementType.NORMAL:
                                // normal element, so recurse
                                result += Strophe.serialize(child);
                                break;
                            case Strophe.ElementType.TEXT:
                                // text element to escape values
                                result += Strophe.xmlescape(child.nodeValue);
                                break;
                            case Strophe.ElementType.CDATA:
                                // cdata section so don't escape values
                                result += "<![CDATA["+child.nodeValue+"]]>";
                        }
                    }
                    result += "</" + nodeName + ">";
                } else {
                    result += "/>";
                }

                return result;
            },

            /** PrivateVariable: _requestId
             *  _Private_ variable that keeps track of the request ids for
             *  connections.
             */
            _requestId: 0,

            /** PrivateVariable: Strophe.connectionPlugins
             *  _Private_ variable Used to store plugin names that need
             *  initialization on Strophe.Connection construction.
             */
            _connectionPlugins: {},

            /** Function: addConnectionPlugin
             *  Extends the Strophe.Connection object with the given plugin.
             *
             *  Parameters:
             *    (String) name - The name of the extension.
             *    (Object) ptype - The plugin's prototype.
             */
            addConnectionPlugin: function (name, ptype)
            {
                Strophe._connectionPlugins[name] = ptype;
            }
        };

        /** Class: Strophe.Builder
         *  XML DOM builder.
         *
         *  This object provides an interface similar to JQuery but for building
         *  DOM elements easily and rapidly.  All the functions except for toString()
         *  and tree() return the object, so calls can be chained.  Here's an
         *  example using the $iq() builder helper.
         *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})
         *  >     .c('query', {xmlns: 'strophe:example'})
         *  >     .c('example')
         *  >     .toString()
         *  The above generates this XML fragment
         *  > <iq to='you' from='me' type='get' id='1'>
         *  >   <query xmlns='strophe:example'>
         *  >     <example/>
         *  >   </query>
         *  > </iq>
         *  The corresponding DOM manipulations to get a similar fragment would be
         *  a lot more tedious and probably involve several helper variables.
         *
         *  Since adding children makes new operations operate on the child, up()
         *  is provided to traverse up the tree.  To add two children, do
         *  > builder.c('child1', ...).up().c('child2', ...)
         *  The next operation on the Builder will be relative to the second child.
         */

        /** Constructor: Strophe.Builder
         *  Create a Strophe.Builder object.
         *
         *  The attributes should be passed in object notation.  For example
         *  > var b = new Builder('message', {to: 'you', from: 'me'});
         *  or
         *  > var b = new Builder('messsage', {'xml:lang': 'en'});
         *
         *  Parameters:
         *    (String) name - The name of the root element.
         *    (Object) attrs - The attributes for the root element in object notation.
         *
         *  Returns:
         *    A new Strophe.Builder.
         */
        Strophe.Builder = function (name, attrs)
        {
            // Set correct namespace for jabber:client elements
            if (name == "presence" || name == "message" || name == "iq") {
                if (attrs && !attrs.xmlns) {
                    attrs.xmlns = Strophe.NS.CLIENT;
                } else if (!attrs) {
                    attrs = {xmlns: Strophe.NS.CLIENT};
                }
            }

            // Holds the tree being built.
            this.nodeTree = Strophe.xmlElement(name, attrs);

            // Points to the current operation node.
            this.node = this.nodeTree;
        };

        Strophe.Builder.prototype = {
            /** Function: tree
             *  Return the DOM tree.
             *
             *  This function returns the current DOM tree as an element object.  This
             *  is suitable for passing to functions like Strophe.Connection.send().
             *
             *  Returns:
             *    The DOM tree as a element object.
             */
            tree: function ()
            {
                return this.nodeTree;
            },

            /** Function: toString
             *  Serialize the DOM tree to a String.
             *
             *  This function returns a string serialization of the current DOM
             *  tree.  It is often used internally to pass data to a
             *  Strophe.Request object.
             *
             *  Returns:
             *    The serialized DOM tree in a String.
             */
            toString: function ()
            {
                return Strophe.serialize(this.nodeTree);
            },

            /** Function: up
             *  Make the current parent element the new current element.
             *
             *  This function is often used after c() to traverse back up the tree.
             *  For example, to add two children to the same element
             *  > builder.c('child1', {}).up().c('child2', {});
             *
             *  Returns:
             *    The Stophe.Builder object.
             */
            up: function ()
            {
                this.node = this.node.parentNode;
                return this;
            },

            /** Function: attrs
             *  Add or modify attributes of the current element.
             *
             *  The attributes should be passed in object notation.  This function
             *  does not move the current element pointer.
             *
             *  Parameters:
             *    (Object) moreattrs - The attributes to add/modify in object notation.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            attrs: function (moreattrs)
            {
                for (var k in moreattrs) {
                    if (moreattrs.hasOwnProperty(k)) {
                        if (moreattrs[k] === undefined) {
                            this.node.removeAttribute(k);
                        } else {
                            this.node.setAttribute(k, moreattrs[k]);
                        }
                    }
                }
                return this;
            },

            /** Function: c
             *  Add a child to the current element and make it the new current
             *  element.
             *
             *  This function moves the current element pointer to the child,
             *  unless text is provided.  If you need to add another child, it
             *  is necessary to use up() to go back to the parent in the tree.
             *
             *  Parameters:
             *    (String) name - The name of the child.
             *    (Object) attrs - The attributes of the child in object notation.
             *    (String) text - The text to add to the child.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            c: function (name, attrs, text)
            {
                var child = Strophe.xmlElement(name, attrs, text);
                this.node.appendChild(child);
                if (typeof text !== "string") {
                    this.node = child;
                }
                return this;
            },

            /** Function: cnode
             *  Add a child to the current element and make it the new current
             *  element.
             *
             *  This function is the same as c() except that instead of using a
             *  name and an attributes object to create the child it uses an
             *  existing DOM element object.
             *
             *  Parameters:
             *    (XMLElement) elem - A DOM element.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            cnode: function (elem)
            {
                var impNode;
                var xmlGen = Strophe.xmlGenerator();
                try {
                    impNode = (xmlGen.importNode !== undefined);
                }
                catch (e) {
                    impNode = false;
                }
                var newElem = impNode ?
                    xmlGen.importNode(elem, true) :
                    Strophe.copyElement(elem);
                this.node.appendChild(newElem);
                this.node = newElem;
                return this;
            },

            /** Function: t
             *  Add a child text element.
             *
             *  This *does not* make the child the new current element since there
             *  are no children of text elements.
             *
             *  Parameters:
             *    (String) text - The text data to append to the current element.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            t: function (text)
            {
                var child = Strophe.xmlTextNode(text);
                this.node.appendChild(child);
                return this;
            },

            /** Function: h
             *  Replace current element contents with the HTML passed in.
             *
             *  This *does not* make the child the new current element
             *
             *  Parameters:
             *    (String) html - The html to insert as contents of current element.
             *
             *  Returns:
             *    The Strophe.Builder object.
             */
            h: function (html)
            {
                var fragment = document.createElement('body');

                // force the browser to try and fix any invalid HTML tags
                fragment.innerHTML = html;

                // copy cleaned html into an xml dom
                var xhtml = Strophe.createHtml(fragment);

                while(xhtml.childNodes.length > 0) {
                    this.node.appendChild(xhtml.childNodes[0]);
                }
                return this;
            }
        };

        /** PrivateClass: Strophe.Handler
         *  _Private_ helper class for managing stanza handlers.
         *
         *  A Strophe.Handler encapsulates a user provided callback function to be
         *  executed when matching stanzas are received by the connection.
         *  Handlers can be either one-off or persistant depending on their
         *  return value. Returning true will cause a Handler to remain active, and
         *  returning false will remove the Handler.
         *
         *  Users will not use Strophe.Handler objects directly, but instead they
         *  will use Strophe.Connection.addHandler() and
         *  Strophe.Connection.deleteHandler().
         */

        /** PrivateConstructor: Strophe.Handler
         *  Create and initialize a new Strophe.Handler.
         *
         *  Parameters:
         *    (Function) handler - A function to be executed when the handler is run.
         *    (String) ns - The namespace to match.
         *    (String) name - The element name to match.
         *    (String) type - The element type to match.
         *    (String) id - The element id attribute to match.
         *    (String) from - The element from attribute to match.
         *    (Object) options - Handler options
         *
         *  Returns:
         *    A new Strophe.Handler object.
         */
        Strophe.Handler = function (handler, ns, name, type, id, from, options)
        {
            this.handler = handler;
            this.ns = ns;
            this.name = name;
            this.type = type;
            this.id = id;
            this.options = options || {matchBare: false};

            // default matchBare to false if undefined
            if (!this.options.matchBare) {
                this.options.matchBare = false;
            }

            if (this.options.matchBare) {
                this.from = from ? Strophe.getBareJidFromJid(from) : null;
            } else {
                this.from = from;
            }

            // whether the handler is a user handler or a system handler
            this.user = true;
        };

        Strophe.Handler.prototype = {
            /** PrivateFunction: isMatch
             *  Tests if a stanza matches the Strophe.Handler.
             *
             *  Parameters:
             *    (XMLElement) elem - The XML element to test.
             *
             *  Returns:
             *    true if the stanza matches and false otherwise.
             */
            isMatch: function (elem)
            {
                var nsMatch;
                var from = null;

                if (this.options.matchBare) {
                    from = Strophe.getBareJidFromJid(elem.getAttribute('from'));
                } else {
                    from = elem.getAttribute('from');
                }

                nsMatch = false;
                if (!this.ns) {
                    nsMatch = true;
                } else {
                    var that = this;
                    Strophe.forEachChild(elem, null, function (elem) {
                        if (elem.getAttribute("xmlns") == that.ns) {
                            nsMatch = true;
                        }
                    });

                    nsMatch = nsMatch || elem.getAttribute("xmlns") == this.ns;
                }

                var elem_type = elem.getAttribute("type");
                if (nsMatch &&
                    (!this.name || Strophe.isTagEqual(elem, this.name)) &&
                    (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) != -1 : elem_type == this.type)) &&
                    (!this.id || elem.getAttribute("id") == this.id) &&
                    (!this.from || from == this.from)) {
                    return true;
                }

                return false;
            },

            /** PrivateFunction: run
             *  Run the callback on a matching stanza.
             *
             *  Parameters:
             *    (XMLElement) elem - The DOM element that triggered the
             *      Strophe.Handler.
             *
             *  Returns:
             *    A boolean indicating if the handler should remain active.
             */
            run: function (elem)
            {
                var result = null;
                try {
                    result = this.handler(elem);
                } catch (e) {
                    if (e.sourceURL) {
                        Strophe.fatal("error: " + this.handler +
                            " " + e.sourceURL + ":" +
                            e.line + " - " + e.name + ": " + e.message);
                    } else if (e.fileName) {
                        if (typeof(console) != "undefined") {
                            console.trace();
                            console.error(this.handler, " - error - ", e, e.message);
                        }
                        Strophe.fatal("error: " + this.handler + " " +
                            e.fileName + ":" + e.lineNumber + " - " +
                            e.name + ": " + e.message);
                    } else {
                        Strophe.fatal("error: " + e.message + "\n" + e.stack);
                    }

                    throw e;
                }

                return result;
            },

            /** PrivateFunction: toString
             *  Get a String representation of the Strophe.Handler object.
             *
             *  Returns:
             *    A String.
             */
            toString: function ()
            {
                return "{Handler: " + this.handler + "(" + this.name + "," +
                    this.id + "," + this.ns + ")}";
            }
        };

        /** PrivateClass: Strophe.TimedHandler
         *  _Private_ helper class for managing timed handlers.
         *
         *  A Strophe.TimedHandler encapsulates a user provided callback that
         *  should be called after a certain period of time or at regular
         *  intervals.  The return value of the callback determines whether the
         *  Strophe.TimedHandler will continue to fire.
         *
         *  Users will not use Strophe.TimedHandler objects directly, but instead
         *  they will use Strophe.Connection.addTimedHandler() and
         *  Strophe.Connection.deleteTimedHandler().
         */

        /** PrivateConstructor: Strophe.TimedHandler
         *  Create and initialize a new Strophe.TimedHandler object.
         *
         *  Parameters:
         *    (Integer) period - The number of milliseconds to wait before the
         *      handler is called.
         *    (Function) handler - The callback to run when the handler fires.  This
         *      function should take no arguments.
         *
         *  Returns:
         *    A new Strophe.TimedHandler object.
         */
        Strophe.TimedHandler = function (period, handler)
        {
            this.period = period;
            this.handler = handler;

            this.lastCalled = new Date().getTime();
            this.user = true;
        };

        Strophe.TimedHandler.prototype = {
            /** PrivateFunction: run
             *  Run the callback for the Strophe.TimedHandler.
             *
             *  Returns:
             *    true if the Strophe.TimedHandler should be called again, and false
             *      otherwise.
             */
            run: function ()
            {
                this.lastCalled = new Date().getTime();
                return this.handler();
            },

            /** PrivateFunction: reset
             *  Reset the last called time for the Strophe.TimedHandler.
             */
            reset: function ()
            {
                this.lastCalled = new Date().getTime();
            },

            /** PrivateFunction: toString
             *  Get a string representation of the Strophe.TimedHandler object.
             *
             *  Returns:
             *    The string representation.
             */
            toString: function ()
            {
                return "{TimedHandler: " + this.handler + "(" + this.period +")}";
            }
        };

        /** Class: Strophe.Connection
         *  XMPP Connection manager.
         *
         *  This class is the main part of Strophe.  It manages a BOSH or websocket
         *  connection to an XMPP server and dispatches events to the user callbacks
         *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1
         *  and legacy authentication.
         *
         *  After creating a Strophe.Connection object, the user will typically
         *  call connect() with a user supplied callback to handle connection level
         *  events like authentication failure, disconnection, or connection
         *  complete.
         *
         *  The user will also have several event handlers defined by using
         *  addHandler() and addTimedHandler().  These will allow the user code to
         *  respond to interesting stanzas or do something periodically with the
         *  connection. These handlers will be active once authentication is
         *  finished.
         *
         *  To send data to the connection, use send().
         */

        /** Constructor: Strophe.Connection
         *  Create and initialize a Strophe.Connection object.
         *
         *  The transport-protocol for this connection will be chosen automatically
         *  based on the given service parameter. URLs starting with "ws://" or
         *  "wss://" will use WebSockets, URLs starting with "http://", "https://"
         *  or without a protocol will use BOSH.
         *
         *  To make Strophe connect to the current host you can leave out the protocol
         *  and host part and just pass the path, e.g.
         *
         *  > var conn = new Strophe.Connection("/http-bind/");
         *
         *  WebSocket options:
         *
         *  If you want to connect to the current host with a WebSocket connection you
         *  can tell Strophe to use WebSockets through a "protocol" attribute in the
         *  optional options parameter. Valid values are "ws" for WebSocket and "wss"
         *  for Secure WebSocket.
         *  So to connect to "wss://CURRENT_HOSTNAME/xmpp-websocket" you would call
         *
         *  > var conn = new Strophe.Connection("/xmpp-websocket/", {protocol: "wss"});
         *
         *  Note that relative URLs _NOT_ starting with a "/" will also include the path
         *  of the current site.
         *
         *  Also because downgrading security is not permitted by browsers, when using
         *  relative URLs both BOSH and WebSocket connections will use their secure
         *  variants if the current connection to the site is also secure (https).
         *
         *  BOSH options:
         *
         *  By adding "sync" to the options, you can control if requests will
         *  be made synchronously or not. The default behaviour is asynchronous.
         *  If you want to make requests synchronous, make "sync" evaluate to true:
         *  > var conn = new Strophe.Connection("/http-bind/", {sync: true});
         *
         *  You can also toggle this on an already established connection:
         *  > conn.options.sync = true;
         *
         *  The "customHeaders" option can be used to provide custom HTTP headers to be
         *  included in the XMLHttpRequests made.
         *
         *  The "keepalive" option can be used to instruct Strophe to maintain the
         *  current BOSH session across interruptions such as webpage reloads.
         *
         *  It will do this by caching the sessions tokens in sessionStorage, and when
         *  "restore" is called it will check whether there are cached tokens with
         *  which it can resume an existing session.
         *
         *  Parameters:
         *    (String) service - The BOSH or WebSocket service URL.
         *    (Object) options - A hash of configuration options
         *
         *  Returns:
         *    A new Strophe.Connection object.
         */
        Strophe.Connection = function (service, options)
        {
            // The service URL
            this.service = service;

            // Configuration options
            this.options = options || {};
            var proto = this.options.protocol || "";

            // Select protocal based on service or options
            if (service.indexOf("ws:") === 0 || service.indexOf("wss:") === 0 ||
                proto.indexOf("ws") === 0) {
                this._proto = new Strophe.Websocket(this);
            } else {
                this._proto = new Strophe.Bosh(this);
            }

            /* The connected JID. */
            this.jid = "";
            /* the JIDs domain */
            this.domain = null;
            /* stream:features */
            this.features = null;

            // SASL
            this._sasl_data = {};
            this.do_session = false;
            this.do_bind = false;

            // handler lists
            this.timedHandlers = [];
            this.handlers = [];
            this.removeTimeds = [];
            this.removeHandlers = [];
            this.addTimeds = [];
            this.addHandlers = [];

            this._authentication = {};
            this._idleTimeout = null;
            this._disconnectTimeout = null;

            this.authenticated = false;
            this.connected = false;
            this.disconnecting = false;
            this.do_authentication = true;
            this.paused = false;
            this.restored = false;

            this._data = [];
            this._uniqueId = 0;

            this._sasl_success_handler = null;
            this._sasl_failure_handler = null;
            this._sasl_challenge_handler = null;

            // Max retries before disconnecting
            this.maxRetries = 5;

            // setup onIdle callback every 1/10th of a second
            this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);

            // initialize plugins
            for (var k in Strophe._connectionPlugins) {
                if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                    var ptype = Strophe._connectionPlugins[k];
                    // jslint complaints about the below line, but this is fine
                    var F = function () {}; // jshint ignore:line
                    F.prototype = ptype;
                    this[k] = new F();
                    this[k].init(this);
                }
            }
        };

        Strophe.Connection.prototype = {
            /** Function: reset
             *  Reset the connection.
             *
             *  This function should be called after a connection is disconnected
             *  before that connection is reused.
             */
            reset: function ()
            {
                this._proto._reset();

                // SASL
                this.do_session = false;
                this.do_bind = false;

                // handler lists
                this.timedHandlers = [];
                this.handlers = [];
                this.removeTimeds = [];
                this.removeHandlers = [];
                this.addTimeds = [];
                this.addHandlers = [];
                this._authentication = {};

                this.authenticated = false;
                this.connected = false;
                this.disconnecting = false;
                this.restored = false;

                this._data = [];
                this._requests = [];
                this._uniqueId = 0;
            },

            /** Function: pause
             *  Pause the request manager.
             *
             *  This will prevent Strophe from sending any more requests to the
             *  server.  This is very useful for temporarily pausing
             *  BOSH-Connections while a lot of send() calls are happening quickly.
             *  This causes Strophe to send the data in a single request, saving
             *  many request trips.
             */
            pause: function ()
            {
                this.paused = true;
            },

            /** Function: resume
             *  Resume the request manager.
             *
             *  This resumes after pause() has been called.
             */
            resume: function ()
            {
                this.paused = false;
            },

            /** Function: getUniqueId
             *  Generate a unique ID for use in <iq/> elements.
             *
             *  All <iq/> stanzas are required to have unique id attributes.  This
             *  function makes creating these easy.  Each connection instance has
             *  a counter which starts from zero, and the value of this counter
             *  plus a colon followed by the suffix becomes the unique id. If no
             *  suffix is supplied, the counter is used as the unique id.
             *
             *  Suffixes are used to make debugging easier when reading the stream
             *  data, and their use is recommended.  The counter resets to 0 for
             *  every new connection for the same reason.  For connections to the
             *  same server that authenticate the same way, all the ids should be
             *  the same, which makes it easy to see changes.  This is useful for
             *  automated testing as well.
             *
             *  Parameters:
             *    (String) suffix - A optional suffix to append to the id.
             *
             *  Returns:
             *    A unique string to be used for the id attribute.
             */
            getUniqueId: function(suffix) {
                var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    var r = Math.random() * 16 | 0,
                        v = c == 'x' ? r : r & 0x3 | 0x8;
                    return v.toString(16);
                });
                if (typeof(suffix) == "string" || typeof(suffix) == "number") {
                    return uuid + ":" + suffix;
                } else {
                    return uuid + "";
                }
            },

            /** Function: connect
             *  Starts the connection process.
             *
             *  As the connection process proceeds, the user supplied callback will
             *  be triggered multiple times with status updates.  The callback
             *  should take two arguments - the status code and the error condition.
             *
             *  The status code will be one of the values in the Strophe.Status
             *  constants.  The error condition will be one of the conditions
             *  defined in RFC 3920 or the condition 'strophe-parsererror'.
             *
             *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant
             *  for BOSH connections. Please see XEP 124 for a more detailed explanation
             *  of the optional parameters.
             *
             *  Parameters:
             *    (String) jid - The user's JID.  This may be a bare JID,
             *      or a full JID.  If a node is not supplied, SASL ANONYMOUS
             *      authentication will be attempted.
             *    (String) pass - The user's password.
             *    (Function) callback - The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (String) route - The optional route value.
             *    (String) authcid - The optional alternative authentication identity
             *      (username) if intending to impersonate another user.
             */
            connect: function (jid, pass, callback, wait, hold, route, authcid)
            {
                this.jid = jid;
                /** Variable: authzid
                 *  Authorization identity.
                 */
                this.authzid = Strophe.getBareJidFromJid(this.jid);
                /** Variable: authcid
                 *  Authentication identity (User name).
                 */
                this.authcid = authcid || Strophe.getNodeFromJid(this.jid);
                /** Variable: pass
                 *  Authentication identity (User password).
                 */
                this.pass = pass;
                /** Variable: servtype
                 *  Digest MD5 compatibility.
                 */
                this.servtype = "xmpp";
                this.connect_callback = callback;
                this.disconnecting = false;
                this.connected = false;
                this.authenticated = false;
                this.restored = false;

                // parse jid for domain
                this.domain = Strophe.getDomainFromJid(this.jid);

                this._changeConnectStatus(Strophe.Status.CONNECTING, null);

                this._proto._connect(wait, hold, route);
            },

            /** Function: attach
             *  Attach to an already created and authenticated BOSH session.
             *
             *  This function is provided to allow Strophe to attach to BOSH
             *  sessions which have been created externally, perhaps by a Web
             *  application.  This is often used to support auto-login type features
             *  without putting user credentials into the page.
             *
             *  Parameters:
             *    (String) jid - The full JID that is bound by the session.
             *    (String) sid - The SID of the BOSH session.
             *    (String) rid - The current RID of the BOSH session.  This RID
             *      will be used by the next request.
             *    (Function) callback The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *      Other settings will require tweaks to the Strophe.TIMEOUT value.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            attach: function (jid, sid, rid, callback, wait, hold, wind)
            {
                if (this._proto instanceof Strophe.Bosh) {
                    this._proto._attach(jid, sid, rid, callback, wait, hold, wind);
                } else {
                    throw {
                        name: 'StropheSessionError',
                        message: 'The "attach" method can only be used with a BOSH connection.'
                    };
                }
            },

            /** Function: restore
             *  Attempt to restore a cached BOSH session.
             *
             *  This function is only useful in conjunction with providing the
             *  "keepalive":true option when instantiating a new Strophe.Connection.
             *
             *  When "keepalive" is set to true, Strophe will cache the BOSH tokens
             *  RID (Request ID) and SID (Session ID) and then when this function is
             *  called, it will attempt to restore the session from those cached
             *  tokens.
             *
             *  This function must therefore be called instead of connect or attach.
             *
             *  For an example on how to use it, please see examples/restore.js
             *
             *  Parameters:
             *    (String) jid - The user's JID.  This may be a bare JID or a full JID.
             *    (Function) callback - The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            restore: function (jid, callback, wait, hold, wind)
            {
                if (this._sessionCachingSupported()) {
                    this._proto._restore(jid, callback, wait, hold, wind);
                } else {
                    throw {
                        name: 'StropheSessionError',
                        message: 'The "restore" method can only be used with a BOSH connection.'
                    };
                }
            },

            /** PrivateFunction: _sessionCachingSupported
             * Checks whether sessionStorage and JSON are supported and whether we're
             * using BOSH.
             */
            _sessionCachingSupported: function ()
            {
                if (this._proto instanceof Strophe.Bosh) {
                    if (!JSON) { return false; }
                    try {
                        window.sessionStorage.setItem('_strophe_', '_strophe_');
                        window.sessionStorage.removeItem('_strophe_');
                    } catch (e) {
                        return false;
                    }
                    return true;
                }
                return false;
            },

            /** Function: xmlInput
             *  User overrideable function that receives XML data coming into the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.xmlInput = function (elem) {
     *  >   (user code)
     *  > };
             *
             *  Due to limitations of current Browsers' XML-Parsers the opening and closing
             *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
             *
             *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
             *  <Strophe.Bosh.strip> if you want to strip this tag.
             *
             *  Parameters:
             *    (XMLElement) elem - The XML data received by the connection.
             */
            /* jshint unused:false */
            xmlInput: function (elem)
            {
                return;
            },
            /* jshint unused:true */

            /** Function: xmlOutput
             *  User overrideable function that receives XML data sent to the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.xmlOutput = function (elem) {
     *  >   (user code)
     *  > };
             *
             *  Due to limitations of current Browsers' XML-Parsers the opening and closing
             *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
             *
             *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
             *  <Strophe.Bosh.strip> if you want to strip this tag.
             *
             *  Parameters:
             *    (XMLElement) elem - The XMLdata sent by the connection.
             */
            /* jshint unused:false */
            xmlOutput: function (elem)
            {
                return;
            },
            /* jshint unused:true */

            /** Function: rawInput
             *  User overrideable function that receives raw data coming into the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.rawInput = function (data) {
     *  >   (user code)
     *  > };
             *
             *  Parameters:
             *    (String) data - The data received by the connection.
             */
            /* jshint unused:false */
            rawInput: function (data)
            {
                return;
            },
            /* jshint unused:true */

            /** Function: rawOutput
             *  User overrideable function that receives raw data sent to the
             *  connection.
             *
             *  The default function does nothing.  User code can override this with
             *  > Strophe.Connection.rawOutput = function (data) {
     *  >   (user code)
     *  > };
             *
             *  Parameters:
             *    (String) data - The data sent by the connection.
             */
            /* jshint unused:false */
            rawOutput: function (data)
            {
                return;
            },
            /* jshint unused:true */

            /** Function: nextValidRid
             *  User overrideable function that receives the new valid rid.
             *
             *  The default function does nothing. User code can override this with
             *  > Strophe.Connection.nextValidRid = function (rid) {
     *  >    (user code)
     *  > };
             *
             *  Parameters:
             *    (Number) rid - The next valid rid
             */
            /* jshint unused:false */
            nextValidRid: function (rid)
            {
                return;
            },
            /* jshint unused:true */

            /** Function: send
             *  Send a stanza.
             *
             *  This function is called to push data onto the send queue to
             *  go out over the wire.  Whenever a request is sent to the BOSH
             *  server, all pending data is sent and the queue is flushed.
             *
             *  Parameters:
             *    (XMLElement |
             *     [XMLElement] |
             *     Strophe.Builder) elem - The stanza to send.
             */
            send: function (elem)
            {
                if (elem === null) { return ; }
                if (typeof(elem.sort) === "function") {
                    for (var i = 0; i < elem.length; i++) {
                        this._queueData(elem[i]);
                    }
                } else if (typeof(elem.tree) === "function") {
                    this._queueData(elem.tree());
                } else {
                    this._queueData(elem);
                }

                this._proto._send();
            },

            /** Function: flush
             *  Immediately send any pending outgoing data.
             *
             *  Normally send() queues outgoing data until the next idle period
             *  (100ms), which optimizes network use in the common cases when
             *  several send()s are called in succession. flush() can be used to
             *  immediately send all pending data.
             */
            flush: function ()
            {
                // cancel the pending idle period and run the idle function
                // immediately
                clearTimeout(this._idleTimeout);
                this._onIdle();
            },

            /** Function: sendIQ
             *  Helper function to send IQ stanzas.
             *
             *  Parameters:
             *    (XMLElement) elem - The stanza to send.
             *    (Function) callback - The callback function for a successful request.
             *    (Function) errback - The callback function for a failed or timed
             *      out request.  On timeout, the stanza will be null.
             *    (Integer) timeout - The time specified in milliseconds for a
             *      timeout to occur.
             *
             *  Returns:
             *    The id used to send the IQ.
             */
            sendIQ: function(elem, callback, errback, timeout) {
                var timeoutHandler = null;
                var that = this;

                if (typeof(elem.tree) === "function") {
                    elem = elem.tree();
                }
                var id = elem.getAttribute('id');

                // inject id if not found
                if (!id) {
                    id = this.getUniqueId("sendIQ");
                    elem.setAttribute("id", id);
                }

                var expectedFrom = elem.getAttribute("to");
                var fulljid = this.jid;

                var handler = this.addHandler(function (stanza) {
                    // remove timeout handler if there is one
                    if (timeoutHandler) {
                        that.deleteTimedHandler(timeoutHandler);
                    }

                    var acceptable = false;
                    var from = stanza.getAttribute("from");
                    if (from === expectedFrom ||
                        (!expectedFrom &&
                        (from === Strophe.getBareJidFromJid(fulljid) ||
                        from === Strophe.getDomainFromJid(fulljid) ||
                        from === fulljid))) {
                        acceptable = true;
                    }

                    if (!acceptable) {
                        throw {
                            name: "StropheError",
                            message: "Got answer to IQ from wrong jid:" + from +
                            "\nExpected jid: " + expectedFrom
                        };
                    }

                    var iqtype = stanza.getAttribute('type');
                    if (iqtype == 'result') {
                        if (callback) {
                            callback(stanza);
                        }
                    } else if (iqtype == 'error') {
                        if (errback) {
                            errback(stanza);
                        }
                    } else {
                        throw {
                            name: "StropheError",
                            message: "Got bad IQ type of " + iqtype
                        };
                    }
                }, null, 'iq', ['error', 'result'], id);

                // if timeout specified, setup timeout handler.
                if (timeout) {
                    timeoutHandler = this.addTimedHandler(timeout, function () {
                        // get rid of normal handler
                        that.deleteHandler(handler);
                        // call errback on timeout with null stanza
                        if (errback) {
                            errback(null);
                        }
                        return false;
                    });
                }
                this.send(elem);
                return id;
            },

            /** PrivateFunction: _queueData
             *  Queue outgoing data for later sending.  Also ensures that the data
             *  is a DOMElement.
             */
            _queueData: function (element) {
                if (element === null ||
                    !element.tagName ||
                    !element.childNodes) {
                    throw {
                        name: "StropheError",
                        message: "Cannot queue non-DOMElement."
                    };
                }

                this._data.push(element);
            },

            /** PrivateFunction: _sendRestart
             *  Send an xmpp:restart stanza.
             */
            _sendRestart: function ()
            {
                this._data.push("restart");

                this._proto._sendRestart();

                this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
            },

            /** Function: addTimedHandler
             *  Add a timed handler to the connection.
             *
             *  This function adds a timed handler.  The provided handler will
             *  be called every period milliseconds until it returns false,
             *  the connection is terminated, or the handler is removed.  Handlers
             *  that wish to continue being invoked should return true.
             *
             *  Because of method binding it is necessary to save the result of
             *  this function if you wish to remove a handler with
             *  deleteTimedHandler().
             *
             *  Note that user handlers are not active until authentication is
             *  successful.
             *
             *  Parameters:
             *    (Integer) period - The period of the handler.
             *    (Function) handler - The callback function.
             *
             *  Returns:
             *    A reference to the handler that can be used to remove it.
             */
            addTimedHandler: function (period, handler)
            {
                var thand = new Strophe.TimedHandler(period, handler);
                this.addTimeds.push(thand);
                return thand;
            },

            /** Function: deleteTimedHandler
             *  Delete a timed handler for a connection.
             *
             *  This function removes a timed handler from the connection.  The
             *  handRef parameter is *not* the function passed to addTimedHandler(),
             *  but is the reference returned from addTimedHandler().
             *
             *  Parameters:
             *    (Strophe.TimedHandler) handRef - The handler reference.
             */
            deleteTimedHandler: function (handRef)
            {
                // this must be done in the Idle loop so that we don't change
                // the handlers during iteration
                this.removeTimeds.push(handRef);
            },

            /** Function: addHandler
             *  Add a stanza handler for the connection.
             *
             *  This function adds a stanza handler to the connection.  The
             *  handler callback will be called for any stanza that matches
             *  the parameters.  Note that if multiple parameters are supplied,
             *  they must all match for the handler to be invoked.
             *
             *  The handler will receive the stanza that triggered it as its argument.
             *  *The handler should return true if it is to be invoked again;
             *  returning false will remove the handler after it returns.*
             *
             *  As a convenience, the ns parameters applies to the top level element
             *  and also any of its immediate children.  This is primarily to make
             *  matching /iq/query elements easy.
             *
             *  The options argument contains handler matching flags that affect how
             *  matches are determined. Currently the only flag is matchBare (a
             *  boolean). When matchBare is true, the from parameter and the from
             *  attribute on the stanza will be matched as bare JIDs instead of
             *  full JIDs. To use this, pass {matchBare: true} as the value of
             *  options. The default value for matchBare is false.
             *
             *  The return value should be saved if you wish to remove the handler
             *  with deleteHandler().
             *
             *  Parameters:
             *    (Function) handler - The user callback.
             *    (String) ns - The namespace to match.
             *    (String) name - The stanza name to match.
             *    (String) type - The stanza type attribute to match.
             *    (String) id - The stanza id attribute to match.
             *    (String) from - The stanza from attribute to match.
             *    (String) options - The handler options
             *
             *  Returns:
             *    A reference to the handler that can be used to remove it.
             */
            addHandler: function (handler, ns, name, type, id, from, options)
            {
                var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
                this.addHandlers.push(hand);
                return hand;
            },

            /** Function: deleteHandler
             *  Delete a stanza handler for a connection.
             *
             *  This function removes a stanza handler from the connection.  The
             *  handRef parameter is *not* the function passed to addHandler(),
             *  but is the reference returned from addHandler().
             *
             *  Parameters:
             *    (Strophe.Handler) handRef - The handler reference.
             */
            deleteHandler: function (handRef)
            {
                // this must be done in the Idle loop so that we don't change
                // the handlers during iteration
                this.removeHandlers.push(handRef);
                // If a handler is being deleted while it is being added,
                // prevent it from getting added
                var i = this.addHandlers.indexOf(handRef);
                if (i >= 0) {
                    this.addHandlers.splice(i, 1);
                }
            },

            /** Function: disconnect
             *  Start the graceful disconnection process.
             *
             *  This function starts the disconnection process.  This process starts
             *  by sending unavailable presence and sending BOSH body of type
             *  terminate.  A timeout handler makes sure that disconnection happens
             *  even if the BOSH server does not respond.
             *  If the Connection object isn't connected, at least tries to abort all pending requests
             *  so the connection object won't generate successful requests (which were already opened).
             *
             *  The user supplied connection callback will be notified of the
             *  progress as this process happens.
             *
             *  Parameters:
             *    (String) reason - The reason the disconnect is occuring.
             */
            disconnect: function (reason)
            {
                this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);

                Strophe.info("Disconnect was called because: " + reason);
                if (this.connected) {
                    var pres = false;
                    this.disconnecting = true;
                    if (this.authenticated) {
                        pres = $pres({
                            xmlns: Strophe.NS.CLIENT,
                            type: 'unavailable'
                        });
                    }
                    // setup timeout handler
                    this._disconnectTimeout = this._addSysTimedHandler(
                        3000, this._onDisconnectTimeout.bind(this));
                    this._proto._disconnect(pres);
                } else {
                    Strophe.info("Disconnect was called before Strophe connected to the server");
                    this._proto._abortAllRequests();
                }
            },

            /** PrivateFunction: _changeConnectStatus
             *  _Private_ helper function that makes sure plugins and the user's
             *  callback are notified of connection status changes.
             *
             *  Parameters:
             *    (Integer) status - the new connection status, one of the values
             *      in Strophe.Status
             *    (String) condition - the error condition or null
             */
            _changeConnectStatus: function (status, condition)
            {
                // notify all plugins listening for status changes
                for (var k in Strophe._connectionPlugins) {
                    if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                        var plugin = this[k];
                        if (plugin.statusChanged) {
                            try {
                                plugin.statusChanged(status, condition);
                            } catch (err) {
                                Strophe.error("" + k + " plugin caused an exception " +
                                    "changing status: " + err);
                            }
                        }
                    }
                }

                // notify the user's callback
                if (this.connect_callback) {
                    try {
                        this.connect_callback(status, condition);
                    } catch (e) {
                        Strophe.error("User connection callback caused an " +
                            "exception: " + e);
                    }
                }
            },

            /** PrivateFunction: _doDisconnect
             *  _Private_ function to disconnect.
             *
             *  This is the last piece of the disconnection logic.  This resets the
             *  connection and alerts the user's connection callback.
             */
            _doDisconnect: function (condition)
            {
                if (typeof this._idleTimeout == "number") {
                    clearTimeout(this._idleTimeout);
                }

                // Cancel Disconnect Timeout
                if (this._disconnectTimeout !== null) {
                    this.deleteTimedHandler(this._disconnectTimeout);
                    this._disconnectTimeout = null;
                }

                Strophe.info("_doDisconnect was called");
                this._proto._doDisconnect();

                this.authenticated = false;
                this.disconnecting = false;
                this.restored = false;

                // delete handlers
                this.handlers = [];
                this.timedHandlers = [];
                this.removeTimeds = [];
                this.removeHandlers = [];
                this.addTimeds = [];
                this.addHandlers = [];

                // tell the parent we disconnected
                this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);
                this.connected = false;
            },

            /** PrivateFunction: _dataRecv
             *  _Private_ handler to processes incoming data from the the connection.
             *
             *  Except for _connect_cb handling the initial connection request,
             *  this function handles the incoming data for all requests.  This
             *  function also fires stanza handlers that match each incoming
             *  stanza.
             *
             *  Parameters:
             *    (Strophe.Request) req - The request that has data ready.
             *    (string) req - The stanza a raw string (optiona).
             */
            _dataRecv: function (req, raw)
            {
                Strophe.info("_dataRecv called");
                var elem = this._proto._reqToData(req);
                if (elem === null) { return; }

                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                    if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
                        this.xmlInput(elem.childNodes[0]);
                    } else {
                        this.xmlInput(elem);
                    }
                }
                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                    if (raw) {
                        this.rawInput(raw);
                    } else {
                        this.rawInput(Strophe.serialize(elem));
                    }
                }

                // remove handlers scheduled for deletion
                var i, hand;
                while (this.removeHandlers.length > 0) {
                    hand = this.removeHandlers.pop();
                    i = this.handlers.indexOf(hand);
                    if (i >= 0) {
                        this.handlers.splice(i, 1);
                    }
                }

                // add handlers scheduled for addition
                while (this.addHandlers.length > 0) {
                    this.handlers.push(this.addHandlers.pop());
                }

                // handle graceful disconnect
                if (this.disconnecting && this._proto._emptyQueue()) {
                    this._doDisconnect();
                    return;
                }

                var type = elem.getAttribute("type");
                var cond, conflict;
                if (type !== null && type == "terminate") {
                    // Don't process stanzas that come in after disconnect
                    if (this.disconnecting) {
                        return;
                    }

                    // an error occurred
                    cond = elem.getAttribute("condition");
                    conflict = elem.getElementsByTagName("conflict");
                    if (cond !== null) {
                        if (cond == "remote-stream-error" && conflict.length > 0) {
                            cond = "conflict";
                        }
                        this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
                    } else {
                        this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
                    }
                    this._doDisconnect(cond);
                    return;
                }

                // send each incoming stanza through the handler chain
                var that = this;
                Strophe.forEachChild(elem, null, function (child) {
                    var i, newList;
                    // process handlers
                    newList = that.handlers;
                    that.handlers = [];
                    for (i = 0; i < newList.length; i++) {
                        var hand = newList[i];
                        // encapsulate 'handler.run' not to lose the whole handler list if
                        // one of the handlers throws an exception
                        try {
                            if (hand.isMatch(child) &&
                                (that.authenticated || !hand.user)) {
                                if (hand.run(child)) {
                                    that.handlers.push(hand);
                                }
                            } else {
                                that.handlers.push(hand);
                            }
                        } catch(e) {
                            // if the handler throws an exception, we consider it as false
                            Strophe.warn('Removing Strophe handlers due to uncaught exception: ' + e.message);
                        }
                    }
                });
            },


            /** Attribute: mechanisms
             *  SASL Mechanisms available for Conncection.
             */
            mechanisms: {},

            /** PrivateFunction: _connect_cb
             *  _Private_ handler for initial connection request.
             *
             *  This handler is used to process the initial connection request
             *  response from the BOSH server. It is used to set up authentication
             *  handlers and start the authentication process.
             *
             *  SASL authentication will be attempted if available, otherwise
             *  the code will fall back to legacy authentication.
             *
             *  Parameters:
             *    (Strophe.Request) req - The current request.
             *    (Function) _callback - low level (xmpp) connect callback function.
             *      Useful for plugins with their own xmpp connect callback (when their)
             *      want to do something special).
             */
            _connect_cb: function (req, _callback, raw)
            {
                Strophe.info("_connect_cb was called");

                this.connected = true;

                var bodyWrap;
                try {
                    bodyWrap = this._proto._reqToData(req);
                } catch (e) {
                    if (e != "badformat") { throw e; }
                    this._changeConnectStatus(Strophe.Status.CONNFAIL, 'bad-format');
                    this._doDisconnect('bad-format');
                }
                if (!bodyWrap) { return; }

                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                    if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
                        this.xmlInput(bodyWrap.childNodes[0]);
                    } else {
                        this.xmlInput(bodyWrap);
                    }
                }
                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                    if (raw) {
                        this.rawInput(raw);
                    } else {
                        this.rawInput(Strophe.serialize(bodyWrap));
                    }
                }

                var conncheck = this._proto._connect_cb(bodyWrap);
                if (conncheck === Strophe.Status.CONNFAIL) {
                    return;
                }

                this._authentication.sasl_scram_sha1 = false;
                this._authentication.sasl_plain = false;
                this._authentication.sasl_digest_md5 = false;
                this._authentication.sasl_anonymous = false;

                this._authentication.legacy_auth = false;

                // Check for the stream:features tag
                var hasFeatures;
                if (bodyWrap.getElementsByTagNameNS) {
                    hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "features").length > 0;
                } else {
                    hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 || bodyWrap.getElementsByTagName("features").length > 0;
                }
                var mechanisms = bodyWrap.getElementsByTagName("mechanism");
                var matched = [];
                var i, mech, found_authentication = false;
                if (!hasFeatures) {
                    this._proto._no_auth_received(_callback);
                    return;
                }
                if (mechanisms.length > 0) {
                    for (i = 0; i < mechanisms.length; i++) {
                        mech = Strophe.getText(mechanisms[i]);
                        if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);
                    }
                }
                this._authentication.legacy_auth =
                    bodyWrap.getElementsByTagName("auth").length > 0;
                found_authentication = this._authentication.legacy_auth ||
                    matched.length > 0;
                if (!found_authentication) {
                    this._proto._no_auth_received(_callback);
                    return;
                }
                if (this.do_authentication !== false)
                    this.authenticate(matched);
            },

            /** Function: authenticate
             * Set up authentication
             *
             *  Contiunues the initial connection request by setting up authentication
             *  handlers and start the authentication process.
             *
             *  SASL authentication will be attempted if available, otherwise
             *  the code will fall back to legacy authentication.
             *
             */
            authenticate: function (matched)
            {
                var i;
                // Sorting matched mechanisms according to priority.
                for (i = 0; i < matched.length - 1; ++i) {
                    var higher = i;
                    for (var j = i + 1; j < matched.length; ++j) {
                        if (matched[j].prototype.priority > matched[higher].prototype.priority) {
                            higher = j;
                        }
                    }
                    if (higher != i) {
                        var swap = matched[i];
                        matched[i] = matched[higher];
                        matched[higher] = swap;
                    }
                }

                // run each mechanism
                var mechanism_found = false;
                for (i = 0; i < matched.length; ++i) {
                    if (!matched[i].test(this)) continue;

                    this._sasl_success_handler = this._addSysHandler(
                        this._sasl_success_cb.bind(this), null,
                        "success", null, null);
                    this._sasl_failure_handler = this._addSysHandler(
                        this._sasl_failure_cb.bind(this), null,
                        "failure", null, null);
                    this._sasl_challenge_handler = this._addSysHandler(
                        this._sasl_challenge_cb.bind(this), null,
                        "challenge", null, null);

                    this._sasl_mechanism = new matched[i]();
                    this._sasl_mechanism.onStart(this);

                    var request_auth_exchange = $build("auth", {
                        xmlns: Strophe.NS.SASL,
                        mechanism: this._sasl_mechanism.name
                    });

                    if (this._sasl_mechanism.isClientFirst) {
                        var response = this._sasl_mechanism.onChallenge(this, null);
                        request_auth_exchange.t(Base64.encode(response));
                    }

                    this.send(request_auth_exchange.tree());

                    mechanism_found = true;
                    break;
                }

                if (!mechanism_found) {
                    // if none of the mechanism worked
                    if (Strophe.getNodeFromJid(this.jid) === null) {
                        // we don't have a node, which is required for non-anonymous
                        // client connections
                        this._changeConnectStatus(Strophe.Status.CONNFAIL,
                            'x-strophe-bad-non-anon-jid');
                        this.disconnect('x-strophe-bad-non-anon-jid');
                    } else {
                        // fall back to legacy authentication
                        this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
                        this._addSysHandler(this._auth1_cb.bind(this), null, null,
                            null, "_auth_1");

                        this.send($iq({
                            type: "get",
                            to: this.domain,
                            id: "_auth_1"
                        }).c("query", {
                            xmlns: Strophe.NS.AUTH
                        }).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).tree());
                    }
                }

            },

            _sasl_challenge_cb: function(elem) {
                var challenge = Base64.decode(Strophe.getText(elem));
                var response = this._sasl_mechanism.onChallenge(this, challenge);

                var stanza = $build('response', {
                    xmlns: Strophe.NS.SASL
                });
                if (response !== "") {
                    stanza.t(Base64.encode(response));
                }
                this.send(stanza.tree());
                return true;
            },

            /** PrivateFunction: _auth1_cb
             *  _Private_ handler for legacy authentication.
             *
             *  This handler is called in response to the initial <iq type='get'/>
             *  for legacy authentication.  It builds an authentication <iq/> and
             *  sends it, creating a handler (calling back to _auth2_cb()) to
             *  handle the result
             *
             *  Parameters:
             *    (XMLElement) elem - The stanza that triggered the callback.
             *
             *  Returns:
             *    false to remove the handler.
             */
            /* jshint unused:false */
            _auth1_cb: function (elem)
            {
                // build plaintext auth iq
                var iq = $iq({type: "set", id: "_auth_2"})
                    .c('query', {xmlns: Strophe.NS.AUTH})
                    .c('username', {}).t(Strophe.getNodeFromJid(this.jid))
                    .up()
                    .c('password').t(this.pass);

                if (!Strophe.getResourceFromJid(this.jid)) {
                    // since the user has not supplied a resource, we pick
                    // a default one here.  unlike other auth methods, the server
                    // cannot do this for us.
                    this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';
                }
                iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));

                this._addSysHandler(this._auth2_cb.bind(this), null,
                    null, null, "_auth_2");

                this.send(iq.tree());

                return false;
            },
            /* jshint unused:true */

            /** PrivateFunction: _sasl_success_cb
             *  _Private_ handler for succesful SASL authentication.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_success_cb: function (elem)
            {
                if (this._sasl_data["server-signature"]) {
                    var serverSignature;
                    var success = Base64.decode(Strophe.getText(elem));
                    var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
                    var matches = success.match(attribMatch);
                    if (matches[1] == "v") {
                        serverSignature = matches[2];
                    }

                    if (serverSignature != this._sasl_data["server-signature"]) {
                        // remove old handlers
                        this.deleteHandler(this._sasl_failure_handler);
                        this._sasl_failure_handler = null;
                        if (this._sasl_challenge_handler) {
                            this.deleteHandler(this._sasl_challenge_handler);
                            this._sasl_challenge_handler = null;
                        }

                        this._sasl_data = {};
                        return this._sasl_failure_cb(null);
                    }
                }

                Strophe.info("SASL authentication succeeded.");

                if(this._sasl_mechanism)
                    this._sasl_mechanism.onSuccess();

                // remove old handlers
                this.deleteHandler(this._sasl_failure_handler);
                this._sasl_failure_handler = null;
                if (this._sasl_challenge_handler) {
                    this.deleteHandler(this._sasl_challenge_handler);
                    this._sasl_challenge_handler = null;
                }

                var streamfeature_handlers = [];
                var wrapper = function(handlers, elem) {
                    while (handlers.length) {
                        this.deleteHandler(handlers.pop());
                    }
                    this._sasl_auth1_cb.bind(this)(elem);
                    return false;
                };
                streamfeature_handlers.push(this._addSysHandler(function(elem) {
                    wrapper.bind(this)(streamfeature_handlers, elem);
                }.bind(this), null, "stream:features", null, null));
                streamfeature_handlers.push(this._addSysHandler(function(elem) {
                    wrapper.bind(this)(streamfeature_handlers, elem);
                }.bind(this), Strophe.NS.STREAM, "features", null, null));

                // we must send an xmpp:restart now
                this._sendRestart();

                return false;
            },

            /** PrivateFunction: _sasl_auth1_cb
             *  _Private_ handler to start stream binding.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_auth1_cb: function (elem)
            {
                // save stream:features for future usage
                this.features = elem;

                var i, child;

                for (i = 0; i < elem.childNodes.length; i++) {
                    child = elem.childNodes[i];
                    if (child.nodeName == 'bind') {
                        this.do_bind = true;
                    }

                    if (child.nodeName == 'session') {
                        this.do_session = true;
                    }
                }

                if (!this.do_bind) {
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    return false;
                } else {
                    this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,
                        null, "_bind_auth_2");

                    var resource = Strophe.getResourceFromJid(this.jid);
                    if (resource) {
                        this.send($iq({type: "set", id: "_bind_auth_2"})
                            .c('bind', {xmlns: Strophe.NS.BIND})
                            .c('resource', {}).t(resource).tree());
                    } else {
                        this.send($iq({type: "set", id: "_bind_auth_2"})
                            .c('bind', {xmlns: Strophe.NS.BIND})
                            .tree());
                    }
                }

                return false;
            },

            /** PrivateFunction: _sasl_bind_cb
             *  _Private_ handler for binding result and session start.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_bind_cb: function (elem)
            {
                if (elem.getAttribute("type") == "error") {
                    Strophe.info("SASL binding failed.");
                    var conflict = elem.getElementsByTagName("conflict"), condition;
                    if (conflict.length > 0) {
                        condition = 'conflict';
                    }
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
                    return false;
                }

                // TODO - need to grab errors
                var bind = elem.getElementsByTagName("bind");
                var jidNode;
                if (bind.length > 0) {
                    // Grab jid
                    jidNode = bind[0].getElementsByTagName("jid");
                    if (jidNode.length > 0) {
                        this.jid = Strophe.getText(jidNode[0]);

                        if (this.do_session) {
                            this._addSysHandler(this._sasl_session_cb.bind(this),
                                null, null, null, "_session_auth_2");

                            this.send($iq({type: "set", id: "_session_auth_2"})
                                .c('session', {xmlns: Strophe.NS.SESSION})
                                .tree());
                        } else {
                            this.authenticated = true;
                            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                        }
                    }
                } else {
                    Strophe.info("SASL binding failed.");
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    return false;
                }
            },

            /** PrivateFunction: _sasl_session_cb
             *  _Private_ handler to finish successful SASL connection.
             *
             *  This sets Connection.authenticated to true on success, which
             *  starts the processing of user handlers.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _sasl_session_cb: function (elem)
            {
                if (elem.getAttribute("type") == "result") {
                    this.authenticated = true;
                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                } else if (elem.getAttribute("type") == "error") {
                    Strophe.info("Session creation failed.");
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    return false;
                }

                return false;
            },

            /** PrivateFunction: _sasl_failure_cb
             *  _Private_ handler for SASL authentication failure.
             *
             *  Parameters:
             *    (XMLElement) elem - The matching stanza.
             *
             *  Returns:
             *    false to remove the handler.
             */
            /* jshint unused:false */
            _sasl_failure_cb: function (elem)
            {
                // delete unneeded handlers
                if (this._sasl_success_handler) {
                    this.deleteHandler(this._sasl_success_handler);
                    this._sasl_success_handler = null;
                }
                if (this._sasl_challenge_handler) {
                    this.deleteHandler(this._sasl_challenge_handler);
                    this._sasl_challenge_handler = null;
                }

                if(this._sasl_mechanism)
                    this._sasl_mechanism.onFailure();
                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                return false;
            },
            /* jshint unused:true */

            /** PrivateFunction: _auth2_cb
             *  _Private_ handler to finish legacy authentication.
             *
             *  This handler is called when the result from the jabber:iq:auth
             *  <iq/> stanza is returned.
             *
             *  Parameters:
             *    (XMLElement) elem - The stanza that triggered the callback.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _auth2_cb: function (elem)
            {
                if (elem.getAttribute("type") == "result") {
                    this.authenticated = true;
                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                } else if (elem.getAttribute("type") == "error") {
                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
                    this.disconnect('authentication failed');
                }

                return false;
            },

            /** PrivateFunction: _addSysTimedHandler
             *  _Private_ function to add a system level timed handler.
             *
             *  This function is used to add a Strophe.TimedHandler for the
             *  library code.  System timed handlers are allowed to run before
             *  authentication is complete.
             *
             *  Parameters:
             *    (Integer) period - The period of the handler.
             *    (Function) handler - The callback function.
             */
            _addSysTimedHandler: function (period, handler)
            {
                var thand = new Strophe.TimedHandler(period, handler);
                thand.user = false;
                this.addTimeds.push(thand);
                return thand;
            },

            /** PrivateFunction: _addSysHandler
             *  _Private_ function to add a system level stanza handler.
             *
             *  This function is used to add a Strophe.Handler for the
             *  library code.  System stanza handlers are allowed to run before
             *  authentication is complete.
             *
             *  Parameters:
             *    (Function) handler - The callback function.
             *    (String) ns - The namespace to match.
             *    (String) name - The stanza name to match.
             *    (String) type - The stanza type attribute to match.
             *    (String) id - The stanza id attribute to match.
             */
            _addSysHandler: function (handler, ns, name, type, id)
            {
                var hand = new Strophe.Handler(handler, ns, name, type, id);
                hand.user = false;
                this.addHandlers.push(hand);
                return hand;
            },

            /** PrivateFunction: _onDisconnectTimeout
             *  _Private_ timeout handler for handling non-graceful disconnection.
             *
             *  If the graceful disconnect process does not complete within the
             *  time allotted, this handler finishes the disconnect anyway.
             *
             *  Returns:
             *    false to remove the handler.
             */
            _onDisconnectTimeout: function ()
            {
                Strophe.info("_onDisconnectTimeout was called");

                this._proto._onDisconnectTimeout();

                // actually disconnect
                this._doDisconnect();

                return false;
            },

            /** PrivateFunction: _onIdle
             *  _Private_ handler to process events during idle cycle.
             *
             *  This handler is called every 100ms to fire timed handlers that
             *  are ready and keep poll requests going.
             */
            _onIdle: function ()
            {
                var i, thand, since, newList;

                // add timed handlers scheduled for addition
                // NOTE: we add before remove in the case a timed handler is
                // added and then deleted before the next _onIdle() call.
                while (this.addTimeds.length > 0) {
                    this.timedHandlers.push(this.addTimeds.pop());
                }

                // remove timed handlers that have been scheduled for deletion
                while (this.removeTimeds.length > 0) {
                    thand = this.removeTimeds.pop();
                    i = this.timedHandlers.indexOf(thand);
                    if (i >= 0) {
                        this.timedHandlers.splice(i, 1);
                    }
                }

                // call ready timed handlers
                var now = new Date().getTime();
                newList = [];
                for (i = 0; i < this.timedHandlers.length; i++) {
                    thand = this.timedHandlers[i];
                    if (this.authenticated || !thand.user) {
                        since = thand.lastCalled + thand.period;
                        if (since - now <= 0) {
                            if (thand.run()) {
                                newList.push(thand);
                            }
                        } else {
                            newList.push(thand);
                        }
                    }
                }
                this.timedHandlers = newList;

                clearTimeout(this._idleTimeout);

                this._proto._onIdle();

                // reactivate the timer only if connected
                if (this.connected) {
                    this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
                }
            }
        };

        /** Class: Strophe.SASLMechanism
         *
         *  encapsulates SASL authentication mechanisms.
         *
         *  User code may override the priority for each mechanism or disable it completely.
         *  See <priority> for information about changing priority and <test> for informatian on
         *  how to disable a mechanism.
         *
         *  By default, all mechanisms are enabled and the priorities are
         *
         *  SCRAM-SHA1 - 40
         *  DIGEST-MD5 - 30
         *  Plain - 20
         */

        /**
         * PrivateConstructor: Strophe.SASLMechanism
         * SASL auth mechanism abstraction.
         *
         *  Parameters:
         *    (String) name - SASL Mechanism name.
         *    (Boolean) isClientFirst - If client should send response first without challenge.
         *    (Number) priority - Priority.
         *
         *  Returns:
         *    A new Strophe.SASLMechanism object.
         */
        Strophe.SASLMechanism = function(name, isClientFirst, priority) {
            /** PrivateVariable: name
             *  Mechanism name.
             */
            this.name = name;
            /** PrivateVariable: isClientFirst
             *  If client sends response without initial server challenge.
             */
            this.isClientFirst = isClientFirst;
            /** Variable: priority
             *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).
             *  Users may override this to prioritize mechanisms differently.
             *
             *  In the default configuration the priorities are
             *
             *  SCRAM-SHA1 - 40
             *  DIGEST-MD5 - 30
             *  Plain - 20
             *
             *  Example: (This will cause Strophe to choose the mechanism that the server sent first)
             *
             *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;
             *
             *  See <SASL mechanisms> for a list of available mechanisms.
             *
             */
            this.priority = priority;
        };

        Strophe.SASLMechanism.prototype = {
            /**
             *  Function: test
             *  Checks if mechanism able to run.
             *  To disable a mechanism, make this return false;
             *
             *  To disable plain authentication run
             *  > Strophe.SASLPlain.test = function() {
   *  >   return false;
   *  > }
             *
             *  See <SASL mechanisms> for a list of available mechanisms.
             *
             *  Parameters:
             *    (Strophe.Connection) connection - Target Connection.
             *
             *  Returns:
             *    (Boolean) If mechanism was able to run.
             */
            /* jshint unused:false */
            test: function(connection) {
                return true;
            },
            /* jshint unused:true */

            /** PrivateFunction: onStart
             *  Called before starting mechanism on some connection.
             *
             *  Parameters:
             *    (Strophe.Connection) connection - Target Connection.
             */
            onStart: function(connection)
            {
                this._connection = connection;
            },

            /** PrivateFunction: onChallenge
             *  Called by protocol implementation on incoming challenge. If client is
             *  first (isClientFirst == true) challenge will be null on the first call.
             *
             *  Parameters:
             *    (Strophe.Connection) connection - Target Connection.
             *    (String) challenge - current challenge to handle.
             *
             *  Returns:
             *    (String) Mechanism response.
             */
            /* jshint unused:false */
            onChallenge: function(connection, challenge) {
                throw new Error("You should implement challenge handling!");
            },
            /* jshint unused:true */

            /** PrivateFunction: onFailure
             *  Protocol informs mechanism implementation about SASL failure.
             */
            onFailure: function() {
                this._connection = null;
            },

            /** PrivateFunction: onSuccess
             *  Protocol informs mechanism implementation about SASL success.
             */
            onSuccess: function() {
                this._connection = null;
            }
        };

        /** Constants: SASL mechanisms
         *  Available authentication mechanisms
         *
         *  Strophe.SASLAnonymous - SASL Anonymous authentication.
         *  Strophe.SASLPlain - SASL Plain authentication.
         *  Strophe.SASLMD5 - SASL Digest-MD5 authentication
         *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication
         */

// Building SASL callbacks

        /** PrivateConstructor: SASLAnonymous
         *  SASL Anonymous authentication.
         */
        Strophe.SASLAnonymous = function() {};

        Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism("ANONYMOUS", false, 10);

        Strophe.SASLAnonymous.test = function(connection) {
            return connection.authcid === null;
        };

        Strophe.Connection.prototype.mechanisms[Strophe.SASLAnonymous.prototype.name] = Strophe.SASLAnonymous;

        /** PrivateConstructor: SASLPlain
         *  SASL Plain authentication.
         */
        Strophe.SASLPlain = function() {};

        Strophe.SASLPlain.prototype = new Strophe.SASLMechanism("PLAIN", true, 20);

        Strophe.SASLPlain.test = function(connection) {
            return connection.authcid !== null;
        };

        Strophe.SASLPlain.prototype.onChallenge = function(connection) {
            var auth_str = connection.authzid;
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + connection.authcid;
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + connection.pass;
            return utils.utf16to8(auth_str);
        };

        Strophe.Connection.prototype.mechanisms[Strophe.SASLPlain.prototype.name] = Strophe.SASLPlain;

        /** PrivateConstructor: SASLSHA1
         *  SASL SCRAM SHA 1 authentication.
         */
        Strophe.SASLSHA1 = function() {};

        Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism("SCRAM-SHA-1", true, 40);

        Strophe.SASLSHA1.test = function(connection) {
            return connection.authcid !== null;
        };

        Strophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {
            var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);
            var auth_str = "n=" + utils.utf16to8(connection.authcid);
            auth_str += ",r=";
            auth_str += cnonce;

            connection._sasl_data.cnonce = cnonce;
            connection._sasl_data["client-first-message-bare"] = auth_str;

            auth_str = "n,," + auth_str;

            this.onChallenge = function (connection, challenge) {
                var nonce, salt, iter, Hi, U, U_old, i, k, pass;
                var clientKey, serverKey, clientSignature;
                var responseText = "c=biws,";
                var authMessage = connection._sasl_data["client-first-message-bare"] + "," +
                    challenge + ",";
                var cnonce = connection._sasl_data.cnonce;
                var attribMatch = /([a-z]+)=([^,]+)(,|$)/;

                while (challenge.match(attribMatch)) {
                    var matches = challenge.match(attribMatch);
                    challenge = challenge.replace(matches[0], "");
                    switch (matches[1]) {
                        case "r":
                            nonce = matches[2];
                            break;
                        case "s":
                            salt = matches[2];
                            break;
                        case "i":
                            iter = matches[2];
                            break;
                    }
                }

                if (nonce.substr(0, cnonce.length) !== cnonce) {
                    connection._sasl_data = {};
                    return connection._sasl_failure_cb();
                }

                responseText += "r=" + nonce;
                authMessage += responseText;

                salt = Base64.decode(salt);
                salt += "\x00\x00\x00\x01";

                pass = utils.utf16to8(connection.pass);
                Hi = U_old = SHA1.core_hmac_sha1(pass, salt);
                for (i = 1; i < iter; i++) {
                    U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));
                    for (k = 0; k < 5; k++) {
                        Hi[k] ^= U[k];
                    }
                    U_old = U;
                }
                Hi = SHA1.binb2str(Hi);

                clientKey = SHA1.core_hmac_sha1(Hi, "Client Key");
                serverKey = SHA1.str_hmac_sha1(Hi, "Server Key");
                clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);
                connection._sasl_data["server-signature"] = SHA1.b64_hmac_sha1(serverKey, authMessage);

                for (k = 0; k < 5; k++) {
                    clientKey[k] ^= clientSignature[k];
                }

                responseText += ",p=" + Base64.encode(SHA1.binb2str(clientKey));
                return responseText;
            }.bind(this);

            return auth_str;
        };

        Strophe.Connection.prototype.mechanisms[Strophe.SASLSHA1.prototype.name] = Strophe.SASLSHA1;

        /** PrivateConstructor: SASLMD5
         *  SASL DIGEST MD5 authentication.
         */
        Strophe.SASLMD5 = function() {};

        Strophe.SASLMD5.prototype = new Strophe.SASLMechanism("DIGEST-MD5", false, 30);

        Strophe.SASLMD5.test = function(connection) {
            return connection.authcid !== null;
        };

        /** PrivateFunction: _quote
         *  _Private_ utility function to backslash escape and quote strings.
         *
         *  Parameters:
         *    (String) str - The string to be quoted.
         *
         *  Returns:
         *    quoted string
         */
        Strophe.SASLMD5.prototype._quote = function (str)
        {
            return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
            //" end string workaround for emacs
        };


        Strophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {
            var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;
            var cnonce = test_cnonce || MD5.hexdigest("" + (Math.random() * 1234567890));
            var realm = "";
            var host = null;
            var nonce = "";
            var qop = "";
            var matches;

            while (challenge.match(attribMatch)) {
                matches = challenge.match(attribMatch);
                challenge = challenge.replace(matches[0], "");
                matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
                switch (matches[1]) {
                    case "realm":
                        realm = matches[2];
                        break;
                    case "nonce":
                        nonce = matches[2];
                        break;
                    case "qop":
                        qop = matches[2];
                        break;
                    case "host":
                        host = matches[2];
                        break;
                }
            }

            var digest_uri = connection.servtype + "/" + connection.domain;
            if (host !== null) {
                digest_uri = digest_uri + "/" + host;
            }

            var cred = utils.utf16to8(connection.authcid + ":" + realm + ":" + this._connection.pass);
            var A1 = MD5.hash(cred) + ":" + nonce + ":" + cnonce;
            var A2 = 'AUTHENTICATE:' + digest_uri;

            var responseText = "";
            responseText += 'charset=utf-8,';
            responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';
            responseText += 'realm=' + this._quote(realm) + ',';
            responseText += 'nonce=' + this._quote(nonce) + ',';
            responseText += 'nc=00000001,';
            responseText += 'cnonce=' + this._quote(cnonce) + ',';
            responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
            responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + ":" +
                    nonce + ":00000001:" +
                    cnonce + ":auth:" +
                    MD5.hexdigest(A2)) + ",";
            responseText += 'qop=auth';

            this.onChallenge = function () {
                return "";
            }.bind(this);

            return responseText;
        };

        Strophe.Connection.prototype.mechanisms[Strophe.SASLMD5.prototype.name] = Strophe.SASLMD5;

        return {
            Strophe:        Strophe,
            $build:         $build,
            $msg:           $msg,
            $iq:            $iq,
            $pres:          $pres,
            SHA1:           SHA1,
            Base64:         Base64,
            MD5:            MD5,
        };
    }));

    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /* global define, window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject, Strophe, $build */

    (function (root, factory) {
        if (typeof define === 'function' && define.amd) {
            define('strophe-bosh', ['strophe-core'], function (core) {
                return factory(
                    core.Strophe,
                    core.$build
                );
            });
        } else {
            // Browser globals
            return factory(Strophe, $build);
        }
    }(this, function (Strophe, $build) {

        /** PrivateClass: Strophe.Request
         *  _Private_ helper class that provides a cross implementation abstraction
         *  for a BOSH related XMLHttpRequest.
         *
         *  The Strophe.Request class is used internally to encapsulate BOSH request
         *  information.  It is not meant to be used from user's code.
         */

        /** PrivateConstructor: Strophe.Request
         *  Create and initialize a new Strophe.Request object.
         *
         *  Parameters:
         *    (XMLElement) elem - The XML data to be sent in the request.
         *    (Function) func - The function that will be called when the
         *      XMLHttpRequest readyState changes.
         *    (Integer) rid - The BOSH rid attribute associated with this request.
         *    (Integer) sends - The number of times this same request has been
         *      sent.
         */
        Strophe.Request = function (elem, func, rid, sends)
        {
            this.id = ++Strophe._requestId;
            this.xmlData = elem;
            this.data = Strophe.serialize(elem);
            // save original function in case we need to make a new request
            // from this one.
            this.origFunc = func;
            this.func = func;
            this.rid = rid;
            this.date = NaN;
            this.sends = sends || 0;
            this.abort = false;
            this.dead = null;

            this.age = function () {
                if (!this.date) { return 0; }
                var now = new Date();
                return (now - this.date) / 1000;
            };
            this.timeDead = function () {
                if (!this.dead) { return 0; }
                var now = new Date();
                return (now - this.dead) / 1000;
            };
            this.xhr = this._newXHR();
        };

        Strophe.Request.prototype = {
            /** PrivateFunction: getResponse
             *  Get a response from the underlying XMLHttpRequest.
             *
             *  This function attempts to get a response from the request and checks
             *  for errors.
             *
             *  Throws:
             *    "parsererror" - A parser error occured.
             *    "badformat" - The entity has sent XML that cannot be processed.
             *
             *  Returns:
             *    The DOM element tree of the response.
             */
            getResponse: function ()
            {
                var node = null;
                if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                    node = this.xhr.responseXML.documentElement;
                    if (node.tagName == "parsererror") {
                        Strophe.error("invalid response received");
                        Strophe.error("responseText: " + this.xhr.responseText);
                        Strophe.error("responseXML: " +
                            Strophe.serialize(this.xhr.responseXML));
                        throw "parsererror";
                    }
                } else if (this.xhr.responseText) {
                    Strophe.error("invalid response received");
                    Strophe.error("responseText: " + this.xhr.responseText);
                    throw "badformat";
                }

                return node;
            },

            /** PrivateFunction: _newXHR
             *  _Private_ helper function to create XMLHttpRequests.
             *
             *  This function creates XMLHttpRequests across all implementations.
             *
             *  Returns:
             *    A new XMLHttpRequest.
             */
            _newXHR: function ()
            {
                var xhr = null;
                if (window.XMLHttpRequest) {
                    xhr = new XMLHttpRequest();
                    if (xhr.overrideMimeType) {
                        xhr.overrideMimeType("text/xml; charset=utf-8");
                    }
                } else if (window.ActiveXObject) {
                    xhr = new ActiveXObject("Microsoft.XMLHTTP");
                }

                // use Function.bind() to prepend ourselves as an argument
                xhr.onreadystatechange = this.func.bind(null, this);

                return xhr;
            }
        };

        /** Class: Strophe.Bosh
         *  _Private_ helper class that handles BOSH Connections
         *
         *  The Strophe.Bosh class is used internally by Strophe.Connection
         *  to encapsulate BOSH sessions. It is not meant to be used from user's code.
         */

        /** File: bosh.js
         *  A JavaScript library to enable BOSH in Strophejs.
         *
         *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)
         *  to emulate a persistent, stateful, two-way connection to an XMPP server.
         *  More information on BOSH can be found in XEP 124.
         */

        /** PrivateConstructor: Strophe.Bosh
         *  Create and initialize a Strophe.Bosh object.
         *
         *  Parameters:
         *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.
         *
         *  Returns:
         *    A new Strophe.Bosh object.
         */
        Strophe.Bosh = function(connection) {
            this._conn = connection;
            /* request id for body tags */
            this.rid = Math.floor(Math.random() * 4294967295);
            /* The current session ID. */
            this.sid = null;

            // default BOSH values
            this.hold = 1;
            this.wait = 60;
            this.window = 5;
            this.errors = 0;

            this._requests = [];
        };

        Strophe.Bosh.prototype = {
            /** Variable: strip
             *
             *  BOSH-Connections will have all stanzas wrapped in a <body> tag when
             *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.
             *  To strip this tag, User code can set <Strophe.Bosh.strip> to "body":
             *
             *  > Strophe.Bosh.prototype.strip = "body";
             *
             *  This will enable stripping of the body tag in both
             *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.
             */
            strip: null,

            /** PrivateFunction: _buildBody
             *  _Private_ helper function to generate the <body/> wrapper for BOSH.
             *
             *  Returns:
             *    A Strophe.Builder with a <body/> element.
             */
            _buildBody: function ()
            {
                var bodyWrap = $build('body', {
                    rid: this.rid++,
                    xmlns: Strophe.NS.HTTPBIND
                });
                if (this.sid !== null) {
                    bodyWrap.attrs({sid: this.sid});
                }
                if (this._conn.options.keepalive) {
                    this._cacheSession();
                }
                return bodyWrap;
            },

            /** PrivateFunction: _reset
             *  Reset the connection.
             *
             *  This function is called by the reset function of the Strophe Connection
             */
            _reset: function ()
            {
                this.rid = Math.floor(Math.random() * 4294967295);
                this.sid = null;
                this.errors = 0;
                window.sessionStorage.removeItem('strophe-bosh-session');

                this._conn.nextValidRid(this.rid);
            },

            /** PrivateFunction: _connect
             *  _Private_ function that initializes the BOSH connection.
             *
             *  Creates and sends the Request that initializes the BOSH connection.
             */
            _connect: function (wait, hold, route)
            {
                this.wait = wait || this.wait;
                this.hold = hold || this.hold;
                this.errors = 0;

                // build the body tag
                var body = this._buildBody().attrs({
                    to: this._conn.domain,
                    "xml:lang": "en",
                    wait: this.wait,
                    hold: this.hold,
                    content: "text/xml; charset=utf-8",
                    ver: "1.6",
                    "xmpp:version": "1.0",
                    "xmlns:xmpp": Strophe.NS.BOSH
                });

                if(route){
                    body.attrs({
                        route: route
                    });
                }

                var _connect_cb = this._conn._connect_cb;

                this._requests.push(
                    new Strophe.Request(body.tree(),
                        this._onRequestStateChange.bind(
                            this, _connect_cb.bind(this._conn)),
                        body.tree().getAttribute("rid")));
                this._throttledRequestHandler();
            },

            /** PrivateFunction: _attach
             *  Attach to an already created and authenticated BOSH session.
             *
             *  This function is provided to allow Strophe to attach to BOSH
             *  sessions which have been created externally, perhaps by a Web
             *  application.  This is often used to support auto-login type features
             *  without putting user credentials into the page.
             *
             *  Parameters:
             *    (String) jid - The full JID that is bound by the session.
             *    (String) sid - The SID of the BOSH session.
             *    (String) rid - The current RID of the BOSH session.  This RID
             *      will be used by the next request.
             *    (Function) callback The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *      Other settings will require tweaks to the Strophe.TIMEOUT value.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            _attach: function (jid, sid, rid, callback, wait, hold, wind)
            {
                this._conn.jid = jid;
                this.sid = sid;
                this.rid = rid;

                this._conn.connect_callback = callback;

                this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);

                this._conn.authenticated = true;
                this._conn.connected = true;

                this.wait = wait || this.wait;
                this.hold = hold || this.hold;
                this.window = wind || this.window;

                this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);
            },

            /** PrivateFunction: _restore
             *  Attempt to restore a cached BOSH session
             *
             *  Parameters:
             *    (String) jid - The full JID that is bound by the session.
             *      This parameter is optional but recommended, specifically in cases
             *      where prebinded BOSH sessions are used where it's important to know
             *      that the right session is being restored.
             *    (Function) callback The connect callback function.
             *    (Integer) wait - The optional HTTPBIND wait value.  This is the
             *      time the server will wait before returning an empty result for
             *      a request.  The default setting of 60 seconds is recommended.
             *      Other settings will require tweaks to the Strophe.TIMEOUT value.
             *    (Integer) hold - The optional HTTPBIND hold value.  This is the
             *      number of connections the server will hold at one time.  This
             *      should almost always be set to 1 (the default).
             *    (Integer) wind - The optional HTTBIND window value.  This is the
             *      allowed range of request ids that are valid.  The default is 5.
             */
            _restore: function (jid, callback, wait, hold, wind)
            {
                var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));
                if (typeof session !== "undefined" &&
                    session !== null &&
                    session.rid &&
                    session.sid &&
                    session.jid &&
                    (typeof jid === "undefined" || jid === "null" || Strophe.getBareJidFromJid(session.jid) == Strophe.getBareJidFromJid(jid)))
                {
                    this._conn.restored = true;
                    this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
                } else {
                    throw { name: "StropheSessionError", message: "_restore: no restoreable session." };
                }
            },

            /** PrivateFunction: _cacheSession
             *  _Private_ handler for the beforeunload event.
             *
             *  This handler is used to process the Bosh-part of the initial request.
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             */
            _cacheSession: function ()
            {
                if (this._conn.authenticated) {
                    if (this._conn.jid && this.rid && this.sid) {
                        window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({
                            'jid': this._conn.jid,
                            'rid': this.rid,
                            'sid': this.sid
                        }));
                    }
                } else {
                    window.sessionStorage.removeItem('strophe-bosh-session');
                }
            },

            /** PrivateFunction: _connect_cb
             *  _Private_ handler for initial connection request.
             *
             *  This handler is used to process the Bosh-part of the initial request.
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             */
            _connect_cb: function (bodyWrap)
            {
                var typ = bodyWrap.getAttribute("type");
                var cond, conflict;
                if (typ !== null && typ == "terminate") {
                    // an error occurred
                    cond = bodyWrap.getAttribute("condition");
                    Strophe.error("BOSH-Connection failed: " + cond);
                    conflict = bodyWrap.getElementsByTagName("conflict");
                    if (cond !== null) {
                        if (cond == "remote-stream-error" && conflict.length > 0) {
                            cond = "conflict";
                        }
                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
                    } else {
                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
                    }
                    this._conn._doDisconnect(cond);
                    return Strophe.Status.CONNFAIL;
                }

                // check to make sure we don't overwrite these if _connect_cb is
                // called multiple times in the case of missing stream:features
                if (!this.sid) {
                    this.sid = bodyWrap.getAttribute("sid");
                }
                var wind = bodyWrap.getAttribute('requests');
                if (wind) { this.window = parseInt(wind, 10); }
                var hold = bodyWrap.getAttribute('hold');
                if (hold) { this.hold = parseInt(hold, 10); }
                var wait = bodyWrap.getAttribute('wait');
                if (wait) { this.wait = parseInt(wait, 10); }
            },

            /** PrivateFunction: _disconnect
             *  _Private_ part of Connection.disconnect for Bosh
             *
             *  Parameters:
             *    (Request) pres - This stanza will be sent before disconnecting.
             */
            _disconnect: function (pres)
            {
                this._sendTerminate(pres);
            },

            /** PrivateFunction: _doDisconnect
             *  _Private_ function to disconnect.
             *
             *  Resets the SID and RID.
             */
            _doDisconnect: function ()
            {
                this.sid = null;
                this.rid = Math.floor(Math.random() * 4294967295);
                window.sessionStorage.removeItem('strophe-bosh-session');

                this._conn.nextValidRid(this.rid);
            },

            /** PrivateFunction: _emptyQueue
             * _Private_ function to check if the Request queue is empty.
             *
             *  Returns:
             *    True, if there are no Requests queued, False otherwise.
             */
            _emptyQueue: function ()
            {
                return this._requests.length === 0;
            },

            /** PrivateFunction: _hitError
             *  _Private_ function to handle the error count.
             *
             *  Requests are resent automatically until their error count reaches
             *  5.  Each time an error is encountered, this function is called to
             *  increment the count and disconnect if the count is too high.
             *
             *  Parameters:
             *    (Integer) reqStatus - The request status.
             */
            _hitError: function (reqStatus)
            {
                this.errors++;
                Strophe.warn("request errored, status: " + reqStatus +
                    ", number of errors: " + this.errors);
                if (this.errors > 4) {
                    this._conn._onDisconnectTimeout();
                }
            },

            /** PrivateFunction: _no_auth_received
             *
             * Called on stream start/restart when no stream:features
             * has been received and sends a blank poll request.
             */
            _no_auth_received: function (_callback)
            {
                if (_callback) {
                    _callback = _callback.bind(this._conn);
                } else {
                    _callback = this._conn._connect_cb.bind(this._conn);
                }
                var body = this._buildBody();
                this._requests.push(
                    new Strophe.Request(body.tree(),
                        this._onRequestStateChange.bind(
                            this, _callback.bind(this._conn)),
                        body.tree().getAttribute("rid")));
                this._throttledRequestHandler();
            },

            /** PrivateFunction: _onDisconnectTimeout
             *  _Private_ timeout handler for handling non-graceful disconnection.
             *
             *  Cancels all remaining Requests and clears the queue.
             */
            _onDisconnectTimeout: function () {
                this._abortAllRequests();
            },

            /** PrivateFunction: _abortAllRequests
             *  _Private_ helper function that makes sure all pending requests are aborted.
             */
            _abortAllRequests: function _abortAllRequests() {
                var req;
                while (this._requests.length > 0) {
                    req = this._requests.pop();
                    req.abort = true;
                    req.xhr.abort();
                    // jslint complains, but this is fine. setting to empty func
                    // is necessary for IE6
                    req.xhr.onreadystatechange = function () {}; // jshint ignore:line
                }
            },

            /** PrivateFunction: _onIdle
             *  _Private_ handler called by Strophe.Connection._onIdle
             *
             *  Sends all queued Requests or polls with empty Request if there are none.
             */
            _onIdle: function () {
                var data = this._conn._data;

                // if no requests are in progress, poll
                if (this._conn.authenticated && this._requests.length === 0 &&
                    data.length === 0 && !this._conn.disconnecting) {
                    Strophe.info("no requests during idle cycle, sending " +
                        "blank request");
                    data.push(null);
                }

                if (this._conn.paused) {
                    return;
                }

                if (this._requests.length < 2 && data.length > 0) {
                    var body = this._buildBody();
                    for (var i = 0; i < data.length; i++) {
                        if (data[i] !== null) {
                            if (data[i] === "restart") {
                                body.attrs({
                                    to: this._conn.domain,
                                    "xml:lang": "en",
                                    "xmpp:restart": "true",
                                    "xmlns:xmpp": Strophe.NS.BOSH
                                });
                            } else {
                                body.cnode(data[i]).up();
                            }
                        }
                    }
                    delete this._conn._data;
                    this._conn._data = [];
                    this._requests.push(
                        new Strophe.Request(body.tree(),
                            this._onRequestStateChange.bind(
                                this, this._conn._dataRecv.bind(this._conn)),
                            body.tree().getAttribute("rid")));
                    this._throttledRequestHandler();
                }

                if (this._requests.length > 0) {
                    var time_elapsed = this._requests[0].age();
                    if (this._requests[0].dead !== null) {
                        if (this._requests[0].timeDead() >
                            Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                            this._throttledRequestHandler();
                        }
                    }

                    if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                        Strophe.warn("Request " +
                            this._requests[0].id +
                            " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) +
                            " seconds since last activity");
                        this._throttledRequestHandler();
                    }
                }
            },

            /** PrivateFunction: _onRequestStateChange
             *  _Private_ handler for Strophe.Request state changes.
             *
             *  This function is called when the XMLHttpRequest readyState changes.
             *  It contains a lot of error handling logic for the many ways that
             *  requests can fail, and calls the request callback when requests
             *  succeed.
             *
             *  Parameters:
             *    (Function) func - The handler for the request.
             *    (Strophe.Request) req - The request that is changing readyState.
             */
            _onRequestStateChange: function (func, req)
            {
                Strophe.debug("request id " + req.id +
                    "." + req.sends + " state changed to " +
                    req.xhr.readyState);

                if (req.abort) {
                    req.abort = false;
                    return;
                }

                // request complete
                var reqStatus;
                if (req.xhr.readyState == 4) {
                    reqStatus = 0;
                    try {
                        reqStatus = req.xhr.status;
                    } catch (e) {
                        // ignore errors from undefined status attribute.  works
                        // around a browser bug
                    }

                    if (typeof(reqStatus) == "undefined") {
                        reqStatus = 0;
                    }

                    if (this.disconnecting) {
                        if (reqStatus >= 400) {
                            this._hitError(reqStatus);
                            return;
                        }
                    }

                    var reqIs0 = (this._requests[0] == req);
                    var reqIs1 = (this._requests[1] == req);

                    if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
                        // remove from internal queue
                        this._removeRequest(req);
                        Strophe.debug("request id " +
                            req.id +
                            " should now be removed");
                    }

                    // request succeeded
                    if (reqStatus == 200) {
                        // if request 1 finished, or request 0 finished and request
                        // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to
                        // restart the other - both will be in the first spot, as the
                        // completed request has been removed from the queue already
                        if (reqIs1 ||
                            (reqIs0 && this._requests.length > 0 &&
                            this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
                            this._restartRequest(0);
                        }

                        this._conn.nextValidRid(Number(req.rid) + 1);

                        // call handler
                        Strophe.debug("request id " +
                            req.id + "." +
                            req.sends + " got 200");
                        func(req);
                        this.errors = 0;
                    } else {
                        Strophe.error("request id " +
                            req.id + "." +
                            req.sends + " error " + reqStatus +
                            " happened");
                        if (reqStatus === 0 ||
                            (reqStatus >= 400 && reqStatus < 600) ||
                            reqStatus >= 12000) {
                            this._hitError(reqStatus);
                            if (reqStatus >= 400 && reqStatus < 500) {
                                this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);
                                this._conn._doDisconnect();
                            }
                        }
                    }

                    if (!((reqStatus > 0 && reqStatus < 500) ||
                        req.sends > 5)) {
                        this._throttledRequestHandler();
                    }
                }
            },

            /** PrivateFunction: _processRequest
             *  _Private_ function to process a request in the queue.
             *
             *  This function takes requests off the queue and sends them and
             *  restarts dead requests.
             *
             *  Parameters:
             *    (Integer) i - The index of the request in the queue.
             */
            _processRequest: function (i)
            {
                var self = this;
                var req = this._requests[i];
                var reqStatus = -1;

                try {
                    if (req.xhr.readyState == 4) {
                        reqStatus = req.xhr.status;
                    }
                } catch (e) {
                    Strophe.error("caught an error in _requests[" + i +
                        "], reqStatus: " + reqStatus);
                }

                if (typeof(reqStatus) == "undefined") {
                    reqStatus = -1;
                }

                // make sure we limit the number of retries
                if (req.sends > this._conn.maxRetries) {
                    this._conn._onDisconnectTimeout();
                    return;
                }

                var time_elapsed = req.age();
                var primaryTimeout = (!isNaN(time_elapsed) &&
                time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
                var secondaryTimeout = (req.dead !== null &&
                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
                var requestCompletedWithServerError = (req.xhr.readyState == 4 &&
                (reqStatus < 1 ||
                reqStatus >= 500));
                if (primaryTimeout || secondaryTimeout ||
                    requestCompletedWithServerError) {
                    if (secondaryTimeout) {
                        Strophe.error("Request " +
                            this._requests[i].id +
                            " timed out (secondary), restarting");
                    }
                    req.abort = true;
                    req.xhr.abort();
                    // setting to null fails on IE6, so set to empty function
                    req.xhr.onreadystatechange = function () {};
                    this._requests[i] = new Strophe.Request(req.xmlData,
                        req.origFunc,
                        req.rid,
                        req.sends);
                    req = this._requests[i];
                }

                if (req.xhr.readyState === 0) {
                    Strophe.debug("request id " + req.id +
                        "." + req.sends + " posting");

                    try {
                        req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
                        req.xhr.setRequestHeader("Content-Type", "text/xml; charset=utf-8");
                    } catch (e2) {
                        Strophe.error("XHR open failed.");
                        if (!this._conn.connected) {
                            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL,
                                "bad-service");
                        }
                        this._conn.disconnect();
                        return;
                    }

                    // Fires the XHR request -- may be invoked immediately
                    // or on a gradually expanding retry window for reconnects
                    var sendFunc = function () {
                        req.date = new Date();
                        if (self._conn.options.customHeaders){
                            var headers = self._conn.options.customHeaders;
                            for (var header in headers) {
                                if (headers.hasOwnProperty(header)) {
                                    req.xhr.setRequestHeader(header, headers[header]);
                                }
                            }
                        }
                        req.xhr.send(req.data);
                    };

                    // Implement progressive backoff for reconnects --
                    // First retry (send == 1) should also be instantaneous
                    if (req.sends > 1) {
                        // Using a cube of the retry number creates a nicely
                        // expanding retry window
                        var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),
                                Math.pow(req.sends, 3)) * 1000;
                        setTimeout(sendFunc, backoff);
                    } else {
                        sendFunc();
                    }

                    req.sends++;

                    if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
                        if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {
                            this._conn.xmlOutput(req.xmlData.childNodes[0]);
                        } else {
                            this._conn.xmlOutput(req.xmlData);
                        }
                    }
                    if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {
                        this._conn.rawOutput(req.data);
                    }
                } else {
                    Strophe.debug("_processRequest: " +
                        (i === 0 ? "first" : "second") +
                        " request has readyState of " +
                        req.xhr.readyState);
                }
            },

            /** PrivateFunction: _removeRequest
             *  _Private_ function to remove a request from the queue.
             *
             *  Parameters:
             *    (Strophe.Request) req - The request to remove.
             */
            _removeRequest: function (req)
            {
                Strophe.debug("removing request");

                var i;
                for (i = this._requests.length - 1; i >= 0; i--) {
                    if (req == this._requests[i]) {
                        this._requests.splice(i, 1);
                    }
                }

                // IE6 fails on setting to null, so set to empty function
                req.xhr.onreadystatechange = function () {};

                this._throttledRequestHandler();
            },

            /** PrivateFunction: _restartRequest
             *  _Private_ function to restart a request that is presumed dead.
             *
             *  Parameters:
             *    (Integer) i - The index of the request in the queue.
             */
            _restartRequest: function (i)
            {
                var req = this._requests[i];
                if (req.dead === null) {
                    req.dead = new Date();
                }

                this._processRequest(i);
            },

            /** PrivateFunction: _reqToData
             * _Private_ function to get a stanza out of a request.
             *
             * Tries to extract a stanza out of a Request Object.
             * When this fails the current connection will be disconnected.
             *
             *  Parameters:
             *    (Object) req - The Request.
             *
             *  Returns:
             *    The stanza that was passed.
             */
            _reqToData: function (req)
            {
                try {
                    return req.getResponse();
                } catch (e) {
                    if (e != "parsererror") { throw e; }
                    this._conn.disconnect("strophe-parsererror");
                }
            },

            /** PrivateFunction: _sendTerminate
             *  _Private_ function to send initial disconnect sequence.
             *
             *  This is the first step in a graceful disconnect.  It sends
             *  the BOSH server a terminate body and includes an unavailable
             *  presence if authentication has completed.
             */
            _sendTerminate: function (pres)
            {
                Strophe.info("_sendTerminate was called");
                var body = this._buildBody().attrs({type: "terminate"});

                if (pres) {
                    body.cnode(pres.tree());
                }

                var req = new Strophe.Request(body.tree(),
                    this._onRequestStateChange.bind(
                        this, this._conn._dataRecv.bind(this._conn)),
                    body.tree().getAttribute("rid"));

                this._requests.push(req);
                this._throttledRequestHandler();
            },

            /** PrivateFunction: _send
             *  _Private_ part of the Connection.send function for BOSH
             *
             * Just triggers the RequestHandler to send the messages that are in the queue
             */
            _send: function () {
                clearTimeout(this._conn._idleTimeout);
                this._throttledRequestHandler();
                this._conn._idleTimeout = setTimeout(this._conn._onIdle.bind(this._conn), 100);
            },

            /** PrivateFunction: _sendRestart
             *
             *  Send an xmpp:restart stanza.
             */
            _sendRestart: function ()
            {
                this._throttledRequestHandler();
                clearTimeout(this._conn._idleTimeout);
            },

            /** PrivateFunction: _throttledRequestHandler
             *  _Private_ function to throttle requests to the connection window.
             *
             *  This function makes sure we don't send requests so fast that the
             *  request ids overflow the connection window in the case that one
             *  request died.
             */
            _throttledRequestHandler: function ()
            {
                if (!this._requests) {
                    Strophe.debug("_throttledRequestHandler called with " +
                        "undefined requests");
                } else {
                    Strophe.debug("_throttledRequestHandler called with " +
                        this._requests.length + " requests");
                }

                if (!this._requests || this._requests.length === 0) {
                    return;
                }

                if (this._requests.length > 0) {
                    this._processRequest(0);
                }

                if (this._requests.length > 1 &&
                    Math.abs(this._requests[0].rid -
                        this._requests[1].rid) < this.window) {
                    this._processRequest(1);
                }
            }
        };
        return Strophe;
    }));

    /*
     This program is distributed under the terms of the MIT license.
     Please see the LICENSE file for details.

     Copyright 2006-2008, OGG, LLC
     */

    /* jshint undef: true, unused: true:, noarg: true, latedef: true */
    /* global define, window, clearTimeout, WebSocket, DOMParser, Strophe, $build */

    (function (root, factory) {
        if (typeof define === 'function' && define.amd) {
            define('strophe-websocket', ['strophe-core'], function (core) {
                return factory(
                    core.Strophe,
                    core.$build
                );
            });
        } else {
            // Browser globals
            return factory(Strophe, $build);
        }
    }(this, function (Strophe, $build) {

        /** Class: Strophe.WebSocket
         *  _Private_ helper class that handles WebSocket Connections
         *
         *  The Strophe.WebSocket class is used internally by Strophe.Connection
         *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.
         */

        /** File: websocket.js
         *  A JavaScript library to enable XMPP over Websocket in Strophejs.
         *
         *  This file implements XMPP over WebSockets for Strophejs.
         *  If a Connection is established with a Websocket url (ws://...)
         *  Strophe will use WebSockets.
         *  For more information on XMPP-over-WebSocket see RFC 7395:
         *  http://tools.ietf.org/html/rfc7395
         *
         *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)
         */

        /** PrivateConstructor: Strophe.Websocket
         *  Create and initialize a Strophe.WebSocket object.
         *  Currently only sets the connection Object.
         *
         *  Parameters:
         *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.
         *
         *  Returns:
         *    A new Strophe.WebSocket object.
         */
        Strophe.Websocket = function(connection) {
            this._conn = connection;
            this.strip = "wrapper";

            var service = connection.service;
            if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
                // If the service is not an absolute URL, assume it is a path and put the absolute
                // URL together from options, current URL and the path.
                var new_service = "";

                if (connection.options.protocol === "ws" && window.location.protocol !== "https:") {
                    new_service += "ws";
                } else {
                    new_service += "wss";
                }

                new_service += "://" + window.location.host;

                if (service.indexOf("/") !== 0) {
                    new_service += window.location.pathname + service;
                } else {
                    new_service += service;
                }

                connection.service = new_service;
            }
        };

        Strophe.Websocket.prototype = {
            /** PrivateFunction: _buildStream
             *  _Private_ helper function to generate the <stream> start tag for WebSockets
             *
             *  Returns:
             *    A Strophe.Builder with a <stream> element.
             */
            _buildStream: function ()
            {
                return $build("open", {
                    "xmlns": Strophe.NS.FRAMING,
                    "to": this._conn.domain,
                    "version": '1.0'
                });
            },

            /** PrivateFunction: _check_streamerror
             * _Private_ checks a message for stream:error
             *
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             *    connectstatus - The ConnectStatus that will be set on error.
             *  Returns:
             *     true if there was a streamerror, false otherwise.
             */
            _check_streamerror: function (bodyWrap, connectstatus) {
                var errors;
                if (bodyWrap.getElementsByTagNameNS) {
                    errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "error");
                } else {
                    errors = bodyWrap.getElementsByTagName("stream:error");
                }
                if (errors.length === 0) {
                    return false;
                }
                var error = errors[0];

                var condition = "";
                var text = "";

                var ns = "urn:ietf:params:xml:ns:xmpp-streams";
                for (var i = 0; i < error.childNodes.length; i++) {
                    var e = error.childNodes[i];
                    if (e.getAttribute("xmlns") !== ns) {
                        break;
                    } if (e.nodeName === "text") {
                        text = e.textContent;
                    } else {
                        condition = e.nodeName;
                    }
                }

                var errorString = "WebSocket stream error: ";

                if (condition) {
                    errorString += condition;
                } else {
                    errorString += "unknown";
                }

                if (text) {
                    errorString += " - " + condition;
                }

                Strophe.error(errorString);

                // close the connection on stream_error
                this._conn._changeConnectStatus(connectstatus, condition);
                this._conn._doDisconnect();
                return true;
            },

            /** PrivateFunction: _reset
             *  Reset the connection.
             *
             *  This function is called by the reset function of the Strophe Connection.
             *  CommonTime alteration - neuter all event handlers for outgoing WebSocket if one exists
             */
            _reset: function ()
            {
                // CommonTime code - neuter all event handlers on outgoing socket
                if (this.socket) {
                    var emptyFn = function () {
                    };
                    this.socket.onopen = emptyFn;
                    this.socket.onerror = emptyFn;
                    this.socket.onclose = emptyFn;
                    this.socket.onmessage = emptyFn;
                }
            },

            /** PrivateFunction: _connect
             *  _Private_ function called by Strophe.Connection.connect
             *
             *  Creates a WebSocket for a connection and assigns Callbacks to it.
             *  Does nothing if there already is a WebSocket.
             */
            _connect: function () {
                // Ensure that there is no open WebSocket from a previous Connection.
                this._closeSocket();

                // Create the new WobSocket
                this.socket = new WebSocket(this._conn.service, "xmpp");
                this.socket.onopen = this._onOpen.bind(this);
                this.socket.onerror = this._onError.bind(this);
                this.socket.onclose = this._onClose.bind(this);
                this.socket.onmessage = this._connect_cb_wrapper.bind(this);
            },

            /** PrivateFunction: _connect_cb
             *  _Private_ function called by Strophe.Connection._connect_cb
             *
             * checks for stream:error
             *
             *  Parameters:
             *    (Strophe.Request) bodyWrap - The received stanza.
             */
            _connect_cb: function(bodyWrap) {
                var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);
                if (error) {
                    return Strophe.Status.CONNFAIL;
                }
            },

            /** PrivateFunction: _handleStreamStart
             * _Private_ function that checks the opening <open /> tag for errors.
             *
             * Disconnects if there is an error and returns false, true otherwise.
             *
             *  Parameters:
             *    (Node) message - Stanza containing the <open /> tag.
             */
            _handleStreamStart: function(message) {
                var error = false;

                // Check for errors in the <open /> tag
                var ns = message.getAttribute("xmlns");
                if (typeof ns !== "string") {
                    error = "Missing xmlns in <open />";
                } else if (ns !== Strophe.NS.FRAMING) {
                    error = "Wrong xmlns in <open />: " + ns;
                }

                var ver = message.getAttribute("version");
                if (typeof ver !== "string") {
                    error = "Missing version in <open />";
                } else if (ver !== "1.0") {
                    error = "Wrong version in <open />: " + ver;
                }

                if (error) {
                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);
                    this._conn._doDisconnect();
                    return false;
                }

                return true;
            },

            /** PrivateFunction: _connect_cb_wrapper
             * _Private_ function that handles the first connection messages.
             *
             * On receiving an opening stream tag this callback replaces itself with the real
             * message handler. On receiving a stream error the connection is terminated.
             */
            _connect_cb_wrapper: function(message) {
                if (message.data.indexOf("<open ") === 0 || message.data.indexOf("<?xml") === 0) {
                    // Strip the XML Declaration, if there is one
                    var data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
                    if (data === '') return;

                    var streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;
                    this._conn.xmlInput(streamStart);
                    this._conn.rawInput(message.data);

                    //_handleStreamSteart will check for XML errors and disconnect on error
                    if (this._handleStreamStart(streamStart)) {
                        //_connect_cb will check for stream:error and disconnect on error
                        this._connect_cb(streamStart);
                    }
                } else if (message.data.indexOf("<close ") === 0) { //'<close xmlns="urn:ietf:params:xml:ns:xmpp-framing />') {
                    this._conn.rawInput(message.data);
                    this._conn.xmlInput(message);
                    var see_uri = message.getAttribute("see-other-uri");
                    if (see_uri) {
                        this._conn._changeConnectStatus(Strophe.Status.REDIRECT, "Received see-other-uri, resetting connection");
                        this._conn.reset();
                        this._conn.service = see_uri;
                        this._connect();
                    } else {
                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Received closing stream");
                        this._conn._doDisconnect();
                    }
                } else {
                    var string = this._streamWrap(message.data);
                    var elem = new DOMParser().parseFromString(string, "text/xml").documentElement;
                    this.socket.onmessage = this._onMessage.bind(this);
                    this._conn._connect_cb(elem, null, message.data);
                }
            },

            /** PrivateFunction: _disconnect
             *  _Private_ function called by Strophe.Connection.disconnect
             *
             *  Disconnects and sends a last stanza if one is given
             *
             *  Parameters:
             *    (Request) pres - This stanza will be sent before disconnecting.
             */
            _disconnect: function (pres)
            {
                if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
                    if (pres) {
                        this._conn.send(pres);
                    }
                    var close = $build("close", { "xmlns": Strophe.NS.FRAMING });
                    this._conn.xmlOutput(close);
                    var closeString = Strophe.serialize(close);
                    this._conn.rawOutput(closeString);
                    try {
                        this.socket.send(closeString);
                    } catch (e) {
                        Strophe.info("Couldn't send <close /> tag.");
                    }
                }
                this._conn._doDisconnect();
            },

            /** PrivateFunction: _doDisconnect
             *  _Private_ function to disconnect.
             *
             *  Just closes the Socket for WebSockets
             */
            _doDisconnect: function ()
            {
                Strophe.info("WebSockets _doDisconnect was called");
                this._closeSocket();
            },

            /** PrivateFunction _streamWrap
             *  _Private_ helper function to wrap a stanza in a <stream> tag.
             *  This is used so Strophe can process stanzas from WebSockets like BOSH
             */
            _streamWrap: function (stanza)
            {
                return "<wrapper>" + stanza + '</wrapper>';
            },


            /** PrivateFunction: _closeSocket
             *  _Private_ function to close the WebSocket.
             *
             *  Closes the socket if it is still open and deletes it
             */
            _closeSocket: function ()
            {
                if (this.socket) { try {
                    this.socket.close();
                } catch (e) {} }
                this.socket = null;
            },

            /** PrivateFunction: _emptyQueue
             * _Private_ function to check if the message queue is empty.
             *
             *  Returns:
             *    True, because WebSocket messages are send immediately after queueing.
             */
            _emptyQueue: function ()
            {
                return true;
            },

            /** PrivateFunction: _onClose
             * _Private_ function to handle websockets closing.
             *
             * Nothing to do here for WebSockets
             */
            _onClose: function() {
                if(this._conn.connected && !this._conn.disconnecting) {
                    Strophe.error("Websocket closed unexcectedly");
                    this._conn._doDisconnect();
                } else {
                    Strophe.info("Websocket closed");
                }
            },

            /** PrivateFunction: _no_auth_received
             *
             * Called on stream start/restart when no stream:features
             * has been received.
             */
            _no_auth_received: function (_callback)
            {
                Strophe.error("Server did not send any auth methods");
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Server did not send any auth methods");
                if (_callback) {
                    _callback = _callback.bind(this._conn);
                    _callback();
                }
                this._conn._doDisconnect();
            },

            /** PrivateFunction: _onDisconnectTimeout
             *  _Private_ timeout handler for handling non-graceful disconnection.
             *
             *  This does nothing for WebSockets
             */
            _onDisconnectTimeout: function () {},

            /** PrivateFunction: _abortAllRequests
             *  _Private_ helper function that makes sure all pending requests are aborted.
             */
            _abortAllRequests: function () {},

            /** PrivateFunction: _onError
             * _Private_ function to handle websockets errors.
             *
             * Parameters:
             * (Object) error - The websocket error.
             */
            _onError: function(error) {
                Strophe.error("Websocket error " + error);
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established was disconnected.");
                //this._disconnect();
            },

            /** PrivateFunction: _onIdle
             *  _Private_ function called by Strophe.Connection._onIdle
             *
             *  sends all queued stanzas
             */
            _onIdle: function () {
                var data = this._conn._data;
                if (data.length > 0 && !this._conn.paused) {
                    for (var i = 0; i < data.length; i++) {
                        if (data[i] !== null) {
                            var stanza, rawStanza;
                            if (data[i] === "restart") {
                                stanza = this._buildStream().tree();
                            } else {
                                stanza = data[i];
                            }
                            rawStanza = Strophe.serialize(stanza);
                            this._conn.xmlOutput(stanza);
                            this._conn.rawOutput(rawStanza);
                            this.socket.send(rawStanza);
                        }
                    }
                    this._conn._data = [];
                }
            },

            /** PrivateFunction: _onMessage
             * _Private_ function to handle websockets messages.
             *
             * This function parses each of the messages as if they are full documents. [TODO : We may actually want to use a SAX Push parser].
             *
             * Since all XMPP traffic starts with "<stream:stream version='1.0' xml:lang='en' xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' id='3697395463' from='SERVER'>"
             * The first stanza will always fail to be parsed...
             * Addtionnaly, the seconds stanza will always be a <stream:features> with the stream NS defined in the previous stanza... so we need to 'force' the inclusion of the NS in this stanza!
             *
             * Parameters:
             * (string) message - The websocket message.
             */
            _onMessage: function(message) {
                var elem, data;
                // check for closing stream
                var close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
                if (message.data === close) {
                    this._conn.rawInput(close);
                    this._conn.xmlInput(message);
                    if (!this._conn.disconnecting) {
                        this._conn._doDisconnect();
                    }
                    return;
                } else if (message.data.search("<open ") === 0) {
                    // This handles stream restarts
                    elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement;

                    if (!this._handleStreamStart(elem)) {
                        return;
                    }
                } else {
                    data = this._streamWrap(message.data);
                    elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
                }

                if (this._check_streamerror(elem, Strophe.Status.ERROR)) {
                    return;
                }

                //handle unavailable presence stanza before disconnecting
                if (this._conn.disconnecting &&
                    elem.firstChild.nodeName === "presence" &&
                    elem.firstChild.getAttribute("type") === "unavailable") {
                    this._conn.xmlInput(elem);
                    this._conn.rawInput(Strophe.serialize(elem));
                    // if we are already disconnecting we will ignore the unavailable stanza and
                    // wait for the </stream:stream> tag before we close the connection
                    return;
                }
                this._conn._dataRecv(elem, message.data);
            },

            /** PrivateFunction: _onOpen
             * _Private_ function to handle websockets connection setup.
             *
             * The opening stream tag is sent here.
             */
            _onOpen: function() {
                Strophe.info("Websocket open");
                var start = this._buildStream();
                this._conn.xmlOutput(start.tree());

                var startString = Strophe.serialize(start);
                this._conn.rawOutput(startString);
                this.socket.send(startString);
            },

            /** PrivateFunction: _reqToData
             * _Private_ function to get a stanza out of a request.
             *
             * WebSockets don't use requests, so the passed argument is just returned.
             *
             *  Parameters:
             *    (Object) stanza - The stanza.
             *
             *  Returns:
             *    The stanza that was passed.
             */
            _reqToData: function (stanza)
            {
                return stanza;
            },

            /** PrivateFunction: _send
             *  _Private_ part of the Connection.send function for WebSocket
             *
             * Just flushes the messages that are in the queue
             */
            _send: function () {
                this._conn.flush();
            },

            /** PrivateFunction: _sendRestart
             *
             *  Send an xmpp:restart stanza.
             */
            _sendRestart: function ()
            {
                clearTimeout(this._conn._idleTimeout);
                this._conn._onIdle.bind(this._conn)();
            }
        };
        return Strophe;
    }));

    (function(root){
        if(typeof define === 'function' && define.amd){
            define("strophe", [
                "strophe-core",
                "strophe-bosh",
                "strophe-websocket"
            ], function (wrapper) {
                return wrapper;
            });
        }
    })(this);

    /* jshint ignore:start */
    if (callback) {
        if(typeof define === 'function' && define.amd){
            //For backwards compatability
            var n_callback = callback;
            require(["strophe"],function(o){
                n_callback(o.Strophe,o.$build,o.$msg,o.$iq,o.$pres);
            });
        }else{
            return callback(Strophe, $build, $msg, $iq, $pres);
        }
    }


})(function (Strophe, build, msg, iq, pres) {
    window.Strophe = Strophe;
    window.$build = build;
    window.$msg = msg;
    window.$iq = iq;
    window.$pres = pres;
});
/* jshint ignore:end */

/**
 * StropheJS - Stream Management XEP-0198
 *
 * This plugin implements stream mangemament ACK capabilities of the specs XEP-0198.
 * Note: Resumption is not supported in this current implementation.
 *
 * Reference: http://xmpp.org/extensions/xep-0198.html
 *
 * @class streamManagement
 */
Strophe.addConnectionPlugin('streamManagement', {

    /**
     * @property {Boolean} autoSendCountOnEveryIncomingStanza: Set to true to send an 'a' response after every stanza.
     * @default false
     * @public
     */
    autoSendCountOnEveryIncomingStanza: false,

    /**
     * @property {Integer} requestResponseInterval: Set this value to send a request for counter on very interval
     * number of stanzas sent. Set to 0 to disable.
     * @default 5
     * @public
     */
    requestResponseInterval: 5,

    /**
     * @property {Pointer} _c: Strophe connection instance.
     * @private
     */
    _c: null,

    /**
     * @property {String} _NS XMPP Namespace.
     * @private
     */
    _NS: 'urn:xmpp:sm:3',

    /**
     * @property {Boolean} _isStreamManagementEnabled
     * @private
     */
    _isStreamManagementEnabled: false,

    /**
     * @property {Integer} _serverProcesssedStanzasCounter: Keeps count of stanzas confirmed processed by the server.
     * The server is the source of truth of this value. It is the 'h' attribute on the latest 'a' element received
     * from the server.
     * @private
     */
    _serverProcesssedStanzasCounter: null,

    /**
     * @property {Integer} _clientProcessedStanzasCounter: Counter of stanzas received by the client from the server.
     * Client is the source of truth of this value. It is the 'h' attribute in the 'a' sent from the client to
     * the server.
     * @private
     */
    _clientProcessedStanzasCounter: null,

    /**
     * @property {Integer} _clientSentStanzasCounter
     * @private
     */
    _clientSentStanzasCounter: null,

    /**
     * Stores a reference to Strophe connection send function to wrap counting functionality.
     * @method _originalSend
     * @type {Handler}
     * @private
     */
    _originalSend: null,

    /**
     * @property {Handler} _requestHandler: Stores reference to handler that process count request from server.
     * @private
     */
    _requestHandler: null,

    /**
     * @property {Handler} _incomingHanlder: Stores reference to hanlder that processes incoming stanzas count.
     * @private
     */
    _incomingHandler: null,

    /**
     * @property {Integer} _requestResponseIntervalCount: Counts sent stanzas since last response request.
     */
    _requestResponseIntervalCount: 0,

    init: function(conn) {
        this._c = conn;
        Strophe.addNamespace('SM', this._NS);

        // Storing origina send function to use additional logic
        this._originalSend = this._c.send;
        this._c.send = this.send.bind(this);
    },

    statusChanged: function (status) {
        if (status === Strophe.Status.CONNECTED || status === Strophe.Status.DISCONNECTED) {

            this._serverProcesssedStanzasCounter = 0;
            this._clientProcessedStanzasCounter = 0;

            this._clientSentStanzasCounter = 0;

            this._isStreamManagementEnabled = false;
            this._requestResponseIntervalCount = 0;

            if (this._requestHandler) {
                this._c.deleteHandler(this._requestHandler);
            }

            if (this._incomingHandler) {
                this._c.deleteHandler(this._incomingHandler);
            }

            this._requestHandler = this._c.addHandler(this._handleServerRequestHandler.bind(this), this._NS, 'r');
            this._incomingHandler = this._c.addHandler(this._incomingStanzaHandler.bind(this));
        }
    },

    enable: function(successCallback, errorCallback) {
        this._c.send($build('enable', {xmlns: this._NS, resume: false}));
        var timeout = setTimeout(function(){
            errorCallback("Stream management couldn't be enabled.");
        }, 5000);
        var $scope = this;
        this._c.addHandler(function(elem){
            if (Strophe.isTagEqual(elem, 'enabled')) {
                clearTimeout(timeout);
                $scope._isStreamManagementEnabled = true;
                successCallback();
            }
        });
    },

    /**
     * This method overrides the send method implemented by Strophe.Connection
     * to count outgoing stanzas
     *
     * @method Send
     * @public
     */
    send: function(elem) {
        if (Strophe.isTagEqual(elem, 'iq') ||
            Strophe.isTagEqual(elem, 'presence') ||
            (elem.node && elem.node.tagName === 'message') ||
            Strophe.isTagEqual(elem, 'message')
        ) {
            this._increaseSentStanzasCounter();
        }

        return this._originalSend.call(this._c, elem);
    },

    _incomingStanzaHandler: function(elem) {
        if (Strophe.isTagEqual(elem, 'enabled') && elem.getAttribute('xmlns') === this._NS) {
            this._isStreamManagementEnabled = true;
        }

        if (Strophe.isTagEqual(elem, 'iq') || Strophe.isTagEqual(elem, 'presence') || Strophe.isTagEqual(elem, 'message'))  {
            this._increaseReceivedStanzasCounter();
            if (this.autoSendCountOnEveryIncomingStanza) {
                this._answerProcessedStanzas();
            }
            // If we got an error back from a previous message rollback the client sent stanza counter
            if (Strophe.isTagEqual(elem, 'message') && elem.getAttribute("type") === "error") {
                this._clientSentStanzasCounter = (this._clientSentStanzasCounter - 1);
            }
        }

        if (Strophe.isTagEqual(elem, 'a')) {
            this._setSentStanzasCounter(parseInt(elem.getAttribute('h')));
            if (this.requestResponseInterval > 0) {
                this._requestResponseIntervalCount = 0;
            }
        }

        return true;
    },

    /**
     * DEPRECATED
     * @returns {*}
     */
    getClientSentStanzasCounter: function() {
        return this.getOutgoingCounter();
    },

    getServerProcessedCounter: function () {
        return this._serverProcesssedStanzasCounter;
    },

    getOutgoingCounter: function () {
        return this._clientSentStanzasCounter;
    },

    requestAcknowledgement: function () {
        this._requestResponseIntervalCount = 0;
        this._c.send($build('r', { xmlns: this._NS }));
    },

    _setSentStanzasCounter: function(count) {
        this._serverProcesssedStanzasCounter = count;
        if (this._clientSentStanzasCounter !== this._serverProcesssedStanzasCounter) {
            console.info('Stream Management stanzas counter mismatch. Client value: ' + this._clientSentStanzasCounter + ' - Server value: ' + this._serverProcesssedStanzasCounter);
        }
    },

    _handleServerRequestHandler: function() {
        this._answerProcessedStanzas();
        return true;
    },

    _answerProcessedStanzas: function() {
        if (this._isStreamManagementEnabled) {
            this._c.send($build('a', { xmlns: this._NS, h: this._clientProcessedStanzasCounter }));
        }
    },

    _increaseSentStanzasCounter: function() {
        if (this._isStreamManagementEnabled) {
            this._clientSentStanzasCounter++;
            if (this.requestResponseInterval > 0) {
                this._requestResponseIntervalCount++;
                if (this._requestResponseIntervalCount === this.requestResponseInterval) {
                    this._requestResponseIntervalCount = 0;
                    setTimeout(function(){
                        this._originalSend.call(this._c, $build('r', { xmlns: this._NS }));
                    }.bind(this), 100);
                }
            }
        }
    },

    _increaseReceivedStanzasCounter: function() {
        if (this._isStreamManagementEnabled) {
            this._clientProcessedStanzasCounter++;
        }
    }

});

/**
 * Created by Leon.Revill on 23/08/2017.
 */
window.Strophe.addConnectionPlugin("outbox", {

    /**
     * Default duration in ms for when to deem a message as failed to send
     */
    sendTimeoutDuration: 5000,
    eventTypes: {
        "MESSAGE_QUEUED": "messagequeued",
        "MESSAGE_RESEND_SUCCESS": "messageresendsuccess",
        "MESSAGE_RESEND_FAILED": "messageresendfail",
        "QUEUE_CLEANED": "queuecleaned",
        "QUEUE_PROCESSED": "queueprocessed"
    },
    _eventListeners: [],
    logLevel: 1,
    _logLevels: {
        "ERROR": 1,
        "WARNING": 2,
        "INFO": 3,
        "DEBUG": 4
    },
    _log: function (message, data, level) {

        if (!level) level = this._logLevels.DEBUG;

        if (this.logLevel < level) return;

        var args = [message];
        if (data) {
            args.push(data);
        }

        switch (level) {
            case this._logLevels.ERROR:
                // eslint-disable-next-line no-console
                console.error.apply(console, args);
                break;
            case this._logLevels.WARNING:
                // eslint-disable-next-line no-console
                console.warn.apply(console, args);
                break;
            case this._logLevels.INFO:
                // eslint-disable-next-line no-console
                console.info.apply(console, args);
                break;
            case this._logLevels.DEBUG:
            default:
                // eslint-disable-next-line no-console
                console.debug.apply(console, args);
        }
    },

    /**
     * Method called by Strophe to initialise the plugin
     * @param conn
     */
    init: function (conn) {
        this.enabled = false;
        this._c = conn;
        this._c.sendMessage = this._sendMessage.bind(this);
    },

    /**
     * Enable outbox queuing
     * @param instanceId {String} - The unique instance ID to be used as the database name prefix
     */
    enable: function (instanceId) {
        if (!instanceId) throw new Error("Instance ID must be provided");
        this._instanceId = instanceId;
        this._db = new PouchDB("strophe_outbox_" + this._instanceId);
        this.enabled = true;
        this._log("XMPP outbox enabled.");
    },

    /**
     * Add a stanza to the outbox queue
     * @param elem - The XML stanza node to add
     * @param success - Function to call on success
     * @param fail - Function to call on fail
     */
    add: function (elem, success, fail) {

        if (!this.enabled) throw new Error("XMPP Outbox must be enabled before performing this operation.");

        this._log("Adding new item to XMPP outbox queue:", elem);

        var id = elem.getAttribute("id");
        var now = Date.now();
        var ttl = null;
        var until = null;
        var $expire = elem.querySelector("x[xmlns='jabber:x:expire']");
        if ($expire !== null) {
            var seconds = $expire.getAttribute("seconds");
            if (seconds !== null) {
                var num = parseInt(seconds);
                if (!isNaN(num)) {
                    ttl = num * 1000;
                    until = (now + ttl);
                }
            }
        }

        // Create queue item object
        var item = {
            _id: id,
            added: now,
            ttl: ttl,
            until: until,
            stanza: elem.outerHTML
        };

        // Stash in PouchDB
        var scope = this;
        this._db.put(item, function (e) {
            if (!e) {
                scope._dispatchEvent(scope.eventTypes.MESSAGE_QUEUED, item);
                if (success) success(item);
            } else {
                if (fail) fail(e);
            }
        });

    },

    /**
     * Remove any expired messages from the queue
     * @param success - Callback function to execute on success
     * @param fail - Callback function to execute on failure
     */
    clean: function (success, fail) {

        if (!this.enabled) throw new Error("XMPP Outbox must be enabled before performing this operation.");

        this._log("Removing all expired items from the queue:", null);

        var scope = this;
        this.fetchExpiredItems(function (results) {

            var total = results.length;
            scope._log("Found '" + total + "' expired items:", results);

            if (total > 0) {
                results.forEach(function (item) {
                    var errors = [];
                    scope._db.remove(item, function (e) {
                        if (e) errors.push(e);
                        --total;
                        if (total <= 0) {
                            if (errors.length === 0) {
                                var msg = "Successfully removed '" + results.length + "' expired items from the queue.";
                                scope._log(msg);
                                scope._dispatchEvent(scope.eventTypes.QUEUE_CLEANED, msg);
                                success(msg);
                            } else {
                                scope._log("One or more errors occurred when cleaning the outbox queue:", errors, scope._logLevels.ERROR);
                                fail(errors);
                            }
                        }
                    });
                });
            } else {
                if (success) success(results);
            }

        }, fail);

    },

    /**
     * Method to destroy the entire queue
     * @param success - The callback function to execute on success
     * @param fail - The callback function to execute on failure
     */
    destroy: function (success, fail) {

        if (!this.enabled) throw new Error("XMPP Outbox must be enabled before performing this operation.");

        var scope = this;
        scope._db.destroy(function (err, response) {
            if (err) {
                if (fail) fail(err);
            } else {
                scope._db = new PouchDB("strophe_outbox_" + scope._instanceId);
                if (success) success(response);
            }
        });
    },

    /**
     * Remove a individual item from the queue
     * @param item - The item to be removed
     * @param success - The callback function to execute on success
     * @param fail - The callback function to execute on failure
     */
    remove: function (item, success, fail) {

        if (!this.enabled) throw new Error("XMPP Outbox must be enabled before performing this operation.");

        this._db.remove(item, function (e) {
            if (!e) {
                if (success) success();
            } else {
                if (fail) fail(e);
            }
        });
    },

    /**
     * Method which returns the number of all messages (expired & active) messages in the queue
     * @param success - The callback function to execute on success
     * @param fail - The callback function to execute on failure
     */
    countAll: function (success, fail) {

        if (!this.enabled) throw new Error("XMPP Outbox must be enabled before performing this operation.");
        if (!success) throw new Error("Success callback must be provided.");

        var scope = this;
        this._db.allDocs({
            // eslint-disable-next-line camelcase
            include_docs: false
        }, function (e, response) {
            if (!e) {
                var total = 0;
                // Only count non-design documents :(
                response.rows.forEach(function (row) {
                    if (row.id.indexOf("_design") === -1) {
                        ++total;
                    }
                });
                success(total);
            } else {
                scope._log("An error occurred when trying to count the number of messages in the outbox queue:", e, scope._logLevels.ERROR);
                if (fail) fail(e);
            }
        });
    },

    /**
     * Method which returns the number of expired items in the queue
     * @param success - The callback function to execute on success
     * @param fail - The callback function to execute on failure
     */
    countExpired: function (success, fail) {

        this.fetchExpiredItems(function (results) {
            success(results.length);
        }, fail);

    },

    /**
     * Method which returns the number of active items in the queue
     * @param success - The callback function to execute on success
     * @param fail - The callback function to execute on failure
     */
    countActive: function (success, fail) {

        this.fetchActiveItems(function (results) {
            success(results.length);
        }, fail);

    },

    /**
     * Method which returns all the expired items in the queue
     * @param success - The callback function to execute on success
     * @param fail - The callback function to execute on failure
     */
    fetchExpiredItems: function (success, fail) {

        if (!this.enabled) throw new Error("XMPP Outbox must be enabled before performing this operation.");

        // Find all items in the queue which have expired
        var scope = this;
        scope._db.createIndex({
            index: {
                fields: ["until"]
            }
        }, function (e) {
            if (!e) {
                scope._db.find({
                    selector: {
                        until: {
                            $lt: Date.now()
                        }
                    }
                }, function (e, response) {
                    if (!e) {
                        if (success) success(response.docs);
                    } else {
                        scope._log("An error occurred when querying for expired messages:", e, scope._logLevels.ERROR);
                        fail(e);
                    }
                });
            } else {
                scope._log("An error occurred when creating an index to query for expired messages:", e, scope._logLevels.ERROR);
                fail(e);
            }
        });

    },

    /**
     * Method which returns all the active items in the queue
     * @param success - The callback function to execute on success
     * @param fail - The callback function to execute on failure
     */
    fetchActiveItems: function (success, fail) {

        if (!this.enabled) throw new Error("XMPP Outbox must be enabled before performing this operation.");

        // Find all items in the queue which have not expired
        var scope = this;
        scope._db.createIndex({
            index: {
                fields: ["until"]
            }
        }, function (e) {
            if (!e) {
                scope._db.find({
                    selector: {
                        until: {
                            $gt: Date.now()
                        }
                    }
                }, function (e, response) {
                    if (!e) {
                        if (success) success(response.docs);
                    } else {
                        scope._log("An error occurred when querying for expired messages:", e, scope._logLevels.ERROR);
                        if (fail) fail(e);
                    }
                });
            } else {
                scope._log("An error occurred when creating an index to query for expired messages:", e, scope._logLevels.ERROR);
                if (fail) fail(e);
            }
        });

    },

    /**
     * Private method used by the public processQueue method to iterate through queued items
     * @param items {Object[]} - An array of items to process
     * @param index {Number} - The current index
     * @param success - The callback function to execute on success
     * @param fail - The callback function to execute on failure
     * @private
     */
    _processItems: function (items, index, success, fail) {

        var scope = this;
        var currentItem = items[index];
        var doc = (new window.DOMParser()).parseFromString(currentItem.stanza, "text/xml");

        this._c.sendMessage(doc.childNodes[0], function () {
            scope._log("Message resend success:", currentItem);
            scope._dispatchEvent(scope.eventTypes.MESSAGE_RESEND_SUCCESS, currentItem);
            // First remove the successfully resent item
            scope.remove(currentItem, function () {
                ++index;
                if (index >= items.length) {
                    success();
                } else {
                    scope._processItems(items, index, success, fail);
                }
            }, function () {
                fail("Couldn't remove item with ID '" + currentItem._id + "' from the queue.", index);
            });

        }, function () {
            scope._dispatchEvent(scope.eventTypes.MESSAGE_RESEND_FAILED, currentItem);
            fail("Couldn't resend item with ID '" + currentItem._id + "'.", index);
        }, false);

    },

    /**
     * Method to resend all unexpired messages in the queue
     * @param success - The callback function to execute on success
     * @param fail - The callback function to execute on failure
     */
    processQueue: function (success, fail) {

        if (!this.enabled) throw new Error("XMPP Outbox must be enabled before performing this operation.");

        var scope = this;
        this.fetchActiveItems(function (results) {

            var length = results.length;

            scope._log("Processing the XMPP outbox queue to resend '" + length + "' item(s):", results);

            if (length > 0) {

                scope._processItems(results, 0, function () {
                    var msg = length + " out of " + length + " items were processed.";
                    scope._log(msg);
                    scope.clean(function (cleanMsg) {
                        scope._dispatchEvent(scope.eventTypes.QUEUE_PROCESSED, msg);
                        scope._log("Finished processing queue:", msg);
                        if (success) success(msg + " Also, " + cleanMsg);
                    }, fail);
                }, function (e, index) {
                    var msg = "Couldn't process entire queue. Failed at item '" + (index + 1) + "'.";
                    if (index > 0) {
                        msg += " Successfully processed " + index + "/" + length + " items.";
                    }
                    scope._log(msg, e, scope._logLevels.ERROR);
                    fail(msg);
                });

            } else {

                var msg = "Nothing to process";
                scope._log(msg, null);
                scope.clean(function (cleanMsg) {
                    success(msg + " Also, " + cleanMsg);
                }, fail);

            }

        }, fail);

    },

    /**
     * Method used to send a message over the XMPP WebSocket connect with a callback when the server has acknowledged the message has been received
     * @param elem - The XML stanza to send
     * @param success - The callback function to execute on success
     * @param fail - The callback function to execute on failure
     * @param addToQueueIfFailed - Flag to set if the message *shouldn't* be added to the queue on failure, used within the processQueue method when resending
     * @private
     */
    _sendMessage: function (elem, success, fail, addToQueueIfFailed) {

        var reasonCodes = {
            "ERROR": 1,
            "TIMEOUT": 2,
            "NOACK": 3,
            "NOCONNECTION": 4
        };

        var scope = this;

        if (!window.Strophe.isTagEqual(elem, "message")) throw new Error("'sendMessage' should only be used to send <message> stanzas");

        var _fail = function (msg, reasonCode) {
            scope._log("Message send failed (Reason Code: '" + reasonCode + "'):", msg, scope._logLevels.ERROR);
            // If the message got a 400 (bad request) from the server then we don't want to keep retrying to send it
            if (scope.enabled === true && addToQueueIfFailed !== false && reasonCode !== 400) {
                scope.add(elem, success, fail);
            } else {
                if (fail) fail(msg);
            }
        };

        var id = elem.getAttribute("id");

        if (this._c.connected === true) {

            this._c.addHandler(function ($stanza) {
                clearTimeout(sendTimeout);
                var msg = "An error was returned from the server after sending a message with ID '" + id + "'.";
                var $errorNode = $stanza.querySelector("error");
                var reasonCode = reasonCodes.ERROR;
                if ($errorNode !== null) {
                    var errorCode = $errorNode.getAttribute("code");
                    if (errorCode !== null) {
                        reasonCode = parseInt(errorCode);
                    }
                    var textNode = $errorNode.querySelector("text");
                    if (textNode !== null) {
                        msg = textNode.innerText;
                    }
                }
                _fail(msg, reasonCode);
                return false;
            }, null, "message", "error", id);

            this._c.addHandler(function () {
                clearTimeout(sendTimeout);
                // Got an acknowledgment so message must have been sent successfully
                if (scope._c.streamManagement.getOutgoingCounter() === scope._c.streamManagement.getServerProcessedCounter()) {
                    if (success) success(null);
                } else {
                    _fail("Stream Management counters don't match, message with ID '" + id + "' might not have been sent!", reasonCodes.NOACK);
                }
                return false;
            }, null, "a");

            var sendTimeout = setTimeout(function () {
                // Message sent failed
                _fail("Message with ID '" + id + "' couldn't be sent within '" + scope.sendTimeoutDuration + "' ms.", reasonCodes.TIMEOUT);
            }, this.sendTimeoutDuration);

            this._c.send(elem);
            this._c.streamManagement.requestAcknowledgement();

        } else {
            _fail("An active connection is required to send a message", reasonCodes.NOCONNECTION);
        }

    },

    addEventListener: function (type, callback) {
        if (this._eventListeners[type] === undefined) {
            this._eventListeners[type] = [];
        }
        this._eventListeners[type].push(callback);
    },

    removeEventListener: function (type, callback) {
        var scope = this;
        if (!this._eventListeners[type]) return;
        this._eventListeners[type].forEach(function (cCallback, idx) {
            if (cCallback === callback) {
                scope._eventListeners[type].splice(idx, 1);
            }
        });
    },

    _dispatchEvent: function (type, data) {
        if (this._eventListeners[type] !== undefined) {
            this._eventListeners[type].forEach(function (callback) {
                callback(data);
            });
        }
    }

});

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  SHA-1 implementation in JavaScript                  (c) Chris Veness 2002-2014 / MIT Licence  */
/*                                                                                                */
/*  - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                              */
/*        http://csrc.nist.gov/groups/ST/toolkit/examples.html                                    */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/* jshint node:true *//* global define, escape, unescape */
'use strict';


/**
 * SHA-1 hash function reference implementation.
 *
 * @namespace
 */
var Sha1 = {};


/**
 * Generates SHA-1 hash of string.
 *
 * @param   {string} msg - (Unicode) string to be hashed.
 * @returns {string} Hash of msg as hex character string.
 */
Sha1.hash = function(msg) {
    // convert string to UTF-8, as SHA only deals with byte-streams
    msg = msg.utf8Encode();

    // constants [4.2.1]
    var K = [ 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6 ];

    // PREPROCESSING

    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [5.1.1]

    // convert string msg into 512-bit/16-integer blocks arrays of ints [5.2.1]
    var l = msg.length/4 + 2; // length (in 32-bit integers) of msg + 1 + appended length
    var N = Math.ceil(l/16);  // number of 16-integer-blocks required to hold 'l' ints
    var M = new Array(N);

    for (var i=0; i<N; i++) {
        M[i] = new Array(16);
        for (var j=0; j<16; j++) {  // encode 4 chars per integer, big-endian encoding
            M[i][j] = (msg.charCodeAt(i*64+j*4)<<24) | (msg.charCodeAt(i*64+j*4+1)<<16) |
                (msg.charCodeAt(i*64+j*4+2)<<8) | (msg.charCodeAt(i*64+j*4+3));
        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0
    }
    // add length (in bits) into final pair of 32-bit integers (big-endian) [5.1.1]
    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts
    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators
    M[N-1][14] = ((msg.length-1)*8) / Math.pow(2, 32); M[N-1][14] = Math.floor(M[N-1][14]);
    M[N-1][15] = ((msg.length-1)*8) & 0xffffffff;

    // set initial hash value [5.3.1]
    var H0 = 0x67452301;
    var H1 = 0xefcdab89;
    var H2 = 0x98badcfe;
    var H3 = 0x10325476;
    var H4 = 0xc3d2e1f0;

    // HASH COMPUTATION [6.1.2]

    var W = new Array(80); var a, b, c, d, e;
    for (var i=0; i<N; i++) {

        // 1 - prepare message schedule 'W'
        for (var t=0;  t<16; t++) W[t] = M[i][t];
        for (var t=16; t<80; t++) W[t] = Sha1.ROTL(W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16], 1);

        // 2 - initialise five working variables a, b, c, d, e with previous hash value
        a = H0; b = H1; c = H2; d = H3; e = H4;

        // 3 - main loop
        for (var t=0; t<80; t++) {
            var s = Math.floor(t/20); // seq for blocks of 'f' functions and 'K' constants
            var T = (Sha1.ROTL(a,5) + Sha1.f(s,b,c,d) + e + K[s] + W[t]) & 0xffffffff;
            e = d;
            d = c;
            c = Sha1.ROTL(b, 30);
            b = a;
            a = T;
        }

        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')
        H0 = (H0+a) & 0xffffffff;
        H1 = (H1+b) & 0xffffffff;
        H2 = (H2+c) & 0xffffffff;
        H3 = (H3+d) & 0xffffffff;
        H4 = (H4+e) & 0xffffffff;
    }

    return Sha1.toHexStr(H0) + Sha1.toHexStr(H1) + Sha1.toHexStr(H2) +
        Sha1.toHexStr(H3) + Sha1.toHexStr(H4);
};


/**
 * Function 'f' [4.1.1].
 * @private
 */
Sha1.f = function(s, x, y, z)  {
    switch (s) {
        case 0: return (x & y) ^ (~x & z);           // Ch()
        case 1: return  x ^ y  ^  z;                 // Parity()
        case 2: return (x & y) ^ (x & z) ^ (y & z);  // Maj()
        case 3: return  x ^ y  ^  z;                 // Parity()
    }
};

/**
 * Rotates left (circular left shift) value x by n positions [3.2.5].
 * @private
 */
Sha1.ROTL = function(x, n) {
    return (x<<n) | (x>>>(32-n));
};


/**
 * Hexadecimal representation of a number.
 * @private
 */
Sha1.toHexStr = function(n) {
    // note can't use toString(16) as it is implementation-dependant,
    // and in IE returns signed numbers when used on full words
    var s="", v;
    for (var i=7; i>=0; i--) { v = (n>>>(i*4)) & 0xf; s += v.toString(16); }
    return s;
};


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */


/** Extend String object with method to encode multi-byte string to utf8
 *  - monsur.hossa.in/2012/07/20/utf-8-in-javascript.html */
if (typeof String.prototype.utf8Encode == 'undefined') {
    String.prototype.utf8Encode = function() {
        return unescape( encodeURIComponent( this ) );
    };
}

/** Extend String object with method to decode utf8 string to multi-byte */
if (typeof String.prototype.utf8Decode == 'undefined') {
    String.prototype.utf8Decode = function() {
        try {
            return decodeURIComponent( escape( this ) );
        } catch (e) {
            return this; // invalid UTF-8? return as-is
        }
    };
}

/**
 * Copyright  CommonTime Ltd. 2016.
 */
Strophe.addConnectionPlugin('httpFileUpload', {
    _c: null,

    init: function (connection) {
        this._c = connection;
        Strophe.addNamespace('HTTP_FILE_UPLOAD', 'urn:xmpp:http:upload');
    },

    slot: function (jid, filename, fileSize, contentType, successCallback, errorCallback) {
        var id = this._c.getUniqueId('httpFileUpload');
        var slotReq = $iq({
                to: jid,
                type: 'get',
                id: id
            })
            .c('request', {xmlns: Strophe.NS.HTTP_FILE_UPLOAD})
            .c('filename', null, filename)
            .c('size', null, fileSize)
            .c('content-type', null, contentType);

        this._c.sendIQ(slotReq, function($xml) {
            var $slot = $xml.getElementsByTagName("slot")[0];
            if ($slot !== undefined) {
                var result = {
                    "put": null,
                    "get": null
                };
                var $put = $slot.getElementsByTagName("put")[0];
                if ($put !== undefined) {
                    result.put = Strophe.getText($put);
                }
                var $get = $slot.getElementsByTagName("get")[0];
                if ($get !== undefined) {
                    result.get = Strophe.getText($get);
                }
                successCallback(result);
            } else {
                errorCallback("Couldn't get slot.");
            }
        }, errorCallback);
    }

});
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
r=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
2),16)<<24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},
u=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,
d)).finalize(c)}}});var t=f.algo={};return f}(Math);
(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64>n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t<=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64>p;p++){if(16>p)a[p]=
c[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+a[p-7]+((l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10)+a[p-16]}k=q+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&m^~h&n)+r[p]+a[p];l=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);
(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;"string"==typeof g&&(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes>m&&(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j<h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=
this._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();

(function () {

    // May need to change these
    var _deviceReadyTimeout = 5000,
        provisioning = null,
        isFromStudio = false,
        _isDevice = window.cordova !== false,
        _deviceReady = false,
        _popupActive = false;

    function popupConfirmation(event, successCallback, dismissCallback) {
        if (!_popupActive) {
            _popupActive = true;
            document.querySelectorAll("#version-modal .version-number")[0].innerText = event.detail.version;
            var versionModal = document.getElementById("version-modal");
            versionModal.style.display = "block";

            document.querySelectorAll("#version-modal .confirm-button")[0].addEventListener("click", function () {
                _popupActive = false;
                versionModal.style.display = "none";
                if (successCallback !== undefined) {
                    successCallback();
                }
            });

            document.querySelectorAll("#version-modal .dismiss-button")[0].addEventListener("click", function () {
                _popupActive = false;
                versionModal.style.display = "none";
                if (dismissCallback !== undefined) {
                    dismissCallback();
                }
            });
        }
    }

    function onUpdateAvailable(event) {
        popupConfirmation(event, function () {
            provisioning.installVersion(function () {
                provisioning.restartApplication(function () {

                }, function () {
                    // eslint-disable-next-line no-console
                    console.error("Provisioning failed to restart and install new version");
                });
            }, function () {
                // eslint-disable-next-line no-console
                console.error("Provisioning failed to update");
            }, {"version": event.detail.version});
        },
        function () {
            // eslint-disable-next-line no-console
            console.info("Update postponed.");
        });
    }

    function addAppDirective() {
        var schemaFile = document.body.getAttribute("data-schema");
        var appElement = window.document.querySelectorAll("body div.view-frame")[0];
        appElement.setAttribute("md-app", "" + (isFromStudio ? "" : (!schemaFile ? "config.json" : schemaFile)));
        /* in your js file */
        angular.element(document).ready(function () {
            angular.bootstrap(document, ["app"]);
        });

    }

    function onDeviceReady() {
        _deviceReady = true;

        // if not from the studio and
        // the plugins object is available and the plugin we want is available
        if (!isFromStudio && window.plugins !== undefined && window.plugins !== null && window.plugins.provisioning !== undefined && window.plugins.provisioning !== null) {
            provisioning = window.plugins.provisioning;
            document.addEventListener("updateavailable", onUpdateAvailable, false);
            addAppDirective();
        } else {
            addAppDirective();
        }
    }

    function init() {
        var appName = localStorage.getItem("appName");
        isFromStudio = appName !== undefined && appName !== null;

        if (_isDevice) {
            document.addEventListener("deviceready", onDeviceReady, false);
            setTimeout(function () {
                // if deviceready was never called, force the app to load
                if (!_deviceReady) {
                    // eslint-disable-next-line no-console
                    console.error("deviceready was not fired");
                    addAppDirective();
                }
            }, _deviceReadyTimeout);
        } else {
            addAppDirective();
        }
    }

    document.addEventListener("DOMContentLoaded", init, false);
})();
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var h=CryptoJS,j=h.lib.WordArray;h.enc.Base64={stringify:function(b){var e=b.words,f=b.sigBytes,c=this._map;b.clamp();b=[];for(var a=0;a<f;a+=3)for(var d=(e[a>>>2]>>>24-8*(a%4)&255)<<16|(e[a+1>>>2]>>>24-8*((a+1)%4)&255)<<8|e[a+2>>>2]>>>24-8*((a+2)%4)&255,g=0;4>g&&a+0.75*g<f;g++)b.push(c.charAt(d>>>6*(3-g)&63));if(e=c.charAt(64))for(;b.length%4;)b.push(e);return b.join("")},parse:function(b){var e=b.length,f=this._map,c=f.charAt(64);c&&(c=b.indexOf(c),-1!=c&&(e=c));for(var c=[],a=0,d=0;d<
e;d++)if(d%4){var g=f.indexOf(b.charAt(d-1))<<2*(d%4),h=f.indexOf(b.charAt(d))>>>6-2*(d%4);c[a>>>2]|=(g|h)<<24-8*(a%4);a++}return j.create(c,a)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();

/* Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.*/
(function(a){function b(a){return a&&a.Object===Object?a:null}function c(a){for(var b=[],c=0,d=a.length;d>c;c++)b.push(a[c]);return b}function d(a){return function(){try{return a.apply(this,arguments)}catch(b){return Za.e=b,Za}}}function e(a){throw a}function f(a,b){if(_a&&b.stack&&"object"==typeof a&&null!==a&&a.stack&&-1===a.stack.indexOf(db)){for(var c=[],d=b;d;d=d.source)d.stack&&c.unshift(d.stack);c.unshift(a.stack);var e=c.join("\n"+db+"\n");a.stack=g(e)}}function g(a){for(var b=a.split("\n"),c=[],d=0,e=b.length;e>d;d++){var f=b[d];h(f)||i(f)||!f||c.push(f)}return c.join("\n")}function h(a){var b=k(a);if(!b)return!1;var c=b[0],d=b[1];return c===bb&&d>=cb&&Gg>=d}function i(a){return-1!==a.indexOf("(module.js:")||-1!==a.indexOf("(node.js:")}function j(){if(_a)try{throw new Error}catch(a){var b=a.stack.split("\n"),c=b[0].indexOf("@")>0?b[1]:b[2],d=k(c);if(!d)return;return bb=d[0],d[1]}}function k(a){var b=/at .+ \((.+):(\d+):(?:\d+)\)$/.exec(a);if(b)return[b[1],Number(b[2])];var c=/at ([^ ]+):(\d+):(?:\d+)$/.exec(a);if(c)return[c[1],Number(c[2])];var d=/.*@(.+):(\d+)$/.exec(a);return d?[d[1],Number(d[2])]:void 0}function l(b,c,d,e,f,g){var h=Sb(b),i=h.length,j=Sb(c),k=j.length;if(i!==k&&!e)return!1;for(var l,m=i;m--;)if(l=h[m],!(e?l in c:Pb.call(c,l)))return!1;for(var n=e;++m<i;){l=h[m];var o,p=b[l],q=c[l];if(!(o===a?d(p,q,e,f,g):o))return!1;n||(n="constructor"===l)}if(!n){var r=b.constructor,s=c.constructor;if(r!==s&&"constructor"in b&&"constructor"in c&&!("function"==typeof r&&r instanceof r&&"function"==typeof s&&s instanceof s))return!1}return!0}function m(a,b,c){switch(c){case sb:case tb:return+a===+b;case ub:return a.name===b.name&&a.message===b.message;case xb:return a!==+a?b!==+b:a===+b;case zb:case Bb:return a===b+""}return!1}function n(a){return!!a&&"object"==typeof a}function o(a){return"number"==typeof a&&a>-1&&a%1===0&&Rb>=a}function p(a){return n(a)&&o(a.length)&&!!Nb[Qb.call(a)]}function q(a,b){for(var c=-1,d=a.length;++c<d;)if(b(a[c],c,a))return!0;return!1}function r(b,c,d,e,f,g){var h=-1,i=b.length,j=c.length;if(i!==j&&!(e&&j>i))return!1;for(;++h<i;){var k,l=b[h],m=c[h];if(k!==a){if(k)continue;return!1}if(e){if(!q(c,function(a){return l===a||d(l,a,e,f,g)}))return!1}else if(l!==m&&!d(l,m,e,f,g))return!1}return!0}function s(a,b,c,d,e,f){var g=Ub(a),h=Ub(b),i=rb,j=rb;g||(i=Qb.call(a),i===qb?i=yb:i!==yb&&(g=p(a))),h||(j=Qb.call(b),j===qb&&(j=yb));var k=i===yb&&!Tb(a),n=j===yb&&!Tb(b),o=i===j;if(o&&!g&&!k)return m(a,b,i);if(!d){var q=k&&Pb.call(a,"__wrapped__"),s=n&&Pb.call(b,"__wrapped__");if(q||s)return c(q?a.value():a,s?b.value():b,d,e,f)}if(!o)return!1;e||(e=[]),f||(f=[]);for(var t=e.length;t--;)if(e[t]===a)return f[t]===b;e.push(a),f.push(b);var u=(g?r:l)(a,b,c,d,e,f);return e.pop(),f.pop(),u}function t(a,b,c,d,e){return a===b?!0:null==a||null==b||!ba(a)&&!n(b)?a!==a&&b!==b:s(a,b,t,c,d,e)}function u(a,b){for(var c=new Array(a),d=0;a>d;d++)c[d]=b();return c}function v(a,b){this.id=a,this.value=b}function w(a,b){this.scheduler=a,this.disposable=b,this.isDisposed=!1}function x(a,b){b.isDisposed||(b.isDisposed=!0,b.disposable.dispose())}function y(a){this._s=a,this.isDisposed=!1}function z(a){this._s=a}function A(a){this._s=a,this._l=a.length,this._i=0}function B(a){this._a=a}function C(a){this._a=a,this._l=G(a),this._i=0}function D(a){return"number"==typeof a&&Pa.isFinite(a)}function E(b){var c,d=b[kb];if(!d&&"string"==typeof b)return c=new z(b),c[kb]();if(!d&&b.length!==a)return c=new B(b),c[kb]();if(!d)throw new TypeError("Object is not iterable");return b[kb]()}function F(a){var b=+a;return 0===b?b:isNaN(b)?b:0>b?-1:1}function G(a){var b=+a.length;return isNaN(b)?0:0!==b&&D(b)?(b=F(b)*Math.floor(Math.abs(b)),0>=b?0:b>ld?ld:b):b}function H(a,b){return pc(a)||(a=wc),new nd(b,a)}function I(a,b){this.observer=a,this.parent=b}function J(a,b){return a.amb(b)}function K(){return!1}function L(){for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];return b}function K(){return!1}function L(){for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];return b}function K(){return!1}function M(){return[]}function K(){return!1}function M(){return[]}function L(){for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];return b}function N(a){return function(b){return a.subscribe(b)}}function O(a){return a.toArray()}function P(a){return a.length>0}function Q(a){return{"@@iterator":function(){return{next:function(){return{done:!1,value:a}}}}}}function Q(a){return{"@@iterator":function(){return{next:function(){return{done:!1,value:a}}}}}}function R(a,b,c){var d=ob(b,c,3);return a.map(function(b,c){var e=d(b,c,a);return Xa(e)&&(e=dd(e)),(nb(e)||mb(e))&&(e=md(e)),e}).concatAll()}function S(a,b,c){for(var d=0,e=a.length;e>d;d++)if(c(a[d],b))return d;return-1}function T(a){this.comparer=a,this.set=[]}function U(b,c){return function(d){for(var e=d,f=0;c>f;f++){var g=e[b[f]];if("undefined"==typeof g)return a;e=g}return e}}function V(a){if(0===a.length)throw new eb;return a[0]}function W(a,b,c,d){var e=ob(b,c,3);return new xg(function(b){return a.subscribe(new gf(b,a,e,d))},a)}function X(a){return a?Sc.isObservable(a)?a:Xa(a)?Sc.fromPromise(a):aa(a)||_(a)?qf.call(this,a):Ya(a)?$.call(this,a):nb(a)||mb(a)?Y.call(this,a):ba(a)?Z.call(this,a):a:a}function Y(a){return Sc.from(a).concatMap(function(a){return Sc.isObservable(a)||ba(a)?X.call(null,a):Qa.Observable.just(a)}).toArray()}function Z(b){function c(b,c){d[c]=a,f.push(b.map(function(a){d[c]=a}))}for(var d=new b.constructor,e=Object.keys(b),f=[],g=0,h=e.length;h>g;g++){var i=e[g],j=X.call(this,b[i]);j&&Sc.isObservable(j)?c(j,i):d[i]=b[i]}return Sc.forkJoin.apply(Sc,f).map(function(){return d})}function $(a){var b=this;return new xg(function(c){a.call(b,function(){var a=arguments[0],b=arguments[1];if(a)return c.onError(a);if(arguments.length>2){for(var d=[],e=1,f=arguments.length;f>e;e++)d.push(arguments[e]);b=d}c.onNext(b),c.onCompleted()})})}function _(a){return Ya(a.next)&&Ya(a["throw"])}function aa(a){var b=a.constructor;return b?"GeneratorFunction"===b.name||"GeneratorFunction"===b.displayName?!0:_(b.prototype):!1}function ba(a){return Object==a.constructor}function ca(a,b,c,d){var e=new Cg;return d.push(da(e,b,c)),a.apply(b,d),e.asObservable()}function da(a,b,c){return function(){for(var d=arguments.length,e=new Array(d),f=0;d>f;f++)e[f]=arguments[f];if(Ya(c)){if(e=$a(c).apply(b,e),e===Za)return a.onError(e.e);a.onNext(e)}else e.length<=1?a.onNext(e[0]):a.onNext(e);a.onCompleted()}}function ea(a,b,c,d){var e=new Cg;return d.push(fa(e,b,c)),a.apply(b,d),e.asObservable()}function fa(a,b,c){return function(){var d=arguments[0];if(d)return a.onError(d);for(var e=arguments.length,f=[],g=1;e>g;g++)f[g-1]=arguments[g];if(Ya(c)){var f=$a(c).apply(b,f);if(f===Za)return a.onError(f.e);a.onNext(f)}else f.length<=1?a.onNext(f[0]):a.onNext(f);a.onCompleted()}}function ga(a){return Pa.StaticNodeList?a instanceof Pa.StaticNodeList||a instanceof Pa.NodeList:"[object NodeList]"===Object.prototype.toString.call(a)}function ha(a,b,c){this._e=a,this._n=b,this._fn=c,this._e.addEventListener(this._n,this._fn,!1),this.isDisposed=!1}function ia(a,b,c){var d=new _b,e=Object.prototype.toString.call(a);if(ga(a)||"[object HTMLCollection]"===e)for(var f=0,g=a.length;g>f;f++)d.add(ia(a.item(f),b,c));else a&&d.add(new ha(a,b,c));return d}function ja(a,b,c){return new xg(function(d){function e(a,b){if(j[b]=a,g[b]=!0,h||(h=g.every(Sa))){if(f)return d.onError(f);var e=$a(c).apply(null,j);if(e===Za)return d.onError(e.e);d.onNext(e)}i&&j[1]&&d.onCompleted()}var f,g=[!1,!1],h=!1,i=!1,j=new Array(2);return new jc(a.subscribe(function(a){e(a,0)},function(a){j[1]?d.onError(a):f=a},function(){i=!0,j[1]&&d.onCompleted()}),b.subscribe(function(a){e(a,1)},function(a){d.onError(a)},function(){i=!0,e(!0,1)}))},a)}function O(a){return a.toArray()}function ka(a,b){return a.groupJoin(this,b,jd,function(a,b){return b})}function la(a){var b=this;return new xg(function(c){var d=new Bg,e=new _b,f=new lc(e);return c.onNext(Yb(d,f)),e.add(b.subscribe(function(a){d.onNext(a)},function(a){d.onError(a),c.onError(a)},function(){d.onCompleted(),c.onCompleted()})),Xa(a)&&(a=dd(a)),e.add(a.subscribe(function(a){d.onCompleted(),d=new Bg,c.onNext(Yb(d,f))},function(a){d.onError(a),c.onError(a)},function(){d.onCompleted(),c.onCompleted()})),f},b)}function ma(a){var b=this;return new xg(function(c){function d(){var b;try{b=a()}catch(f){return void c.onError(f)}Xa(b)&&(b=dd(b));var i=new hc;e.setDisposable(i),i.setDisposable(b.take(1).subscribe(Ra,function(a){h.onError(a),c.onError(a)},function(){h.onCompleted(),h=new Bg,c.onNext(Yb(h,g)),d()}))}var e=new ic,f=new _b(e),g=new lc(f),h=new Bg;return c.onNext(Yb(h,g)),f.add(b.subscribe(function(a){h.onNext(a)},function(a){h.onError(a),c.onError(a)},function(){h.onCompleted(),c.onCompleted()})),d(),g},b)}function na(a,b){return new Hf(a,b)}function L(){for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];return b}function oa(a){this.patterns=a}function pa(a,b){this.expression=a,this.selector=b}function qa(a){return function(b){a.onError(b)}}function ra(a,b){return function(){var c=$a(a.selector).apply(a,arguments);return c===Za?b.onError(c.e):void b.onNext(c)}}function sa(a,b,c){var d=a.get(b);if(!d){var e=new Pf(b,c);return a.set(b,e),e}return d}function ta(a,b,c){this.joinObserverArray=a,this.onNext=b,this.onCompleted=c,this.joinObservers=new Of;for(var d=0,e=this.joinObserverArray.length;e>d;d++){var f=this.joinObserverArray[d];this.joinObservers.set(f,f)}}function ua(a,b){return new Qf(a,b)}function va(a,b,c){return new xg(function(d){var e=a,f=oc(b);return c.scheduleRecursiveFuture(0,e,function(a,b){if(f>0){var g=c.now();e=new Date(e.getTime()+f),e.getTime()<=g&&(e=new Date(g+f))}d.onNext(a),b(a+1,new Date(e))})})}function wa(a,b,c){return a===b?new xg(function(a){return c.schedulePeriodic(0,b,function(b){return a.onNext(b),b+1})}):gd(function(){return va(new Date(c.now()+a),b,c)})}function xa(a,b,c){return new xg(function(d){var e,f=!1,g=new ic,h=null,i=[],j=!1;return e=a.materialize().timestamp(c).subscribe(function(a){var e,k;"E"===a.value.kind?(i=[],i.push(a),h=a.value.error,k=!j):(i.push({value:a.value,timestamp:a.timestamp+b}),k=!f,f=!0),k&&(null!==h?d.onError(h):(e=new hc,g.setDisposable(e),e.setDisposable(c.scheduleRecursiveFuture(null,b,function(a,b){var e,g,k,l;if(null===h){j=!0;do k=null,i.length>0&&i[0].timestamp-c.now()<=0&&(k=i.shift().value),null!==k&&k.accept(d);while(null!==k);l=!1,g=0,i.length>0?(l=!0,g=Math.max(0,i[0].timestamp-c.now())):f=!1,e=h,j=!1,null!==e?d.onError(e):l&&b(null,g)}}))))}),new jc(e,g)},a)}function ya(a,b,c){return gd(function(){return xa(a,b-c.now(),c)})}function za(a,b,c){var d,e;return Ya(b)?e=b:(d=b,e=c),new xg(function(b){function c(){i.setDisposable(a.subscribe(function(a){var c=$a(e)(a);if(c===Za)return b.onError(c.e);var d=new hc;g.add(d),d.setDisposable(c.subscribe(function(){b.onNext(a),g.remove(d),f()},function(a){b.onError(a)},function(){b.onNext(a),g.remove(d),f()}))},function(a){b.onError(a)},function(){h=!0,i.dispose(),f()}))}function f(){h&&0===g.length&&b.onCompleted()}var g=new _b,h=!1,i=new ic;return d?i.setDisposable(d.subscribe(c,function(a){b.onError(a)},c)):c(),new jc(i,g)},a)}function Aa(a,b){return new xg(function(c){var d,e=!1,f=new ic,g=0,h=a.subscribe(function(a){var h=$a(b)(a);if(h===Za)return c.onError(h.e);Xa(h)&&(h=dd(h)),e=!0,d=a,g++;var i=g,j=new hc;f.setDisposable(j),j.setDisposable(h.subscribe(function(){e&&g===i&&c.onNext(d),e=!1,j.dispose()},function(a){c.onError(a)},function(){e&&g===i&&c.onNext(d),e=!1,j.dispose()}))},function(a){f.dispose(),c.onError(a),e=!1,g++},function(){f.dispose(),e&&c.onNext(d),c.onCompleted(),e=!1,g++});return new jc(h,f)},a)}function O(a){return a.toArray()}function O(a){return a.toArray()}function Ba(a,b,c,d){return Ya(b)&&(d=c,c=b,b=sd()),Sc.isObservable(d)||(d=yd(new _f)),new xg(function(e){function f(a){function b(){return l=c===k}var c=k,f=new hc;i.setDisposable(f),f.setDisposable(a.subscribe(function(){b()&&h.setDisposable(d.subscribe(e)),f.dispose()},function(a){b()&&e.onError(a)},function(){b()&&h.setDisposable(d.subscribe(e))}))}function g(){var a=!l;return a&&k++,a}var h=new ic,i=new ic,j=new hc;h.setDisposable(j);var k=0,l=!1;return f(b),j.setDisposable(a.subscribe(function(a){if(g()){e.onNext(a);var b=$a(c)(a);if(b===Za)return e.onError(b.e);f(Xa(b)?dd(b):b)}},function(a){g()&&e.onError(a)},function(){g()&&e.onCompleted()})),new jc(h,i)},a)}function Ca(a,b,c,d){return pc(c)&&(d=c,c=yd(new _f)),c instanceof Error&&(c=yd(c)),pc(d)||(d=Bc),Sc.isObservable(c)||(c=yd(new _f)),new xg(function(e){function f(){var a=g;k.setDisposable(d.scheduleFuture(null,b,function(){j=g===a,j&&(Xa(c)&&(c=dd(c)),i.setDisposable(c.subscribe(e)))}))}var g=0,h=new hc,i=new ic,j=!1,k=new ic;return i.setDisposable(h),f(),h.setDisposable(a.subscribe(function(a){j||(g++,e.onNext(a),f())},function(a){j||(g++,e.onError(a))},function(){j||(g++,e.onCompleted())})),new jc(i,k)},a)}function Da(a){return{"@@transducer/init":function(){return a},"@@transducer/step":function(a,b){return a.onNext(b)},"@@transducer/result":function(a){return a.onCompleted()}}}function Ea(a){this.predicate=a}function Fa(a){this.predicate=a}function Ga(a,b){var c=this;this.scheduler=a,this.messages=b,this.subscriptions=[],this.observers=[];for(var d=0,e=this.messages.length;e>d;d++){var f=this.messages[d],g=f.value;!function(b){a.scheduleAbsolute(null,f.time,function(){for(var a=c.observers.slice(0),d=0,e=a.length;e>d;d++)b.accept(a[d]);return dc})}(g)}}var Ha={"function":!0,object:!0},Ia=Ha[typeof exports]&&exports&&!exports.nodeType?exports:null,Ja=Ha[typeof module]&&module&&!module.nodeType?module:null,Ka=b(Ia&&Ja&&"object"==typeof global&&global),La=b(Ha[typeof self]&&self),Ma=b(Ha[typeof window]&&window),Na=Ja&&Ja.exports===Ia?Ia:null,Oa=b(Ha[typeof this]&&this),Pa=Ka||Ma!==(Oa&&Oa.window)&&Ma||La||Oa||Function("return this")(),Qa={internals:{},config:{Promise:Pa.Promise},helpers:{}},Ra=Qa.helpers.noop=function(){},Sa=Qa.helpers.identity=function(a){return a},Ta=Qa.helpers.defaultNow=Date.now,Ua=Qa.helpers.defaultComparer=function(a,b){return Vb(a,b)},Va=Qa.helpers.defaultSubComparer=function(a,b){return a>b?1:b>a?-1:0},Wa=(Qa.helpers.defaultKeySerializer=function(a){return a.toString()},Qa.helpers.defaultError=function(a){throw a}),Xa=Qa.helpers.isPromise=function(a){return!!a&&"function"!=typeof a.subscribe&&"function"==typeof a.then},Ya=Qa.helpers.isFunction=function(){var a=function(a){return"function"==typeof a||!1};return a(/x/)&&(a=function(a){return"function"==typeof a&&"[object Function]"==toString.call(a)}),a}(),Za={e:{}},$a=Qa.internals.tryCatch=function(a){if(!Ya(a))throw new TypeError("fn must be a function");return d(a)};Qa.config.longStackSupport=!1;var _a=!1,ab=$a(function(){throw new Error})();_a=!!ab.e&&!!ab.e.stack;var bb,cb=j(),db="From previous event:",eb=Qa.EmptyError=function(){this.message="Sequence contains no elements.",Error.call(this)};eb.prototype=Object.create(Error.prototype),eb.prototype.name="EmptyError";var fb=Qa.ObjectDisposedError=function(){this.message="Object has been disposed",Error.call(this)};fb.prototype=Object.create(Error.prototype),fb.prototype.name="ObjectDisposedError";var gb=Qa.ArgumentOutOfRangeError=function(){this.message="Argument out of range",Error.call(this)};gb.prototype=Object.create(Error.prototype),gb.prototype.name="ArgumentOutOfRangeError";var hb=Qa.NotSupportedError=function(a){this.message=a||"This operation is not supported",Error.call(this)};hb.prototype=Object.create(Error.prototype),hb.prototype.name="NotSupportedError";var ib=Qa.NotImplementedError=function(a){this.message=a||"This operation is not implemented",Error.call(this)};ib.prototype=Object.create(Error.prototype),ib.prototype.name="NotImplementedError";var jb=Qa.helpers.notImplemented=function(){throw new ib},kb=(Qa.helpers.notSupported=function(){throw new hb},"function"==typeof Symbol&&Symbol.iterator||"_es6shim_iterator_");Pa.Set&&"function"==typeof(new Pa.Set)["@@iterator"]&&(kb="@@iterator");var lb=Qa.doneEnumerator={done:!0,value:a},mb=Qa.helpers.isIterable=function(b){return b&&b[kb]!==a},nb=Qa.helpers.isArrayLike=function(b){return b&&b.length!==a};Qa.helpers.iterator=kb;var ob=Qa.internals.bindCallback=function(a,b,c){if("undefined"==typeof b)return a;switch(c){case 0:return function(){return a.call(b)};case 1:return function(c){return a.call(b,c)};case 2:return function(c,d){return a.call(b,c,d)};case 3:return function(c,d,e){return a.call(b,c,d,e)}}return function(){return a.apply(b,arguments)}},pb=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],qb=(pb.length,"[object Arguments]"),rb="[object Array]",sb="[object Boolean]",tb="[object Date]",ub="[object Error]",vb="[object Function]",wb="[object Map]",xb="[object Number]",yb="[object Object]",zb="[object RegExp]",Ab="[object Set]",Bb="[object String]",Cb="[object WeakMap]",Db="[object ArrayBuffer]",Eb="[object Float32Array]",Fb="[object Float64Array]",Gb="[object Int8Array]",Hb="[object Int16Array]",Ib="[object Int32Array]",Jb="[object Uint8Array]",Kb="[object Uint8ClampedArray]",Lb="[object Uint16Array]",Mb="[object Uint32Array]",Nb={};Nb[Eb]=Nb[Fb]=Nb[Gb]=Nb[Hb]=Nb[Ib]=Nb[Jb]=Nb[Kb]=Nb[Lb]=Nb[Mb]=!0,Nb[qb]=Nb[rb]=Nb[Db]=Nb[sb]=Nb[tb]=Nb[ub]=Nb[vb]=Nb[wb]=Nb[xb]=Nb[yb]=Nb[zb]=Nb[Ab]=Nb[Bb]=Nb[Cb]=!1;var Ob=Object.prototype,Pb=Ob.hasOwnProperty,Qb=Ob.toString,Rb=Math.pow(2,53)-1,Sb=Object.keys||function(){var a=Object.prototype.hasOwnProperty,b=!{toString:null}.propertyIsEnumerable("toString"),c=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=c.length;return function(e){if("object"!=typeof e&&("function"!=typeof e||null===e))throw new TypeError("Object.keys called on non-object");var f,g,h=[];for(f in e)a.call(e,f)&&h.push(f);if(b)for(g=0;d>g;g++)a.call(e,c[g])&&h.push(c[g]);return h}}(),ba=Qa.internals.isObject=function(a){var b=typeof a;return!!a&&("object"===b||"function"===b)},Tb=function(){try{Object({toString:0}+"")}catch(a){return function(){return!1}}return function(a){return"function"!=typeof a.toString&&"string"==typeof(a+"")}}(),Ub=Array.isArray||function(a){return n(a)&&o(a.length)&&Qb.call(a)===rb},Vb=Qa.internals.isEqual=function(a,b){return t(a,b)},Wb=({}.hasOwnProperty,Array.prototype.slice,Qa.internals.inherits=function(a,b){function c(){this.constructor=a}c.prototype=b.prototype,a.prototype=new c}),Xb=Qa.internals.addProperties=function(a){for(var b=[],c=1,d=arguments.length;d>c;c++)b.push(arguments[c]);for(var e=0,f=b.length;f>e;e++){var g=b[e];for(var h in g)a[h]=g[h]}},Yb=Qa.internals.addRef=function(a,b){return new xg(function(c){return new jc(b.getDisposable(),a.subscribe(c))})};v.prototype.compareTo=function(a){var b=this.value.compareTo(a.value);return 0===b&&(b=this.id-a.id),b};var Zb=Qa.internals.PriorityQueue=function(a){this.items=new Array(a),this.length=0},$b=Zb.prototype;$b.isHigherPriority=function(a,b){return this.items[a].compareTo(this.items[b])<0},$b.percolate=function(a){if(!(a>=this.length||0>a)){var b=a-1>>1;if(!(0>b||b===a)&&this.isHigherPriority(a,b)){var c=this.items[a];this.items[a]=this.items[b],this.items[b]=c,this.percolate(b)}}},$b.heapify=function(a){if(+a||(a=0),!(a>=this.length||0>a)){var b=2*a+1,c=2*a+2,d=a;if(b<this.length&&this.isHigherPriority(b,d)&&(d=b),c<this.length&&this.isHigherPriority(c,d)&&(d=c),d!==a){var e=this.items[a];this.items[a]=this.items[d],this.items[d]=e,this.heapify(d)}}},$b.peek=function(){return this.items[0].value},$b.removeAt=function(b){this.items[b]=this.items[--this.length],this.items[this.length]=a,this.heapify()},$b.dequeue=function(){var a=this.peek();return this.removeAt(0),a},$b.enqueue=function(a){var b=this.length++;this.items[b]=new v(Zb.count++,a),this.percolate(b)},$b.remove=function(a){for(var b=0;b<this.length;b++)if(this.items[b].value===a)return this.removeAt(b),!0;return!1},Zb.count=0;var _b=Qa.CompositeDisposable=function(){var a,b,c=[];if(Array.isArray(arguments[0]))c=arguments[0];else for(b=arguments.length,c=new Array(b),a=0;b>a;a++)c[a]=arguments[a];this.disposables=c,this.isDisposed=!1,this.length=c.length},ac=_b.prototype;ac.add=function(a){this.isDisposed?a.dispose():(this.disposables.push(a),this.length++)},ac.remove=function(a){var b=!1;if(!this.isDisposed){var c=this.disposables.indexOf(a);-1!==c&&(b=!0,this.disposables.splice(c,1),this.length--,a.dispose())}return b},ac.dispose=function(){if(!this.isDisposed){this.isDisposed=!0;for(var a=this.disposables.length,b=new Array(a),c=0;a>c;c++)b[c]=this.disposables[c];for(this.disposables=[],this.length=0,c=0;a>c;c++)b[c].dispose()}};var bc=Qa.Disposable=function(a){this.isDisposed=!1,this.action=a||Ra};bc.prototype.dispose=function(){this.isDisposed||(this.action(),this.isDisposed=!0)};var cc=bc.create=function(a){return new bc(a)},dc=bc.empty={dispose:Ra},ec=bc.isDisposable=function(a){return a&&Ya(a.dispose)},fc=bc.checkDisposed=function(a){if(a.isDisposed)throw new fb},gc=bc._fixup=function(a){return ec(a)?a:dc},hc=Qa.SingleAssignmentDisposable=function(){this.isDisposed=!1,this.current=null};hc.prototype.getDisposable=function(){return this.current},hc.prototype.setDisposable=function(a){if(this.current)throw new Error("Disposable has already been assigned");var b=this.isDisposed;!b&&(this.current=a),b&&a&&a.dispose()},hc.prototype.dispose=function(){if(!this.isDisposed){this.isDisposed=!0;var a=this.current;this.current=null,a&&a.dispose()}};var ic=Qa.SerialDisposable=function(){this.isDisposed=!1,this.current=null};ic.prototype.getDisposable=function(){return this.current},ic.prototype.setDisposable=function(a){var b=this.isDisposed;if(!b){var c=this.current;this.current=a}c&&c.dispose(),b&&a&&a.dispose()},ic.prototype.dispose=function(){if(!this.isDisposed){this.isDisposed=!0;var a=this.current;this.current=null}a&&a.dispose()};var jc=Qa.BinaryDisposable=function(a,b){this._first=a,this._second=b,this.isDisposed=!1};jc.prototype.dispose=function(){if(!this.isDisposed){this.isDisposed=!0;var a=this._first;this._first=null,a&&a.dispose();var b=this._second;this._second=null,b&&b.dispose()}};var kc=Qa.NAryDisposable=function(a){this._disposables=a,this.isDisposed=!1};kc.prototype.dispose=function(){if(!this.isDisposed){this.isDisposed=!0;for(var a=0,b=this._disposables.length;b>a;a++)this._disposables[a].dispose();this._disposables.length=0}};var lc=Qa.RefCountDisposable=function(){function a(a){this.disposable=a,this.disposable.count++,this.isInnerDisposed=!1}function b(a){this.underlyingDisposable=a,this.isDisposed=!1,this.isPrimaryDisposed=!1,this.count=0}return a.prototype.dispose=function(){this.disposable.isDisposed||this.isInnerDisposed||(this.isInnerDisposed=!0,this.disposable.count--,0===this.disposable.count&&this.disposable.isPrimaryDisposed&&(this.disposable.isDisposed=!0,this.disposable.underlyingDisposable.dispose()))},b.prototype.dispose=function(){this.isDisposed||this.isPrimaryDisposed||(this.isPrimaryDisposed=!0,0===this.count&&(this.isDisposed=!0,this.underlyingDisposable.dispose()))},b.prototype.getDisposable=function(){return this.isDisposed?dc:new a(this)},b}();w.prototype.dispose=function(){this.scheduler.schedule(this,x)};var mc=Qa.internals.ScheduledItem=function(a,b,c,d,e){this.scheduler=a,this.state=b,this.action=c,this.dueTime=d,this.comparer=e||Va,this.disposable=new hc};mc.prototype.invoke=function(){this.disposable.setDisposable(this.invokeCore())},mc.prototype.compareTo=function(a){return this.comparer(this.dueTime,a.dueTime)},mc.prototype.isCancelled=function(){return this.disposable.isDisposed},mc.prototype.invokeCore=function(){return gc(this.action(this.scheduler,this.state))};var nc=Qa.Scheduler=function(){function a(){}a.isScheduler=function(b){return b instanceof a};var b=a.prototype;return b.schedule=function(a,b){throw new ib},b.scheduleFuture=function(b,c,d){var e=c;return e instanceof Date&&(e-=this.now()),e=a.normalize(e),0===e?this.schedule(b,d):this._scheduleFuture(b,e,d)},b._scheduleFuture=function(a,b,c){throw new ib},a.now=Ta,a.prototype.now=Ta,a.normalize=function(a){return 0>a&&(a=0),a},a}(),oc=nc.normalize,pc=nc.isScheduler;!function(a){function b(a,b){function c(b){function d(a,b){return g?f.remove(i):h=!0,e(b,c),dc}var g=!1,h=!1,i=a.schedule(b,d);h||(f.add(i),g=!0)}var d=b[0],e=b[1],f=new _b;return e(d,c),f}function c(a,b){function c(b,d){function g(a,b){return h?f.remove(j):i=!0,e(b,c),dc}var h=!1,i=!1,j=a.scheduleFuture(b,d,g);i||(f.add(j),h=!0)}var d=b[0],e=b[1],f=new _b;return e(d,c),f}a.scheduleRecursive=function(a,c){return this.schedule([a,c],b)},a.scheduleRecursiveFuture=function(a,b,d){return this.scheduleFuture([a,d],b,c)}}(nc.prototype),function(a){a.schedulePeriodic=function(a,b,c){if("undefined"==typeof Pa.setInterval)throw new hb;b=oc(b);var d=a,e=Pa.setInterval(function(){d=c(d)},b);return cc(function(){Pa.clearInterval(e)})}}(nc.prototype),function(a){a.catchError=a["catch"]=function(a){return new Cc(this,a)}}(nc.prototype);var qc,rc,sc=Qa.internals.SchedulePeriodicRecursive=function(){function a(a){return function(b,c){c(0,a._period);var d=$a(a._action)(a._state);d===Za&&(a._cancel.dispose(),e(d.e)),a._state=d}}function b(a,b,c,d){this._scheduler=a,this._state=b,this._period=c,this._action=d}return b.prototype.start=function(){var b=new hc;return this._cancel=b,b.setDisposable(this._scheduler.scheduleRecursiveFuture(0,this._period,a(this))),b},b}(),tc=function(a){function b(){a.call(this)}return Wb(b,a),b.prototype.schedule=function(a,b){return gc(b(this,a))},b}(nc),uc=nc.immediate=new tc,vc=function(a){function b(){for(;d.length>0;){var a=d.dequeue();!a.isCancelled()&&a.invoke()}}function c(){a.call(this)}var d;return Wb(c,a),c.prototype.schedule=function(a,c){var f=new mc(this,a,c,this.now());if(d)d.enqueue(f);else{d=new Zb(4),d.enqueue(f);var g=$a(b)();d=null,g===Za&&e(g.e)}return f.disposable},c.prototype.scheduleRequired=function(){return!d},c}(nc),wc=nc.currentThread=new vc,xc=function(){var a,b=Ra;if(Pa.setTimeout)a=Pa.setTimeout,b=Pa.clearTimeout;else{if(!Pa.WScript)throw new hb;a=function(a,b){Pa.WScript.Sleep(b),a()}}return{setTimeout:a,clearTimeout:b}}(),yc=xc.setTimeout,zc=xc.clearTimeout;!function(){function a(b){if(f)yc(function(){a(b)},0);else{var c=d[b];if(c){f=!0;var g=$a(c)();rc(b),f=!1,g===Za&&e(g.e)}}}function b(){if(!Pa.postMessage||Pa.importScripts)return!1;var a=!1,b=Pa.onmessage;return Pa.onmessage=function(){a=!0},Pa.postMessage("","*"),Pa.onmessage=b,a}var c=1,d={},f=!1;rc=function(a){delete d[a]};var g=new RegExp("^"+String(toString).replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/toString| for [^\]]+/g,".*?")+"$"),h="function"==typeof(h=Ka&&Na&&Ka.setImmediate)&&!g.test(h)&&h;if(Ya(h))qc=function(b){var e=c++;return d[e]=b,h(function(){a(e)}),e};else if("undefined"!=typeof process&&"[object process]"==={}.toString.call(process))qc=function(b){var e=c++;return d[e]=b,process.nextTick(function(){a(e)}),e};else if(b()){var i="ms.rx.schedule"+Math.random(),j=function(b){"string"==typeof b.data&&b.data.substring(0,i.length)===i&&a(b.data.substring(i.length))};Pa.addEventListener("message",j,!1),qc=function(a){var b=c++;return d[b]=a,Pa.postMessage(i+b,"*"),b}}else if(Pa.MessageChannel){var k=new Pa.MessageChannel;k.port1.onmessage=function(b){a(b.data)},qc=function(a){var b=c++;return d[b]=a,k.port2.postMessage(b),b}}else qc="document"in Pa&&"onreadystatechange"in Pa.document.createElement("script")?function(b){var e=Pa.document.createElement("script"),f=c++;return d[f]=b,e.onreadystatechange=function(){a(f),e.onreadystatechange=null,e.parentNode.removeChild(e),e=null},Pa.document.documentElement.appendChild(e),f}:function(b){var e=c++;return d[e]=b,yc(function(){a(e)},0),e}}();var Ac=function(a){function b(){a.call(this)}function c(a,b,c,d){return function(){a.setDisposable(bc._fixup(b(c,d)))}}function d(a){this._id=a,this.isDisposed=!1}function e(a){this._id=a,this.isDisposed=!1}function f(a,b,c){return function(){b(a,c)}}return Wb(b,a),d.prototype.dispose=function(){this.isDisposed||(this.isDisposed=!0,rc(this._id))},e.prototype.dispose=function(){this.isDisposed||(this.isDisposed=!0,zc(this._id))},b.prototype.schedule=function(a,b){var e=new hc,f=qc(c(e,b,this,a));return new jc(e,new d(f))},b.prototype._scheduleFuture=function(a,b,d){if(0===b)return this.schedule(a,d);var f=new hc,g=yc(c(f,d,this,a),b);return new jc(f,new e(g))},b.prototype.scheduleLongRunning=function(a,b){var c=cc(Ra);return qc(f(a,b,c)),c},b}(nc),Bc=nc["default"]=nc.async=new Ac,Cc=function(a){function b(b,c){this._scheduler=b,this._handler=c,this._recursiveOriginal=null,this._recursiveWrapper=null,a.call(this)}return Wb(b,a),b.prototype.schedule=function(a,b){return this._scheduler.schedule(a,this._wrap(b))},b.prototype._scheduleFuture=function(a,b,c){return this._scheduler.schedule(a,b,this._wrap(c))},b.prototype.now=function(){return this._scheduler.now()},b.prototype._clone=function(a){return new b(a,this._handler)},b.prototype._wrap=function(a){var b=this;return function(c,d){var f=$a(a)(b._getRecursiveWrapper(c),d);return f===Za?(b._handler(f.e)||e(f.e),dc):gc(f)}},b.prototype._getRecursiveWrapper=function(a){if(this._recursiveOriginal!==a){this._recursiveOriginal=a;var b=this._clone(a);b._recursiveOriginal=a,b._recursiveWrapper=b,this._recursiveWrapper=b}return this._recursiveWrapper},b.prototype.schedulePeriodic=function(a,b,c){var d=this,f=!1,g=new hc;return g.setDisposable(this._scheduler.schedulePeriodic(a,b,function(a){if(f)return null;var b=$a(c)(a);return b===Za?(f=!0,d._handler(b.e)||e(b.e),g.dispose(),null):b})),g},b}(nc),Dc=Qa.Notification=function(){function a(){}return a.prototype._accept=function(a,b,c){throw new ib},a.prototype._acceptObserver=function(a,b,c){throw new ib},a.prototype.accept=function(a,b,c){return a&&"object"==typeof a?this._acceptObserver(a):this._accept(a,b,c)},a.prototype.toObservable=function(a){var b=this;return pc(a)||(a=uc),new xg(function(c){return a.schedule(b,function(a,b){b._acceptObserver(c),"N"===b.kind&&c.onCompleted()})})},a}(),Ec=function(a){function b(a){this.value=a,this.kind="N"}return Wb(b,a),b.prototype._accept=function(a){return a(this.value)},b.prototype._acceptObserver=function(a){return a.onNext(this.value)},b.prototype.toString=function(){return"OnNext("+this.value+")"},b}(Dc),Fc=function(a){function b(a){this.error=a,this.kind="E"}return Wb(b,a),b.prototype._accept=function(a,b){return b(this.error)},b.prototype._acceptObserver=function(a){return a.onError(this.error)},b.prototype.toString=function(){return"OnError("+this.error+")"},b}(Dc),Gc=function(a){function b(){this.kind="C"}return Wb(b,a),b.prototype._accept=function(a,b,c){return c()},b.prototype._acceptObserver=function(a){return a.onCompleted()},b.prototype.toString=function(){return"OnCompleted()"},b}(Dc),Hc=Dc.createOnNext=function(a){return new Ec(a)},Ic=Dc.createOnError=function(a){return new Fc(a)},Jc=Dc.createOnCompleted=function(){return new Gc},Kc=Qa.Observer=function(){};Kc.prototype.toNotifier=function(){var a=this;return function(b){return b.accept(a)}},Kc.prototype.asObserver=function(){var a=this;return new Oc(function(b){a.onNext(b)},function(b){a.onError(b)},function(){a.onCompleted()})},Kc.prototype.checked=function(){return new Pc(this)};var Lc=Kc.create=function(a,b,c){return a||(a=Ra),b||(b=Wa),c||(c=Ra),new Oc(a,b,c)};Kc.fromNotifier=function(a,b){var c=ob(a,b,1);return new Oc(function(a){return c(Hc(a))},function(a){return c(Ic(a))},function(){return c(Jc())})},Kc.prototype.notifyOn=function(a){return new Rc(a,this)},Kc.prototype.makeSafe=function(a){return new AnonymousSafeObserver(this._onNext,this._onError,this._onCompleted,a)};var Mc,Nc=Qa.internals.AbstractObserver=function(a){function b(){this.isStopped=!1}return Wb(b,a),b.prototype.next=jb,b.prototype.error=jb,b.prototype.completed=jb,b.prototype.onNext=function(a){!this.isStopped&&this.next(a);
},b.prototype.onError=function(a){this.isStopped||(this.isStopped=!0,this.error(a))},b.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.completed())},b.prototype.dispose=function(){this.isStopped=!0},b.prototype.fail=function(a){return this.isStopped?!1:(this.isStopped=!0,this.error(a),!0)},b}(Kc),Oc=Qa.AnonymousObserver=function(a){function b(b,c,d){a.call(this),this._onNext=b,this._onError=c,this._onCompleted=d}return Wb(b,a),b.prototype.next=function(a){this._onNext(a)},b.prototype.error=function(a){this._onError(a)},b.prototype.completed=function(){this._onCompleted()},b}(Nc),Pc=function(a){function b(b){a.call(this),this._observer=b,this._state=0}Wb(b,a);var c=b.prototype;return c.onNext=function(a){this.checkAccess();var b=$a(this._observer.onNext).call(this._observer,a);this._state=0,b===Za&&e(b.e)},c.onError=function(a){this.checkAccess();var b=$a(this._observer.onError).call(this._observer,a);this._state=2,b===Za&&e(b.e)},c.onCompleted=function(){this.checkAccess();var a=$a(this._observer.onCompleted).call(this._observer);this._state=2,a===Za&&e(a.e)},c.checkAccess=function(){if(1===this._state)throw new Error("Re-entrancy detected");if(2===this._state)throw new Error("Observer completed");0===this._state&&(this._state=1)},b}(Kc),Qc=Qa.internals.ScheduledObserver=function(a){function b(b,c){a.call(this),this.scheduler=b,this.observer=c,this.isAcquired=!1,this.hasFaulted=!1,this.queue=[],this.disposable=new ic}function c(a,b){return function(){a.onNext(b)}}function d(a,b){return function(){a.onError(b)}}function f(a){return function(){a.onCompleted()}}function g(a,b){var c;if(!(a.queue.length>0))return void(a.isAcquired=!1);c=a.queue.shift();var d=$a(c)();return d===Za?(a.queue=[],a.hasFaulted=!0,e(d.e)):void b(a)}return Wb(b,a),b.prototype.next=function(a){this.queue.push(c(this.observer,a))},b.prototype.error=function(a){this.queue.push(d(this.observer,a))},b.prototype.completed=function(){this.queue.push(f(this.observer))},b.prototype.ensureActive=function(){var a=!1;!this.hasFaulted&&this.queue.length>0&&(a=!this.isAcquired,this.isAcquired=!0),a&&this.disposable.setDisposable(this.scheduler.scheduleRecursive(this,g))},b.prototype.dispose=function(){a.prototype.dispose.call(this),this.disposable.dispose()},b}(Nc),Rc=function(a){function b(b,c,d){a.call(this,b,c),this._cancel=d}return Wb(b,a),b.prototype.next=function(b){a.prototype.next.call(this,b),this.ensureActive()},b.prototype.error=function(b){a.prototype.error.call(this,b),this.ensureActive()},b.prototype.completed=function(){a.prototype.completed.call(this),this.ensureActive()},b.prototype.dispose=function(){a.prototype.dispose.call(this),this._cancel&&this._cancel.dispose(),this._cancel=null},b}(Qc),Sc=Qa.Observable=function(){function a(a,b){return function(c){var d=c.onError;return c.onError=function(b){f(b,a),d.call(c,b)},b.call(a,c)}}function b(){if(Qa.config.longStackSupport&&_a){var b=this._subscribe,c=$a(e)(new Error).e;this.stack=c.stack.substring(c.stack.indexOf("\n")+1),this._subscribe=a(this,b)}}return Mc=b.prototype,b.isObservable=function(a){return a&&Ya(a.subscribe)},Mc.subscribe=Mc.forEach=function(a,b,c){return this._subscribe("object"==typeof a?a:Lc(a,b,c))},Mc.subscribeOnNext=function(a,b){return this._subscribe(Lc("undefined"!=typeof b?function(c){a.call(b,c)}:a))},Mc.subscribeOnError=function(a,b){return this._subscribe(Lc(null,"undefined"!=typeof b?function(c){a.call(b,c)}:a))},Mc.subscribeOnCompleted=function(a,b){return this._subscribe(Lc(null,null,"undefined"!=typeof b?function(){a.call(b)}:a))},b}(),Tc=Qa.ObservableBase=function(a){function b(a){return a&&Ya(a.dispose)?a:Ya(a)?cc(a):dc}function c(a,c){var d=c[0],f=c[1],g=$a(f.subscribeCore).call(f,d);g!==Za||d.fail(Za.e)||e(Za.e),d.setDisposable(b(g))}function d(){a.call(this)}return Wb(d,a),d.prototype._subscribe=function(a){var b=new yg(a),d=[b,this];return wc.scheduleRequired()?wc.schedule(d,c):c(null,d),b},d.prototype.subscribeCore=jb,d}(Sc),Uc=Qa.FlatMapObservable=function(a){function b(b,c,d,e){this.resultSelector=Ya(d)?d:null,this.selector=ob(Ya(c)?c:function(){return c},e,3),this.source=b,a.call(this)}function c(a,b,c,d){this.i=0,this.selector=b,this.resultSelector=c,this.source=d,this.o=a,Nc.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new c(a,this.selector,this.resultSelector,this))},Wb(c,Nc),c.prototype._wrapResult=function(a,b,c){return this.resultSelector?a.map(function(a,d){return this.resultSelector(b,a,c,d)},this):a},c.prototype.next=function(a){var b=this.i++,c=$a(this.selector)(a,b,this.source);return c===Za?this.o.onError(c.e):(Xa(c)&&(c=dd(c)),(nb(c)||mb(c))&&(c=Sc.from(c)),void this.o.onNext(this._wrapResult(c,a,b)))},c.prototype.error=function(a){this.o.onError(a)},c.prototype.completed=function(){this.o.onCompleted()},b}(Tc),Vc=Qa.internals.Enumerable=function(){};y.prototype.dispose=function(){this.isDisposed||(this.isDisposed=!0,this._s.isDisposed=!0)};var Wc=function(a){function b(b){this.sources=b,a.call(this)}function c(a,b){if(!a.isDisposed){var c=$a(a.e.next).call(a.e);if(c===Za)return a.o.onError(c.e);if(c.done)return a.o.onCompleted();var e=c.value;Xa(e)&&(e=dd(e));var f=new hc;a.subscription.setDisposable(f),f.setDisposable(e.subscribe(new d(a,b)))}}function d(a,b){this._state=a,this._recurse=b,Nc.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new ic,d={isDisposed:!1,o:a,subscription:b,e:this.sources[kb]()},e=wc.scheduleRecursive(d,c);return new kc([b,e,new y(d)])},Wb(d,Nc),d.prototype.next=function(a){this._state.o.onNext(a)},d.prototype.error=function(a){this._state.o.onError(a)},d.prototype.completed=function(){this._recurse(this._state)},b}(Tc);Vc.prototype.concat=function(){return new Wc(this)};var Xc=function(a){function b(b){this.sources=b,a.call(this)}function c(a,b){if(!a.isDisposed){var c=$a(a.e.next).call(a.e);if(c===Za)return a.o.onError(c.e);if(c.done)return null!==a.lastError?a.o.onError(a.lastError):a.o.onCompleted();var e=c.value;Xa(e)&&(e=dd(e));var f=new hc;a.subscription.setDisposable(f),f.setDisposable(e.subscribe(new d(a,b)))}}function d(a,b){this._state=a,this._recurse=b,Nc.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new ic,d={isDisposed:!1,e:this.sources[kb](),subscription:b,lastError:null,o:a},e=wc.scheduleRecursive(d,c);return new kc([b,e,new y(d)])},Wb(d,Nc),d.prototype.next=function(a){this._state.o.onNext(a)},d.prototype.error=function(a){this._state.lastError=a,this._recurse(this._state)},d.prototype.completed=function(){this._state.o.onCompleted()},b}(Tc);Vc.prototype.catchError=function(){return new Xc(this)};var Yc=function(a){function b(a,b){this.v=a,this.c=null==b?-1:b}function c(a){this.v=a.v,this.l=a.c}return Wb(b,a),b.prototype[kb]=function(){return new c(this)},c.prototype.next=function(){return 0===this.l?lb:(this.l>0&&this.l--,{done:!1,value:this.v})},b}(Vc),Zc=Vc.repeat=function(a,b){return new Yc(a,b)},$c=function(a){function b(a,b,c){this.s=a,this.fn=b?ob(b,c,3):null}function c(a){this.i=-1,this.s=a.s,this.l=this.s.length,this.fn=a.fn}return Wb(b,a),b.prototype[kb]=function(){return new c(this)},c.prototype.next=function(){return++this.i<this.l?{done:!1,value:this.fn?this.fn(this.s[this.i],this.i,this.s):this.s[this.i]}:lb},b}(Vc),_c=Vc.of=function(a,b,c){return new $c(a,b,c)},ad=function(a){function b(b,c){this.source=b,this._s=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Rc(this._s,a))},b}(Tc);Mc.observeOn=function(a){return new ad(this,a)};var bd=function(a){function b(b,c){this.source=b,this._s=c,a.call(this)}function c(a,b){var c=b[0],d=b[1],e=b[2];d.setDisposable(new w(a,c.subscribe(e)))}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new hc,d=new ic;return d.setDisposable(b),b.setDisposable(this._s.schedule([this.source,d,a],c)),d},b}(Tc);Mc.subscribeOn=function(a){return new bd(this,a)};var cd=function(a){function b(b,c){this._p=b,this._s=c,a.call(this)}function c(a,b){var c=b[0],d=b[1];c.onNext(d),c.onCompleted()}function d(a,b){var c=b[0],d=b[1];c.onError(d)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new hc,e=this,f=this._p;return Ya(f)&&(f=$a(f)(),f===Za)?(a.onError(f.e),b):(f.then(function(d){b.setDisposable(e._s.schedule([a,d],c))},function(c){b.setDisposable(e._s.schedule([a,c],d))}),b)},b}(Tc),dd=Sc.fromPromise=function(a,b){return b||(b=Bc),new cd(a,b)};Mc.toPromise=function(a){if(a||(a=Qa.config.Promise),!a)throw new hb("Promise type not provided nor in Rx.config.Promise");var b=this;return new a(function(a,c){var d;b.subscribe(function(a){d=a},c,function(){a(d)})})};var ed=function(a){function b(b){this.source=b,a.call(this)}function c(a){this.o=a,this.a=[],Nc.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new c(a))},Wb(c,Nc),c.prototype.next=function(a){this.a.push(a)},c.prototype.error=function(a){this.o.onError(a)},c.prototype.completed=function(){this.o.onNext(this.a),this.o.onCompleted()},b}(Tc);Mc.toArray=function(){return new ed(this)},Sc.create=function(a,b){return new xg(a,b)};var fd=function(a){function b(b){this._f=b,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=$a(this._f)();return b===Za?yd(b.e).subscribe(a):(Xa(b)&&(b=dd(b)),b.subscribe(a))},b}(Tc),gd=Sc.defer=function(a){return new fd(a)},hd=function(a){function b(b){this.scheduler=b,a.call(this)}function c(a,b){this.observer=a,this.scheduler=b}function d(a,b){return b.onCompleted(),dc}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new c(a,this.scheduler);return b.run()},c.prototype.run=function(){var a=this.observer;return this.scheduler===uc?d(null,a):this.scheduler.schedule(a,d)},b}(Tc),id=new hd(uc),jd=Sc.empty=function(a){return pc(a)||(a=uc),a===uc?id:new hd(a)},kd=function(a){function b(b,c,d){this._iterable=b,this._fn=c,this._scheduler=d,a.call(this)}function c(a,b,c){return function(d,e){var f=$a(b.next).call(b);if(f===Za)return a.onError(f.e);if(f.done)return a.onCompleted();var g=f.value;return Ya(c)&&(g=$a(c)(g,d),g===Za)?a.onError(g.e):(a.onNext(g),void e(d+1))}}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=Object(this._iterable),d=E(b);return this._scheduler.scheduleRecursive(0,c(a,d,this._fn))},b}(Tc),ld=Math.pow(2,53)-1;z.prototype[kb]=function(){return new A(this._s)},A.prototype[kb]=function(){return this},A.prototype.next=function(){return this._i<this._l?{done:!1,value:this._s.charAt(this._i++)}:lb},B.prototype[kb]=function(){return new C(this._a)},C.prototype[kb]=function(){return this},C.prototype.next=function(){return this._i<this._l?{done:!1,value:this._a[this._i++]}:lb};var md=Sc.from=function(a,b,c,d){if(null==a)throw new Error("iterable cannot be null.");if(b&&!Ya(b))throw new Error("mapFn when provided must be a function");if(b)var e=ob(b,c,2);return pc(d)||(d=wc),new kd(a,e,d)},nd=function(a){function b(b,c){this._args=b,this._scheduler=c,a.call(this)}function c(a,b){var c=b.length;return function(d,e){c>d?(a.onNext(b[d]),e(d+1)):a.onCompleted()}}return Wb(b,a),b.prototype.subscribeCore=function(a){return this._scheduler.scheduleRecursive(0,c(a,this._args))},b}(Tc),od=Sc.fromArray=function(a,b){return pc(b)||(b=wc),new nd(a,b)},pd=function(a){function b(b,c,d,e,f){this._initialState=b,this._cndFn=c,this._itrFn=d,this._resFn=e,this._s=f,a.call(this)}function c(a,b){if(a.first)a.first=!1;else if(a.newState=$a(a.self._itrFn)(a.newState),a.newState===Za)return a.o.onError(a.newState.e);var c=$a(a.self._cndFn)(a.newState);if(c===Za)return a.o.onError(c.e);if(c){var d=$a(a.self._resFn)(a.newState);if(d===Za)return a.o.onError(d.e);a.o.onNext(d),b(a)}else a.o.onCompleted()}return Wb(b,a),b.prototype.subscribeCore=function(a){var b={o:a,self:this,first:!0,newState:this._initialState};return this._s.scheduleRecursive(b,c)},b}(Tc);Sc.generate=function(a,b,c,d,e){return pc(e)||(e=wc),new pd(a,b,c,d,e)},Sc.of=function(){for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];return new nd(b,wc)},Sc.ofWithScheduler=function(a){for(var b=arguments.length,c=new Array(b-1),d=1;b>d;d++)c[d-1]=arguments[d];return new nd(c,a)},Sc.ofArrayChanges=function(a){if(!Array.isArray(a))throw new TypeError("Array.observe only accepts arrays.");if("function"!=typeof Array.observe&&"function"!=typeof Array.unobserve)throw new TypeError("Array.observe is not supported on your platform");return new xg(function(b){function c(a){for(var c=0,d=a.length;d>c;c++)b.onNext(a[c])}return Array.observe(a,c),function(){Array.unobserve(a,c)}})},Sc.ofObjectChanges=function(a){if(null==a)throw new TypeError("object must not be null or undefined.");if("function"!=typeof Object.observe&&"function"!=typeof Object.unobserve)throw new TypeError("Object.observe is not supported on your platform");return new xg(function(b){function c(a){for(var c=0,d=a.length;d>c;c++)b.onNext(a[c])}return Object.observe(a,c),function(){Object.unobserve(a,c)}})};var qd=function(a){function b(){a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return dc},b}(Tc),rd=new qd,sd=Sc.never=function(){return rd},td=function(a){function b(b,c){this._o=b,this._keys=Object.keys(b),this._scheduler=c,a.call(this)}function c(a,b,c){return function(d,e){if(d<c.length){var f=c[d];a.onNext([f,b[f]]),e(d+1)}else a.onCompleted()}}return Wb(b,a),b.prototype.subscribeCore=function(a){return this._scheduler.scheduleRecursive(0,c(a,this._o,this._keys))},b}(Tc);Sc.pairs=function(a,b){return b||(b=wc),new td(a,b)};var ud=function(a){function b(b,c,d){this.start=b,this.rangeCount=c,this.scheduler=d,a.call(this)}function c(a,b,c){return function(d,e){b>d?(c.onNext(a+d),e(d+1)):c.onCompleted()}}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.scheduler.scheduleRecursive(0,c(this.start,this.rangeCount,a))},b}(Tc);Sc.range=function(a,b,c){return pc(c)||(c=wc),new ud(a,b,c)};var vd=function(a){function b(b,c,d){this.value=b,this.repeatCount=null==c?-1:c,this.scheduler=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new I(a,this);return b.run()},b}(Tc);I.prototype.run=function(){function a(a,d){return(-1===a||a>0)&&(b.onNext(c),a>0&&a--),0===a?b.onCompleted():void d(a)}var b=this.observer,c=this.parent.value;return this.parent.scheduler.scheduleRecursive(this.parent.repeatCount,a)},Sc.repeat=function(a,b,c){return pc(c)||(c=wc),new vd(a,b,c)};var wd=function(a){function b(b,c){this._value=b,this._scheduler=c,a.call(this)}function c(a,b){var c=b[0],d=b[1];return d.onNext(c),d.onCompleted(),dc}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=[this._value,a];return this._scheduler===uc?c(null,b):this._scheduler.schedule(b,c)},b}(Tc),xd=(Sc["return"]=Sc.just=function(a,b){return pc(b)||(b=uc),new wd(a,b)},function(a){function b(b,c){this._error=b,this._scheduler=c,a.call(this)}function c(a,b){var c=b[0],d=b[1];return d.onError(c),dc}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=[this._error,a];return this._scheduler===uc?c(null,b):this._scheduler.schedule(b,c)},b}(Tc)),yd=Sc["throw"]=function(a,b){return pc(b)||(b=uc),new xd(a,b)},zd=function(a){function b(b,c){this._resFn=b,this._obsFn=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=dc,c=$a(this._resFn)();if(c===Za)return new jc(yd(c.e).subscribe(a),b);c&&(b=c);var d=$a(this._obsFn)(c);return d===Za?new jc(yd(d.e).subscribe(a),b):new jc(d.subscribe(a),b)},b}(Tc);Sc.using=function(a,b){return new zd(a,b)},Mc.amb=function(a){var b=this;return new xg(function(c){function d(){f||(f=g,j.dispose())}function e(){f||(f=h,i.dispose())}var f,g="L",h="R",i=new hc,j=new hc;Xa(a)&&(a=dd(a));var k=Lc(function(a){d(),f===g&&c.onNext(a)},function(a){d(),f===g&&c.onError(a)},function(){d(),f===g&&c.onCompleted()}),l=Lc(function(a){e(),f===h&&c.onNext(a)},function(a){e(),f===h&&c.onError(a)},function(){e(),f===h&&c.onCompleted()});return i.setDisposable(b.subscribe(k)),j.setDisposable(a.subscribe(l)),new jc(i,j)})},Sc.amb=function(){var a,b=sd();if(Array.isArray(arguments[0]))a=arguments[0];else{var c=arguments.length;a=new Array(a);for(var d=0;c>d;d++)a[d]=arguments[d]}for(var d=0,c=a.length;c>d;d++)b=J(b,a[d]);return b};var Ad=function(a){function b(b,c){this.source=b,this._fn=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new hc,c=new ic;return c.setDisposable(b),b.setDisposable(this.source.subscribe(new Bd(a,c,this._fn))),c},b}(Tc),Bd=function(a){function b(b,c,d){this._o=b,this._s=c,this._fn=d,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._o.onNext(a)},b.prototype.completed=function(){return this._o.onCompleted()},b.prototype.error=function(a){var b=$a(this._fn)(a);if(b===Za)return this._o.onError(b.e);Xa(b)&&(b=dd(b));var c=new hc;this._s.setDisposable(c),c.setDisposable(b.subscribe(this._o))},b}(Nc);Mc["catch"]=function(a){return Ya(a)?new Ad(this,a):Cd([this,a])};var Cd=Sc["catch"]=function(){var a;if(Array.isArray(arguments[0]))a=arguments[0];else{var b=arguments.length;a=new Array(b);for(var c=0;b>c;c++)a[c]=arguments[c]}return _c(a).catchError()};Mc.combineLatest=function(){for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];return Array.isArray(b[0])?b[0].unshift(this):b.unshift(this),Fd.apply(this,b)};var Dd=function(a){function b(b,c){this._params=b,this._cb=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){for(var b=this._params.length,c=new Array(b),d={hasValue:u(b,K),hasValueAll:!1,isDone:u(b,K),values:new Array(b)},e=0;b>e;e++){var f=this._params[e],g=new hc;c[e]=g,Xa(f)&&(f=dd(f)),g.setDisposable(f.subscribe(new Ed(a,e,this._cb,d)))}return new kc(c)},b}(Tc),Ed=function(a){function b(b,c,d,e){this._o=b,this._i=c,this._cb=d,this._state=e,a.call(this)}function c(a){return function(b,c){return c!==a}}return Wb(b,a),b.prototype.next=function(a){if(this._state.values[this._i]=a,this._state.hasValue[this._i]=!0,this._state.hasValueAll||(this._state.hasValueAll=this._state.hasValue.every(Sa))){var b=$a(this._cb).apply(null,this._state.values);if(b===Za)return this._o.onError(b.e);this._o.onNext(b)}else this._state.isDone.filter(c(this._i)).every(Sa)&&this._o.onCompleted()},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._state.isDone[this._i]=!0,this._state.isDone.every(Sa)&&this._o.onCompleted()},b}(Nc),Fd=Sc.combineLatest=function(){for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];var d=Ya(b[a-1])?b.pop():L;return Array.isArray(b[0])&&(b=b[0]),new Dd(b,d)};Mc.concat=function(){for(var a=[],b=0,c=arguments.length;c>b;b++)a.push(arguments[b]);return a.unshift(this),Id.apply(null,a)};var Gd=function(a){function b(b,c){this._s=b,this._fn=c,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._s.o.onNext(a)},b.prototype.error=function(a){this._s.o.onError(a)},b.prototype.completed=function(){this._s.i++,this._fn(this._s)},b}(Nc),Hd=function(a){function b(b){this._sources=b,a.call(this)}function c(a,b){if(!a.disposable.isDisposed){if(a.i===a.sources.length)return a.o.onCompleted();var c=a.sources[a.i];Xa(c)&&(c=dd(c));var d=new hc;a.subscription.setDisposable(d),d.setDisposable(c.subscribe(new Gd(a,b)))}}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new ic,d=cc(Ra),e={o:a,i:0,subscription:b,disposable:d,sources:this._sources},f=uc.scheduleRecursive(e,c);return new kc([b,d,f])},b}(Tc),Id=Sc.concat=function(){var a;if(Array.isArray(arguments[0]))a=arguments[0];else{a=new Array(arguments.length);for(var b=0,c=arguments.length;c>b;b++)a[b]=arguments[b]}return new Hd(a)};Mc.concatAll=function(){return this.merge(1)};var Jd=function(a){function b(b,c){this.source=b,this.maxConcurrent=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new _b;return b.add(this.source.subscribe(new Kd(a,this.maxConcurrent,b))),b},b}(Tc),Kd=function(a){function b(b,c,d){this.o=b,this.max=c,this.g=d,this.done=!1,this.q=[],this.activeCount=0,a.call(this)}function c(b,c){this.parent=b,this.sad=c,a.call(this)}return Wb(b,a),b.prototype.handleSubscribe=function(a){var b=new hc;this.g.add(b),Xa(a)&&(a=dd(a)),b.setDisposable(a.subscribe(new c(this,b)))},b.prototype.next=function(a){this.activeCount<this.max?(this.activeCount++,this.handleSubscribe(a)):this.q.push(a)},b.prototype.error=function(a){this.o.onError(a)},b.prototype.completed=function(){this.done=!0,0===this.activeCount&&this.o.onCompleted()},Wb(c,a),c.prototype.next=function(a){this.parent.o.onNext(a)},c.prototype.error=function(a){this.parent.o.onError(a)},c.prototype.completed=function(){this.parent.g.remove(this.sad),this.parent.q.length>0?this.parent.handleSubscribe(this.parent.q.shift()):(this.parent.activeCount--,this.parent.done&&0===this.parent.activeCount&&this.parent.o.onCompleted())},b}(Nc);Mc.merge=function(a){return"number"!=typeof a?Ld(this,a):new Jd(this,a)};var Ld=Sc.merge=function(){var a,b,c=[],d=arguments.length;if(arguments[0])if(pc(arguments[0]))for(a=arguments[0],b=1;d>b;b++)c.push(arguments[b]);else for(a=uc,b=0;d>b;b++)c.push(arguments[b]);else for(a=uc,b=1;d>b;b++)c.push(arguments[b]);return Array.isArray(c[0])&&(c=c[0]),H(a,c).mergeAll()},Md=function(a){function b(b){this.source=b,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new _b,c=new hc;return b.add(c),c.setDisposable(this.source.subscribe(new Nd(a,b))),b},b}(Tc),Nd=function(a){function b(b,c){this.o=b,this.g=c,this.done=!1,a.call(this)}function c(b,c){this.parent=b,this.sad=c,a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=new hc;this.g.add(b),Xa(a)&&(a=dd(a)),b.setDisposable(a.subscribe(new c(this,b)))},b.prototype.error=function(a){this.o.onError(a)},b.prototype.completed=function(){this.done=!0,1===this.g.length&&this.o.onCompleted()},Wb(c,a),c.prototype.next=function(a){this.parent.o.onNext(a)},c.prototype.error=function(a){this.parent.o.onError(a)},c.prototype.completed=function(){this.parent.g.remove(this.sad),this.parent.done&&1===this.parent.g.length&&this.parent.o.onCompleted()},b}(Nc);Mc.mergeAll=function(){return new Md(this)};var Od=Qa.CompositeError=function(a){this.innerErrors=a,this.message="This contains multiple errors. Check the innerErrors",Error.call(this)};Od.prototype=Object.create(Error.prototype),Od.prototype.name="CompositeError";var Pd=function(a){function b(b){this.source=b,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new _b,c=new hc,d={isStopped:!1,errors:[],o:a};return b.add(c),c.setDisposable(this.source.subscribe(new Qd(b,d))),b},b}(Tc),Qd=function(a){function b(b,c){this._group=b,this._state=c,a.call(this)}function c(a,b){0===b.length?a.onCompleted():1===b.length?a.onError(b[0]):a.onError(new Od(b))}function d(b,c,d){this._inner=b,this._group=c,this._state=d,a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=new hc;this._group.add(b),Xa(a)&&(a=dd(a)),b.setDisposable(a.subscribe(new d(b,this._group,this._state)))},b.prototype.error=function(a){this._state.errors.push(a),this._state.isStopped=!0,1===this._group.length&&c(this._state.o,this._state.errors)},b.prototype.completed=function(){this._state.isStopped=!0,1===this._group.length&&c(this._state.o,this._state.errors)},Wb(d,a),d.prototype.next=function(a){this._state.o.onNext(a)},d.prototype.error=function(a){this._state.errors.push(a),this._group.remove(this._inner),this._state.isStopped&&1===this._group.length&&c(this._state.o,this._state.errors)},d.prototype.completed=function(){this._group.remove(this._inner),this._state.isStopped&&1===this._group.length&&c(this._state.o,this._state.errors)},b}(Nc);Sc.mergeDelayError=function(){var a;if(Array.isArray(arguments[0]))a=arguments[0];else{var b=arguments.length;a=new Array(b);for(var c=0;b>c;c++)a[c]=arguments[c]}var d=H(null,a);return new Pd(d)},Mc.onErrorResumeNext=function(a){if(!a)throw new Error("Second observable is required");return Td([this,a])};var Rd=function(a){function b(b){this.sources=b,a.call(this)}function c(a,b){if(a.pos<a.sources.length){var c=a.sources[a.pos++];Xa(c)&&(c=dd(c));var d=new hc;a.subscription.setDisposable(d),d.setDisposable(c.subscribe(new Sd(a,b)))}else a.o.onCompleted()}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new ic,d={pos:0,subscription:b,o:a,sources:this.sources},e=uc.scheduleRecursive(d,c);return new jc(b,e)},b}(Tc),Sd=function(a){function b(b,c){this._state=b,this._recurse=c,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._state.o.onNext(a)},b.prototype.error=function(){this._recurse(this._state)},b.prototype.completed=function(){this._recurse(this._state)},b}(Nc),Td=Sc.onErrorResumeNext=function(){var a=[];if(Array.isArray(arguments[0]))a=arguments[0];else{var b=arguments.length;a=new Array(b);for(var c=0;b>c;c++)a[c]=arguments[c]}return new Rd(a)},Ud=function(a){function b(b,c){this._s=b,this._o=Xa(c)?dd(c):c,this._open=!1,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new hc;b.setDisposable(this._s.subscribe(new Vd(a,this))),Xa(this._o)&&(this._o=dd(this._o));var c=new hc;return c.setDisposable(this._o.subscribe(new Wd(a,this,c))),new jc(b,c)},b}(Tc),Vd=function(a){function b(b,c){this._o=b,this._p=c,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._p._open&&this._o.onNext(a)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.onCompleted=function(){this._p._open&&this._o.onCompleted()},b}(Nc),Wd=function(a){function b(b,c,d){this._o=b,this._p=c,this._r=d,a.call(this)}return Wb(b,a),b.prototype.next=function(){this._p._open=!0,this._r.dispose()},b.prototype.error=function(a){this._o.onError(a)},b.prototype.onCompleted=function(){this._r.dispose()},b}(Nc);Mc.skipUntil=function(a){return new Ud(this,a)};var Xd=function(a){function b(b){this.source=b,a.call(this)}function c(a,b){this.o=a,this.inner=b,this.stopped=!1,this.latest=0,this.hasLatest=!1,Nc.call(this)}function d(a,b){this.parent=a,this.id=b,Nc.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new ic,d=this.source.subscribe(new c(a,b));return new jc(d,b)},Wb(c,Nc),c.prototype.next=function(a){var b=new hc,c=++this.latest;this.hasLatest=!0,this.inner.setDisposable(b),Xa(a)&&(a=dd(a)),b.setDisposable(a.subscribe(new d(this,c)))},c.prototype.error=function(a){this.o.onError(a)},c.prototype.completed=function(){this.stopped=!0,!this.hasLatest&&this.o.onCompleted()},Wb(d,Nc),d.prototype.next=function(a){this.parent.latest===this.id&&this.parent.o.onNext(a)},d.prototype.error=function(a){this.parent.latest===this.id&&this.parent.o.onError(a)},d.prototype.completed=function(){this.parent.latest===this.id&&(this.parent.hasLatest=!1,this.parent.stopped&&this.parent.o.onCompleted())},b}(Tc);Mc["switch"]=Mc.switchLatest=function(){return new Xd(this)};var Yd=function(a){function b(b,c){this.source=b,this.other=Xa(c)?dd(c):c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return new jc(this.source.subscribe(a),this.other.subscribe(new Zd(a)))},b}(Tc),Zd=function(a){function b(b){this._o=b,a.call(this)}return Wb(b,a),b.prototype.next=function(){this._o.onCompleted()},b.prototype.error=function(a){this._o.onError(a)},b.prototype.onCompleted=Ra,b}(Nc);Mc.takeUntil=function(a){return new Yd(this,a)};var $d=function(a){function b(b,c,d){this._s=b,this._ss=c,this._cb=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){for(var b=this._ss.length,c={hasValue:u(b,K),hasValueAll:!1,values:new Array(b)},d=this._ss.length,e=new Array(d+1),f=0;d>f;f++){var g=this._ss[f],h=new hc;Xa(g)&&(g=dd(g)),h.setDisposable(g.subscribe(new _d(a,f,c))),e[f]=h}var i=new hc;return i.setDisposable(this._s.subscribe(new ae(a,this._cb,c))),e[d]=i,new kc(e)},b}(Tc),_d=function(a){function b(b,c,d){this._o=b,this._i=c,this._state=d,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._state.values[this._i]=a,this._state.hasValue[this._i]=!0,this._state.hasValueAll=this._state.hasValue.every(Sa)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=Ra,b}(Nc),ae=function(a){function b(b,c,d){this._o=b,this._cb=c,this._state=d,a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=[a].concat(this._state.values);if(this._state.hasValueAll){var c=$a(this._cb).apply(null,b);return c===Za?this._o.onError(c.e):void this._o.onNext(c)}},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.withLatestFrom=function(){if(0===arguments.length)throw new Error("invalid arguments");for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];var d=Ya(b[a-1])?b.pop():L;return Array.isArray(b[0])&&(b=b[0]),new $d(this,b,d)};var be=function(a){function b(b,c){this._s=b,this._cb=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){for(var b=this._s.length,c=new Array(b),d=u(b,K),e=u(b,M),f=0;b>f;f++){var g=this._s[f],h=new hc;c[f]=h,Xa(g)&&(g=dd(g)),h.setDisposable(g.subscribe(new ce(a,f,this,e,d)))}return new kc(c)},b}(Tc),ce=function(a){function b(b,c,d,e,f){this._o=b,this._i=c,this._p=d,this._q=e,this._d=f,a.call(this)}function c(a){return a.length>0}function d(a){return a.shift()}function e(a){return function(b,c){return c!==a}}return Wb(b,a),b.prototype.next=function(a){if(this._q[this._i].push(a),this._q.every(c)){var b=this._q.map(d),f=$a(this._p._cb).apply(null,b);if(f===Za)return this._o.onError(f.e);this._o.onNext(f)}else this._d.filter(e(this._i)).every(Sa)&&this._o.onCompleted()},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._d[this._i]=!0,this._d.every(Sa)&&this._o.onCompleted()},b}(Nc);Mc.zip=function(){if(0===arguments.length)throw new Error("invalid arguments");for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];var d=Ya(b[a-1])?b.pop():L;Array.isArray(b[0])&&(b=b[0]);var e=this;return b.unshift(e),new be(b,d)},Sc.zip=function(){for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];Array.isArray(b[0])&&(b=Ya(b[1])?b[0].concat(b[1]):b[0]);var d=b.shift();return d.zip.apply(d,b)};var de=function(a){function b(b,c){this.sources=b,this._cb=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){for(var b=this.sources,c=b.length,d=new Array(c),e={q:u(c,M),done:u(c,K),cb:this._cb,o:a},f=0;c>f;f++)!function(a){var c=b[a],f=new hc;(nb(c)||mb(c))&&(c=md(c)),d[a]=f,f.setDisposable(c.subscribe(new ee(e,a)))}(f);return new kc(d)},b}(Tc),ee=function(a){function b(b,c){this._s=b,this._i=c,a.call(this)}function c(a){return a.length>0}function d(a){return a.shift()}function e(a){return function(b,c){return c!==a}}return Wb(b,a),b.prototype.next=function(a){if(this._s.q[this._i].push(a),this._s.q.every(c)){var b=this._s.q.map(d),f=$a(this._s.cb).apply(null,b);if(f===Za)return this._s.o.onError(f.e);this._s.o.onNext(f)}else this._s.done.filter(e(this._i)).every(Sa)&&this._s.o.onCompleted()},b.prototype.error=function(a){this._s.o.onError(a)},b.prototype.completed=function(){this._s.done[this._i]=!0,this._s.done.every(Sa)&&this._s.o.onCompleted()},b}(Nc);Mc.zipIterable=function(){if(0===arguments.length)throw new Error("invalid arguments");for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];var d=Ya(b[a-1])?b.pop():L,e=this;return b.unshift(e),new de(b,d)},Mc.asObservable=function(){return new xg(N(this),this)},Mc.bufferWithCount=Mc.bufferCount=function(a,b){return"number"!=typeof b&&(b=a),this.windowWithCount(a,b).flatMap(O).filter(P)};var fe=function(a){function b(b){this.source=b,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new ge(a))},b}(Tc),ge=function(a){function b(b){this._o=b,a.call(this)}return Wb(b,a),b.prototype.next=function(a){a.accept(this._o)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.dematerialize=function(){return new fe(this)};var he=function(a){function b(b,c,d){this.source=b,this.keyFn=c,this.comparer=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){
return this.source.subscribe(new ie(a,this.keyFn,this.comparer))},b}(Tc),ie=function(a){function b(b,c,d){this.o=b,this.keyFn=c,this.comparer=d,this.hasCurrentKey=!1,this.currentKey=null,a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b,c=a;return Ya(this.keyFn)&&(c=$a(this.keyFn)(a),c===Za)?this.o.onError(c.e):this.hasCurrentKey&&(b=$a(this.comparer)(this.currentKey,c),b===Za)?this.o.onError(b.e):void(this.hasCurrentKey&&b||(this.hasCurrentKey=!0,this.currentKey=c,this.o.onNext(a)))},b.prototype.error=function(a){this.o.onError(a)},b.prototype.completed=function(){this.o.onCompleted()},b}(Nc);Mc.distinctUntilChanged=function(a,b){return b||(b=Ua),new he(this,a,b)};var je=function(a){function b(b,c,d,e){this.source=b,this._oN=c,this._oE=d,this._oC=e,a.call(this)}function c(a,b){this.o=a,this.t=!b._oN||Ya(b._oN)?Lc(b._oN||Ra,b._oE||Ra,b._oC||Ra):b._oN,this.isStopped=!1,Nc.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new c(a,this))},Wb(c,Nc),c.prototype.next=function(a){var b=$a(this.t.onNext).call(this.t,a);b===Za&&this.o.onError(b.e),this.o.onNext(a)},c.prototype.error=function(a){var b=$a(this.t.onError).call(this.t,a);return b===Za?this.o.onError(b.e):void this.o.onError(a)},c.prototype.completed=function(){var a=$a(this.t.onCompleted).call(this.t);return a===Za?this.o.onError(a.e):void this.o.onCompleted()},b}(Tc);Mc["do"]=Mc.tap=Mc.doAction=function(a,b,c){return new je(this,a,b,c)},Mc.doOnNext=Mc.tapOnNext=function(a,b){return this.tap("undefined"!=typeof b?function(c){a.call(b,c)}:a)},Mc.doOnError=Mc.tapOnError=function(a,b){return this.tap(Ra,"undefined"!=typeof b?function(c){a.call(b,c)}:a)},Mc.doOnCompleted=Mc.tapOnCompleted=function(a,b){return this.tap(Ra,null,"undefined"!=typeof b?function(){a.call(b)}:a)};var ke=function(a){function b(b,c,d){this.source=b,this._fn=ob(c,d,0),a.call(this)}function c(a,b){this.isDisposed=!1,this._s=a,this._fn=b}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=$a(this.source.subscribe).call(this.source,a);return b===Za&&(this._fn(),e(b.e)),new c(b,this._fn)},c.prototype.dispose=function(){if(!this.isDisposed){var a=$a(this._s.dispose).call(this._s);this._fn(),a===Za&&e(a.e)}},b}(Tc);Mc["finally"]=function(a,b){return new ke(this,a,b)};var le=function(a){function b(b){this.source=b,a.call(this)}function c(a){this.o=a,this.isStopped=!1}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new c(a))},c.prototype.onNext=Ra,c.prototype.onError=function(a){this.isStopped||(this.isStopped=!0,this.o.onError(a))},c.prototype.onCompleted=function(){this.isStopped||(this.isStopped=!0,this.o.onCompleted())},c.prototype.dispose=function(){this.isStopped=!0},c.prototype.fail=function(a){return this.isStopped?!1:(this.isStopped=!0,this.observer.onError(a),!0)},b}(Tc);Mc.ignoreElements=function(){return new le(this)};var me=function(a){function b(b,c){this.source=b,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new ne(a))},b}(Tc),ne=function(a){function b(b){this._o=b,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._o.onNext(Hc(a))},b.prototype.error=function(a){this._o.onNext(Ic(a)),this._o.onCompleted()},b.prototype.completed=function(){this._o.onNext(Jc()),this._o.onCompleted()},b}(Nc);Mc.materialize=function(){return new me(this)},Mc.repeat=function(a){return Zc(this,a).concat()},Mc.retry=function(a){return Zc(this,a).catchError()};var oe=function(a){function b(a){return{isDisposed:!1,dispose:function(){this.isDisposed||(this.isDisposed=!0,a.isDisposed=!0)}}}function c(b,c){this.source=b,this._notifier=c,a.call(this)}return Wb(c,a),c.prototype.subscribeCore=function(a){var c,d=new Bg,e=new Bg,f=this._notifier(d),g=f.subscribe(e),h=this.source["@@iterator"](),i={isDisposed:!1},j=new ic,k=wc.scheduleRecursive(null,function(b,f){if(!i.isDisposed){var g=h.next();if(g.done)return void(c?a.onError(c):a.onCompleted());var k=g.value;Xa(k)&&(k=dd(k));var l=new hc,m=new hc;j.setDisposable(new jc(m,l)),l.setDisposable(k.subscribe(function(b){a.onNext(b)},function(b){m.setDisposable(e.subscribe(f,function(b){a.onError(b)},function(){a.onCompleted()})),d.onNext(b),l.dispose()},function(){a.onCompleted()}))}});return new kc([g,j,k,b(i)])},c}(Tc);Mc.retryWhen=function(a){return new oe(Q(this),a)};var pe=function(a){function b(a){return{isDisposed:!1,dispose:function(){this.isDisposed||(this.isDisposed=!0,a.isDisposed=!0)}}}function c(b,c){this.source=b,this._notifier=c,a.call(this)}return Wb(c,a),c.prototype.subscribeCore=function(a){var c,d=new Bg,e=new Bg,f=this._notifier(d),g=f.subscribe(e),h=this.source["@@iterator"](),i={isDisposed:!1},j=new ic,k=wc.scheduleRecursive(null,function(b,f){if(!i.isDisposed){var g=h.next();if(g.done)return void(c?a.onError(c):a.onCompleted());var k=g.value;Xa(k)&&(k=dd(k));var l=new hc,m=new hc;j.setDisposable(new jc(m,l)),l.setDisposable(k.subscribe(function(b){a.onNext(b)},function(b){a.onError(b)},function(){m.setDisposable(e.subscribe(f,function(b){a.onError(b)},function(){a.onCompleted()})),d.onNext(null),l.dispose()}))}});return new kc([g,j,k,b(i)])},c}(Tc);Mc.repeatWhen=function(a){return new pe(Q(this),a)};var qe=function(a){function b(b,c,d,e){this.source=b,this.accumulator=c,this.hasSeed=d,this.seed=e,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new re(a,this))},b}(Tc),re=function(a){function b(b,c){this._o=b,this._p=c,this._fn=c.accumulator,this._hs=c.hasSeed,this._s=c.seed,this._ha=!1,this._a=null,this._hv=!1,this._i=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){return!this._hv&&(this._hv=!0),this._ha?this._a=$a(this._fn)(this._a,a,this._i,this._p):(this._a=this._hs?$a(this._fn)(this._s,a,this._i,this._p):a,this._ha=!0),this._a===Za?this._o.onError(this._a.e):(this._o.onNext(this._a),void this._i++)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){!this._hv&&this._hs&&this._o.onNext(this._s),this._o.onCompleted()},b}(Nc);Mc.scan=function(){var a,b=!1,c=arguments[0];return 2===arguments.length&&(b=!0,a=arguments[1]),new qe(this,c,b,a)};var se=function(a){function b(b,c){this.source=b,this._c=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new te(a,this._c))},b}(Tc),te=function(a){function b(b,c){this._o=b,this._c=c,this._q=[],a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._q.push(a),this._q.length>this._c&&this._o.onNext(this._q.shift())},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.skipLast=function(a){if(0>a)throw new gb;return new se(this,a)},Mc.startWith=function(){var a,b=0;arguments.length&&pc(arguments[0])?(a=arguments[0],b=1):a=uc;for(var c=[],d=b,e=arguments.length;e>d;d++)c.push(arguments[d]);return Id.apply(null,[od(c,a),this])};var ue=function(a){function b(b,c){this._o=b,this._c=c,this._q=[],a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._q.push(a),this._q.length>this._c&&this._q.shift()},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){for(;this._q.length>0;)this._o.onNext(this._q.shift());this._o.onCompleted()},b}(Nc);Mc.takeLast=function(a){if(0>a)throw new gb;var b=this;return new xg(function(c){return b.subscribe(new ue(c,a))},b)};var ve=function(a){function b(b,c){this._o=b,this._c=c,this._q=[],a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._q.push(a),this._q.length>this._c&&this._q.shift()},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onNext(this._q),this._o.onCompleted()},b}(Nc);Mc.takeLastBuffer=function(a){if(0>a)throw new gb;var b=this;return new xg(function(c){return b.subscribe(new ve(c,a))},b)},Mc.windowWithCount=Mc.windowCount=function(a,b){var c=this;if(+a||(a=0),Math.abs(a)===1/0&&(a=0),0>=a)throw new gb;if(null==b&&(b=a),+b||(b=0),Math.abs(b)===1/0&&(b=0),0>=b)throw new gb;return new xg(function(d){function e(){var a=new Bg;i.push(a),d.onNext(Yb(a,g))}var f=new hc,g=new lc(f),h=0,i=[];return e(),f.setDisposable(c.subscribe(function(c){for(var d=0,f=i.length;f>d;d++)i[d].onNext(c);var g=h-a+1;g>=0&&g%b===0&&i.shift().onCompleted(),++h%b===0&&e()},function(a){for(;i.length>0;)i.shift().onError(a);d.onError(a)},function(){for(;i.length>0;)i.shift().onCompleted();d.onCompleted()})),g},c)},Mc.selectConcat=Mc.concatMap=function(a,b,c){return Ya(a)&&Ya(b)?this.concatMap(function(c,d){var e=a(c,d);return Xa(e)&&(e=dd(e)),(nb(e)||mb(e))&&(e=md(e)),e.map(function(a,e){return b(c,a,d,e)})}):Ya(a)?R(this,a,c):R(this,function(){return a})},Mc.concatMapObserver=Mc.selectConcatObserver=function(a,b,c,d){var e=this,f=ob(a,d,2),g=ob(b,d,1),h=ob(c,d,0);return new xg(function(a){var b=0;return e.subscribe(function(c){var d;try{d=f(c,b++)}catch(e){return void a.onError(e)}Xa(d)&&(d=dd(d)),a.onNext(d)},function(b){var c;try{c=g(b)}catch(d){return void a.onError(d)}Xa(c)&&(c=dd(c)),a.onNext(c),a.onCompleted()},function(){var b;try{b=h()}catch(c){return void a.onError(c)}Xa(b)&&(b=dd(b)),a.onNext(b),a.onCompleted()})},this).concatAll()};var we=function(a){function b(b,c){this._o=b,this._d=c,this._f=!1,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._f=!0,this._o.onNext(a)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){!this._f&&this._o.onNext(this._d),this._o.onCompleted()},b}(Nc);Mc.defaultIfEmpty=function(b){var c=this;return b===a&&(b=null),new xg(function(a){return c.subscribe(new we(a,b))},c)},T.prototype.push=function(a){var b=-1===S(this.set,a,this.comparer);return b&&this.set.push(a),b};var xe=function(a){function b(b,c,d){this.source=b,this._keyFn=c,this._cmpFn=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new ye(a,this._keyFn,this._cmpFn))},b}(Tc),ye=function(a){function b(b,c,d){this._o=b,this._keyFn=c,this._h=new T(d),a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=a;return Ya(this._keyFn)&&(b=$a(this._keyFn)(a),b===Za)?this._o.onError(b.e):void(this._h.push(b)&&this._o.onNext(a))},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.distinct=function(a,b){return b||(b=Ua),new xe(this,a,b)},Mc.groupBy=function(a,b){return this.groupByUntil(a,b,sd)},Mc.groupByUntil=function(b,c,d){var e=this;return new xg(function(f){var g=new Of,h=new _b,i=new lc(h),j=function(a){return function(b){b.onError(a)}};return h.add(e.subscribe(function(e){var k=$a(b)(e);if(k===Za)return g.forEach(j(k.e)),f.onError(k.e);var l=!1,m=g.get(k);if(m===a&&(m=new Bg,g.set(k,m),l=!0),l){var n=new Ag(k,m,i),o=new Ag(k,m),p=$a(d)(o);if(p===Za)return g.forEach(j(p.e)),f.onError(p.e);f.onNext(n);var q=new hc;h.add(q),q.setDisposable(p.take(1).subscribe(Ra,function(a){g.forEach(j(a)),f.onError(a)},function(){g["delete"](k)&&m.onCompleted(),h.remove(q)}))}var r=e;return Ya(c)&&(r=$a(c)(e),r===Za)?(g.forEach(j(r.e)),f.onError(r.e)):void m.onNext(r)},function(a){g.forEach(j(a)),f.onError(a)},function(){g.forEach(function(a){a.onCompleted()}),f.onCompleted()})),i},e)};var ze=function(a){function b(b,c,d){this.source=b,this.selector=ob(c,d,3),a.call(this)}function c(a,b){return function(c,d,e){return a.call(this,b.selector(c,d,e),d,e)}}function d(a,b,c){this.o=a,this.selector=b,this.source=c,this.i=0,Nc.call(this)}return Wb(b,a),b.prototype.internalMap=function(a,d){return new b(this.source,c(a,this),d)},b.prototype.subscribeCore=function(a){return this.source.subscribe(new d(a,this.selector,this))},Wb(d,Nc),d.prototype.next=function(a){var b=$a(this.selector)(a,this.i++,this.source);return b===Za?this.o.onError(b.e):void this.o.onNext(b)},d.prototype.error=function(a){this.o.onError(a)},d.prototype.completed=function(){this.o.onCompleted()},b}(Tc);Mc.map=Mc.select=function(a,b){var c="function"==typeof a?a:function(){return a};return this instanceof ze?this.internalMap(c,b):new ze(this,c,b)},Mc.pluck=function(){var a=arguments.length,b=new Array(a);if(0===a)throw new Error("List of properties cannot be empty.");for(var c=0;a>c;c++)b[c]=arguments[c];return this.map(U(b,a))},Mc.flatMap=Mc.selectMany=Mc.mergeMap=function(a,b,c){return new Uc(this,a,b,c).mergeAll()},Mc.flatMapObserver=Mc.selectManyObserver=function(a,b,c,d){var e=this;return new xg(function(f){var g=0;return e.subscribe(function(b){var c;try{c=a.call(d,b,g++)}catch(e){return void f.onError(e)}Xa(c)&&(c=dd(c)),f.onNext(c)},function(a){var c;try{c=b.call(d,a)}catch(e){return void f.onError(e)}Xa(c)&&(c=dd(c)),f.onNext(c),f.onCompleted()},function(){var a;try{a=c.call(d)}catch(b){return void f.onError(b)}Xa(a)&&(a=dd(a)),f.onNext(a),f.onCompleted()})},e).mergeAll()},Mc.flatMapLatest=Mc.switchMap=function(a,b,c){return new Uc(this,a,b,c).switchLatest()};var Ae=function(a){function b(b,c){this.source=b,this._count=c,a.call(this)}function c(a,b){this._o=a,this._r=b,Nc.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new c(a,this._count))},Wb(c,Nc),c.prototype.next=function(a){this._r<=0?this._o.onNext(a):this._r--},c.prototype.error=function(a){this._o.onError(a)},c.prototype.completed=function(){this._o.onCompleted()},b}(Tc);Mc.skip=function(a){if(0>a)throw new gb;return new Ae(this,a)};var Be=function(a){function b(b,c){this.source=b,this._fn=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Ce(a,this))},b}(Tc),Ce=function(a){function b(b,c){this._o=b,this._p=c,this._i=0,this._r=!1,a.call(this)}return Wb(b,a),b.prototype.next=function(a){if(!this._r){var b=$a(this._p._fn)(a,this._i++,this._p);if(b===Za)return this._o.onError(b.e);this._r=!b}this._r&&this._o.onNext(a)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.skipWhile=function(a,b){var c=ob(a,b,3);return new Be(this,c)};var De=function(a){function b(b,c){this.source=b,this._count=c,a.call(this)}function c(a,b){this._o=a,this._c=b,this._r=b,Nc.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new c(a,this._count))},Wb(c,Nc),c.prototype.next=function(a){this._r-->0&&(this._o.onNext(a),this._r<=0&&this._o.onCompleted())},c.prototype.error=function(a){this._o.onError(a)},c.prototype.completed=function(){this._o.onCompleted()},b}(Tc);Mc.take=function(a,b){if(0>a)throw new gb;return 0===a?jd(b):new De(this,a)};var Ee=function(a){function b(b,c){this.source=b,this._fn=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Fe(a,this))},b}(Tc),Fe=function(a){function b(b,c){this._o=b,this._p=c,this._i=0,this._r=!0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){return this._r&&(this._r=$a(this._p._fn)(a,this._i++,this._p),this._r===Za)?this._o.onError(this._r.e):void(this._r?this._o.onNext(a):this._o.onCompleted())},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.takeWhile=function(a,b){var c=ob(a,b,3);return new Ee(this,c)};var Ge=function(a){function b(b,c,d){this.source=b,this.predicate=ob(c,d,3),a.call(this)}function c(a,b){return function(c,d,e){return b.predicate(c,d,e)&&a.call(this,c,d,e)}}function d(a,b,c){this.o=a,this.predicate=b,this.source=c,this.i=0,Nc.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new d(a,this.predicate,this))},b.prototype.internalFilter=function(a,d){return new b(this.source,c(a,this),d)},Wb(d,Nc),d.prototype.next=function(a){var b=$a(this.predicate)(a,this.i++,this.source);return b===Za?this.o.onError(b.e):void(b&&this.o.onNext(a))},d.prototype.error=function(a){this.o.onError(a)},d.prototype.completed=function(){this.o.onCompleted()},b}(Tc);Mc.filter=Mc.where=function(a,b){return this instanceof Ge?this.internalFilter(a,b):new Ge(this,a,b)};var He=function(a){function b(b,c,d){this.source=b,this._k=c,this._c=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Ie(a,this._k,this._c))},b}(Tc),Ie=function(a){function b(b,c,d){this._o=b,this._k=c,this._c=d,this._v=null,this._hv=!1,this._l=[],a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=$a(this._k)(a);if(b===Za)return this._o.onError(b.e);var c=0;if(this._hv){if(c=$a(this._c)(b,this._v),c===Za)return this._o.onError(c.e)}else this._hv=!0,this._v=b;c>0&&(this._v=b,this._l=[]),c>=0&&this._l.push(a)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onNext(this._l),this._o.onCompleted()},b}(Nc),Je=function(a){function b(b,c,d,e){this.source=b,this.accumulator=c,this.hasSeed=d,this.seed=e,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Ke(a,this))},b}(Tc),Ke=function(a){function b(b,c){this._o=b,this._p=c,this._fn=c.accumulator,this._hs=c.hasSeed,this._s=c.seed,this._ha=!1,this._a=null,this._hv=!1,this._i=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){return!this._hv&&(this._hv=!0),this._ha?this._a=$a(this._fn)(this._a,a,this._i,this._p):(this._a=this._hs?$a(this._fn)(this._s,a,this._i,this._p):a,this._ha=!0),this._a===Za?this._o.onError(this._a.e):void this._i++},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._hv&&this._o.onNext(this._a),!this._hv&&this._hs&&this._o.onNext(this._s),!this._hv&&!this._hs&&this._o.onError(new eb),this._o.onCompleted()},b}(Nc);Mc.reduce=function(){var a,b=!1,c=arguments[0];return 2===arguments.length&&(b=!0,a=arguments[1]),new Je(this,c,b,a)};var Le=function(a){function b(b,c){this.source=b,this._fn=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Me(a,this._fn,this.source))},b}(Tc),Me=function(a){function b(b,c,d){this._o=b,this._fn=c,this._s=d,this._i=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=$a(this._fn)(a,this._i++,this._s);return b===Za?this._o.onError(b.e):void(Boolean(b)&&(this._o.onNext(!0),this._o.onCompleted()))},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onNext(!1),this._o.onCompleted()},b}(Nc);Mc.some=function(a,b){var c=ob(a,b,3);return new Le(this,c)};var Ne=function(a){function b(b){this.source=b,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Oe(a))},b}(Tc),Oe=function(a){function b(b){this._o=b,a.call(this)}return Wb(b,a),b.prototype.next=function(){this._o.onNext(!1),this._o.onCompleted()},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onNext(!0),this._o.onCompleted()},b}(Nc);Mc.isEmpty=function(){return new Ne(this)};var Pe=function(a){function b(b,c){this.source=b,this._fn=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Qe(a,this._fn,this.source))},b}(Tc),Qe=function(a){function b(b,c,d){this._o=b,this._fn=c,this._s=d,this._i=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=$a(this._fn)(a,this._i++,this._s);return b===Za?this._o.onError(b.e):void(Boolean(b)||(this._o.onNext(!1),this._o.onCompleted()))},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onNext(!0),this._o.onCompleted()},b}(Nc);Mc.every=function(a,b){var c=ob(a,b,3);return new Pe(this,c)};var Re=function(a){function b(b,c,d){var e=+d||0;Math.abs(e)===1/0&&(e=0),this.source=b,this._elem=c,this._n=e,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this._n<0?(a.onNext(!1),a.onCompleted(),dc):this.source.subscribe(new Se(a,this._elem,this._n))},b}(Tc),Se=function(a){function b(b,c,d){this._o=b,this._elem=c,this._n=d,this._i=0,a.call(this)}function c(a,b){return 0===a&&0===b||a===b||isNaN(a)&&isNaN(b)}return Wb(b,a),b.prototype.next=function(a){this._i++>=this._n&&c(a,this._elem)&&(this._o.onNext(!0),this._o.onCompleted())},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onNext(!1),this._o.onCompleted()},b}(Nc);Mc.includes=function(a,b){return new Re(this,a,b)};var Te=function(a){function b(b,c){this.source=b,this._fn=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Ue(a,this._fn,this.source))},b}(Tc),Ue=function(a){function b(b,c,d){this._o=b,this._fn=c,this._s=d,this._i=0,this._c=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){if(this._fn){var b=$a(this._fn)(a,this._i++,this._s);if(b===Za)return this._o.onError(b.e);Boolean(b)&&this._c++}else this._c++},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onNext(this._c),this._o.onCompleted()},b}(Nc);Mc.count=function(a,b){var c=ob(a,b,3);return new Te(this,c)};var Ve=function(a){function b(b,c,d){this.source=b,this._e=c,this._n=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this._n<0?(a.onNext(-1),a.onCompleted(),dc):this.source.subscribe(new We(a,this._e,this._n))},b}(Tc),We=function(a){function b(b,c,d){this._o=b,this._e=c,this._n=d,this._i=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._i>=this._n&&a===this._e&&(this._o.onNext(this._i),this._o.onCompleted()),this._i++},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onNext(-1),this._o.onCompleted()},b}(Nc);Mc.indexOf=function(a,b){var c=+b||0;return Math.abs(c)===1/0&&(c=0),new Ve(this,a,c)};var Xe=function(a){function b(b,c){this.source=b,this._fn=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Ye(a,this._fn,this.source))},b}(Tc),Ye=function(a){function b(b,c,d){this._o=b,this._fn=c,this._s=d,this._i=0,this._c=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){if(this._fn){var b=$a(this._fn)(a,this._i++,this._s);if(b===Za)return this._o.onError(b.e);this._c+=b}else this._c+=a},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onNext(this._c),this._o.onCompleted()},b}(Nc);Mc.sum=function(a,b){var c=ob(a,b,3);return new Xe(this,c)},Mc.minBy=function(a,b){return b||(b=Va),new He(this,a,function(a,c){return-1*b(a,c)})},Mc.min=function(a){return this.minBy(Sa,a).map(V)},Mc.maxBy=function(a,b){return b||(b=Va),new He(this,a,b)},Mc.max=function(a){return this.maxBy(Sa,a).map(V)};var Ze=function(a){function b(b,c){this.source=b,this._fn=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new $e(a,this._fn,this.source))},b}(Tc),$e=function(a){function b(b,c,d){this._o=b,this._fn=c,this._s=d,this._c=0,this._t=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){if(this._fn){var b=$a(this._fn)(a,this._c++,this._s);if(b===Za)return this._o.onError(b.e);this._t+=b}else this._c++,this._t+=a},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){return 0===this._c?this._o.onError(new eb):(this._o.onNext(this._t/this._c),void this._o.onCompleted())},b}(Nc);Mc.average=function(a,b){var c,d=this;return Ya(a)&&(c=ob(a,b,3)),new Ze(d,c)},Mc.sequenceEqual=function(a,b){var c=this;return b||(b=Ua),new xg(function(d){var e=!1,f=!1,g=[],h=[],i=c.subscribe(function(a){if(h.length>0){var c=h.shift(),e=$a(b)(c,a);if(e===Za)return d.onError(e.e);e||(d.onNext(!1),d.onCompleted())}else f?(d.onNext(!1),d.onCompleted()):g.push(a)},function(a){d.onError(a)},function(){e=!0,0===g.length&&(h.length>0?(d.onNext(!1),d.onCompleted()):f&&(d.onNext(!0),d.onCompleted()))});(nb(a)||mb(a))&&(a=md(a)),Xa(a)&&(a=dd(a));var j=a.subscribe(function(a){if(g.length>0){var c=g.shift(),f=$a(b)(c,a);if(f===Za)return d.onError(f.e);f||(d.onNext(!1),d.onCompleted())}else e?(d.onNext(!1),d.onCompleted()):h.push(a)},function(a){d.onError(a)},function(){f=!0,0===h.length&&(g.length>0?(d.onNext(!1),d.onCompleted()):e&&(d.onNext(!0),d.onCompleted()))});return new jc(i,j)},c)};var _e=function(a){function b(b,c,d){this.source=b,this._i=c,this._d=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new af(a,this._i,this._d))},b}(Tc),af=function(b){function c(a,c,d){this._o=a,this._i=c,this._d=d,b.call(this)}return Wb(c,b),c.prototype.next=function(a){0===this._i--&&(this._o.onNext(a),this._o.onCompleted())},c.prototype.error=function(a){this._o.onError(a)},c.prototype.completed=function(){this._d===a?this._o.onError(new gb):(this._o.onNext(this._d),this._o.onCompleted())},c}(Nc);Mc.elementAt=function(a,b){if(0>a)throw new gb;return new _e(this,a,b)};var bf=function(b){function c(a,c,d){this._o=a,this._obj=c,this._s=d,this._i=0,this._hv=!1,this._v=null,b.call(this)}return Wb(c,b),c.prototype.next=function(a){var b=!1;if(this._obj.predicate){var c=$a(this._obj.predicate)(a,this._i++,this._s);if(c===Za)return this._o.onError(c.e);Boolean(c)&&(b=!0)}else this._obj.predicate||(b=!0);if(b){if(this._hv)return this._o.onError(new Error("Sequence contains more than one matching element"));this._hv=!0,this._v=a}},c.prototype.error=function(a){this._o.onError(a)},c.prototype.completed=function(){this._hv?(this._o.onNext(this._v),this._o.onCompleted()):this._obj.defaultValue===a?this._o.onError(new eb):(this._o.onNext(this._obj.defaultValue),this._o.onCompleted())},c}(Nc);Mc.single=function(a,b){var c={},d=this;if(c="object"==typeof arguments[0]?arguments[0]:{predicate:arguments[0],thisArg:arguments[1],defaultValue:arguments[2]},Ya(c.predicate)){var e=c.predicate;c.predicate=ob(e,c.thisArg,3)}return new xg(function(a){return d.subscribe(new bf(a,c,d))},d)};var cf=function(a){function b(b,c){this.source=b,this._obj=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new df(a,this._obj,this.source))},b}(Tc),df=function(b){function c(a,c,d){this._o=a,this._obj=c,this._s=d,this._i=0,b.call(this)}return Wb(c,b),c.prototype.next=function(a){if(this._obj.predicate){var b=$a(this._obj.predicate)(a,this._i++,this._s);if(b===Za)return this._o.onError(b.e);Boolean(b)&&(this._o.onNext(a),this._o.onCompleted())}else this._obj.predicate||(this._o.onNext(a),this._o.onCompleted())},c.prototype.error=function(a){this._o.onError(a)},c.prototype.completed=function(){this._obj.defaultValue===a?this._o.onError(new eb):(this._o.onNext(this._obj.defaultValue),this._o.onCompleted())},c}(Nc);Mc.first=function(){var a={};if(a="object"==typeof arguments[0]?arguments[0]:{predicate:arguments[0],thisArg:arguments[1],defaultValue:arguments[2]},Ya(a.predicate)){var b=a.predicate;a.predicate=ob(b,a.thisArg,3)}return new cf(this,a)};var ef=function(a){function b(b,c){this.source=b,this._obj=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new ff(a,this._obj,this.source))},b}(Tc),ff=function(b){function c(a,c,d){this._o=a,this._obj=c,this._s=d,this._i=0,this._hv=!1,this._v=null,b.call(this)}return Wb(c,b),c.prototype.next=function(a){var b=!1;if(this._obj.predicate){var c=$a(this._obj.predicate)(a,this._i++,this._s);if(c===Za)return this._o.onError(c.e);Boolean(c)&&(b=!0)}else this._obj.predicate||(b=!0);b&&(this._hv=!0,this._v=a)},c.prototype.error=function(a){this._o.onError(a)},c.prototype.completed=function(){this._hv?(this._o.onNext(this._v),this._o.onCompleted()):this._obj.defaultValue===a?this._o.onError(new eb):(this._o.onNext(this._obj.defaultValue),this._o.onCompleted())},c}(Nc);Mc.last=function(){var a={};if(a="object"==typeof arguments[0]?arguments[0]:{predicate:arguments[0],thisArg:arguments[1],defaultValue:arguments[2]},Ya(a.predicate)){var b=a.predicate;a.predicate=ob(b,a.thisArg,3)}return new ef(this,a)};var gf=function(a){function b(b,c,d,e){this._o=b,this._s=c,this._cb=d,this._y=e,this._i=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=$a(this._cb)(a,this._i,this._s);return b===Za?this._o.onError(b.e):void(b?(this._o.onNext(this._y?this._i:a),this._o.onCompleted()):this._i++)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._y&&this._o.onNext(-1),this._o.onCompleted()},b}(Nc);Mc.find=function(a,b){return W(this,a,b,!1)},Mc.findIndex=function(a,b){return W(this,a,b,!0)};var hf=function(a){function b(b){this.source=b,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new jf(a))},b}(Tc),jf=function(a){function b(b){this._o=b,this._s=new Pa.Set,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._s.add(a)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onNext(this._s),this._o.onCompleted()},b}(Nc);Mc.toSet=function(){if("undefined"==typeof Pa.Set)throw new TypeError;return new hf(this)};var kf=function(a){function b(b,c,d){this.source=b,this._k=c,this._e=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new lf(a,this._k,this._e))},b}(Tc),lf=function(a){function b(b,c,d){this._o=b,this._k=c,this._e=d,this._m=new Pa.Map,a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=$a(this._k)(a);if(b===Za)return this._o.onError(b.e);var c=a;return this._e&&(c=$a(this._e)(a),c===Za)?this._o.onError(c.e):void this._m.set(b,c)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onNext(this._m),this._o.onCompleted()},b}(Nc);Mc.toMap=function(a,b){if("undefined"==typeof Pa.Map)throw new TypeError;return new kf(this,a,b)};var mf=function(a){function b(b,c,d){this.source=b,this._b=c,this._e=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new nf(a,this._b,this._e))},b}(Tc),nf=function(a){function b(b,c,d){this._o=b,this._b=c,this._e=d,this._i=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._i>=this._b&&(this._e===this._i?this._o.onCompleted():this._o.onNext(a)),this._i++},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.slice=function(a,b){var c=a||0;if(0>c)throw new Qa.ArgumentOutOfRangeError;if("number"==typeof b&&c>b)throw new Qa.ArgumentOutOfRangeError;return new mf(this,c,b)};var of=function(a){function b(b,c,d){this.source=b,this._e=c,this._n=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this._n<0?(a.onNext(-1),a.onCompleted(),dc):this.source.subscribe(new pf(a,this._e,this._n))},b}(Tc),pf=function(a){function b(b,c,d){this._o=b,this._e=c,this._n=d,this._v=0,this._hv=!1,this._i=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._i>=this._n&&a===this._e&&(this._hv=!0,this._v=this._i),this._i++},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._hv?this._o.onNext(this._v):this._o.onNext(-1),this._o.onCompleted()},b}(Nc);Mc.lastIndexOf=function(a,b){var c=+b||0;return Math.abs(c)===1/0&&(c=0),new of(this,a,c)},Sc.wrap=function(a){function b(){return Sc.spawn.call(this,a.apply(this,arguments))}return b.__generatorFunction__=a,b};var qf=Sc.spawn=function(){for(var a=arguments[0],b=this,c=[],d=1,e=arguments.length;e>d;d++)c.push(arguments[d]);return new xg(function(d){function e(b){var c=$a(a.next).call(a,b);return c===Za?d.onError(c.e):void g(c)}function f(b){var c=$a(a.next).call(a,b);return c===Za?d.onError(c.e):void g(c)}function g(a){if(a.done)return d.onNext(a.value),void d.onCompleted();var c=X.call(b,a.value),g=null,i=!1;Sc.isObservable(c)?h.add(c.subscribe(function(a){i=!0,g=a},f,function(){i&&e(g)})):f(new TypeError("type not supported"))}var h=new _b;return Ya(a)&&(a=a.apply(b,c)),a&&Ya(a.next)?(e(),h):(d.onNext(a),d.onCompleted())})};Sc.start=function(a,b,c){return rf(a,b,c)()};var rf=Sc.toAsync=function(a,b,c){return pc(c)||(c=Bc),function(){var d=arguments,e=new Cg;return c.schedule(null,function(){var c;try{c=a.apply(b,d)}catch(f){return void e.onError(f)}e.onNext(c),e.onCompleted()}),e.asObservable()}};Sc.fromCallback=function(a,b,c){return function(){"undefined"==typeof b&&(b=this);
for(var d=arguments.length,e=new Array(d),f=0;d>f;f++)e[f]=arguments[f];return ca(a,b,c,e)}},Sc.fromNodeCallback=function(a,b,c){return function(){"undefined"==typeof b&&(b=this);for(var d=arguments.length,e=new Array(d),f=0;d>f;f++)e[f]=arguments[f];return ea(a,b,c,e)}},ha.prototype.dispose=function(){this.isDisposed||(this._e.removeEventListener(this._n,this._fn,!1),this.isDisposed=!0)},Qa.config.useNativeEvents=!1;var sf=function(a){function b(b,c,d){this._el=b,this._n=c,this._fn=d,a.call(this)}function c(a,b){return function(){var c=arguments[0];return Ya(b)&&(c=$a(b).apply(null,arguments),c===Za)?a.onError(c.e):void a.onNext(c)}}return Wb(b,a),b.prototype.subscribeCore=function(a){return ia(this._el,this._n,c(a,this._fn))},b}(Tc);Sc.fromEvent=function(a,b,c){return a.addListener?uf(function(c){a.addListener(b,c)},function(c){a.removeListener(b,c)},c):Qa.config.useNativeEvents||"function"!=typeof a.on||"function"!=typeof a.off?new sf(a,b,c).publish().refCount():uf(function(c){a.on(b,c)},function(c){a.off(b,c)},c)};var tf=function(a){function b(b,c,d){this._add=b,this._del=c,this._fn=d,a.call(this)}function c(a,b){return function(){var c=arguments[0];return Ya(b)&&(c=$a(b).apply(null,arguments),c===Za)?a.onError(c.e):void a.onNext(c)}}function d(a,b,c){this._del=a,this._fn=b,this._ret=c,this.isDisposed=!1}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=c(a,this._fn),e=this._add(b);return new d(this._del,b,e)},d.prototype.dispose=function(){this.isDisposed||(Ya(this._del)&&this._del(this._fn,this._ret),this.isDisposed=!0)},b}(Tc),uf=Sc.fromEventPattern=function(a,b,c){return new tf(a,b,c).publish().refCount()};Sc.startAsync=function(a){var b=$a(a)();return b===Za?yd(b.e):dd(b)};var vf=function(a){function b(b,c){this.source=b,this.controller=new Bg,this.paused=!0,c&&c.subscribe?this.pauser=this.controller.merge(c):this.pauser=this.controller,a.call(this)}return Wb(b,a),b.prototype._subscribe=function(a){var b=this.source.publish(),c=b.subscribe(a),d=dc,e=this.pauser.startWith(!this.paused).distinctUntilChanged().subscribe(function(a){a?d=b.connect():(d.dispose(),d=dc)});return new kc([c,d,e])},b.prototype.pause=function(){this.paused=!0,this.controller.onNext(!1)},b.prototype.resume=function(){this.paused=!1,this.controller.onNext(!0)},b}(Sc);Mc.pausable=function(a){return new vf(this,a)};var wf=function(b){function c(a,c){this.source=a,this.controller=new Bg,this.paused=!0,c&&c.subscribe?this.pauser=this.controller.merge(c):this.pauser=this.controller,b.call(this)}return Wb(c,b),c.prototype._subscribe=function(b){function c(){for(;e.length>0;)b.onNext(e.shift())}var d,e=[],f=ja(this.source,this.pauser.startWith(!this.paused).distinctUntilChanged(),function(a,b){return{data:a,shouldFire:b}}).subscribe(function(f){d!==a&&f.shouldFire!==d?(d=f.shouldFire,f.shouldFire&&c()):(d=f.shouldFire,f.shouldFire?b.onNext(f.data):e.push(f.data))},function(a){c(),b.onError(a)},function(){c(),b.onCompleted()});return f},c.prototype.pause=function(){this.paused=!0,this.controller.onNext(!1)},c.prototype.resume=function(){this.paused=!1,this.controller.onNext(!0)},c}(Sc);Mc.pausableBuffered=function(a){return new wf(this,a)};var xf=function(a){function b(b,c,d){a.call(this),this.subject=new yf(c,d),this.source=b.multicast(this.subject).refCount()}return Wb(b,a),b.prototype._subscribe=function(a){return this.source.subscribe(a)},b.prototype.request=function(a){return this.subject.request(null==a?-1:a)},b}(Sc),yf=function(a){function b(b,c){null==b&&(b=!0),a.call(this),this.subject=new Bg,this.enableQueue=b,this.queue=b?[]:null,this.requestedCount=0,this.requestedDisposable=null,this.error=null,this.hasFailed=!1,this.hasCompleted=!1,this.scheduler=c||wc}return Wb(b,a),Xb(b.prototype,Kc,{_subscribe:function(a){return this.subject.subscribe(a)},onCompleted:function(){this.hasCompleted=!0,this.enableQueue&&0!==this.queue.length?this.queue.push(Dc.createOnCompleted()):(this.subject.onCompleted(),this.disposeCurrentRequest())},onError:function(a){this.hasFailed=!0,this.error=a,this.enableQueue&&0!==this.queue.length?this.queue.push(Dc.createOnError(a)):(this.subject.onError(a),this.disposeCurrentRequest())},onNext:function(a){this.requestedCount<=0?this.enableQueue&&this.queue.push(Dc.createOnNext(a)):(0===this.requestedCount--&&this.disposeCurrentRequest(),this.subject.onNext(a))},_processRequest:function(a){if(this.enableQueue)for(;this.queue.length>0&&(a>0||"N"!==this.queue[0].kind);){var b=this.queue.shift();b.accept(this.subject),"N"===b.kind?a--:(this.disposeCurrentRequest(),this.queue=[])}return a},request:function(a){this.disposeCurrentRequest();var b=this;return this.requestedDisposable=this.scheduler.schedule(a,function(a,c){var d=b._processRequest(c),e=b.hasCompleted||b.hasFailed;return!e&&d>0?(b.requestedCount=d,cc(function(){b.requestedCount=0})):void 0}),this.requestedDisposable},disposeCurrentRequest:function(){this.requestedDisposable&&(this.requestedDisposable.dispose(),this.requestedDisposable=null)}}),b}(Sc);Mc.controlled=function(a,b){return a&&pc(a)&&(b=a,a=!0),null==a&&(a=!0),new xf(this,a,b)};var zf=function(a){function b(b){a.call(this),this.source=b}function c(a,b){return b.source.request(1)}Wb(b,a),b.prototype._subscribe=function(a){return this.subscription=this.source.subscribe(new d(a,this,this.subscription)),new jc(this.subscription,Bc.schedule(this,c))};var d=function(a){function b(b,c,d){a.call(this),this.observer=b,this.observable=c,this.cancel=d,this.scheduleDisposable=null}function c(a,b){return b.observable.source.request(1)}return Wb(b,a),b.prototype.completed=function(){this.observer.onCompleted(),this.dispose()},b.prototype.error=function(a){this.observer.onError(a),this.dispose()},b.prototype.next=function(a){this.observer.onNext(a),this.scheduleDisposable=Bc.schedule(this,c)},b.dispose=function(){this.observer=null,this.cancel&&(this.cancel.dispose(),this.cancel=null),this.scheduleDisposable&&(this.scheduleDisposable.dispose(),this.scheduleDisposable=null),a.prototype.dispose.call(this)},b}(Nc);return b}(Sc);xf.prototype.stopAndWait=function(){return new zf(this)};var Af=function(a){function b(b,c){a.call(this),this.source=b,this.windowSize=c}function c(a,b){return b.source.request(b.windowSize)}Wb(b,a),b.prototype._subscribe=function(a){return this.subscription=this.source.subscribe(new d(a,this,this.subscription)),new jc(this.subscription,Bc.schedule(this,c))};var d=function(a){function b(b,c,d){this.observer=b,this.observable=c,this.cancel=d,this.received=0,this.scheduleDisposable=null,a.call(this)}function c(a,b){return b.observable.source.request(b.observable.windowSize)}return Wb(b,a),b.prototype.completed=function(){this.observer.onCompleted(),this.dispose()},b.prototype.error=function(a){this.observer.onError(a),this.dispose()},b.prototype.next=function(a){this.observer.onNext(a),this.received=++this.received%this.observable.windowSize,0===this.received&&(this.scheduleDisposable=Bc.schedule(this,c))},b.prototype.dispose=function(){this.observer=null,this.cancel&&(this.cancel.dispose(),this.cancel=null),this.scheduleDisposable&&(this.scheduleDisposable.dispose(),this.scheduleDisposable=null),a.prototype.dispose.call(this)},b}(Nc);return b}(Sc);xf.prototype.windowed=function(a){return new Af(this,a)},Mc.pipe=function(a){function b(){c.resume()}var c=this.pausableBuffered();return a.addListener("drain",b),c.subscribe(function(b){!a.write(b)&&c.pause()},function(b){a.emit("error",b)},function(){!a._isStdio&&a.end(),a.removeListener("drain",b)}),c.resume(),a};var Bf=function(a){function b(b,c,d){this.source=b,this._fn1=c,this._fn2=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=this.source.multicast(this._fn1());return new jc(this._fn2(b).subscribe(a),b.connect())},b}(Tc);Mc.multicast=function(a,b){return Ya(a)?new Bf(this,a,b):new Ef(this,a)},Mc.publish=function(a){return a&&Ya(a)?this.multicast(function(){return new Bg},a):this.multicast(new Bg)},Mc.share=function(){return this.publish().refCount()},Mc.publishLast=function(a){return a&&Ya(a)?this.multicast(function(){return new Cg},a):this.multicast(new Cg)},Mc.publishValue=function(a,b){return 2===arguments.length?this.multicast(function(){return new Dg(b)},a):this.multicast(new Dg(a))},Mc.shareValue=function(a){return this.publishValue(a).refCount()},Mc.replay=function(a,b,c,d){return a&&Ya(a)?this.multicast(function(){return new Eg(b,c,d)},a):this.multicast(new Eg(b,c,d))},Mc.shareReplay=function(a,b,c){return this.replay(null,a,b,c).refCount()};var Cf=function(a,b){this._s=a,this._o=b};Cf.prototype.dispose=function(){if(!this._s.isDisposed&&null!==this._o){var a=this._s.observers.indexOf(this._o);this._s.observers.splice(a,1),this._o=null}};var Df=function(a){function b(b){this.source=b,this._count=0,this._connectableSubscription=null,a.call(this)}function c(a,b){this._p=a,this._s=b,this.isDisposed=!1}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=this.source.subscribe(a);return 1===++this._count&&(this._connectableSubscription=this.source.connect()),new c(this,b)},c.prototype.dispose=function(){this.isDisposed||(this.isDisposed=!0,this._s.dispose(),0===--this._p._count&&this._p._connectableSubscription.dispose())},b}(Tc),Ef=Qa.ConnectableObservable=function(a){function b(b,c){this.source=b,this._connection=null,this._source=b.asObservable(),this._subject=c,a.call(this)}function c(a,b){this._p=a,this._s=b}return Wb(b,a),c.prototype.dispose=function(){this._s&&(this._s.dispose(),this._s=null,this._p._connection=null)},b.prototype.connect=function(){if(!this._connection){if(this._subject.isStopped)return dc;var a=this._source.subscribe(this._subject);this._connection=new c(this,a)}return this._connection},b.prototype._subscribe=function(a){return this._subject.subscribe(a)},b.prototype.refCount=function(){return new Df(this)},b}(Sc);Mc.singleInstance=function(){function a(){return d||(d=!0,b=c["finally"](function(){d=!1}).publish().refCount()),b}var b,c=this,d=!1;return new xg(function(b){return a().subscribe(b)})},Mc.join=function(a,b,c,d){var e=this;return new xg(function(f){var g=new _b,h=!1,i=!1,j=0,k=0,l=new Of,m=new Of,n=function(a){f.onError(a)};return g.add(e.subscribe(function(a){var c=j++,e=new hc;l.set(c,a),g.add(e);var i=$a(b)(a);return i===Za?f.onError(i.e):(e.setDisposable(i.take(1).subscribe(Ra,n,function(){l["delete"](c)&&0===l.size&&h&&f.onCompleted(),g.remove(e)})),void m.forEach(function(b){var c=$a(d)(a,b);return c===Za?f.onError(c.e):void f.onNext(c)}))},n,function(){h=!0,(i||0===l.size)&&f.onCompleted()})),g.add(a.subscribe(function(a){var b=k++,e=new hc;m.set(b,a),g.add(e);var h=$a(c)(a);return h===Za?f.onError(h.e):(e.setDisposable(h.take(1).subscribe(Ra,n,function(){m["delete"](b)&&0===m.size&&i&&f.onCompleted(),g.remove(e)})),void l.forEach(function(b){var c=$a(d)(b,a);return c===Za?f.onError(c.e):void f.onNext(c)}))},n,function(){i=!0,(h||0===m.size)&&f.onCompleted()})),g},e)},Mc.groupJoin=function(a,b,c,d){var e=this;return new xg(function(f){function g(a){}var h=new _b,i=new lc(h),j=new Of,k=new Of,l=0,m=0,g=function(a){return function(b){b.onError(a)}};return h.add(e.subscribe(function(a){var c=new Bg,e=l++;j.set(e,c);var m=$a(d)(a,Yb(c,i));if(m===Za)return j.forEach(g(m.e)),f.onError(m.e);f.onNext(m),k.forEach(function(a){c.onNext(a)});var n=new hc;h.add(n);var o=$a(b)(a);return o===Za?(j.forEach(g(o.e)),f.onError(o.e)):void n.setDisposable(o.take(1).subscribe(Ra,function(a){j.forEach(g(a)),f.onError(a)},function(){j["delete"](e)&&c.onCompleted(),h.remove(n)}))},function(a){j.forEach(g(a)),f.onError(a)},function(){f.onCompleted()})),h.add(a.subscribe(function(a){var b=m++;k.set(b,a);var d=new hc;h.add(d);var e=$a(c)(a);return e===Za?(j.forEach(g(e.e)),f.onError(e.e)):(d.setDisposable(e.take(1).subscribe(Ra,function(a){j.forEach(g(a)),f.onError(a)},function(){k["delete"](b),h.remove(d)})),void j.forEach(function(b){b.onNext(a)}))},function(a){j.forEach(g(a)),f.onError(a)})),i},e)},Mc.buffer=function(){return this.window.apply(this,arguments).flatMap(O)},Mc.window=function(a,b){return 1===arguments.length&&"function"!=typeof arguments[0]?la.call(this,a):"function"==typeof a?ma.call(this,a):ka.call(this,a,b)};var Ff=function(a){function b(b){this.source=b,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Gf(a))},b}(Tc),Gf=function(a){function b(b){this._o=b,this._p=null,this._hp=!1,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._hp?this._o.onNext([this._p,a]):this._hp=!0,this._p=a},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.pairwise=function(){return new Ff(this)},Mc.partition=function(a,b){var c=ob(a,b,3);return[this.filter(a,b),this.filter(function(a,b,d){return!c(a,b,d)})]};var Hf=function(a){function b(a,b){this.c=a,this.s=b}return Wb(b,a),b.prototype[kb]=function(){var a=this;return{next:function(){return a.c()?{done:!1,value:a.s}:{done:!0,value:void 0}}}},b}(Vc);Mc.letBind=Mc.let=function(a){return a(this)},Sc["if"]=function(a,b,c){return gd(function(){return c||(c=jd()),Xa(b)&&(b=dd(b)),Xa(c)&&(c=dd(c)),"function"==typeof c.now&&(c=jd(c)),a()?b:c})},Sc["for"]=Sc.forIn=function(a,b,c){return _c(a,b,c).concat()};var If=Sc["while"]=Sc.whileDo=function(a,b){return Xa(b)&&(b=dd(b)),na(a,b).concat()};Mc.doWhile=function(a){return Id([this,If(a,this)])},Sc["case"]=function(a,b,c){return gd(function(){Xa(c)&&(c=dd(c)),c||(c=jd()),pc(c)&&(c=jd(c));var d=b[a()];return Xa(d)&&(d=dd(d)),d||c})};var Jf=function(a){function b(b,c,d){this.source=b,this._fn=c,this._scheduler=d,a.call(this)}function c(a,b){var c,d=a[0],e=a[1];if(!(d.q.length>0))return void(d.isAcquired=!1);c=d.q.shift();var f=new hc;d.d.add(f),f.setDisposable(c.subscribe(new Kf(d,e,f))),b([d,e])}return Wb(b,a),b.prototype._ensureActive=function(a){var b=!1;a.q.length>0&&(b=!a.isAcquired,a.isAcquired=!0),b&&a.m.setDisposable(this._scheduler.scheduleRecursive([a,this],c))},b.prototype.subscribeCore=function(a){var b=new ic,c=new _b(b),d={q:[],m:b,d:c,activeCount:0,isAcquired:!1,o:a};return d.q.push(this.source),d.activeCount++,this._ensureActive(d),c},b}(Tc),Kf=function(a){function b(b,c,d){this._s=b,this._p=c,this._m1=d,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._s.o.onNext(a);var b=$a(this._p._fn)(a);return b===Za?this._s.o.onError(b.e):(this._s.q.push(b),this._s.activeCount++,void this._p._ensureActive(this._s))},b.prototype.error=function(a){this._s.o.onError(a)},b.prototype.completed=function(){this._s.d.remove(this._m1),this._s.activeCount--,0===this._s.activeCount&&this._s.o.onCompleted()},b}(Nc);Mc.expand=function(a,b){return pc(b)||(b=wc),new Jf(this,a,b)};var Lf=function(a){function b(b,c){this._sources=b,this._cb=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){if(0===this._sources.length)return a.onCompleted(),dc;for(var b=this._sources.length,c={finished:!1,hasResults:new Array(b),hasCompleted:new Array(b),results:new Array(b)},d=new _b,e=0,f=this._sources.length;f>e;e++){var g=this._sources[e];Xa(g)&&(g=dd(g)),d.add(g.subscribe(new Mf(a,c,e,this._cb,d)))}return d},b}(Tc),Mf=function(a){function b(b,c,d,e,f){this._o=b,this._s=c,this._i=d,this._cb=e,this._subs=f,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._s.finished||(this._s.hasResults[this._i]=!0,this._s.results[this._i]=a)},b.prototype.error=function(a){this._s.finished=!0,this._o.onError(a),this._subs.dispose()},b.prototype.completed=function(){if(!this._s.finished){if(!this._s.hasResults[this._i])return this._o.onCompleted();this._s.hasCompleted[this._i]=!0;for(var a=0;a<this._s.results.length;a++)if(!this._s.hasCompleted[a])return;this._s.finished=!0;var b=$a(this._cb).apply(null,this._s.results);if(b===Za)return this._o.onError(b.e);this._o.onNext(b),this._o.onCompleted()}},b}(Nc);Sc.forkJoin=function(){for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];var d=Ya(b[a-1])?b.pop():L;return Array.isArray(b[0])&&(b=b[0]),new Lf(b,d)},Mc.forkJoin=function(){for(var a=arguments.length,b=new Array(a),c=0;a>c;c++)b[c]=arguments[c];return Array.isArray(b[0])?b[0].unshift(this):b.unshift(this),Sc.forkJoin.apply(null,b)},Mc.manySelect=Mc.extend=function(a,b){pc(b)||(b=Qa.Scheduler.immediate);var c=this;return gd(function(){var d;return c.map(function(a){var b=new Nf(a);return d&&d.onNext(a),d=b,b}).tap(Ra,function(a){d&&d.onError(a)},function(){d&&d.onCompleted()}).observeOn(b).map(a)},c)};var Nf=function(a){function b(b){a.call(this),this.head=b,this.tail=new Cg}return Wb(b,a),Xb(b.prototype,Kc,{_subscribe:function(a){var b=new _b;return b.add(wc.schedule(this,function(c,d){a.onNext(d.head),b.add(d.tail.mergeAll().subscribe(a))})),b},onCompleted:function(){this.onNext(Sc.empty())},onError:function(a){this.onNext(Sc["throw"](a))},onNext:function(a){this.tail.onNext(a),this.tail.onCompleted()}}),b}(Sc),Of=Pa.Map||function(){function b(){this.size=0,this._values=[],this._keys=[]}return b.prototype["delete"]=function(a){var b=this._keys.indexOf(a);return-1===b?!1:(this._values.splice(b,1),this._keys.splice(b,1),this.size--,!0)},b.prototype.get=function(b){var c=this._keys.indexOf(b);return-1===c?a:this._values[c]},b.prototype.set=function(a,b){var c=this._keys.indexOf(a);return-1===c?(this._keys.push(a),this._values.push(b),this.size++):this._values[c]=b,this},b.prototype.forEach=function(a,b){for(var c=0;c<this.size;c++)a.call(b,this._values[c],this._keys[c])},b}();oa.prototype.and=function(a){return new oa(this.patterns.concat(a))},oa.prototype.thenDo=function(a){return new pa(this,a)},pa.prototype.activate=function(a,b,c){for(var d=[],e=qa(b),f=0,g=this.expression.patterns.length;g>f;f++)d.push(sa(a,this.expression.patterns[f],e));var h=new ta(d,ra(this,b),function(){for(var a=0,b=d.length;b>a;a++)d[a].removeActivePlan(h);c(h)});for(f=0,g=d.length;g>f;f++)d[f].addActivePlan(h);return h},ta.prototype.dequeue=function(){this.joinObservers.forEach(function(a){a.queue.shift()})},ta.prototype.match=function(){var a,b,c=!0;for(a=0,b=this.joinObserverArray.length;b>a;a++)if(0===this.joinObserverArray[a].queue.length){c=!1;break}if(c){var d=[],e=!1;for(a=0,b=this.joinObserverArray.length;b>a;a++)d.push(this.joinObserverArray[a].queue[0]),"C"===this.joinObserverArray[a].queue[0].kind&&(e=!0);if(e)this.onCompleted();else{this.dequeue();var f=[];for(a=0,b=d.length;a<d.length;a++)f.push(d[a].value);this.onNext.apply(this,f)}}};var Pf=function(a){function b(b,c){a.call(this),this.source=b,this.onError=c,this.queue=[],this.activePlans=[],this.subscription=new hc,this.isDisposed=!1}Wb(b,a);var c=b.prototype;return c.next=function(a){if(!this.isDisposed){if("E"===a.kind)return this.onError(a.error);this.queue.push(a);for(var b=this.activePlans.slice(0),c=0,d=b.length;d>c;c++)b[c].match()}},c.error=Ra,c.completed=Ra,c.addActivePlan=function(a){this.activePlans.push(a)},c.subscribe=function(){this.subscription.setDisposable(this.source.materialize().subscribe(this))},c.removeActivePlan=function(a){this.activePlans.splice(this.activePlans.indexOf(a),1),0===this.activePlans.length&&this.dispose()},c.dispose=function(){a.prototype.dispose.call(this),this.isDisposed||(this.isDisposed=!0,this.subscription.dispose())},b}(Nc);Mc.and=function(a){return new oa([this,a])},Mc.thenDo=function(a){return new oa([this]).thenDo(a)},Sc.when=function(){var a,b=arguments.length;if(Array.isArray(arguments[0]))a=arguments[0];else{a=new Array(b);for(var c=0;b>c;c++)a[c]=arguments[c]}return new xg(function(b){var c=[],d=new Of,e=Lc(function(a){b.onNext(a)},function(a){d.forEach(function(b){b.onError(a)}),b.onError(a)},function(a){b.onCompleted()});try{for(var f=0,g=a.length;g>f;f++)c.push(a[f].activate(d,e,function(a){var d=c.indexOf(a);c.splice(d,1),0===c.length&&b.onCompleted()}))}catch(h){return yd(h).subscribe(b)}var i=new _b;return d.forEach(function(a){a.subscribe(),i.add(a)}),i})};var Qf=function(a){function b(b,c){this._dt=b,this._s=c,a.call(this)}function c(a,b){b.onNext(0),b.onCompleted()}return Wb(b,a),b.prototype.subscribeCore=function(a){return this._s.scheduleFuture(a,this._dt,c)},b}(Tc),Rf=Sc.interval=function(a,b){return wa(a,a,pc(b)?b:Bc)};Sc.timer=function(b,c,d){var e;return pc(d)||(d=Bc),null!=c&&"number"==typeof c?e=c:pc(c)&&(d=c),(b instanceof Date||"number"==typeof b)&&e===a?ua(b,d):b instanceof Date&&e!==a?va(b,c,d):wa(b,e,d)};Mc.delay=function(){var a=arguments[0];if("number"==typeof a||a instanceof Date){var b=a,c=arguments[1];return pc(c)||(c=Bc),b instanceof Date?ya(this,b,c):xa(this,b,c)}if(Sc.isObservable(a)||Ya(a))return za(this,a,arguments[1]);throw new Error("Invalid arguments")};var Sf=function(a){function b(b,c,d){pc(d)||(d=Bc),this.source=b,this._dt=c,this._s=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new ic;return new jc(this.source.subscribe(new Tf(a,this._dt,this._s,b)),b)},b}(Tc),Tf=function(a){function b(b,c,d,e){this._o=b,this._d=c,this._scheduler=d,this._c=e,this._v=null,this._hv=!1,this._id=0,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._hv=!0,this._v=a;var b=++this._id,c=new hc;this._c.setDisposable(c),c.setDisposable(this._scheduler.scheduleFuture(this,this._d,function(c,d){d._hv&&d._id===b&&d._o.onNext(a),d._hv=!1}))},b.prototype.error=function(a){this._c.dispose(),this._o.onError(a),this._hv=!1,this._id++},b.prototype.completed=function(){this._c.dispose(),this._hv&&this._o.onNext(this._v),this._o.onCompleted(),this._hv=!1,this._id++},b}(Nc);Mc.debounce=function(){if(Ya(arguments[0]))return Aa(this,arguments[0]);if("number"==typeof arguments[0])return new Sf(this,arguments[0],arguments[1]);throw new Error("Invalid arguments")},Mc.windowWithTime=Mc.windowTime=function(a,b,c){var d,e=this;return null==b&&(d=a),pc(c)||(c=Bc),"number"==typeof b?d=b:pc(b)&&(d=a,c=b),new xg(function(b){function f(){var a=new hc,e=!1,g=!1;l.setDisposable(a),j===i?(e=!0,g=!0):i>j?e=!0:g=!0;var n=e?j:i,o=n-m;m=n,e&&(j+=d),g&&(i+=d),a.setDisposable(c.scheduleFuture(null,o,function(){if(g){var a=new Bg;k.push(a),b.onNext(Yb(a,h))}e&&k.shift().onCompleted(),f()}))}var g,h,i=d,j=a,k=[],l=new ic,m=0;return g=new _b(l),h=new lc(g),k.push(new Bg),b.onNext(Yb(k[0],h)),f(),g.add(e.subscribe(function(a){for(var b=0,c=k.length;c>b;b++)k[b].onNext(a)},function(a){for(var c=0,d=k.length;d>c;c++)k[c].onError(a);b.onError(a)},function(){for(var a=0,c=k.length;c>a;a++)k[a].onCompleted();b.onCompleted()})),h},e)},Mc.windowWithTimeOrCount=Mc.windowTimeOrCount=function(a,b,c){var d=this;return pc(c)||(c=Bc),new xg(function(e){function f(b){var d=new hc;g.setDisposable(d),d.setDisposable(c.scheduleFuture(null,a,function(){if(b===k){j=0;var a=++k;l.onCompleted(),l=new Bg,e.onNext(Yb(l,i)),f(a)}}))}var g=new ic,h=new _b(g),i=new lc(h),j=0,k=0,l=new Bg;return e.onNext(Yb(l,i)),f(0),h.add(d.subscribe(function(a){var c=0,d=!1;l.onNext(a),++j===b&&(d=!0,j=0,c=++k,l.onCompleted(),l=new Bg,e.onNext(Yb(l,i))),d&&f(c)},function(a){l.onError(a),e.onError(a)},function(){l.onCompleted(),e.onCompleted()})),i},d)},Mc.bufferWithTime=Mc.bufferTime=function(a,b,c){return this.windowWithTime(a,b,c).flatMap(O)},Mc.bufferWithTimeOrCount=Mc.bufferTimeOrCount=function(a,b,c){return this.windowWithTimeOrCount(a,b,c).flatMap(O)};var Uf=function(a){function b(b,c){this.source=b,this._s=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Vf(a,this._s))},b}(Tc),Vf=function(a){function b(b,c){this._o=b,this._s=c,this._l=c.now(),a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=this._s.now(),c=b-this._l;this._l=b,this._o.onNext({value:a,interval:c})},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.timeInterval=function(a){return pc(a)||(a=Bc),new Uf(this,a)};var Wf=function(a){function b(b,c){this.source=b,this._s=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new Xf(a,this._s))},b}(Tc),Xf=function(a){function b(b,c){this._o=b,this._s=c,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._o.onNext({value:a,timestamp:this._s.now()})},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.timestamp=function(a){return pc(a)||(a=Bc),new Wf(this,a)};var Yf=function(a){function b(b,c){this.source=b,this._sampler=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b={o:a,atEnd:!1,value:null,hasValue:!1,sourceSubscription:new hc};return b.sourceSubscription.setDisposable(this.source.subscribe(new $f(b))),new jc(b.sourceSubscription,this._sampler.subscribe(new Zf(b)))},b}(Tc),Zf=function(a){function b(b){this._s=b,a.call(this)}return Wb(b,a),b.prototype._handleMessage=function(){this._s.hasValue&&(this._s.hasValue=!1,this._s.o.onNext(this._s.value)),this._s.atEnd&&this._s.o.onCompleted()},b.prototype.next=function(){this._handleMessage()},b.prototype.error=function(a){this._s.onError(a)},b.prototype.completed=function(){this._handleMessage()},b}(Nc),$f=function(a){function b(b){this._s=b,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._s.hasValue=!0,this._s.value=a},b.prototype.error=function(a){this._s.o.onError(a)},b.prototype.completed=function(){this._s.atEnd=!0,this._s.sourceSubscription.dispose()},b}(Nc);Mc.sample=function(a,b){return pc(b)||(b=Bc),"number"==typeof a?new Yf(this,Rf(a,b)):new Yf(this,a)};var _f=Qa.TimeoutError=function(a){this.message=a||"Timeout has occurred",this.name="TimeoutError",Error.call(this)};_f.prototype=Object.create(Error.prototype),Mc.timeout=function(){var a=arguments[0];if(a instanceof Date||"number"==typeof a)return Ca(this,a,arguments[1],arguments[2]);if(Sc.isObservable(a)||Ya(a))return Ba(this,a,arguments[1],arguments[2]);throw new Error("Invalid arguments")};var ag=function(a){function b(b,c,d,e,f,g){this._state=b,this._cndFn=c,this._itrFn=d,this._resFn=e,this._timeFn=f,this._s=g,a.call(this)}function c(a,b){if(a.hasResult&&a.o.onNext(a.result),a.first)a.first=!1;else if(a.newState=$a(a.self._itrFn)(a.newState),a.newState===Za)return a.o.onError(a.newState.e);if(a.hasResult=$a(a.self._cndFn)(a.newState),a.hasResult===Za)return a.o.onError(a.hasResult.e);if(a.hasResult){if(a.result=$a(a.self._resFn)(a.newState),a.result===Za)return a.o.onError(a.result.e);var c=$a(a.self._timeFn)(a.newState);if(c===Za)return a.o.onError(c.e);b(a,c)}else a.o.onCompleted()}return Wb(b,a),b.prototype.subscribeCore=function(a){var b={o:a,self:this,newState:this._state,first:!0,hasResult:!1};return this._s.scheduleRecursiveFuture(b,new Date(this._s.now()),c)},b}(Tc);Sc.generateWithAbsoluteTime=function(a,b,c,d,e,f){return pc(f)||(f=Bc),new ag(a,b,c,d,e,f)};var bg=function(a){function b(b,c,d,e,f,g){this._state=b,this._cndFn=c,this._itrFn=d,this._resFn=e,this._timeFn=f,this._s=g,a.call(this)}function c(a,b){if(a.hasResult&&a.o.onNext(a.result),a.first)a.first=!1;else if(a.newState=$a(a.self._itrFn)(a.newState),a.newState===Za)return a.o.onError(a.newState.e);if(a.hasResult=$a(a.self._cndFn)(a.newState),a.hasResult===Za)return a.o.onError(a.hasResult.e);if(a.hasResult){if(a.result=$a(a.self._resFn)(a.newState),a.result===Za)return a.o.onError(a.result.e);var c=$a(a.self._timeFn)(a.newState);if(c===Za)return a.o.onError(c.e);b(a,c)}else a.o.onCompleted()}return Wb(b,a),b.prototype.subscribeCore=function(a){var b={o:a,self:this,newState:this._state,first:!0,hasResult:!1};return this._s.scheduleRecursiveFuture(b,0,c)},b}(Tc);Sc.generateWithRelativeTime=function(a,b,c,d,e,f){return pc(f)||(f=Bc),new bg(a,b,c,d,e,f)};var cg=function(a){function b(b,c,d){this.source=b,this._dt=c,this._s=d,a.call(this)}function c(a,b){var c=b[0],d=b[1],e=b[2];e.setDisposable(c.subscribe(d))}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new ic;return b.setDisposable(this._s.scheduleFuture([this.source,a,b],this._dt,c)),b},b}(Tc);Mc.delaySubscription=function(a,b){return pc(b)||(b=Bc),new cg(this,a,b)};var dg=function(a){function b(b,c,d){this.source=b,this._d=c,this._s=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new eg(a,this))},b}(Tc),eg=function(a){function b(b,c){this._o=b,this._s=c._s,this._d=c._d,this._q=[],a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=this._s.now();for(this._q.push({interval:b,value:a});this._q.length>0&&b-this._q[0].interval>=this._d;)this._o.onNext(this._q.shift().value)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){for(var a=this._s.now();this._q.length>0&&a-this._q[0].interval>=this._d;)this._o.onNext(this._q.shift().value);this._o.onCompleted()},b}(Nc);Mc.skipLastWithTime=function(a,b){return pc(b)||(b=Bc),new dg(this,a,b)};var fg=function(a){function b(b,c,d){this.source=b,this._d=c,this._s=d,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return this.source.subscribe(new gg(a,this._d,this._s))},b}(Tc),gg=function(a){function b(b,c,d){this._o=b,this._d=c,this._s=d,this._q=[],a.call(this)}return Wb(b,a),b.prototype.next=function(a){var b=this._s.now();for(this._q.push({interval:b,value:a});this._q.length>0&&b-this._q[0].interval>=this._d;)this._q.shift()},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){for(var a=this._s.now();this._q.length>0;){var b=this._q.shift();a-b.interval<=this._d&&this._o.onNext(b.value)}this._o.onCompleted()},b}(Nc);Mc.takeLastWithTime=function(a,b){return pc(b)||(b=Bc),new fg(this,a,b)},Mc.takeLastBufferWithTime=function(a,b){var c=this;return pc(b)||(b=Bc),new xg(function(d){var e=[];return c.subscribe(function(c){var d=b.now();for(e.push({interval:d,value:c});e.length>0&&d-e[0].interval>=a;)e.shift()},function(a){d.onError(a)},function(){for(var c=b.now(),f=[];e.length>0;){var g=e.shift();c-g.interval<=a&&f.push(g.value)}d.onNext(f),d.onCompleted()})},c)};var hg=function(a){function b(b,c,d){this.source=b,this._d=c,this._s=d,a.call(this)}function c(a,b){b.onCompleted()}return Wb(b,a),b.prototype.subscribeCore=function(a){return new jc(this._s.scheduleFuture(a,this._d,c),this.source.subscribe(a))},b}(Tc);Mc.takeWithTime=function(a,b){return pc(b)||(b=Bc),new hg(this,a,b)};var ig=function(a){function b(b,c,d){this.source=b,this._d=c,this._s=d,this._open=!1,a.call(this)}function c(a,b){b._open=!0}return Wb(b,a),b.prototype.subscribeCore=function(a){return new jc(this._s.scheduleFuture(this,this._d,c),this.source.subscribe(new jg(a,this)))},b}(Tc),jg=function(a){function b(b,c){this._o=b,this._p=c,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._p._open&&this._o.onNext(a)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.skipWithTime=function(a,b){return pc(b)||(b=Bc),new ig(this,a,b)};var kg=function(a){function b(b,c,d){this.source=b,this._st=c,this._s=d,a.call(this)}function c(a,b){b._open=!0}return Wb(b,a),b.prototype.subscribeCore=function(a){return this._open=!1,new jc(this._s.scheduleFuture(this,this._st,c),this.source.subscribe(new lg(a,this)))},b}(Tc),lg=function(a){function b(b,c){this._o=b,this._p=c,a.call(this)}return Wb(b,a),b.prototype.next=function(a){this._p._open&&this._o.onNext(a)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._o.onCompleted()},b}(Nc);Mc.skipUntilWithTime=function(a,b){return pc(b)||(b=Bc),new kg(this,a,b)},Mc.takeUntilWithTime=function(a,b){pc(b)||(b=Bc);var c=this;return new xg(function(d){return new jc(b.scheduleFuture(d,a,function(a,b){b.onCompleted()}),c.subscribe(d))},c)},Mc.throttle=function(a,b){pc(b)||(b=Bc);var c=+a||0;if(0>=c)throw new RangeError("windowDuration cannot be less or equal zero.");var d=this;return new xg(function(a){var e=0;return d.subscribe(function(d){var f=b.now();(0===e||f-e>=c)&&(e=f,a.onNext(d))},function(b){a.onError(b)},function(){a.onCompleted()})},d)};var mg=function(a){function b(b,c){this._o=b,this._xform=c,a.call(this)}return Wb(b,a),b.prototype.next=function(a){
var b=$a(this._xform["@@transducer/step"]).call(this._xform,this._o,a);b===Za&&this._o.onError(b.e)},b.prototype.error=function(a){this._o.onError(a)},b.prototype.completed=function(){this._xform["@@transducer/result"](this._o)},b}(Nc);Mc.transduce=function(a){var b=this;return new xg(function(c){var d=a(Da(c));return b.subscribe(new mg(c,d))},b)};var ng=function(a){function b(b){this.source=b,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){var b=new hc,c=new _b,d={hasCurrent:!1,isStopped:!1,o:a,g:c};return c.add(b),b.setDisposable(this.source.subscribe(new og(d))),c},b}(Tc),og=function(a){function b(b){this._s=b,a.call(this)}function c(b,c){this._s=b,this._i=c,a.call(this)}return Wb(b,a),b.prototype.next=function(a){if(!this._s.hasCurrent){this._s.hasCurrent=!0,Xa(a)&&(a=dd(a));var b=new hc;this._s.g.add(b),b.setDisposable(a.subscribe(new c(this._s,b)))}},b.prototype.error=function(a){this._s.o.onError(a)},b.prototype.completed=function(){this._s.isStopped=!0,!this._s.hasCurrent&&1===this._s.g.length&&this._s.o.onCompleted()},Wb(c,a),c.prototype.next=function(a){this._s.o.onNext(a)},c.prototype.error=function(a){this._s.o.onError(a)},c.prototype.completed=function(){this._s.g.remove(this._i),this._s.hasCurrent=!1,this._s.isStopped&&1===this._s.g.length&&this._s.o.onCompleted()},b}(Nc);Mc.switchFirst=function(){return new ng(this)},Mc.flatMapFirst=Mc.exhaustMap=function(a,b,c){return new Uc(this,a,b,c).switchFirst()},Mc.flatMapWithMaxConcurrent=Mc.flatMapMaxConcurrent=function(a,b,c,d){return new Uc(this,b,c,d).merge(a)};var pg=Qa.VirtualTimeScheduler=function(a){function b(b,c){this.clock=b,this.comparer=c,this.isEnabled=!1,this.queue=new Zb(1024),a.call(this)}Wb(b,a);var c=b.prototype;return c.now=function(){return this.toAbsoluteTime(this.clock)},c.schedule=function(a,b){return this.scheduleAbsolute(a,this.clock,b)},c.scheduleFuture=function(a,b,c){var d=b instanceof Date?this.toRelativeTime(b-this.now()):this.toRelativeTime(b);return this.scheduleRelative(a,d,c)},c.add=jb,c.toAbsoluteTime=jb,c.toRelativeTime=jb,c.schedulePeriodic=function(a,b,c){var d=new sc(this,a,b,c);return d.start()},c.scheduleRelative=function(a,b,c){var d=this.add(this.clock,b);return this.scheduleAbsolute(a,d,c)},c.start=function(){if(!this.isEnabled){this.isEnabled=!0;do{var a=this.getNext();null!==a?(this.comparer(a.dueTime,this.clock)>0&&(this.clock=a.dueTime),a.invoke()):this.isEnabled=!1}while(this.isEnabled)}},c.stop=function(){this.isEnabled=!1},c.advanceTo=function(a){var b=this.comparer(this.clock,a);if(this.comparer(this.clock,a)>0)throw new gb;if(0!==b&&!this.isEnabled){this.isEnabled=!0;do{var c=this.getNext();null!==c&&this.comparer(c.dueTime,a)<=0?(this.comparer(c.dueTime,this.clock)>0&&(this.clock=c.dueTime),c.invoke()):this.isEnabled=!1}while(this.isEnabled);this.clock=a}},c.advanceBy=function(a){var b=this.add(this.clock,a),c=this.comparer(this.clock,b);if(c>0)throw new gb;0!==c&&this.advanceTo(b)},c.sleep=function(a){var b=this.add(this.clock,a);if(this.comparer(this.clock,b)>=0)throw new gb;this.clock=b},c.getNext=function(){for(;this.queue.length>0;){var a=this.queue.peek();if(!a.isCancelled())return a;this.queue.dequeue()}return null},c.scheduleAbsolute=function(a,b,c){function d(a,b){return e.queue.remove(f),c(a,b)}var e=this,f=new mc(this,a,d,b,this.comparer);return this.queue.enqueue(f),f.disposable},b}(nc);Qa.HistoricalScheduler=function(a){function b(b,c){var d=null==b?0:b,e=c||Va;a.call(this,d,e)}Wb(b,a);var c=b.prototype;return c.add=function(a,b){return a+b},c.toAbsoluteTime=function(a){return new Date(a).getTime()},c.toRelativeTime=function(a){return a},b}(Qa.VirtualTimeScheduler),Ea.prototype.equals=function(a){return a===this?!0:null==a?!1:"N"!==a.kind?!1:this.predicate(a.value)},Fa.prototype.equals=function(a){return a===this?!0:null==a?!1:"E"!==a.kind?!1:this.predicate(a.error)};var qg=Qa.ReactiveTest={created:100,subscribed:200,disposed:1e3,onNext:function(a,b){return"function"==typeof b?new rg(a,new Ea(b)):new rg(a,Dc.createOnNext(b))},onError:function(a,b){return"function"==typeof b?new rg(a,new Fa(b)):new rg(a,Dc.createOnError(b))},onCompleted:function(a){return new rg(a,Dc.createOnCompleted())},subscribe:function(a,b){return new sg(a,b)}},rg=Qa.Recorded=function(a,b,c){this.time=a,this.value=b,this.comparer=c||Ua};rg.prototype.equals=function(a){return this.time===a.time&&this.comparer(this.value,a.value)},rg.prototype.toString=function(){return this.value.toString()+"@"+this.time};var sg=Qa.Subscription=function(a,b){this.subscribe=a,this.unsubscribe=b||Number.MAX_VALUE};sg.prototype.equals=function(a){return this.subscribe===a.subscribe&&this.unsubscribe===a.unsubscribe},sg.prototype.toString=function(){return"("+this.subscribe+", "+(this.unsubscribe===Number.MAX_VALUE?"Infinite":this.unsubscribe)+")"};var tg=Qa.MockDisposable=function(a){this.scheduler=a,this.disposes=[],this.disposes.push(this.scheduler.clock)};tg.prototype.dispose=function(){this.disposes.push(this.scheduler.clock)};var ug=function(a){function b(b){a.call(this),this.scheduler=b,this.messages=[]}Wb(b,a);var c=b.prototype;return c.onNext=function(a){this.messages.push(new rg(this.scheduler.clock,Dc.createOnNext(a)))},c.onError=function(a){this.messages.push(new rg(this.scheduler.clock,Dc.createOnError(a)))},c.onCompleted=function(){this.messages.push(new rg(this.scheduler.clock,Dc.createOnCompleted()))},b}(Kc);Ga.prototype.then=function(b,c){var d=this;this.subscriptions.push(new sg(this.scheduler.clock));var e,f=this.subscriptions.length-1,g=Qa.Observer.create(function(c){var h=b(c);if(h&&"function"==typeof h.then)e=h;else{var i=d.scheduler.clock;e=new Ga(d.scheduler,[Qa.ReactiveTest.onNext(i,a),Qa.ReactiveTest.onCompleted(i)])}var j=d.observers.indexOf(g);d.observers.splice(j,1),d.subscriptions[f]=new sg(d.subscriptions[f].subscribe,d.scheduler.clock)},function(a){c(a);var b=d.observers.indexOf(g);d.observers.splice(b,1),d.subscriptions[f]=new sg(d.subscriptions[f].subscribe,d.scheduler.clock)});return this.observers.push(g),e||new Ga(this.scheduler,this.messages)};var vg=function(a){function b(b,c){a.call(this);var d,e,f=this;this.scheduler=b,this.messages=c,this.subscriptions=[],this.observers=[];for(var g=0,h=this.messages.length;h>g;g++)d=this.messages[g],e=d.value,function(a){b.scheduleAbsolute(null,d.time,function(){for(var b=f.observers.slice(0),c=0,d=b.length;d>c;c++)a.accept(b[c]);return dc})}(e)}return Wb(b,a),b.prototype._subscribe=function(a){var b=this;this.observers.push(a),this.subscriptions.push(new sg(this.scheduler.clock));var c=this.subscriptions.length-1;return cc(function(){var d=b.observers.indexOf(a);b.observers.splice(d,1),b.subscriptions[c]=new sg(b.subscriptions[c].subscribe,b.scheduler.clock)})},b}(Sc),wg=function(a){function b(b,c){a.call(this),this.scheduler=b,this.messages=c,this.subscriptions=[]}return Wb(b,a),b.prototype._subscribe=function(a){var b,c,d=this;this.subscriptions.push(new sg(this.scheduler.clock));for(var e=this.subscriptions.length-1,f=new _b,g=0,h=this.messages.length;h>g;g++)b=this.messages[g],c=b.value,function(c){f.add(d.scheduler.scheduleRelative(null,b.time,function(){return c.accept(a),dc}))}(c);return cc(function(){d.subscriptions[e]=new sg(d.subscriptions[e].subscribe,d.scheduler.clock),f.dispose()})},b}(Sc);Qa.TestScheduler=function(a){function b(a,b){return a>b?1:b>a?-1:0}function c(){a.call(this,0,b)}return Wb(c,a),c.prototype.scheduleAbsolute=function(b,c,d){return c<=this.clock&&(c=this.clock+1),a.prototype.scheduleAbsolute.call(this,b,c,d)},c.prototype.add=function(a,b){return a+b},c.prototype.toAbsoluteTime=function(a){return new Date(a).getTime()},c.prototype.toRelativeTime=function(a){return a},c.prototype.startScheduler=function(a,b){b||(b={}),null==b.created&&(b.created=qg.created),null==b.subscribed&&(b.subscribed=qg.subscribed),null==b.disposed&&(b.disposed=qg.disposed);var c,d,e=this.createObserver();return this.scheduleAbsolute(null,b.created,function(){return c=a(),dc}),this.scheduleAbsolute(null,b.subscribed,function(){return d=c.subscribe(e),dc}),this.scheduleAbsolute(null,b.disposed,function(){return d.dispose(),dc}),this.start(),e},c.prototype.createHotObservable=function(){var a,b=arguments.length;if(Array.isArray(arguments[0]))a=arguments[0];else{a=new Array(b);for(var c=0;b>c;c++)a[c]=arguments[c]}return new vg(this,a)},c.prototype.createColdObservable=function(){var a,b=arguments.length;if(Array.isArray(arguments[0]))a=arguments[0];else{a=new Array(b);for(var c=0;b>c;c++)a[c]=arguments[c]}return new wg(this,a)},c.prototype.createResolvedPromise=function(a,b){return new Ga(this,[Qa.ReactiveTest.onNext(a,b),Qa.ReactiveTest.onCompleted(a)])},c.prototype.createRejectedPromise=function(a,b){return new Ga(this,[Qa.ReactiveTest.onError(a,b)])},c.prototype.createObserver=function(){return new ug(this)},c}(pg);var xg=Qa.AnonymousObservable=function(a){function b(a){return a&&Ya(a.dispose)?a:Ya(a)?cc(a):dc}function c(a,c){var d=c[0],f=c[1],g=$a(f.__subscribe).call(f,d);g!==Za||d.fail(Za.e)||e(Za.e),d.setDisposable(b(g))}function d(b,c){this.source=c,this.__subscribe=b,a.call(this)}return Wb(d,a),d.prototype._subscribe=function(a){var b=new yg(a),d=[b,this];return wc.scheduleRequired()?wc.schedule(d,c):c(null,d),b},d}(Sc),yg=function(a){function b(b){a.call(this),this.observer=b,this.m=new hc}Wb(b,a);var c=b.prototype;return c.next=function(a){var b=$a(this.observer.onNext).call(this.observer,a);b===Za&&(this.dispose(),e(b.e))},c.error=function(a){var b=$a(this.observer.onError).call(this.observer,a);this.dispose(),b===Za&&e(b.e)},c.completed=function(){var a=$a(this.observer.onCompleted).call(this.observer);this.dispose(),a===Za&&e(a.e)},c.setDisposable=function(a){this.m.setDisposable(a)},c.getDisposable=function(){return this.m.getDisposable()},c.dispose=function(){a.prototype.dispose.call(this),this.m.dispose()},b}(Nc),zg=function(a){function b(b,c){this._m=b,this._u=c,a.call(this)}return Wb(b,a),b.prototype.subscribeCore=function(a){return new jc(this._m.getDisposable(),this._u.subscribe(a))},b}(Tc),Ag=function(a){function b(b,c,d){a.call(this),this.key=b,this.underlyingObservable=d?new zg(d,c):c}return Wb(b,a),b.prototype._subscribe=function(a){return this.underlyingObservable.subscribe(a)},b}(Sc),Bg=Qa.Subject=function(a){function b(){a.call(this),this.isDisposed=!1,this.isStopped=!1,this.observers=[],this.hasError=!1}return Wb(b,a),Xb(b.prototype,Kc.prototype,{_subscribe:function(a){return fc(this),this.isStopped?this.hasError?(a.onError(this.error),dc):(a.onCompleted(),dc):(this.observers.push(a),new Cf(this,a))},hasObservers:function(){return fc(this),this.observers.length>0},onCompleted:function(){if(fc(this),!this.isStopped){this.isStopped=!0;for(var a=0,b=c(this.observers),d=b.length;d>a;a++)b[a].onCompleted();this.observers.length=0}},onError:function(a){if(fc(this),!this.isStopped){this.isStopped=!0,this.error=a,this.hasError=!0;for(var b=0,d=c(this.observers),e=d.length;e>b;b++)d[b].onError(a);this.observers.length=0}},onNext:function(a){if(fc(this),!this.isStopped)for(var b=0,d=c(this.observers),e=d.length;e>b;b++)d[b].onNext(a)},dispose:function(){this.isDisposed=!0,this.observers=null}}),b.create=function(a,b){return new Fg(a,b)},b}(Sc),Cg=Qa.AsyncSubject=function(a){function b(){a.call(this),this.isDisposed=!1,this.isStopped=!1,this.hasValue=!1,this.observers=[],this.hasError=!1}return Wb(b,a),Xb(b.prototype,Kc.prototype,{_subscribe:function(a){return fc(this),this.isStopped?(this.hasError?a.onError(this.error):this.hasValue?(a.onNext(this.value),a.onCompleted()):a.onCompleted(),dc):(this.observers.push(a),new Cf(this,a))},hasObservers:function(){return fc(this),this.observers.length>0},onCompleted:function(){var a,b;if(fc(this),!this.isStopped){this.isStopped=!0;var d=c(this.observers),b=d.length;if(this.hasValue)for(a=0;b>a;a++){var e=d[a];e.onNext(this.value),e.onCompleted()}else for(a=0;b>a;a++)d[a].onCompleted();this.observers.length=0}},onError:function(a){if(fc(this),!this.isStopped){this.isStopped=!0,this.hasError=!0,this.error=a;for(var b=0,d=c(this.observers),e=d.length;e>b;b++)d[b].onError(a);this.observers.length=0}},onNext:function(a){fc(this),this.isStopped||(this.value=a,this.hasValue=!0)},dispose:function(){this.isDisposed=!0,this.observers=null,this.error=null,this.value=null}}),b}(Sc),Dg=Qa.BehaviorSubject=function(a){function b(b){a.call(this),this.value=b,this.observers=[],this.isDisposed=!1,this.isStopped=!1,this.hasError=!1}return Wb(b,a),Xb(b.prototype,Kc.prototype,{_subscribe:function(a){return fc(this),this.isStopped?(this.hasError?a.onError(this.error):a.onCompleted(),dc):(this.observers.push(a),a.onNext(this.value),new Cf(this,a))},getValue:function(){return fc(this),this.hasError&&e(this.error),this.value},hasObservers:function(){return fc(this),this.observers.length>0},onCompleted:function(){if(fc(this),!this.isStopped){this.isStopped=!0;for(var a=0,b=c(this.observers),d=b.length;d>a;a++)b[a].onCompleted();this.observers.length=0}},onError:function(a){if(fc(this),!this.isStopped){this.isStopped=!0,this.hasError=!0,this.error=a;for(var b=0,d=c(this.observers),e=d.length;e>b;b++)d[b].onError(a);this.observers.length=0}},onNext:function(a){if(fc(this),!this.isStopped){this.value=a;for(var b=0,d=c(this.observers),e=d.length;e>b;b++)d[b].onNext(a)}},dispose:function(){this.isDisposed=!0,this.observers=null,this.value=null,this.error=null}}),b}(Sc),Eg=Qa.ReplaySubject=function(a){function b(a,b){return cc(function(){b.dispose(),!a.isDisposed&&a.observers.splice(a.observers.indexOf(b),1)})}function d(b,c,d){this.bufferSize=null==b?e:b,this.windowSize=null==c?e:c,this.scheduler=d||wc,this.q=[],this.observers=[],this.isStopped=!1,this.isDisposed=!1,this.hasError=!1,this.error=null,a.call(this)}var e=Math.pow(2,53)-1;return Wb(d,a),Xb(d.prototype,Kc.prototype,{_subscribe:function(a){fc(this);var c=new Qc(this.scheduler,a),d=b(this,c);this._trim(this.scheduler.now()),this.observers.push(c);for(var e=0,f=this.q.length;f>e;e++)c.onNext(this.q[e].value);return this.hasError?c.onError(this.error):this.isStopped&&c.onCompleted(),c.ensureActive(),d},hasObservers:function(){return fc(this),this.observers.length>0},_trim:function(a){for(;this.q.length>this.bufferSize;)this.q.shift();for(;this.q.length>0&&a-this.q[0].interval>this.windowSize;)this.q.shift()},onNext:function(a){if(fc(this),!this.isStopped){var b=this.scheduler.now();this.q.push({interval:b,value:a}),this._trim(b);for(var d=0,e=c(this.observers),f=e.length;f>d;d++){var g=e[d];g.onNext(a),g.ensureActive()}}},onError:function(a){if(fc(this),!this.isStopped){this.isStopped=!0,this.error=a,this.hasError=!0;var b=this.scheduler.now();this._trim(b);for(var d=0,e=c(this.observers),f=e.length;f>d;d++){var g=e[d];g.onError(a),g.ensureActive()}this.observers.length=0}},onCompleted:function(){if(fc(this),!this.isStopped){this.isStopped=!0;var a=this.scheduler.now();this._trim(a);for(var b=0,d=c(this.observers),e=d.length;e>b;b++){var f=d[b];f.onCompleted(),f.ensureActive()}this.observers.length=0}},dispose:function(){this.isDisposed=!0,this.observers=null}}),d}(Sc),Fg=Qa.AnonymousSubject=function(a){function b(b,c){this.observer=b,this.observable=c,a.call(this)}return Wb(b,a),Xb(b.prototype,Kc.prototype,{_subscribe:function(a){return this.observable.subscribe(a)},onCompleted:function(){this.observer.onCompleted()},onError:function(a){this.observer.onError(a)},onNext:function(a){this.observer.onNext(a)}}),b}(Sc);Qa.Pauser=function(a){function b(){a.call(this)}return Wb(b,a),b.prototype.pause=function(){this.onNext(!1)},b.prototype.resume=function(){this.onNext(!0)},b}(Bg),"function"==typeof define&&"object"==typeof define.amd&&define.amd?(Pa.Rx=Qa,define(function(){return Qa})):Ia&&Ja?Na?(Ja.exports=Qa).Rx=Qa:Ia.Rx=Qa:Pa.Rx=Qa;var Gg=j()}).call(this);
//# sourceMappingURL=rx.all.map
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

var _ = require('lodash');

var prototype = {
    dataKeyToInput: function (input, dataKey) {
        if (typeof dataKey === 'function') {
            return dataKey(input, this.context);
        } else {
            return _.get(input, dataKey, null);
        }
    },
    dataKeyArrayToInput: function (input, dataKeyArray) {
        var n = dataKeyArray.length;
        for (var i = 0; i < n; ++i) {
            var dataKey = dataKeyArray[i];
            var inputCandidate = this.dataKeyToInput(input, dataKey);
            if ((inputCandidate !== null) && (inputCandidate !== undefined)) {
                return inputCandidate;
            }
        }
        return null;
    },
    evaluateDataKey: function (input, dataKey) {
        if (Array.isArray(dataKey)) {
            return this.dataKeyArrayToInput(input, dataKey);
        } else {
            return this.dataKeyToInput(input, dataKey);
        }
    },
    evaluateValue: function (value, input) {
        var valueType = (typeof value);
        if (valueType === 'function') {
            return value(input);
        } else if (valueType === 'object') {
            return this.run(value, input);
        } else {
            return value;
        }
    },
    content: function (template, input) {
        var that = this;
        var content = template.content;
        var hasValue = false;
        var keys = Object.keys(content);
        var result = keys.reduce(function (r, key) {
            var contentValue = template.content[key];
            var value = that.evaluateValue(contentValue, input);
            if (value !== null) {
                if (template.ignoreDeep) {
                    r[key] = value;
                } else {
                    _.set(r, key, value);
                }
                hasValue = true;
            }
            return r;
        }, {});
        return hasValue ? result : null;
    },
    arrayContent: function (template, input) {
        var that = this;
        var content = template.arrayContent;
        var result = content.reduce(function (r, e) {
            var value = that.evaluateValue(e, input);
            if (value !== null) {
                if (Array.isArray(value)) {
                    Array.prototype.push.apply(r, value);
                } else {
                    r.push(value);
                }
            }
            return r;
        }, []);
        return result.length ? result : null;
    },
    assign: function (template, input) {
        var templateAssign = template.assign;
        var that = this;
        var assignValues = templateAssign.reduce(function (r, assignValue) {
            var v = that.evaluateValue(assignValue, input);
            if ((v !== null) && (typeof v === 'object')) {
                r.push(v);
            }
            return r;
        }, [{}]);
        if (assignValues.length === 1) {
            return null;
        }
        var v = _.assign.apply(null, assignValues);
        return v;
    },
    firstOf: function (template, input) {
        var templateFirstOf = template.firstOf;
        for (var i = 0; i < templateFirstOf.length; ++i) {
            var t = templateFirstOf[i];
            var value = this.evaluateValue(t, input);
            if (value !== null) {
                return value;
            }
        }
        return null;
    },
    constant: function (template, input) {
        return template.constant;
    },
    value: function (template, input) {
        var templateValue = template.value;
        return this.evaluateValue(templateValue, input);
    },
    runForArray: function (template, input) {
        var hasActionKeys = false;
        var modifiedTemplate = this.actionKeys.reduce(function (r, actionKey) {
            // dataTransform tags only apply to the array
            if (template[actionKey]) {
                r[actionKey] = template[actionKey];
                hasActionKeys = true;
            }
            return r;
        }, {});
        if (!hasActionKeys) {
            return input;
        }
        var that = this;
        var result = input.reduce(function (r, e) {
            var value = that.run(modifiedTemplate, e);
            if (value !== null) {
                r.push(value);
            }
            return r;
        }, []);
        if (result.length > 0) {
            return result;
        } else {
            return null;
        }
    },
    evaluateExistsWhen: function (template, input) {
        var existsWhen = template.existsWhen;
        if (existsWhen) {
            if (Array.isArray(existsWhen)) {
                return existsWhen.every(function (ew) {
                    return ew(input);
                });
            } else {
                return existsWhen(input);
            }
        }
        return true;
    },
    evaluateExistsUnless: function (template, input) {
        var existsUnless = template.existsUnless;
        if (existsUnless) {
            if (Array.isArray(existsUnless)) {
                return existsUnless.every(function (ew) {
                    return ew(input);
                });
            } else {
                return existsUnless(input);
            }
        }
        return false;
    },
    run: function (template, input) {
        if (!this.evaluateExistsWhen(template, input)) {
            return null;
        }
        if (this.evaluateExistsUnless(template, input)) {
            return null;
        }
        if ((input !== null) && (input !== undefined) && template.dataKey) {
            input = this.evaluateDataKey(input, template.dataKey);
        }
        if ((input !== null) && template.dataTransform) {
            input = template.dataTransform(input, this.context);
        }
        if (Array.isArray(input)) {
            if (template.single) {
                input = input[0];
            } else {
                var resultForArray = this.runForArray(template, input);
                if (resultForArray === null && (template.default !== null && template.default !== undefined)) {
                    resultForArray = template.default;
                }
                return resultForArray;
            }
        }
        var result = input;
        if (input !== null) {
            for (var i = 0; i < this.actionKeys.length; ++i) {
                var actionKey = this.actionKeys[i];
                if (template.hasOwnProperty(actionKey)) {
                    result = this[actionKey](template, input);
                    break;
                }
            }
        }
        if (result === null && (template.default !== null && template.default !== undefined)) {
            result = template.default;
        }
        if ((result !== null) && template.multiple) {
            result = [result];
        }
        return result;
    },
    actionKeys: ['content', 'value', 'assign', 'firstOf', 'constant', 'arrayContent'],
    context: {}
};

    window.jsonapter = {};
window.jsonapter.instance = function (overrides, addlActionKeys) {
    var result = Object.create(prototype);
    if (overrides) {
        _.assign(result, overrides);
    }
    if (addlActionKeys) {
        result.actionKeys = result.actionKeys.concat(addlActionKeys);
    }
    return result;
};

},{"lodash":2}],2:[function(require,module,exports){
(function (global){
/**
 * @license
 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.10.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

  /**
   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
   */
  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHasHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled regexes. */
  var regexpEscapes = {
    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it's the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsNull = value === null,
          valIsUndef = value === undefined,
          valIsReflexive = value === value;

      var othIsNull = other === null,
          othIsUndef = other === undefined,
          othIsReflexive = other === other;

      if ((value > other && !othIsNull) || !valIsReflexive ||
          (valIsNull && !othIsUndef && othIsReflexive) ||
          (valIsUndef && othIsReflexive)) {
        return 1;
      }
      if ((value < other && !valIsNull) || !othIsReflexive ||
          (othIsNull && !valIsUndef && valIsReflexive) ||
          (othIsUndef && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it's not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
   * a value is sorted in ascending order if its corresponding order is "asc", and
   * descending if "desc".
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * ((order === 'asc' || order === true) ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @param {string} leadingChar The capture group for a leading character.
   * @param {string} whitespaceChar The capture group for a whitespace character.
   * @returns {string} Returns the escaped character.
   */
  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
    if (leadingChar) {
      chr = regexpEscapes[chr];
    } else if (whitespaceChar) {
      chr = stringEscapes[chr];
    }
    return '\\' + chr;
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = context.ArrayBuffer,
        clearTimeout = context.clearTimeout,
        parseFloat = context.parseFloat,
        pow = Math.pow,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = getNative(context, 'Set'),
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = context.Uint8Array,
        WeakMap = getNative(context, 'WeakMap');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeCreate = getNative(Object, 'create'),
        nativeFloor = Math.floor,
        nativeIsArray = getNative(Array, 'isArray'),
        nativeIsFinite = context.isFinite,
        nativeKeys = getNative(Object, 'keys'),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = getNative(Date, 'now'),
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /**
     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that retrieve a single value or may return a
     * primitive value will automatically end the chain returning the unwrapped
     * value. Explicit chaining may be enabled using `_.chain`. The execution of
     * chained methods is lazy, that is, execution is deferred until `_#value`
     * is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization strategy which merge iteratee calls; this can help
     * to avoid the creation of intermediate data structures and greatly reduce the
     * number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
     * `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = arrayCopy(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = arrayCopy(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = arrayCopy(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Sets `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a new array joining `array` with `other`.
     *
     * @private
     * @param {Array} array The array to join.
     * @param {Array} other The other array to join.
     * @returns {Array} Returns the new concatenated array.
     */
    function arrayConcat(array, other) {
      var index = -1,
          length = array.length,
          othIndex = -1,
          othLength = other.length,
          result = Array(length + othLength);

      while (++index < length) {
        result[index] = array[index];
      }
      while (++othIndex < othLength) {
        result[index++] = other[othIndex];
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
     * with one argument: (value).
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function arrayExtremum(array, iteratee, comparator, exValue) {
      var index = -1,
          length = array.length,
          computed = exValue,
          result = computed;

      while (++index < length) {
        var value = array[index],
            current = +iteratee(value);

        if (comparator(current, computed)) {
          computed = current;
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for callback
     * shorthands and `this` binding..
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function arraySum(array, iteratee) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +iteratee(array[length]) || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This function is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (objectValue === undefined || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * A specialized version of `_.assign` for customizing assigned values without
     * support for argument juggling, multiple sources, and `this` binding `customizer`
     * functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     */
    function assignWith(object, source, customizer) {
      var index = -1,
          props = keys(source),
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (value === undefined && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return source == null
        ? object
        : baseCopy(source, keys(source), object);
    }

    /**
     * The base implementation of `_.at` without support for string collections
     * and individual key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} props The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          isNil = collection == null,
          isArr = !isNil && isArrayLike(collection),
          length = isArr ? collection.length : 0,
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = isNil ? undefined : collection[key];
        }
      }
      return result;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, props, object) {
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return thisArg === undefined
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return thisArg === undefined
        ? property(func)
        : baseMatchesProperty(func, thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseAssign(result, value);
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return its corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          object.prototype = prototype;
          var result = new object;
          object.prototype = undefined;
        }
        return result || {};
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(collection, iteratee, comparator, exValue) {
      var computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = +iteratee(value, index, collection);
        if (comparator(current, computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, result) {
      result || (result = []);

      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index];
        if (isObjectLike(value) && isArrayLike(value) &&
            (isStrict || isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, isDeep, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `get` without support for string paths
     * and default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path of the property to get.
     * @param {string} [pathKey] The key representation of path.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (!isLoose) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} matchData The propery names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = toObject(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];

        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value && (value !== undefined || (key in toObject(object)));
        };
      }
      return function(object) {
        return baseIsMatch(object, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(path, srcValue) {
      var isArr = isArray(path),
          isCommon = isKey(path) && isStrictComparable(srcValue),
          pathKey = (path + '');

      path = toPath(path);
      return function(object) {
        if (object == null) {
          return false;
        }
        var key = pathKey;
        object = toObject(object);
        if ((isArr || !isCommon) && !(key in object)) {
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          if (object == null) {
            return false;
          }
          key = last(path);
          object = toObject(object);
        }
        return object[key] === srcValue
          ? (srcValue !== undefined || (key in object))
          : baseIsEqual(srcValue, object[key], undefined, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns `object`.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
          props = isSrcArr ? undefined : keys(source);

      arrayEach(props || source, function(srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        else {
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

          if (isCommon) {
            result = srcValue;
          }
          if ((result !== undefined || (isSrcArr && !(key in object))) &&
              (isCommon || (result === result ? (result !== value) : (value === value)))) {
            object[key] = result;
          }
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (isArrayLike(value) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     */
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments and capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0;
      while (length--) {
        var index = indexes[length];
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + nativeFloor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, iteratees, orders) {
      var callback = getCallback(),
          index = -1;

      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

      var result = baseMap(collection, function(value) {
        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var action = actions[index];
        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsUndef = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            isDef = computed !== undefined,
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsNull) {
          setLow = isReflexive && isDef && (retHighest || computed != null);
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || isDef);
        } else if (computed == null) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (thisArg === undefined) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      var result = new ArrayBuffer(buffer.byteLength),
          view = new Uint8Array(result);

      view.set(new Uint8Array(buffer));
      return result;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(leftLength + argsLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return restParam(function(object, sources) {
        var index = -1,
            length = object == null ? 0 : sources.length,
            customizer = length > 2 ? sources[length - 2] : undefined,
            guard = length > 2 ? sources[2] : undefined,
            thisArg = length > 1 ? sources[length - 1] : undefined;

        if (typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = typeof thisArg == 'function' ? thisArg : undefined;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? getLength(collection) : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    function createCache(values) {
      return (nativeCreate && Set) ? new SetCache(values) : null;
    }

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors.
        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = undefined;
        }
        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.defaults` or `_.defaultsDeep` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Function} Returns the new defaults function.
     */
    function createDefaults(assigner, customizer) {
      return restParam(function(args) {
        var object = args[0];
        if (object == null) {
          return object;
        }
        args.push(customizer);
        return assigner.apply(undefined, args);
      });
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(comparator, exValue) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = undefined;
        }
        iteratee = getCallback(iteratee, thisArg, 3);
        if (iteratee.length == 1) {
          collection = isArray(collection) ? collection : toIterable(collection);
          var result = arrayExtremum(collection, iteratee, comparator, exValue);
          if (!(collection.length && result === exValue)) {
            return result;
          }
        }
        return baseExtremum(collection, iteratee, comparator, exValue);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      };
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var wrapper,
            length = arguments.length,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
            wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.mapKeys` or `_.mapValues`.
     *
     * @private
     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
     * @returns {Function} Returns the new map function.
     */
    function createObjectMapper(isMapKeys) {
      return function(object, iteratee, thisArg) {
        var result = {};
        iteratee = getCallback(iteratee, thisArg, 3);

        baseForOwn(object, function(value, key, object) {
          var mapped = iteratee(value, key, object);
          key = isMapKeys ? mapped : key;
          value = isMapKeys ? value : mapped;
          result[key] = value;
        });
        return result;
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, undefined, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
          Ctor = isBindKey ? undefined : createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : undefined,
                newHoldersRight = isCurry ? undefined : argsHolders,
                newPartials = isCurry ? args : undefined,
                newPartialsRight = isCurry ? undefined : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtorWrapper(func);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        precision = precision === undefined ? 0 : (+precision || 0);
        if (precision) {
          precision = pow(10, precision);
          return func(number * precision) / precision;
        }
        return func(number);
      };
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var callback = getCallback(iteratee);
        return (iteratee == null && callback === baseCallback)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index],
            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

        if (result !== undefined) {
          if (result) {
            continue;
          }
          return false;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (isLoose) {
          if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
            return false;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            : object == +other;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var skipCtor = isLoose;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key],
            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

        // Recursively compare objects (susceptible to call stack limits).
        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = func.name,
          array = realNames[result],
          length = array ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Gets the propery names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = pairs(object),
          length = result.length;

      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object == null ? undefined : object[key];
      return isNative(value) ? value : undefined;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Invokes the method at `path` on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function invokePath(object, path, args) {
      if (object != null && !isKey(path, object)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        path = last(path);
      }
      var func = object == null ? object : object[path];
      return func == null ? undefined : func.apply(object, args);
    }

    /**
     * Checks if `value` is array-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value));
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func);
      if (!(funcName in LazyWrapper.prototype)) {
        return false;
      }
      var other = lodash[funcName];
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function mergeDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties specified
     * by `props`.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length;

      var allowIndexes = !!length && isLength(length) &&
        (isArray(object) || isArguments(object));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isArrayLike(value)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to property path array if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array} Returns the property path array.
     */
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(nativeFloor(size) || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array of unique `array` values not included in the other
     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isObjectLike(array) && isArrayLike(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
     * performs a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value);
        if (index < length &&
            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values that are included in all of the provided
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    var intersection = restParam(function(arrays) {
      var othLength = arrays.length,
          othIndex = othLength,
          caches = Array(length),
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          result = [];

      while (othIndex--) {
        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
      }
      var array = arrays[0],
          index = -1,
          length = array ? array.length : 0,
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          var othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      indexes = baseFlatten(indexes);

      var result = baseAt(array, indexes);
      basePullAt(array, indexes.sort(baseCompareAscending));
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all of the provided arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurence of each element
     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
     * for sorted arrays. If an iteratee function is provided it is invoked for
     * each element in the array to generate the criterion by which uniqueness
     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
        isSorted = false;
      }
      var callback = getCallback();
      if (!(iteratee == null && callback === baseCallback)) {
        iteratee = callback(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var index = -1,
          length = 0;

      array = arrayFilter(array, function(group) {
        if (isArrayLike(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      var result = Array(length);
      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * This method is like `_.unzip` except that it accepts an iteratee to specify
     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee] The function to combine regrouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      iteratee = bindCallback(iteratee, thisArg, 4);
      return arrayMap(result, function(group) {
        return arrayReduce(group, iteratee, undefined, true);
      });
    }

    /**
     * Creates an array excluding all provided values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return isArrayLike(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArrayLike(array)) {
          var result = result
            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /**
     * This method is like `_.zip` except that it accepts an iteratee to specify
     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee] The function to combine grouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
     * // => [111, 222]
     */
    var zipWith = restParam(function(arrays) {
      var length = arrays.length,
          iteratee = length > 2 ? arrays[length - 2] : undefined,
          thisArg = length > 1 ? arrays[length - 1] : undefined;

      if (length > 2 && typeof iteratee == 'function') {
        length -= 2;
      } else {
        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
        thisArg = undefined;
      }
      arrays.length = length;
      return unzipWith(arrays, iteratee, thisArg);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a new array joining a wrapped array with any additional arrays
     * and/or values.
     *
     * @name concat
     * @memberOf _
     * @category Chain
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var wrapped = _(array).concat(2, [3], [[4]]);
     *
     * console.log(wrapped.value());
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    var wrapperConcat = restParam(function(values) {
      values = baseFlatten(values);
      return this.thru(function(array) {
        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
      });
    });

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapped = wrapped.plant(other);
     *
     * otherWrapped.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;

      var interceptor = function(value) {
        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
      };
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(interceptor);
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iteratee functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length" property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
     * from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `methodName` is a function it is
     * invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          isProp = isKey(path),
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
     * `sum`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the property value of `path` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|string} path The path of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, path) {
      return map(collection, property(path));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
     * and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var index = -1,
          result = toArray(collection),
          length = result.length,
          lastIndex = length - 1;

      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
      while (++index < n) {
        var rand = baseRandom(index, lastIndex),
            value = result[rand];

        result[rand] = result[index];
        result[index] = value;
      }
      result.length = n;
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      return sample(collection, POSITIVE_INFINITY);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? getLength(collection) : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      var index = -1;
      iteratee = getCallback(iteratee, thisArg, 3);

      var result = baseMap(collection, function(value, key, collection) {
        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it can sort by multiple iteratees
     * or property names.
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
     *  The iteratees to sort by, specified as individual values or arrays of values.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
     *
     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    var sortByAll = restParam(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var guard = iteratees[2];
      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
        iteratees.length = 1;
      }
      return baseSortByOrder(collection, baseFlatten(iteratees), []);
    });

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
     * values are sorted in ascending order. Otherwise, a value is sorted in
     * ascending order if its corresponding order is "asc", and descending if "desc".
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    function sortByOrder(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(iteratees, orders, guard)) {
        orders = undefined;
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, iteratees, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = undefined;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the "length" property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the debounced function return the result of the last
     * `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = !!options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        lastCalled = 0;
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function complete(isCalled, id) {
        if (id) {
          clearTimeout(id);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = undefined;
          }
        }
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          complete(trailingCall, maxTimeoutId);
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        complete(trailing, timeoutId);
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = undefined;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that runs each argument through a corresponding
     * transform function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms] The functions to transform
     * arguments, specified as individual functions or arrays of functions.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
     *
     * modded(1, 2);
     * // => [1, 4]
     *
     * modded(5, 10);
     * // => [25, 20]
     */
    var modArgs = restParam(function(func, transforms) {
      transforms = baseFlatten(transforms);
      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = transforms.length;
      return restParam(function(args) {
        var index = nativeMin(args.length, length);
        while (index--) {
          args[index] = transforms[index](args[index]);
        }
        return func.apply(this, args);
      });
    });

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed invocations. Provide an options object to indicate
     * that `func` should be invoked on the leading and/or trailing edge of the
     * `wait` timeout. Subsequent calls to the throttled function return the
     * result of the last `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      return typeof customizer == 'function'
        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
        : baseClone(value, isDeep);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      return typeof customizer == 'function'
        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
        : baseClone(value, true);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    function gt(value, other) {
      return value > other;
    }

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    function gte(value, other) {
      return value >= other;
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return isObjectLike(value) && isArrayLike(value) &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !value.length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @alias eq
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return isObject(value) && objToString.call(value) == funcTag;
    }

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      return baseIsMatch(object, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reIsHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      var Ctor;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return isObject(value) && objToString.call(value) == regexpTag;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    function lt(value, other) {
      return value < other;
    }

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    function lte(value, other) {
      return value <= other;
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? getLength(value) : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * **Note:** This method mutates `object` and is based on
     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(function(object, source, customizer) {
      return customizer
        ? assignWith(object, source, customizer)
        : baseAssign(object, source);
    });

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = undefined;
      }
      return properties ? baseAssign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = createDefaults(assign, assignDefaults);

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
     * // => { 'user': { 'name': 'barney', 'age': 36 } }
     *
     */
    var defaultsDeep = createDefaults(merge, mergeDefaults);

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the property value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': { 'c': 3 } } };
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b.c');
     * // => true
     *
     * _.has(object, ['a', 'b', 'c']);
     * // => true
     */
    function has(object, path) {
      if (object == null) {
        return false;
      }
      var result = hasOwnProperty.call(object, path);
      if (!result && !isKey(path)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        path = last(path);
        result = hasOwnProperty.call(object, path);
      }
      return result || (isLength(object.length) && isIndex(path, object.length) &&
        (isArray(object) || isArguments(object)));
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = undefined;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      var Ctor = object == null ? undefined : object.constructor;
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && isArrayLike(object))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || isArguments(object)) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * property of `object` through `iteratee`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    var mapKeys = createObjectMapper(true);

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    var mapValues = createObjectMapper();

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      object = toObject(object);

      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * This method is like `_.get` except that if the resolved value is a function
     * it is invoked with the `this` binding of its parent object and its result
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a.b.c', 'default');
     * // => 'default'
     *
     * _.result(object, 'a.b.c', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      var result = object == null ? undefined : object[path];
      if (result === undefined) {
        if (object != null && !isKey(path, object)) {
          path = toPath(path);
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          result = object == null ? undefined : object[last(path)];
        }
        result = result === undefined ? defaultValue : result;
      }
      return isFunction(result) ? result.call(object) : result;
    }

    /**
     * Sets the property value of `path` on `object`. If a portion of `path`
     * does not exist it is created.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to augment.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, 'x[0].y.z', 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      if (object == null) {
        return object;
      }
      var pathKey = (path + '');
      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = path[index];
        if (isObject(nested)) {
          if (index == lastIndex) {
            nested[key] = value;
          } else if (nested[key] == null) {
            nested[key] = isIndex(path[index + 1]) ? [] : {};
          }
        }
        nested = nested[key];
      }
      return object;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iteratee functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it is set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= nativeMin(start, end) && value < nativeMax(start, end);
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = undefined;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = position === undefined
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
     * for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, escapeRegExpChar)
        : (string || '(?:)');
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = nativeFloor(mid),
          rightLength = nativeCeil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
      // Chrome fails to trim leading <BOM> whitespace characters.
      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      string = trim(string);
      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = undefined;
      }
      string = baseToString(string);
      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = undefined;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = undefined;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function that compares the property value of `path` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, true));
    }

    /**
     * Creates a function that invokes the method at `path` on a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': _.constant(2) } } },
     *   { 'a': { 'b': { 'c': _.constant(1) } } }
     * ];
     *
     * _.map(objects, _.method('a.b.c'));
     * // => [2, 1]
     *
     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    var method = restParam(function(path, args) {
      return function(object) {
        return invokePath(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path on `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = restParam(function(object, args) {
      return function(path) {
        return invokePath(object, path, args);
      };
    });

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj ? keys(source) : undefined,
            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      root._ = oldDash;
      return this;
    }

    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that returns the property value at `path` on a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': 2 } } },
     *   { 'a': { 'b': { 'c': 1 } } }
     * ];
     *
     * _.map(objects, _.property('a.b.c'));
     * // => [2, 1]
     *
     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the property value at a given path on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return baseGet(object, toPath(path), path + '');
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it is
     * set to `start` with `start` then set to `0`. If `end` is less than `start`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = undefined;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = nativeFloor(n);

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return (+augend || 0) + (+addend || 0);
    }

    /**
     * Calculates `n` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Calculates `n` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(gt, NEGATIVE_INFINITY);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(lt, POSITIVE_INFINITY);

    /**
     * Calculates `n` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      return iteratee.length == 1
        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.modArgs = modArgs;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.set = set;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.floor = floor;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.eq = isEqual;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__;
        if (filtered && !index) {
          return new LazyWrapper(this);
        }
        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

        var result = this.clone();
        if (filtered) {
          result.__takeCount__ = nativeMin(result.__takeCount__, n);
        } else {
          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type != LAZY_MAP_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone();
        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : property;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
      return this.reverse().takeWhile(predicate, thisArg).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(POSITIVE_INFINITY);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName),
          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var args = retUnwrapped ? [1] : arguments,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var interceptor = function(value) {
          return (retUnwrapped && chainAll)
            ? lodashFunc(value, 1)[0]
            : lodashFunc.apply(undefined, arrayPush([value], args));
        };

        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          if (onlyLazy) {
            value = value.clone();
            value.__actions__.push(action);
            return func.call(value);
          }
          return lodashFunc.call(undefined, this.value())[0];
        }
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push(action);
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name,
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.concat = wrapperConcat;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Rhino with CommonJS support.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1]);

/*
 * jsrsasign 6.2.3 (2016-11-29) (c) 2010-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */

/*
yahoo-min.js
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
if(typeof YAHOO=="undefined"||!YAHOO){var YAHOO={};}YAHOO.namespace=function(){var b=arguments,g=null,e,c,f;for(e=0;e<b.length;e=e+1){f=(""+b[e]).split(".");g=YAHOO;for(c=(f[0]=="YAHOO")?1:0;c<f.length;c=c+1){g[f[c]]=g[f[c]]||{};g=g[f[c]];}}return g;};YAHOO.log=function(d,a,c){var b=YAHOO.widget.Logger;if(b&&b.log){return b.log(d,a,c);}else{return false;}};YAHOO.register=function(a,f,e){var k=YAHOO.env.modules,c,j,h,g,d;if(!k[a]){k[a]={versions:[],builds:[]};}c=k[a];j=e.version;h=e.build;g=YAHOO.env.listeners;c.name=a;c.version=j;c.build=h;c.versions.push(j);c.builds.push(h);c.mainClass=f;for(d=0;d<g.length;d=d+1){g[d](c);}if(f){f.VERSION=j;f.BUILD=h;}else{YAHOO.log("mainClass is undefined for module "+a,"warn");}};YAHOO.env=YAHOO.env||{modules:[],listeners:[]};YAHOO.env.getVersion=function(a){return YAHOO.env.modules[a]||null;};YAHOO.env.parseUA=function(d){var e=function(i){var j=0;return parseFloat(i.replace(/\./g,function(){return(j++==1)?"":".";}));},h=navigator,g={ie:0,opera:0,gecko:0,webkit:0,chrome:0,mobile:null,air:0,ipad:0,iphone:0,ipod:0,ios:null,android:0,webos:0,caja:h&&h.cajaVersion,secure:false,os:null},c=d||(navigator&&navigator.userAgent),f=window&&window.location,b=f&&f.href,a;g.secure=b&&(b.toLowerCase().indexOf("https")===0);if(c){if((/windows|win32/i).test(c)){g.os="windows";}else{if((/macintosh/i).test(c)){g.os="macintosh";}else{if((/rhino/i).test(c)){g.os="rhino";}}}if((/KHTML/).test(c)){g.webkit=1;}a=c.match(/AppleWebKit\/([^\s]*)/);if(a&&a[1]){g.webkit=e(a[1]);if(/ Mobile\//.test(c)){g.mobile="Apple";a=c.match(/OS ([^\s]*)/);if(a&&a[1]){a=e(a[1].replace("_","."));}g.ios=a;g.ipad=g.ipod=g.iphone=0;a=c.match(/iPad|iPod|iPhone/);if(a&&a[0]){g[a[0].toLowerCase()]=g.ios;}}else{a=c.match(/NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/);if(a){g.mobile=a[0];}if(/webOS/.test(c)){g.mobile="WebOS";a=c.match(/webOS\/([^\s]*);/);if(a&&a[1]){g.webos=e(a[1]);}}if(/ Android/.test(c)){g.mobile="Android";a=c.match(/Android ([^\s]*);/);if(a&&a[1]){g.android=e(a[1]);}}}a=c.match(/Chrome\/([^\s]*)/);if(a&&a[1]){g.chrome=e(a[1]);}else{a=c.match(/AdobeAIR\/([^\s]*)/);if(a){g.air=a[0];}}}if(!g.webkit){a=c.match(/Opera[\s\/]([^\s]*)/);if(a&&a[1]){g.opera=e(a[1]);a=c.match(/Version\/([^\s]*)/);if(a&&a[1]){g.opera=e(a[1]);}a=c.match(/Opera Mini[^;]*/);if(a){g.mobile=a[0];}}else{a=c.match(/MSIE\s([^;]*)/);if(a&&a[1]){g.ie=e(a[1]);}else{a=c.match(/Gecko\/([^\s]*)/);if(a){g.gecko=1;a=c.match(/rv:([^\s\)]*)/);if(a&&a[1]){g.gecko=e(a[1]);}}}}}}return g;};YAHOO.env.ua=YAHOO.env.parseUA();(function(){YAHOO.namespace("util","widget","example");if("undefined"!==typeof YAHOO_config){var b=YAHOO_config.listener,a=YAHOO.env.listeners,d=true,c;if(b){for(c=0;c<a.length;c++){if(a[c]==b){d=false;break;}}if(d){a.push(b);}}}})();YAHOO.lang=YAHOO.lang||{};(function(){var f=YAHOO.lang,a=Object.prototype,c="[object Array]",h="[object Function]",i="[object Object]",b=[],g={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;","`":"&#x60;"},d=["toString","valueOf"],e={isArray:function(j){return a.toString.apply(j)===c;},isBoolean:function(j){return typeof j==="boolean";},isFunction:function(j){return(typeof j==="function")||a.toString.apply(j)===h;},isNull:function(j){return j===null;},isNumber:function(j){return typeof j==="number"&&isFinite(j);},isObject:function(j){return(j&&(typeof j==="object"||f.isFunction(j)))||false;},isString:function(j){return typeof j==="string";},isUndefined:function(j){return typeof j==="undefined";},_IEEnumFix:(YAHOO.env.ua.ie)?function(l,k){var j,n,m;for(j=0;j<d.length;j=j+1){n=d[j];m=k[n];if(f.isFunction(m)&&m!=a[n]){l[n]=m;}}}:function(){},escapeHTML:function(j){return j.replace(/[&<>"'\/`]/g,function(k){return g[k];});},extend:function(m,n,l){if(!n||!m){throw new Error("extend failed, please check that "+"all dependencies are included.");}var k=function(){},j;k.prototype=n.prototype;m.prototype=new k();m.prototype.constructor=m;m.superclass=n.prototype;if(n.prototype.constructor==a.constructor){n.prototype.constructor=n;}if(l){for(j in l){if(f.hasOwnProperty(l,j)){m.prototype[j]=l[j];}}f._IEEnumFix(m.prototype,l);}},augmentObject:function(n,m){if(!m||!n){throw new Error("Absorb failed, verify dependencies.");}var j=arguments,l,o,k=j[2];if(k&&k!==true){for(l=2;l<j.length;l=l+1){n[j[l]]=m[j[l]];}}else{for(o in m){if(k||!(o in n)){n[o]=m[o];}}f._IEEnumFix(n,m);}return n;},augmentProto:function(m,l){if(!l||!m){throw new Error("Augment failed, verify dependencies.");}var j=[m.prototype,l.prototype],k;for(k=2;k<arguments.length;k=k+1){j.push(arguments[k]);}f.augmentObject.apply(this,j);return m;},dump:function(j,p){var l,n,r=[],t="{...}",k="f(){...}",q=", ",m=" => ";if(!f.isObject(j)){return j+"";}else{if(j instanceof Date||("nodeType" in j&&"tagName" in j)){return j;}else{if(f.isFunction(j)){return k;}}}p=(f.isNumber(p))?p:3;if(f.isArray(j)){r.push("[");for(l=0,n=j.length;l<n;l=l+1){if(f.isObject(j[l])){r.push((p>0)?f.dump(j[l],p-1):t);}else{r.push(j[l]);}r.push(q);}if(r.length>1){r.pop();}r.push("]");}else{r.push("{");for(l in j){if(f.hasOwnProperty(j,l)){r.push(l+m);if(f.isObject(j[l])){r.push((p>0)?f.dump(j[l],p-1):t);}else{r.push(j[l]);}r.push(q);}}if(r.length>1){r.pop();}r.push("}");}return r.join("");},substitute:function(x,y,E,l){var D,C,B,G,t,u,F=[],p,z=x.length,A="dump",r=" ",q="{",m="}",n,w;for(;;){D=x.lastIndexOf(q,z);if(D<0){break;}C=x.indexOf(m,D);if(D+1>C){break;}p=x.substring(D+1,C);G=p;u=null;B=G.indexOf(r);if(B>-1){u=G.substring(B+1);G=G.substring(0,B);}t=y[G];if(E){t=E(G,t,u);}if(f.isObject(t)){if(f.isArray(t)){t=f.dump(t,parseInt(u,10));}else{u=u||"";n=u.indexOf(A);if(n>-1){u=u.substring(4);}w=t.toString();if(w===i||n>-1){t=f.dump(t,parseInt(u,10));}else{t=w;}}}else{if(!f.isString(t)&&!f.isNumber(t)){t="~-"+F.length+"-~";F[F.length]=p;}}x=x.substring(0,D)+t+x.substring(C+1);if(l===false){z=D-1;}}for(D=F.length-1;D>=0;D=D-1){x=x.replace(new RegExp("~-"+D+"-~"),"{"+F[D]+"}","g");}return x;},trim:function(j){try{return j.replace(/^\s+|\s+$/g,"");}catch(k){return j;
}},merge:function(){var n={},k=arguments,j=k.length,m;for(m=0;m<j;m=m+1){f.augmentObject(n,k[m],true);}return n;},later:function(t,k,u,n,p){t=t||0;k=k||{};var l=u,s=n,q,j;if(f.isString(u)){l=k[u];}if(!l){throw new TypeError("method undefined");}if(!f.isUndefined(n)&&!f.isArray(s)){s=[n];}q=function(){l.apply(k,s||b);};j=(p)?setInterval(q,t):setTimeout(q,t);return{interval:p,cancel:function(){if(this.interval){clearInterval(j);}else{clearTimeout(j);}}};},isValue:function(j){return(f.isObject(j)||f.isString(j)||f.isNumber(j)||f.isBoolean(j));}};f.hasOwnProperty=(a.hasOwnProperty)?function(j,k){return j&&j.hasOwnProperty&&j.hasOwnProperty(k);}:function(j,k){return !f.isUndefined(j[k])&&j.constructor.prototype[k]!==j[k];};e.augmentObject(f,e,true);YAHOO.util.Lang=f;f.augment=f.augmentProto;YAHOO.augment=f.augmentProto;YAHOO.extend=f.extend;})();YAHOO.register("yahoo",YAHOO,{version:"2.9.0",build:"2800"});

/*! CryptoJS v3.1.2 core-fix.js
 * code.google.com/p/crypto-js
 * (c) 2009-2013 by Jeff Mott. All rights reserved.
 * code.google.com/p/crypto-js/wiki/License
 * THIS IS FIX of 'core.js' to fix Hmac issue.
 * https://code.google.com/p/crypto-js/issues/detail?id=84
 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
 */
var CryptoJS=CryptoJS||(function(e,g){var a={};var b=a.lib={};var j=b.Base=(function(){function n(){}return{extend:function(p){n.prototype=this;var o=new n();if(p){o.mixIn(p)}if(!o.hasOwnProperty("init")){o.init=function(){o.$super.init.apply(this,arguments)}}o.init.prototype=o;o.$super=this;return o},create:function(){var o=this.extend();o.init.apply(o,arguments);return o},init:function(){},mixIn:function(p){for(var o in p){if(p.hasOwnProperty(o)){this[o]=p[o]}}if(p.hasOwnProperty("toString")){this.toString=p.toString}},clone:function(){return this.init.prototype.extend(this)}}}());var l=b.WordArray=j.extend({init:function(o,n){o=this.words=o||[];if(n!=g){this.sigBytes=n}else{this.sigBytes=o.length*4}},toString:function(n){return(n||h).stringify(this)},concat:function(t){var q=this.words;var p=t.words;var n=this.sigBytes;var s=t.sigBytes;this.clamp();if(n%4){for(var r=0;r<s;r++){var o=(p[r>>>2]>>>(24-(r%4)*8))&255;q[(n+r)>>>2]|=o<<(24-((n+r)%4)*8)}}else{for(var r=0;r<s;r+=4){q[(n+r)>>>2]=p[r>>>2]}}this.sigBytes+=s;return this},clamp:function(){var o=this.words;var n=this.sigBytes;o[n>>>2]&=4294967295<<(32-(n%4)*8);o.length=e.ceil(n/4)},clone:function(){var n=j.clone.call(this);n.words=this.words.slice(0);return n},random:function(p){var o=[];for(var n=0;n<p;n+=4){o.push((e.random()*4294967296)|0)}return new l.init(o,p)}});var m=a.enc={};var h=m.Hex={stringify:function(p){var r=p.words;var o=p.sigBytes;var q=[];for(var n=0;n<o;n++){var s=(r[n>>>2]>>>(24-(n%4)*8))&255;q.push((s>>>4).toString(16));q.push((s&15).toString(16))}return q.join("")},parse:function(p){var n=p.length;var q=[];for(var o=0;o<n;o+=2){q[o>>>3]|=parseInt(p.substr(o,2),16)<<(24-(o%8)*4)}return new l.init(q,n/2)}};var d=m.Latin1={stringify:function(q){var r=q.words;var p=q.sigBytes;var n=[];for(var o=0;o<p;o++){var s=(r[o>>>2]>>>(24-(o%4)*8))&255;n.push(String.fromCharCode(s))}return n.join("")},parse:function(p){var n=p.length;var q=[];for(var o=0;o<n;o++){q[o>>>2]|=(p.charCodeAt(o)&255)<<(24-(o%4)*8)}return new l.init(q,n)}};var c=m.Utf8={stringify:function(n){try{return decodeURIComponent(escape(d.stringify(n)))}catch(o){throw new Error("Malformed UTF-8 data")}},parse:function(n){return d.parse(unescape(encodeURIComponent(n)))}};var i=b.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new l.init();this._nDataBytes=0},_append:function(n){if(typeof n=="string"){n=c.parse(n)}this._data.concat(n);this._nDataBytes+=n.sigBytes},_process:function(w){var q=this._data;var x=q.words;var n=q.sigBytes;var t=this.blockSize;var v=t*4;var u=n/v;if(w){u=e.ceil(u)}else{u=e.max((u|0)-this._minBufferSize,0)}var s=u*t;var r=e.min(s*4,n);if(s){for(var p=0;p<s;p+=t){this._doProcessBlock(x,p)}var o=x.splice(0,s);q.sigBytes-=r}return new l.init(o,r)},clone:function(){var n=j.clone.call(this);n._data=this._data.clone();return n},_minBufferSize:0});var f=b.Hasher=i.extend({cfg:j.extend(),init:function(n){this.cfg=this.cfg.extend(n);this.reset()},reset:function(){i.reset.call(this);this._doReset()},update:function(n){this._append(n);this._process();return this},finalize:function(n){if(n){this._append(n)}var o=this._doFinalize();return o},blockSize:512/32,_createHelper:function(n){return function(p,o){return new n.init(o).finalize(p)}},_createHmacHelper:function(n){return function(p,o){return new k.HMAC.init(n,o).finalize(p)}}});var k=a.algo={};return a}(Math));
/*
CryptoJS v3.1.2 x64-core-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(g){var a=CryptoJS,f=a.lib,e=f.Base,h=f.WordArray,a=a.x64={};a.Word=e.extend({init:function(b,c){this.high=b;this.low=c}});a.WordArray=e.extend({init:function(b,c){b=this.words=b||[];this.sigBytes=c!=g?c:8*b.length},toX32:function(){for(var b=this.words,c=b.length,a=[],d=0;d<c;d++){var e=b[d];a.push(e.high);a.push(e.low)}return h.create(a,this.sigBytes)},clone:function(){for(var b=e.clone.call(this),c=b.words=this.words.slice(0),a=c.length,d=0;d<a;d++)c[d]=c[d].clone();return b}})})();

/*
CryptoJS v3.1.2 cipher-core.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
CryptoJS.lib.Cipher||function(u){var g=CryptoJS,f=g.lib,k=f.Base,l=f.WordArray,q=f.BufferedBlockAlgorithm,r=g.enc.Base64,v=g.algo.EvpKDF,n=f.Cipher=q.extend({cfg:k.extend(),createEncryptor:function(a,b){return this.create(this._ENC_XFORM_MODE,a,b)},createDecryptor:function(a,b){return this.create(this._DEC_XFORM_MODE,a,b)},init:function(a,b,c){this.cfg=this.cfg.extend(c);this._xformMode=a;this._key=b;this.reset()},reset:function(){q.reset.call(this);this._doReset()},process:function(a){this._append(a);
return this._process()},finalize:function(a){a&&this._append(a);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(a){return{encrypt:function(b,c,d){return("string"==typeof c?s:j).encrypt(a,b,c,d)},decrypt:function(b,c,d){return("string"==typeof c?s:j).decrypt(a,b,c,d)}}}});f.StreamCipher=n.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var m=g.mode={},t=function(a,b,c){var d=this._iv;d?this._iv=u:d=this._prevBlock;for(var e=
0;e<c;e++)a[b+e]^=d[e]},h=(f.BlockCipherMode=k.extend({createEncryptor:function(a,b){return this.Encryptor.create(a,b)},createDecryptor:function(a,b){return this.Decryptor.create(a,b)},init:function(a,b){this._cipher=a;this._iv=b}})).extend();h.Encryptor=h.extend({processBlock:function(a,b){var c=this._cipher,d=c.blockSize;t.call(this,a,b,d);c.encryptBlock(a,b);this._prevBlock=a.slice(b,b+d)}});h.Decryptor=h.extend({processBlock:function(a,b){var c=this._cipher,d=c.blockSize,e=a.slice(b,b+d);c.decryptBlock(a,
b);t.call(this,a,b,d);this._prevBlock=e}});m=m.CBC=h;h=(g.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,e=[],f=0;f<c;f+=4)e.push(d);c=l.create(e,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};f.BlockCipher=n.extend({cfg:n.cfg.extend({mode:m,padding:h}),reset:function(){n.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;
this._mode=c.call(a,this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var p=f.CipherParams=k.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),m=(g.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;
return(a?l.create([1398893684,1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=l.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return p.create({ciphertext:a,salt:c})}},j=f.SerializableCipher=k.extend({cfg:k.extend({format:m}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var e=a.createEncryptor(c,d);b=e.finalize(b);e=e.cfg;return p.create({ciphertext:b,key:c,iv:e.iv,algorithm:a,mode:e.mode,padding:e.padding,
blockSize:a.blockSize,formatter:d.format})},decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),g=(g.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=l.random(8));a=v.create({keySize:b+c}).compute(a,d);c=l.create(a.words.slice(b),4*c);a.sigBytes=4*b;return p.create({key:a,iv:c,salt:d})}},s=f.PasswordBasedCipher=j.extend({cfg:j.cfg.extend({kdf:g}),encrypt:function(a,
b,c,d){d=this.cfg.extend(d);c=d.kdf.execute(c,a.keySize,a.ivSize);d.iv=c.iv;a=j.encrypt.call(this,a,b,c.key,d);a.mixIn(c);return a},decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);c=d.kdf.execute(c,a.keySize,a.ivSize,b.salt);d.iv=c.iv;return j.decrypt.call(this,a,b,c.key,d)}})}();

/*
CryptoJS v3.1.2 aes.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){for(var q=CryptoJS,x=q.lib.BlockCipher,r=q.algo,j=[],y=[],z=[],A=[],B=[],C=[],s=[],u=[],v=[],w=[],g=[],k=0;256>k;k++)g[k]=128>k?k<<1:k<<1^283;for(var n=0,l=0,k=0;256>k;k++){var f=l^l<<1^l<<2^l<<3^l<<4,f=f>>>8^f&255^99;j[n]=f;y[f]=n;var t=g[n],D=g[t],E=g[D],b=257*g[f]^16843008*f;z[n]=b<<24|b>>>8;A[n]=b<<16|b>>>16;B[n]=b<<8|b>>>24;C[n]=b;b=16843009*E^65537*D^257*t^16843008*n;s[f]=b<<24|b>>>8;u[f]=b<<16|b>>>16;v[f]=b<<8|b>>>24;w[f]=b;n?(n=t^g[g[g[E^t]]],l^=g[g[l]]):n=l=1}var F=[0,1,2,4,8,
16,32,64,128,27,54],r=r.AES=x.extend({_doReset:function(){for(var c=this._key,e=c.words,a=c.sigBytes/4,c=4*((this._nRounds=a+6)+1),b=this._keySchedule=[],h=0;h<c;h++)if(h<a)b[h]=e[h];else{var d=b[h-1];h%a?6<a&&4==h%a&&(d=j[d>>>24]<<24|j[d>>>16&255]<<16|j[d>>>8&255]<<8|j[d&255]):(d=d<<8|d>>>24,d=j[d>>>24]<<24|j[d>>>16&255]<<16|j[d>>>8&255]<<8|j[d&255],d^=F[h/a|0]<<24);b[h]=b[h-a]^d}e=this._invKeySchedule=[];for(a=0;a<c;a++)h=c-a,d=a%4?b[h]:b[h-4],e[a]=4>a||4>=h?d:s[j[d>>>24]]^u[j[d>>>16&255]]^v[j[d>>>
8&255]]^w[j[d&255]]},encryptBlock:function(c,e){this._doCryptBlock(c,e,this._keySchedule,z,A,B,C,j)},decryptBlock:function(c,e){var a=c[e+1];c[e+1]=c[e+3];c[e+3]=a;this._doCryptBlock(c,e,this._invKeySchedule,s,u,v,w,y);a=c[e+1];c[e+1]=c[e+3];c[e+3]=a},_doCryptBlock:function(c,e,a,b,h,d,j,m){for(var n=this._nRounds,f=c[e]^a[0],g=c[e+1]^a[1],k=c[e+2]^a[2],p=c[e+3]^a[3],l=4,t=1;t<n;t++)var q=b[f>>>24]^h[g>>>16&255]^d[k>>>8&255]^j[p&255]^a[l++],r=b[g>>>24]^h[k>>>16&255]^d[p>>>8&255]^j[f&255]^a[l++],s=
b[k>>>24]^h[p>>>16&255]^d[f>>>8&255]^j[g&255]^a[l++],p=b[p>>>24]^h[f>>>16&255]^d[g>>>8&255]^j[k&255]^a[l++],f=q,g=r,k=s;q=(m[f>>>24]<<24|m[g>>>16&255]<<16|m[k>>>8&255]<<8|m[p&255])^a[l++];r=(m[g>>>24]<<24|m[k>>>16&255]<<16|m[p>>>8&255]<<8|m[f&255])^a[l++];s=(m[k>>>24]<<24|m[p>>>16&255]<<16|m[f>>>8&255]<<8|m[g&255])^a[l++];p=(m[p>>>24]<<24|m[f>>>16&255]<<16|m[g>>>8&255]<<8|m[k&255])^a[l++];c[e]=q;c[e+1]=r;c[e+2]=s;c[e+3]=p},keySize:8});q.AES=x._createHelper(r)})();

/*
CryptoJS v3.1.2 tripledes-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){function j(b,c){var a=(this._lBlock>>>b^this._rBlock)&c;this._rBlock^=a;this._lBlock^=a<<b}function l(b,c){var a=(this._rBlock>>>b^this._lBlock)&c;this._lBlock^=a;this._rBlock^=a<<b}var h=CryptoJS,e=h.lib,n=e.WordArray,e=e.BlockCipher,g=h.algo,q=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],p=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,
55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],r=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],s=[{"0":8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,
2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,
1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{"0":1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,
75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,
276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{"0":260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,
14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,
17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{"0":2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,
98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,
1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{"0":128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,
10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,
83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{"0":268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,
2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{"0":1048576,
16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,
496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{"0":134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,
2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,
2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],t=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],m=g.DES=e.extend({_doReset:function(){for(var b=this._key.words,c=[],a=0;56>a;a++){var f=q[a]-1;c[a]=b[f>>>5]>>>31-f%32&1}b=this._subKeys=[];for(f=0;16>f;f++){for(var d=b[f]=[],e=r[f],a=0;24>a;a++)d[a/6|0]|=c[(p[a]-1+e)%28]<<31-a%6,d[4+(a/6|0)]|=c[28+(p[a+24]-1+e)%28]<<31-a%6;d[0]=d[0]<<1|d[0]>>>31;for(a=1;7>a;a++)d[a]>>>=
4*(a-1)+3;d[7]=d[7]<<5|d[7]>>>27}c=this._invSubKeys=[];for(a=0;16>a;a++)c[a]=b[15-a]},encryptBlock:function(b,c){this._doCryptBlock(b,c,this._subKeys)},decryptBlock:function(b,c){this._doCryptBlock(b,c,this._invSubKeys)},_doCryptBlock:function(b,c,a){this._lBlock=b[c];this._rBlock=b[c+1];j.call(this,4,252645135);j.call(this,16,65535);l.call(this,2,858993459);l.call(this,8,16711935);j.call(this,1,1431655765);for(var f=0;16>f;f++){for(var d=a[f],e=this._lBlock,h=this._rBlock,g=0,k=0;8>k;k++)g|=s[k][((h^
d[k])&t[k])>>>0];this._lBlock=h;this._rBlock=e^g}a=this._lBlock;this._lBlock=this._rBlock;this._rBlock=a;j.call(this,1,1431655765);l.call(this,8,16711935);l.call(this,2,858993459);j.call(this,16,65535);j.call(this,4,252645135);b[c]=this._lBlock;b[c+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});h.DES=e._createHelper(m);g=g.TripleDES=e.extend({_doReset:function(){var b=this._key.words;this._des1=m.createEncryptor(n.create(b.slice(0,2)));this._des2=m.createEncryptor(n.create(b.slice(2,4)));this._des3=
m.createEncryptor(n.create(b.slice(4,6)))},encryptBlock:function(b,c){this._des1.encryptBlock(b,c);this._des2.decryptBlock(b,c);this._des3.encryptBlock(b,c)},decryptBlock:function(b,c){this._des3.decryptBlock(b,c);this._des2.encryptBlock(b,c);this._des1.decryptBlock(b,c)},keySize:6,ivSize:2,blockSize:2});h.TripleDES=e._createHelper(g)})();

/*
CryptoJS v3.1.2 enc-base64.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var h=CryptoJS,j=h.lib.WordArray;h.enc.Base64={stringify:function(b){var e=b.words,f=b.sigBytes,c=this._map;b.clamp();b=[];for(var a=0;a<f;a+=3)for(var d=(e[a>>>2]>>>24-8*(a%4)&255)<<16|(e[a+1>>>2]>>>24-8*((a+1)%4)&255)<<8|e[a+2>>>2]>>>24-8*((a+2)%4)&255,g=0;4>g&&a+0.75*g<f;g++)b.push(c.charAt(d>>>6*(3-g)&63));if(e=c.charAt(64))for(;b.length%4;)b.push(e);return b.join("")},parse:function(b){var e=b.length,f=this._map,c=f.charAt(64);c&&(c=b.indexOf(c),-1!=c&&(e=c));for(var c=[],a=0,d=0;d<
e;d++)if(d%4){var g=f.indexOf(b.charAt(d-1))<<2*(d%4),h=f.indexOf(b.charAt(d))>>>6-2*(d%4);c[a>>>2]|=(g|h)<<24-8*(a%4);a++}return j.create(c,a)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();

/*
CryptoJS v3.1.2 md5.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(E){function h(a,f,g,j,p,h,k){a=a+(f&g|~f&j)+p+k;return(a<<h|a>>>32-h)+f}function k(a,f,g,j,p,h,k){a=a+(f&j|g&~j)+p+k;return(a<<h|a>>>32-h)+f}function l(a,f,g,j,h,k,l){a=a+(f^g^j)+h+l;return(a<<k|a>>>32-k)+f}function n(a,f,g,j,h,k,l){a=a+(g^(f|~j))+h+l;return(a<<k|a>>>32-k)+f}for(var r=CryptoJS,q=r.lib,F=q.WordArray,s=q.Hasher,q=r.algo,a=[],t=0;64>t;t++)a[t]=4294967296*E.abs(E.sin(t+1))|0;q=q.MD5=s.extend({_doReset:function(){this._hash=new F.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(m,f){for(var g=0;16>g;g++){var j=f+g,p=m[j];m[j]=(p<<8|p>>>24)&16711935|(p<<24|p>>>8)&4278255360}var g=this._hash.words,j=m[f+0],p=m[f+1],q=m[f+2],r=m[f+3],s=m[f+4],t=m[f+5],u=m[f+6],v=m[f+7],w=m[f+8],x=m[f+9],y=m[f+10],z=m[f+11],A=m[f+12],B=m[f+13],C=m[f+14],D=m[f+15],b=g[0],c=g[1],d=g[2],e=g[3],b=h(b,c,d,e,j,7,a[0]),e=h(e,b,c,d,p,12,a[1]),d=h(d,e,b,c,q,17,a[2]),c=h(c,d,e,b,r,22,a[3]),b=h(b,c,d,e,s,7,a[4]),e=h(e,b,c,d,t,12,a[5]),d=h(d,e,b,c,u,17,a[6]),c=h(c,d,e,b,v,22,a[7]),
b=h(b,c,d,e,w,7,a[8]),e=h(e,b,c,d,x,12,a[9]),d=h(d,e,b,c,y,17,a[10]),c=h(c,d,e,b,z,22,a[11]),b=h(b,c,d,e,A,7,a[12]),e=h(e,b,c,d,B,12,a[13]),d=h(d,e,b,c,C,17,a[14]),c=h(c,d,e,b,D,22,a[15]),b=k(b,c,d,e,p,5,a[16]),e=k(e,b,c,d,u,9,a[17]),d=k(d,e,b,c,z,14,a[18]),c=k(c,d,e,b,j,20,a[19]),b=k(b,c,d,e,t,5,a[20]),e=k(e,b,c,d,y,9,a[21]),d=k(d,e,b,c,D,14,a[22]),c=k(c,d,e,b,s,20,a[23]),b=k(b,c,d,e,x,5,a[24]),e=k(e,b,c,d,C,9,a[25]),d=k(d,e,b,c,r,14,a[26]),c=k(c,d,e,b,w,20,a[27]),b=k(b,c,d,e,B,5,a[28]),e=k(e,b,
c,d,q,9,a[29]),d=k(d,e,b,c,v,14,a[30]),c=k(c,d,e,b,A,20,a[31]),b=l(b,c,d,e,t,4,a[32]),e=l(e,b,c,d,w,11,a[33]),d=l(d,e,b,c,z,16,a[34]),c=l(c,d,e,b,C,23,a[35]),b=l(b,c,d,e,p,4,a[36]),e=l(e,b,c,d,s,11,a[37]),d=l(d,e,b,c,v,16,a[38]),c=l(c,d,e,b,y,23,a[39]),b=l(b,c,d,e,B,4,a[40]),e=l(e,b,c,d,j,11,a[41]),d=l(d,e,b,c,r,16,a[42]),c=l(c,d,e,b,u,23,a[43]),b=l(b,c,d,e,x,4,a[44]),e=l(e,b,c,d,A,11,a[45]),d=l(d,e,b,c,D,16,a[46]),c=l(c,d,e,b,q,23,a[47]),b=n(b,c,d,e,j,6,a[48]),e=n(e,b,c,d,v,10,a[49]),d=n(d,e,b,c,
C,15,a[50]),c=n(c,d,e,b,t,21,a[51]),b=n(b,c,d,e,A,6,a[52]),e=n(e,b,c,d,r,10,a[53]),d=n(d,e,b,c,y,15,a[54]),c=n(c,d,e,b,p,21,a[55]),b=n(b,c,d,e,w,6,a[56]),e=n(e,b,c,d,D,10,a[57]),d=n(d,e,b,c,u,15,a[58]),c=n(c,d,e,b,B,21,a[59]),b=n(b,c,d,e,s,6,a[60]),e=n(e,b,c,d,z,10,a[61]),d=n(d,e,b,c,q,15,a[62]),c=n(c,d,e,b,x,21,a[63]);g[0]=g[0]+b|0;g[1]=g[1]+c|0;g[2]=g[2]+d|0;g[3]=g[3]+e|0},_doFinalize:function(){var a=this._data,f=a.words,g=8*this._nDataBytes,j=8*a.sigBytes;f[j>>>5]|=128<<24-j%32;var h=E.floor(g/
4294967296);f[(j+64>>>9<<4)+15]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;f[(j+64>>>9<<4)+14]=(g<<8|g>>>24)&16711935|(g<<24|g>>>8)&4278255360;a.sigBytes=4*(f.length+1);this._process();a=this._hash;f=a.words;for(g=0;4>g;g++)j=f[g],f[g]=(j<<8|j>>>24)&16711935|(j<<24|j>>>8)&4278255360;return a},clone:function(){var a=s.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=s._createHelper(q);r.HmacMD5=s._createHmacHelper(q)})(Math);

/*
CryptoJS v3.1.2 sha1-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var k=CryptoJS,b=k.lib,m=b.WordArray,l=b.Hasher,d=[],b=k.algo.SHA1=l.extend({_doReset:function(){this._hash=new m.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(n,p){for(var a=this._hash.words,e=a[0],f=a[1],h=a[2],j=a[3],b=a[4],c=0;80>c;c++){if(16>c)d[c]=n[p+c]|0;else{var g=d[c-3]^d[c-8]^d[c-14]^d[c-16];d[c]=g<<1|g>>>31}g=(e<<5|e>>>27)+b+d[c];g=20>c?g+((f&h|~f&j)+1518500249):40>c?g+((f^h^j)+1859775393):60>c?g+((f&h|f&j|h&j)-1894007588):g+((f^h^
j)-899497514);b=j;j=h;h=f<<30|f>>>2;f=e;e=g}a[0]=a[0]+e|0;a[1]=a[1]+f|0;a[2]=a[2]+h|0;a[3]=a[3]+j|0;a[4]=a[4]+b|0},_doFinalize:function(){var b=this._data,d=b.words,a=8*this._nDataBytes,e=8*b.sigBytes;d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=Math.floor(a/4294967296);d[(e+64>>>9<<4)+15]=a;b.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var b=l.clone.call(this);b._hash=this._hash.clone();return b}});k.SHA1=l._createHelper(b);k.HmacSHA1=l._createHmacHelper(b)})();

/*
CryptoJS v3.1.2 sha256-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(k){for(var g=CryptoJS,h=g.lib,v=h.WordArray,j=h.Hasher,h=g.algo,s=[],t=[],u=function(q){return 4294967296*(q-(q|0))|0},l=2,b=0;64>b;){var d;a:{d=l;for(var w=k.sqrt(d),r=2;r<=w;r++)if(!(d%r)){d=!1;break a}d=!0}d&&(8>b&&(s[b]=u(k.pow(l,0.5))),t[b]=u(k.pow(l,1/3)),b++);l++}var n=[],h=h.SHA256=j.extend({_doReset:function(){this._hash=new v.init(s.slice(0))},_doProcessBlock:function(q,h){for(var a=this._hash.words,c=a[0],d=a[1],b=a[2],k=a[3],f=a[4],g=a[5],j=a[6],l=a[7],e=0;64>e;e++){if(16>e)n[e]=
q[h+e]|0;else{var m=n[e-15],p=n[e-2];n[e]=((m<<25|m>>>7)^(m<<14|m>>>18)^m>>>3)+n[e-7]+((p<<15|p>>>17)^(p<<13|p>>>19)^p>>>10)+n[e-16]}m=l+((f<<26|f>>>6)^(f<<21|f>>>11)^(f<<7|f>>>25))+(f&g^~f&j)+t[e]+n[e];p=((c<<30|c>>>2)^(c<<19|c>>>13)^(c<<10|c>>>22))+(c&d^c&b^d&b);l=j;j=g;g=f;f=k+m|0;k=b;b=d;d=c;c=m+p|0}a[0]=a[0]+c|0;a[1]=a[1]+d|0;a[2]=a[2]+b|0;a[3]=a[3]+k|0;a[4]=a[4]+f|0;a[5]=a[5]+g|0;a[6]=a[6]+j|0;a[7]=a[7]+l|0},_doFinalize:function(){var d=this._data,b=d.words,a=8*this._nDataBytes,c=8*d.sigBytes;
b[c>>>5]|=128<<24-c%32;b[(c+64>>>9<<4)+14]=k.floor(a/4294967296);b[(c+64>>>9<<4)+15]=a;d.sigBytes=4*b.length;this._process();return this._hash},clone:function(){var b=j.clone.call(this);b._hash=this._hash.clone();return b}});g.SHA256=j._createHelper(h);g.HmacSHA256=j._createHmacHelper(h)})(Math);

/*
CryptoJS v3.1.2 sha224-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var b=CryptoJS,d=b.lib.WordArray,a=b.algo,c=a.SHA256,a=a.SHA224=c.extend({_doReset:function(){this._hash=new d.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var a=c._doFinalize.call(this);a.sigBytes-=4;return a}});b.SHA224=c._createHelper(a);b.HmacSHA224=c._createHmacHelper(a)})();

/*
CryptoJS v3.1.2 sha512-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){function a(){return d.create.apply(d,arguments)}for(var n=CryptoJS,r=n.lib.Hasher,e=n.x64,d=e.Word,T=e.WordArray,e=n.algo,ea=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),
a(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,
2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),
a(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,
3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],v=[],w=0;80>w;w++)v[w]=a();e=e.SHA512=r.extend({_doReset:function(){this._hash=new T.init([new d.init(1779033703,4089235720),new d.init(3144134277,2227873595),new d.init(1013904242,4271175723),new d.init(2773480762,1595750129),new d.init(1359893119,2917565137),new d.init(2600822924,725511199),new d.init(528734635,4215389547),new d.init(1541459225,327033209)])},_doProcessBlock:function(a,d){for(var f=this._hash.words,
F=f[0],e=f[1],n=f[2],r=f[3],G=f[4],H=f[5],I=f[6],f=f[7],w=F.high,J=F.low,X=e.high,K=e.low,Y=n.high,L=n.low,Z=r.high,M=r.low,$=G.high,N=G.low,aa=H.high,O=H.low,ba=I.high,P=I.low,ca=f.high,Q=f.low,k=w,g=J,z=X,x=K,A=Y,y=L,U=Z,B=M,l=$,h=N,R=aa,C=O,S=ba,D=P,V=ca,E=Q,m=0;80>m;m++){var s=v[m];if(16>m)var j=s.high=a[d+2*m]|0,b=s.low=a[d+2*m+1]|0;else{var j=v[m-15],b=j.high,p=j.low,j=(b>>>1|p<<31)^(b>>>8|p<<24)^b>>>7,p=(p>>>1|b<<31)^(p>>>8|b<<24)^(p>>>7|b<<25),u=v[m-2],b=u.high,c=u.low,u=(b>>>19|c<<13)^(b<<
3|c>>>29)^b>>>6,c=(c>>>19|b<<13)^(c<<3|b>>>29)^(c>>>6|b<<26),b=v[m-7],W=b.high,t=v[m-16],q=t.high,t=t.low,b=p+b.low,j=j+W+(b>>>0<p>>>0?1:0),b=b+c,j=j+u+(b>>>0<c>>>0?1:0),b=b+t,j=j+q+(b>>>0<t>>>0?1:0);s.high=j;s.low=b}var W=l&R^~l&S,t=h&C^~h&D,s=k&z^k&A^z&A,T=g&x^g&y^x&y,p=(k>>>28|g<<4)^(k<<30|g>>>2)^(k<<25|g>>>7),u=(g>>>28|k<<4)^(g<<30|k>>>2)^(g<<25|k>>>7),c=ea[m],fa=c.high,da=c.low,c=E+((h>>>14|l<<18)^(h>>>18|l<<14)^(h<<23|l>>>9)),q=V+((l>>>14|h<<18)^(l>>>18|h<<14)^(l<<23|h>>>9))+(c>>>0<E>>>0?1:
0),c=c+t,q=q+W+(c>>>0<t>>>0?1:0),c=c+da,q=q+fa+(c>>>0<da>>>0?1:0),c=c+b,q=q+j+(c>>>0<b>>>0?1:0),b=u+T,s=p+s+(b>>>0<u>>>0?1:0),V=S,E=D,S=R,D=C,R=l,C=h,h=B+c|0,l=U+q+(h>>>0<B>>>0?1:0)|0,U=A,B=y,A=z,y=x,z=k,x=g,g=c+b|0,k=q+s+(g>>>0<c>>>0?1:0)|0}J=F.low=J+g;F.high=w+k+(J>>>0<g>>>0?1:0);K=e.low=K+x;e.high=X+z+(K>>>0<x>>>0?1:0);L=n.low=L+y;n.high=Y+A+(L>>>0<y>>>0?1:0);M=r.low=M+B;r.high=Z+U+(M>>>0<B>>>0?1:0);N=G.low=N+h;G.high=$+l+(N>>>0<h>>>0?1:0);O=H.low=O+C;H.high=aa+R+(O>>>0<C>>>0?1:0);P=I.low=P+D;
I.high=ba+S+(P>>>0<D>>>0?1:0);Q=f.low=Q+E;f.high=ca+V+(Q>>>0<E>>>0?1:0)},_doFinalize:function(){var a=this._data,d=a.words,f=8*this._nDataBytes,e=8*a.sigBytes;d[e>>>5]|=128<<24-e%32;d[(e+128>>>10<<5)+30]=Math.floor(f/4294967296);d[(e+128>>>10<<5)+31]=f;a.sigBytes=4*d.length;this._process();return this._hash.toX32()},clone:function(){var a=r.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});n.SHA512=r._createHelper(e);n.HmacSHA512=r._createHmacHelper(e)})();

/*
CryptoJS v3.1.2 sha384-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var c=CryptoJS,a=c.x64,b=a.Word,e=a.WordArray,a=c.algo,d=a.SHA512,a=a.SHA384=d.extend({_doReset:function(){this._hash=new e.init([new b.init(3418070365,3238371032),new b.init(1654270250,914150663),new b.init(2438529370,812702999),new b.init(355462360,4144912697),new b.init(1731405415,4290775857),new b.init(2394180231,1750603025),new b.init(3675008525,1694076839),new b.init(1203062813,3204075428)])},_doFinalize:function(){var a=d._doFinalize.call(this);a.sigBytes-=16;return a}});c.SHA384=
d._createHelper(a);c.HmacSHA384=d._createHmacHelper(a)})();

/*
CryptoJS v3.1.2 ripemd160-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/*

(c) 2012 by Cedric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function(){var q=CryptoJS,d=q.lib,n=d.WordArray,p=d.Hasher,d=q.algo,x=n.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),y=n.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),z=n.create([11,14,15,12,
5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),A=n.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),B=n.create([0,1518500249,1859775393,2400959708,2840853838]),C=n.create([1352829926,1548603684,1836072691,
2053994217,0]),d=d.RIPEMD160=p.extend({_doReset:function(){this._hash=n.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,v){for(var b=0;16>b;b++){var c=v+b,f=e[c];e[c]=(f<<8|f>>>24)&16711935|(f<<24|f>>>8)&4278255360}var c=this._hash.words,f=B.words,d=C.words,n=x.words,q=y.words,p=z.words,w=A.words,t,g,h,j,r,u,k,l,m,s;u=t=c[0];k=g=c[1];l=h=c[2];m=j=c[3];s=r=c[4];for(var a,b=0;80>b;b+=1)a=t+e[v+n[b]]|0,a=16>b?a+((g^h^j)+f[0]):32>b?a+((g&h|~g&j)+f[1]):48>b?
a+(((g|~h)^j)+f[2]):64>b?a+((g&j|h&~j)+f[3]):a+((g^(h|~j))+f[4]),a|=0,a=a<<p[b]|a>>>32-p[b],a=a+r|0,t=r,r=j,j=h<<10|h>>>22,h=g,g=a,a=u+e[v+q[b]]|0,a=16>b?a+((k^(l|~m))+d[0]):32>b?a+((k&m|l&~m)+d[1]):48>b?a+(((k|~l)^m)+d[2]):64>b?a+((k&l|~k&m)+d[3]):a+((k^l^m)+d[4]),a|=0,a=a<<w[b]|a>>>32-w[b],a=a+s|0,u=s,s=m,m=l<<10|l>>>22,l=k,k=a;a=c[1]+h+m|0;c[1]=c[2]+j+s|0;c[2]=c[3]+r+u|0;c[3]=c[4]+t+k|0;c[4]=c[0]+g+l|0;c[0]=a},_doFinalize:function(){var e=this._data,d=e.words,b=8*this._nDataBytes,c=8*e.sigBytes;
d[c>>>5]|=128<<24-c%32;d[(c+64>>>9<<4)+14]=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360;e.sigBytes=4*(d.length+1);this._process();e=this._hash;d=e.words;for(b=0;5>b;b++)c=d[b],d[b]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return e},clone:function(){var d=p.clone.call(this);d._hash=this._hash.clone();return d}});q.RIPEMD160=p._createHelper(d);q.HmacRIPEMD160=p._createHmacHelper(d)})(Math);

/*
CryptoJS v3.1.2 hmac.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var c=CryptoJS,k=c.enc.Utf8;c.algo.HMAC=c.lib.Base.extend({init:function(a,b){a=this._hasher=new a.init;"string"==typeof b&&(b=k.parse(b));var c=a.blockSize,e=4*c;b.sigBytes>e&&(b=a.finalize(b));b.clamp();for(var f=this._oKey=b.clone(),g=this._iKey=b.clone(),h=f.words,j=g.words,d=0;d<c;d++)h[d]^=1549556828,j[d]^=909522486;f.sigBytes=g.sigBytes=e;this.reset()},reset:function(){var a=this._hasher;a.reset();a.update(this._iKey)},update:function(a){this._hasher.update(a);return this},finalize:function(a){var b=
this._hasher;a=b.finalize(a);b.reset();return b.finalize(this._oKey.clone().concat(a))}})})();

/*
CryptoJS v3.1.2 pbkdf2-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var b=CryptoJS,a=b.lib,d=a.Base,m=a.WordArray,a=b.algo,q=a.HMAC,l=a.PBKDF2=d.extend({cfg:d.extend({keySize:4,hasher:a.SHA1,iterations:1}),init:function(a){this.cfg=this.cfg.extend(a)},compute:function(a,b){for(var c=this.cfg,f=q.create(c.hasher,a),g=m.create(),d=m.create([1]),l=g.words,r=d.words,n=c.keySize,c=c.iterations;l.length<n;){var h=f.update(b).finalize(d);f.reset();for(var j=h.words,s=j.length,k=h,p=1;p<c;p++){k=f.finalize(k);f.reset();for(var t=k.words,e=0;e<s;e++)j[e]^=t[e]}g.concat(h);
r[0]++}g.sigBytes=4*n;return g}});b.PBKDF2=function(a,b,c){return l.create(c).compute(a,b)}})();

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var b64pad="=";function hex2b64(d){var b;var e;var a="";for(b=0;b+3<=d.length;b+=3){e=parseInt(d.substring(b,b+3),16);a+=b64map.charAt(e>>6)+b64map.charAt(e&63)}if(b+1==d.length){e=parseInt(d.substring(b,b+1),16);a+=b64map.charAt(e<<2)}else{if(b+2==d.length){e=parseInt(d.substring(b,b+2),16);a+=b64map.charAt(e>>2)+b64map.charAt((e&3)<<4)}}if(b64pad){while((a.length&3)>0){a+=b64pad}}return a}function b64tohex(f){var d="";var e;var b=0;var c;var a;for(e=0;e<f.length;++e){if(f.charAt(e)==b64pad){break}a=b64map.indexOf(f.charAt(e));if(a<0){continue}if(b==0){d+=int2char(a>>2);c=a&3;b=1}else{if(b==1){d+=int2char((c<<2)|(a>>4));c=a&15;b=2}else{if(b==2){d+=int2char(c);d+=int2char(a>>2);c=a&3;b=3}else{d+=int2char((c<<2)|(a>>4));d+=int2char(a&15);b=0}}}}if(b==1){d+=int2char(c<<2)}return d}function b64toBA(e){var d=b64tohex(e);var c;var b=new Array();for(c=0;2*c<d.length;++c){b[c]=parseInt(d.substring(2*c,2*c+2),16)}return b};
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var dbits;var canary=244837814094590;var j_lm=((canary&16777215)==15715070);function BigInteger(e,d,f){if(e!=null){if("number"==typeof e){this.fromNumber(e,d,f)}else{if(d==null&&"string"!=typeof e){this.fromString(e,256)}else{this.fromString(e,d)}}}}function nbi(){return new BigInteger(null)}function am1(f,a,b,e,h,g){while(--g>=0){var d=a*this[f++]+b[e]+h;h=Math.floor(d/67108864);b[e++]=d&67108863}return h}function am2(f,q,r,e,o,a){var k=q&32767,p=q>>15;while(--a>=0){var d=this[f]&32767;var g=this[f++]>>15;var b=p*d+g*k;d=k*d+((b&32767)<<15)+r[e]+(o&1073741823);o=(d>>>30)+(b>>>15)+p*g+(o>>>30);r[e++]=d&1073741823}return o}function am3(f,q,r,e,o,a){var k=q&16383,p=q>>14;while(--a>=0){var d=this[f]&16383;var g=this[f++]>>14;var b=p*d+g*k;d=k*d+((b&16383)<<14)+r[e]+o;o=(d>>28)+(b>>14)+p*g;r[e++]=d&268435455}return o}if(j_lm&&(navigator.appName=="Microsoft Internet Explorer")){BigInteger.prototype.am=am2;dbits=30}else{if(j_lm&&(navigator.appName!="Netscape")){BigInteger.prototype.am=am1;dbits=26}else{BigInteger.prototype.am=am3;dbits=28}}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=((1<<dbits)-1);BigInteger.prototype.DV=(1<<dbits);var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array();var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv){BI_RC[rr++]=vv}rr="a".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv}rr="A".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv}function int2char(a){return BI_RM.charAt(a)}function intAt(b,a){var d=BI_RC[b.charCodeAt(a)];return(d==null)?-1:d}function bnpCopyTo(b){for(var a=this.t-1;a>=0;--a){b[a]=this[a]}b.t=this.t;b.s=this.s}function bnpFromInt(a){this.t=1;this.s=(a<0)?-1:0;if(a>0){this[0]=a}else{if(a<-1){this[0]=a+this.DV}else{this.t=0}}}function nbv(a){var b=nbi();b.fromInt(a);return b}function bnpFromString(h,c){var e;if(c==16){e=4}else{if(c==8){e=3}else{if(c==256){e=8}else{if(c==2){e=1}else{if(c==32){e=5}else{if(c==4){e=2}else{this.fromRadix(h,c);return}}}}}}this.t=0;this.s=0;var g=h.length,d=false,f=0;while(--g>=0){var a=(e==8)?h[g]&255:intAt(h,g);if(a<0){if(h.charAt(g)=="-"){d=true}continue}d=false;if(f==0){this[this.t++]=a}else{if(f+e>this.DB){this[this.t-1]|=(a&((1<<(this.DB-f))-1))<<f;this[this.t++]=(a>>(this.DB-f))}else{this[this.t-1]|=a<<f}}f+=e;if(f>=this.DB){f-=this.DB}}if(e==8&&(h[0]&128)!=0){this.s=-1;if(f>0){this[this.t-1]|=((1<<(this.DB-f))-1)<<f}}this.clamp();if(d){BigInteger.ZERO.subTo(this,this)}}function bnpClamp(){var a=this.s&this.DM;while(this.t>0&&this[this.t-1]==a){--this.t}}function bnToString(c){if(this.s<0){return"-"+this.negate().toString(c)}var e;if(c==16){e=4}else{if(c==8){e=3}else{if(c==2){e=1}else{if(c==32){e=5}else{if(c==4){e=2}else{return this.toRadix(c)}}}}}var g=(1<<e)-1,l,a=false,h="",f=this.t;var j=this.DB-(f*this.DB)%e;if(f-->0){if(j<this.DB&&(l=this[f]>>j)>0){a=true;h=int2char(l)}while(f>=0){if(j<e){l=(this[f]&((1<<j)-1))<<(e-j);l|=this[--f]>>(j+=this.DB-e)}else{l=(this[f]>>(j-=e))&g;if(j<=0){j+=this.DB;--f}}if(l>0){a=true}if(a){h+=int2char(l)}}}return a?h:"0"}function bnNegate(){var a=nbi();BigInteger.ZERO.subTo(this,a);return a}function bnAbs(){return(this.s<0)?this.negate():this}function bnCompareTo(b){var d=this.s-b.s;if(d!=0){return d}var c=this.t;d=c-b.t;if(d!=0){return(this.s<0)?-d:d}while(--c>=0){if((d=this[c]-b[c])!=0){return d}}return 0}function nbits(a){var c=1,b;if((b=a>>>16)!=0){a=b;c+=16}if((b=a>>8)!=0){a=b;c+=8}if((b=a>>4)!=0){a=b;c+=4}if((b=a>>2)!=0){a=b;c+=2}if((b=a>>1)!=0){a=b;c+=1}return c}function bnBitLength(){if(this.t<=0){return 0}return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM))}function bnpDLShiftTo(c,b){var a;for(a=this.t-1;a>=0;--a){b[a+c]=this[a]}for(a=c-1;a>=0;--a){b[a]=0}b.t=this.t+c;b.s=this.s}function bnpDRShiftTo(c,b){for(var a=c;a<this.t;++a){b[a-c]=this[a]}b.t=Math.max(this.t-c,0);b.s=this.s}function bnpLShiftTo(j,e){var b=j%this.DB;var a=this.DB-b;var g=(1<<a)-1;var f=Math.floor(j/this.DB),h=(this.s<<b)&this.DM,d;for(d=this.t-1;d>=0;--d){e[d+f+1]=(this[d]>>a)|h;h=(this[d]&g)<<b}for(d=f-1;d>=0;--d){e[d]=0}e[f]=h;e.t=this.t+f+1;e.s=this.s;e.clamp()}function bnpRShiftTo(g,d){d.s=this.s;var e=Math.floor(g/this.DB);if(e>=this.t){d.t=0;return}var b=g%this.DB;var a=this.DB-b;var f=(1<<b)-1;d[0]=this[e]>>b;for(var c=e+1;c<this.t;++c){d[c-e-1]|=(this[c]&f)<<a;d[c-e]=this[c]>>b}if(b>0){d[this.t-e-1]|=(this.s&f)<<a}d.t=this.t-e;d.clamp()}function bnpSubTo(d,f){var e=0,g=0,b=Math.min(d.t,this.t);while(e<b){g+=this[e]-d[e];f[e++]=g&this.DM;g>>=this.DB}if(d.t<this.t){g-=d.s;while(e<this.t){g+=this[e];f[e++]=g&this.DM;g>>=this.DB}g+=this.s}else{g+=this.s;while(e<d.t){g-=d[e];f[e++]=g&this.DM;g>>=this.DB}g-=d.s}f.s=(g<0)?-1:0;if(g<-1){f[e++]=this.DV+g}else{if(g>0){f[e++]=g}}f.t=e;f.clamp()}function bnpMultiplyTo(c,e){var b=this.abs(),f=c.abs();var d=b.t;e.t=d+f.t;while(--d>=0){e[d]=0}for(d=0;d<f.t;++d){e[d+b.t]=b.am(0,f[d],e,d,0,b.t)}e.s=0;e.clamp();if(this.s!=c.s){BigInteger.ZERO.subTo(e,e)}}function bnpSquareTo(d){var a=this.abs();var b=d.t=2*a.t;while(--b>=0){d[b]=0}for(b=0;b<a.t-1;++b){var e=a.am(b,a[b],d,2*b,0,1);if((d[b+a.t]+=a.am(b+1,2*a[b],d,2*b+1,e,a.t-b-1))>=a.DV){d[b+a.t]-=a.DV;d[b+a.t+1]=1}}if(d.t>0){d[d.t-1]+=a.am(b,a[b],d,2*b,0,1)}d.s=0;d.clamp()}function bnpDivRemTo(n,h,g){var w=n.abs();if(w.t<=0){return}var k=this.abs();if(k.t<w.t){if(h!=null){h.fromInt(0)}if(g!=null){this.copyTo(g)}return}if(g==null){g=nbi()}var d=nbi(),a=this.s,l=n.s;var v=this.DB-nbits(w[w.t-1]);if(v>0){w.lShiftTo(v,d);k.lShiftTo(v,g)}else{w.copyTo(d);k.copyTo(g)}var p=d.t;var b=d[p-1];if(b==0){return}var o=b*(1<<this.F1)+((p>1)?d[p-2]>>this.F2:0);var A=this.FV/o,z=(1<<this.F1)/o,x=1<<this.F2;var u=g.t,s=u-p,f=(h==null)?nbi():h;d.dlShiftTo(s,f);if(g.compareTo(f)>=0){g[g.t++]=1;g.subTo(f,g)}BigInteger.ONE.dlShiftTo(p,f);f.subTo(d,d);while(d.t<p){d[d.t++]=0}while(--s>=0){var c=(g[--u]==b)?this.DM:Math.floor(g[u]*A+(g[u-1]+x)*z);if((g[u]+=d.am(0,c,g,s,0,p))<c){d.dlShiftTo(s,f);g.subTo(f,g);while(g[u]<--c){g.subTo(f,g)}}}if(h!=null){g.drShiftTo(p,h);if(a!=l){BigInteger.ZERO.subTo(h,h)}}g.t=p;g.clamp();if(v>0){g.rShiftTo(v,g)}if(a<0){BigInteger.ZERO.subTo(g,g)}}function bnMod(b){var c=nbi();this.abs().divRemTo(b,null,c);if(this.s<0&&c.compareTo(BigInteger.ZERO)>0){b.subTo(c,c)}return c}function Classic(a){this.m=a}function cConvert(a){if(a.s<0||a.compareTo(this.m)>=0){return a.mod(this.m)}else{return a}}function cRevert(a){return a}function cReduce(a){a.divRemTo(this.m,null,a)}function cMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b)}function cSqrTo(a,b){a.squareTo(b);this.reduce(b)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1){return 0}var a=this[0];if((a&1)==0){return 0}var b=a&3;b=(b*(2-(a&15)*b))&15;b=(b*(2-(a&255)*b))&255;b=(b*(2-(((a&65535)*b)&65535)))&65535;b=(b*(2-a*b%this.DV))%this.DV;return(b>0)?this.DV-b:-b}function Montgomery(a){this.m=a;this.mp=a.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<(a.DB-15))-1;this.mt2=2*a.t}function montConvert(a){var b=nbi();a.abs().dlShiftTo(this.m.t,b);b.divRemTo(this.m,null,b);if(a.s<0&&b.compareTo(BigInteger.ZERO)>0){this.m.subTo(b,b)}return b}function montRevert(a){var b=nbi();a.copyTo(b);this.reduce(b);return b}function montReduce(a){while(a.t<=this.mt2){a[a.t++]=0}for(var c=0;c<this.m.t;++c){var b=a[c]&32767;var d=(b*this.mpl+(((b*this.mph+(a[c]>>15)*this.mpl)&this.um)<<15))&a.DM;b=c+this.m.t;a[b]+=this.m.am(0,d,a,c,0,this.m.t);while(a[b]>=a.DV){a[b]-=a.DV;a[++b]++}}a.clamp();a.drShiftTo(this.m.t,a);if(a.compareTo(this.m)>=0){a.subTo(this.m,a)}}function montSqrTo(a,b){a.squareTo(b);this.reduce(b)}function montMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return((this.t>0)?(this[0]&1):this.s)==0}function bnpExp(h,j){if(h>4294967295||h<1){return BigInteger.ONE}var f=nbi(),a=nbi(),d=j.convert(this),c=nbits(h)-1;d.copyTo(f);while(--c>=0){j.sqrTo(f,a);if((h&(1<<c))>0){j.mulTo(a,d,f)}else{var b=f;f=a;a=b}}return j.revert(f)}function bnModPowInt(b,a){var c;if(b<256||a.isEven()){c=new Classic(a)}else{c=new Montgomery(a)}return this.exp(b,c)}BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=bnMod;BigInteger.prototype.modPowInt=bnModPowInt;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function bnClone(){var a=nbi();this.copyTo(a);return a}function bnIntValue(){if(this.s<0){if(this.t==1){return this[0]-this.DV}else{if(this.t==0){return -1}}}else{if(this.t==1){return this[0]}else{if(this.t==0){return 0}}}return((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0]}function bnByteValue(){return(this.t==0)?this.s:(this[0]<<24)>>24}function bnShortValue(){return(this.t==0)?this.s:(this[0]<<16)>>16}function bnpChunkSize(a){return Math.floor(Math.LN2*this.DB/Math.log(a))}function bnSigNum(){if(this.s<0){return -1}else{if(this.t<=0||(this.t==1&&this[0]<=0)){return 0}else{return 1}}}function bnpToRadix(c){if(c==null){c=10}if(this.signum()==0||c<2||c>36){return"0"}var f=this.chunkSize(c);var e=Math.pow(c,f);var i=nbv(e),j=nbi(),h=nbi(),g="";this.divRemTo(i,j,h);while(j.signum()>0){g=(e+h.intValue()).toString(c).substr(1)+g;j.divRemTo(i,j,h)}return h.intValue().toString(c)+g}function bnpFromRadix(m,h){this.fromInt(0);if(h==null){h=10}var f=this.chunkSize(h);var g=Math.pow(h,f),e=false,a=0,l=0;for(var c=0;c<m.length;++c){var k=intAt(m,c);if(k<0){if(m.charAt(c)=="-"&&this.signum()==0){e=true}continue}l=h*l+k;if(++a>=f){this.dMultiply(g);this.dAddOffset(l,0);a=0;l=0}}if(a>0){this.dMultiply(Math.pow(h,a));this.dAddOffset(l,0)}if(e){BigInteger.ZERO.subTo(this,this)}}function bnpFromNumber(f,e,h){if("number"==typeof e){if(f<2){this.fromInt(1)}else{this.fromNumber(f,h);if(!this.testBit(f-1)){this.bitwiseTo(BigInteger.ONE.shiftLeft(f-1),op_or,this)}if(this.isEven()){this.dAddOffset(1,0)}while(!this.isProbablePrime(e)){this.dAddOffset(2,0);if(this.bitLength()>f){this.subTo(BigInteger.ONE.shiftLeft(f-1),this)}}}}else{var d=new Array(),g=f&7;d.length=(f>>3)+1;e.nextBytes(d);if(g>0){d[0]&=((1<<g)-1)}else{d[0]=0}this.fromString(d,256)}}function bnToByteArray(){var b=this.t,c=new Array();c[0]=this.s;var e=this.DB-(b*this.DB)%8,f,a=0;if(b-->0){if(e<this.DB&&(f=this[b]>>e)!=(this.s&this.DM)>>e){c[a++]=f|(this.s<<(this.DB-e))}while(b>=0){if(e<8){f=(this[b]&((1<<e)-1))<<(8-e);f|=this[--b]>>(e+=this.DB-8)}else{f=(this[b]>>(e-=8))&255;if(e<=0){e+=this.DB;--b}}if((f&128)!=0){f|=-256}if(a==0&&(this.s&128)!=(f&128)){++a}if(a>0||f!=this.s){c[a++]=f}}}return c}function bnEquals(b){return(this.compareTo(b)==0)}function bnMin(b){return(this.compareTo(b)<0)?this:b}function bnMax(b){return(this.compareTo(b)>0)?this:b}function bnpBitwiseTo(c,h,e){var d,g,b=Math.min(c.t,this.t);for(d=0;d<b;++d){e[d]=h(this[d],c[d])}if(c.t<this.t){g=c.s&this.DM;for(d=b;d<this.t;++d){e[d]=h(this[d],g)}e.t=this.t}else{g=this.s&this.DM;for(d=b;d<c.t;++d){e[d]=h(g,c[d])}e.t=c.t}e.s=h(this.s,c.s);e.clamp()}function op_and(a,b){return a&b}function bnAnd(b){var c=nbi();this.bitwiseTo(b,op_and,c);return c}function op_or(a,b){return a|b}function bnOr(b){var c=nbi();this.bitwiseTo(b,op_or,c);return c}function op_xor(a,b){return a^b}function bnXor(b){var c=nbi();this.bitwiseTo(b,op_xor,c);return c}function op_andnot(a,b){return a&~b}function bnAndNot(b){var c=nbi();this.bitwiseTo(b,op_andnot,c);return c}function bnNot(){var b=nbi();for(var a=0;a<this.t;++a){b[a]=this.DM&~this[a]}b.t=this.t;b.s=~this.s;return b}function bnShiftLeft(b){var a=nbi();if(b<0){this.rShiftTo(-b,a)}else{this.lShiftTo(b,a)}return a}function bnShiftRight(b){var a=nbi();if(b<0){this.lShiftTo(-b,a)}else{this.rShiftTo(b,a)}return a}function lbit(a){if(a==0){return -1}var b=0;if((a&65535)==0){a>>=16;b+=16}if((a&255)==0){a>>=8;b+=8}if((a&15)==0){a>>=4;b+=4}if((a&3)==0){a>>=2;b+=2}if((a&1)==0){++b}return b}function bnGetLowestSetBit(){for(var a=0;a<this.t;++a){if(this[a]!=0){return a*this.DB+lbit(this[a])}}if(this.s<0){return this.t*this.DB}return -1}function cbit(a){var b=0;while(a!=0){a&=a-1;++b}return b}function bnBitCount(){var c=0,a=this.s&this.DM;for(var b=0;b<this.t;++b){c+=cbit(this[b]^a)}return c}function bnTestBit(b){var a=Math.floor(b/this.DB);if(a>=this.t){return(this.s!=0)}return((this[a]&(1<<(b%this.DB)))!=0)}function bnpChangeBit(c,b){var a=BigInteger.ONE.shiftLeft(c);this.bitwiseTo(a,b,a);return a}function bnSetBit(a){return this.changeBit(a,op_or)}function bnClearBit(a){return this.changeBit(a,op_andnot)}function bnFlipBit(a){return this.changeBit(a,op_xor)}function bnpAddTo(d,f){var e=0,g=0,b=Math.min(d.t,this.t);while(e<b){g+=this[e]+d[e];f[e++]=g&this.DM;g>>=this.DB}if(d.t<this.t){g+=d.s;while(e<this.t){g+=this[e];f[e++]=g&this.DM;g>>=this.DB}g+=this.s}else{g+=this.s;while(e<d.t){g+=d[e];f[e++]=g&this.DM;g>>=this.DB}g+=d.s}f.s=(g<0)?-1:0;if(g>0){f[e++]=g}else{if(g<-1){f[e++]=this.DV+g}}f.t=e;f.clamp()}function bnAdd(b){var c=nbi();this.addTo(b,c);return c}function bnSubtract(b){var c=nbi();this.subTo(b,c);return c}function bnMultiply(b){var c=nbi();this.multiplyTo(b,c);return c}function bnSquare(){var a=nbi();this.squareTo(a);return a}function bnDivide(b){var c=nbi();this.divRemTo(b,c,null);return c}function bnRemainder(b){var c=nbi();this.divRemTo(b,null,c);return c}function bnDivideAndRemainder(b){var d=nbi(),c=nbi();this.divRemTo(b,d,c);return new Array(d,c)}function bnpDMultiply(a){this[this.t]=this.am(0,a-1,this,0,0,this.t);++this.t;this.clamp()}function bnpDAddOffset(b,a){if(b==0){return}while(this.t<=a){this[this.t++]=0}this[a]+=b;while(this[a]>=this.DV){this[a]-=this.DV;if(++a>=this.t){this[this.t++]=0}++this[a]}}function NullExp(){}function nNop(a){return a}function nMulTo(a,c,b){a.multiplyTo(c,b)}function nSqrTo(a,b){a.squareTo(b)}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;function bnPow(a){return this.exp(a,new NullExp())}function bnpMultiplyLowerTo(b,f,e){var d=Math.min(this.t+b.t,f);e.s=0;e.t=d;while(d>0){e[--d]=0}var c;for(c=e.t-this.t;d<c;++d){e[d+this.t]=this.am(0,b[d],e,d,0,this.t)}for(c=Math.min(b.t,f);d<c;++d){this.am(0,b[d],e,d,0,f-d)}e.clamp()}function bnpMultiplyUpperTo(b,e,d){--e;var c=d.t=this.t+b.t-e;d.s=0;while(--c>=0){d[c]=0}for(c=Math.max(e-this.t,0);c<b.t;++c){d[this.t+c-e]=this.am(e-c,b[c],d,0,0,this.t+c-e)}d.clamp();d.drShiftTo(1,d)}function Barrett(a){this.r2=nbi();this.q3=nbi();BigInteger.ONE.dlShiftTo(2*a.t,this.r2);this.mu=this.r2.divide(a);this.m=a}function barrettConvert(a){if(a.s<0||a.t>2*this.m.t){return a.mod(this.m)}else{if(a.compareTo(this.m)<0){return a}else{var b=nbi();a.copyTo(b);this.reduce(b);return b}}}function barrettRevert(a){return a}function barrettReduce(a){a.drShiftTo(this.m.t-1,this.r2);if(a.t>this.m.t+1){a.t=this.m.t+1;a.clamp()}this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(a.compareTo(this.r2)<0){a.dAddOffset(1,this.m.t+1)}a.subTo(this.r2,a);while(a.compareTo(this.m)>=0){a.subTo(this.m,a)}}function barrettSqrTo(a,b){a.squareTo(b);this.reduce(b)}function barrettMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b)}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;function bnModPow(q,f){var o=q.bitLength(),h,b=nbv(1),v;if(o<=0){return b}else{if(o<18){h=1}else{if(o<48){h=3}else{if(o<144){h=4}else{if(o<768){h=5}else{h=6}}}}}if(o<8){v=new Classic(f)}else{if(f.isEven()){v=new Barrett(f)}else{v=new Montgomery(f)}}var p=new Array(),d=3,s=h-1,a=(1<<h)-1;p[1]=v.convert(this);if(h>1){var A=nbi();v.sqrTo(p[1],A);while(d<=a){p[d]=nbi();v.mulTo(A,p[d-2],p[d]);d+=2}}var l=q.t-1,x,u=true,c=nbi(),y;o=nbits(q[l])-1;while(l>=0){if(o>=s){x=(q[l]>>(o-s))&a}else{x=(q[l]&((1<<(o+1))-1))<<(s-o);if(l>0){x|=q[l-1]>>(this.DB+o-s)}}d=h;while((x&1)==0){x>>=1;--d}if((o-=d)<0){o+=this.DB;--l}if(u){p[x].copyTo(b);u=false}else{while(d>1){v.sqrTo(b,c);v.sqrTo(c,b);d-=2}if(d>0){v.sqrTo(b,c)}else{y=b;b=c;c=y}v.mulTo(c,p[x],b)}while(l>=0&&(q[l]&(1<<o))==0){v.sqrTo(b,c);y=b;b=c;c=y;if(--o<0){o=this.DB-1;--l}}}return v.revert(b)}function bnGCD(c){var b=(this.s<0)?this.negate():this.clone();var h=(c.s<0)?c.negate():c.clone();if(b.compareTo(h)<0){var e=b;b=h;h=e}var d=b.getLowestSetBit(),f=h.getLowestSetBit();if(f<0){return b}if(d<f){f=d}if(f>0){b.rShiftTo(f,b);h.rShiftTo(f,h)}while(b.signum()>0){if((d=b.getLowestSetBit())>0){b.rShiftTo(d,b)}if((d=h.getLowestSetBit())>0){h.rShiftTo(d,h)}if(b.compareTo(h)>=0){b.subTo(h,b);b.rShiftTo(1,b)}else{h.subTo(b,h);h.rShiftTo(1,h)}}if(f>0){h.lShiftTo(f,h)}return h}function bnpModInt(e){if(e<=0){return 0}var c=this.DV%e,b=(this.s<0)?e-1:0;if(this.t>0){if(c==0){b=this[0]%e}else{for(var a=this.t-1;a>=0;--a){b=(c*b+this[a])%e}}}return b}function bnModInverse(f){var j=f.isEven();if((this.isEven()&&j)||f.signum()==0){return BigInteger.ZERO}var i=f.clone(),h=this.clone();var g=nbv(1),e=nbv(0),l=nbv(0),k=nbv(1);while(i.signum()!=0){while(i.isEven()){i.rShiftTo(1,i);if(j){if(!g.isEven()||!e.isEven()){g.addTo(this,g);e.subTo(f,e)}g.rShiftTo(1,g)}else{if(!e.isEven()){e.subTo(f,e)}}e.rShiftTo(1,e)}while(h.isEven()){h.rShiftTo(1,h);if(j){if(!l.isEven()||!k.isEven()){l.addTo(this,l);k.subTo(f,k)}l.rShiftTo(1,l)}else{if(!k.isEven()){k.subTo(f,k)}}k.rShiftTo(1,k)}if(i.compareTo(h)>=0){i.subTo(h,i);if(j){g.subTo(l,g)}e.subTo(k,e)}else{h.subTo(i,h);if(j){l.subTo(g,l)}k.subTo(e,k)}}if(h.compareTo(BigInteger.ONE)!=0){return BigInteger.ZERO}if(k.compareTo(f)>=0){return k.subtract(f)}if(k.signum()<0){k.addTo(f,k)}else{return k}if(k.signum()<0){return k.add(f)}else{return k}}var lowprimes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];var lplim=(1<<26)/lowprimes[lowprimes.length-1];function bnIsProbablePrime(e){var d,b=this.abs();if(b.t==1&&b[0]<=lowprimes[lowprimes.length-1]){for(d=0;d<lowprimes.length;++d){if(b[0]==lowprimes[d]){return true}}return false}if(b.isEven()){return false}d=1;while(d<lowprimes.length){var a=lowprimes[d],c=d+1;while(c<lowprimes.length&&a<lplim){a*=lowprimes[c++]}a=b.modInt(a);while(d<c){if(a%lowprimes[d++]==0){return false}}}return b.millerRabin(e)}function bnpMillerRabin(f){var g=this.subtract(BigInteger.ONE);var c=g.getLowestSetBit();if(c<=0){return false}var h=g.shiftRight(c);f=(f+1)>>1;if(f>lowprimes.length){f=lowprimes.length}var b=nbi();for(var e=0;e<f;++e){b.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);var l=b.modPow(h,this);if(l.compareTo(BigInteger.ONE)!=0&&l.compareTo(g)!=0){var d=1;while(d++<c&&l.compareTo(g)!=0){l=l.modPowInt(2,this);if(l.compareTo(BigInteger.ONE)==0){return false}}if(l.compareTo(g)!=0){return false}}}return true}BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.fromNumber=bnpFromNumber;BigInteger.prototype.bitwiseTo=bnpBitwiseTo;BigInteger.prototype.changeBit=bnpChangeBit;BigInteger.prototype.addTo=bnpAddTo;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.multiplyLowerTo=bnpMultiplyLowerTo;BigInteger.prototype.multiplyUpperTo=bnpMultiplyUpperTo;BigInteger.prototype.modInt=bnpModInt;BigInteger.prototype.millerRabin=bnpMillerRabin;BigInteger.prototype.clone=bnClone;BigInteger.prototype.intValue=bnIntValue;BigInteger.prototype.byteValue=bnByteValue;BigInteger.prototype.shortValue=bnShortValue;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.toByteArray=bnToByteArray;BigInteger.prototype.equals=bnEquals;BigInteger.prototype.min=bnMin;BigInteger.prototype.max=bnMax;BigInteger.prototype.and=bnAnd;BigInteger.prototype.or=bnOr;BigInteger.prototype.xor=bnXor;BigInteger.prototype.andNot=bnAndNot;BigInteger.prototype.not=bnNot;BigInteger.prototype.shiftLeft=bnShiftLeft;BigInteger.prototype.shiftRight=bnShiftRight;BigInteger.prototype.getLowestSetBit=bnGetLowestSetBit;BigInteger.prototype.bitCount=bnBitCount;BigInteger.prototype.testBit=bnTestBit;BigInteger.prototype.setBit=bnSetBit;BigInteger.prototype.clearBit=bnClearBit;BigInteger.prototype.flipBit=bnFlipBit;BigInteger.prototype.add=bnAdd;BigInteger.prototype.subtract=bnSubtract;BigInteger.prototype.multiply=bnMultiply;BigInteger.prototype.divide=bnDivide;BigInteger.prototype.remainder=bnRemainder;BigInteger.prototype.divideAndRemainder=bnDivideAndRemainder;BigInteger.prototype.modPow=bnModPow;BigInteger.prototype.modInverse=bnModInverse;BigInteger.prototype.pow=bnPow;BigInteger.prototype.gcd=bnGCD;BigInteger.prototype.isProbablePrime=bnIsProbablePrime;BigInteger.prototype.square=bnSquare;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function Arcfour(){this.i=0;this.j=0;this.S=new Array()}function ARC4init(d){var c,a,b;for(c=0;c<256;++c){this.S[c]=c}a=0;for(c=0;c<256;++c){a=(a+this.S[c]+d[c%d.length])&255;b=this.S[c];this.S[c]=this.S[a];this.S[a]=b}this.i=0;this.j=0}function ARC4next(){var a;this.i=(this.i+1)&255;this.j=(this.j+this.S[this.i])&255;a=this.S[this.i];this.S[this.i]=this.S[this.j];this.S[this.j]=a;return this.S[(a+this.S[this.i])&255]}Arcfour.prototype.init=ARC4init;Arcfour.prototype.next=ARC4next;function prng_newstate(){return new Arcfour()}var rng_psize=256;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var rng_state;var rng_pool;var rng_pptr;function rng_seed_int(a){rng_pool[rng_pptr++]^=a&255;rng_pool[rng_pptr++]^=(a>>8)&255;rng_pool[rng_pptr++]^=(a>>16)&255;rng_pool[rng_pptr++]^=(a>>24)&255;if(rng_pptr>=rng_psize){rng_pptr-=rng_psize}}function rng_seed_time(){rng_seed_int(new Date().getTime())}if(rng_pool==null){rng_pool=new Array();rng_pptr=0;var t;if(window.crypto&&window.crypto.getRandomValues){var ua=new Uint8Array(32);window.crypto.getRandomValues(ua);for(t=0;t<32;++t){rng_pool[rng_pptr++]=ua[t]}}if(navigator.appName=="Netscape"&&navigator.appVersion<"5"&&window.crypto){var z=window.crypto.random(32);for(t=0;t<z.length;++t){rng_pool[rng_pptr++]=z.charCodeAt(t)&255}}while(rng_pptr<rng_psize){t=Math.floor(65536*Math.random());rng_pool[rng_pptr++]=t>>>8;rng_pool[rng_pptr++]=t&255}rng_pptr=0;rng_seed_time()}function rng_get_byte(){if(rng_state==null){rng_seed_time();rng_state=prng_newstate();rng_state.init(rng_pool);for(rng_pptr=0;rng_pptr<rng_pool.length;++rng_pptr){rng_pool[rng_pptr]=0}rng_pptr=0}return rng_state.next()}function rng_get_bytes(b){var a;for(a=0;a<b.length;++a){b[a]=rng_get_byte()}}function SecureRandom(){}SecureRandom.prototype.nextBytes=rng_get_bytes;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function parseBigInt(b,a){return new BigInteger(b,a)}function linebrk(c,d){var a="";var b=0;while(b+d<c.length){a+=c.substring(b,b+d)+"\n";b+=d}return a+c.substring(b,c.length)}function byte2Hex(a){if(a<16){return"0"+a.toString(16)}else{return a.toString(16)}}function pkcs1pad2(e,h){if(h<e.length+11){alert("Message too long for RSA");return null}var g=new Array();var d=e.length-1;while(d>=0&&h>0){var f=e.charCodeAt(d--);if(f<128){g[--h]=f}else{if((f>127)&&(f<2048)){g[--h]=(f&63)|128;g[--h]=(f>>6)|192}else{g[--h]=(f&63)|128;g[--h]=((f>>6)&63)|128;g[--h]=(f>>12)|224}}}g[--h]=0;var b=new SecureRandom();var a=new Array();while(h>2){a[0]=0;while(a[0]==0){b.nextBytes(a)}g[--h]=a[0]}g[--h]=2;g[--h]=0;return new BigInteger(g)}function oaep_mgf1_arr(c,a,e){var b="",d=0;while(b.length<a){b+=e(String.fromCharCode.apply(String,c.concat([(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255])));d+=1}return b}function oaep_pad(q,a,f,l){var c=KJUR.crypto.MessageDigest;var o=KJUR.crypto.Util;var b=null;if(!f){f="sha1"}if(typeof f==="string"){b=c.getCanonicalAlgName(f);l=c.getHashLength(b);f=function(i){return hextorstr(o.hashString(i,b))}}if(q.length+2*l+2>a){throw"Message too long for RSA"}var k="",e;for(e=0;e<a-q.length-2*l-2;e+=1){k+="\x00"}var h=f("")+k+"\x01"+q;var g=new Array(l);new SecureRandom().nextBytes(g);var j=oaep_mgf1_arr(g,h.length,f);var p=[];for(e=0;e<h.length;e+=1){p[e]=h.charCodeAt(e)^j.charCodeAt(e)}var m=oaep_mgf1_arr(p,g.length,f);var d=[0];for(e=0;e<g.length;e+=1){d[e+1]=g[e]^m.charCodeAt(e)}return new BigInteger(d.concat(p))}function RSAKey(){this.n=null;this.e=0;this.d=null;this.p=null;this.q=null;this.dmp1=null;this.dmq1=null;this.coeff=null}function RSASetPublic(b,a){this.isPublic=true;if(typeof b!=="string"){this.n=b;this.e=a}else{if(b!=null&&a!=null&&b.length>0&&a.length>0){this.n=parseBigInt(b,16);this.e=parseInt(a,16)}else{alert("Invalid RSA public key")}}}function RSADoPublic(a){return a.modPowInt(this.e,this.n)}function RSAEncrypt(d){var a=pkcs1pad2(d,(this.n.bitLength()+7)>>3);if(a==null){return null}var e=this.doPublic(a);if(e==null){return null}var b=e.toString(16);if((b.length&1)==0){return b}else{return"0"+b}}function RSAEncryptOAEP(f,e,b){var a=oaep_pad(f,(this.n.bitLength()+7)>>3,e,b);if(a==null){return null}var g=this.doPublic(a);if(g==null){return null}var d=g.toString(16);if((d.length&1)==0){return d}else{return"0"+d}}RSAKey.prototype.doPublic=RSADoPublic;RSAKey.prototype.setPublic=RSASetPublic;RSAKey.prototype.encrypt=RSAEncrypt;RSAKey.prototype.encryptOAEP=RSAEncryptOAEP;RSAKey.prototype.type="RSA";
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function pkcs1unpad2(g,j){var a=g.toByteArray();var f=0;while(f<a.length&&a[f]==0){++f}if(a.length-f!=j-1||a[f]!=2){return null}++f;while(a[f]!=0){if(++f>=a.length){return null}}var e="";while(++f<a.length){var h=a[f]&255;if(h<128){e+=String.fromCharCode(h)}else{if((h>191)&&(h<224)){e+=String.fromCharCode(((h&31)<<6)|(a[f+1]&63));++f}else{e+=String.fromCharCode(((h&15)<<12)|((a[f+1]&63)<<6)|(a[f+2]&63));f+=2}}}return e}function oaep_mgf1_str(c,a,e){var b="",d=0;while(b.length<a){b+=e(c+String.fromCharCode.apply(String,[(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255]));d+=1}return b}function oaep_unpad(o,b,g,p){var e=KJUR.crypto.MessageDigest;var r=KJUR.crypto.Util;var c=null;if(!g){g="sha1"}if(typeof g==="string"){c=e.getCanonicalAlgName(g);p=e.getHashLength(c);g=function(d){return hextorstr(r.hashString(d,c))}}o=o.toByteArray();var h;for(h=0;h<o.length;h+=1){o[h]&=255}while(o.length<b){o.unshift(0)}o=String.fromCharCode.apply(String,o);if(o.length<2*p+2){throw"Cipher too short"}var f=o.substr(1,p);var s=o.substr(p+1);var q=oaep_mgf1_str(s,p,g);var k=[],h;for(h=0;h<f.length;h+=1){k[h]=f.charCodeAt(h)^q.charCodeAt(h)}var l=oaep_mgf1_str(String.fromCharCode.apply(String,k),o.length-p,g);var j=[];for(h=0;h<s.length;h+=1){j[h]=s.charCodeAt(h)^l.charCodeAt(h)}j=String.fromCharCode.apply(String,j);if(j.substr(0,p)!==g("")){throw"Hash mismatch"}j=j.substr(p);var a=j.indexOf("\x01");var m=(a!=-1)?j.substr(0,a).lastIndexOf("\x00"):-1;if(m+1!=a){throw"Malformed data"}return j.substr(a+1)}function RSASetPrivate(c,a,b){this.isPrivate=true;if(typeof c!=="string"){this.n=c;this.e=a;this.d=b}else{if(c!=null&&a!=null&&c.length>0&&a.length>0){this.n=parseBigInt(c,16);this.e=parseInt(a,16);this.d=parseBigInt(b,16)}else{alert("Invalid RSA private key")}}}function RSASetPrivateEx(g,d,e,c,b,a,h,f){this.isPrivate=true;if(g==null){throw"RSASetPrivateEx N == null"}if(d==null){throw"RSASetPrivateEx E == null"}if(g.length==0){throw"RSASetPrivateEx N.length == 0"}if(d.length==0){throw"RSASetPrivateEx E.length == 0"}if(g!=null&&d!=null&&g.length>0&&d.length>0){this.n=parseBigInt(g,16);this.e=parseInt(d,16);this.d=parseBigInt(e,16);this.p=parseBigInt(c,16);this.q=parseBigInt(b,16);this.dmp1=parseBigInt(a,16);this.dmq1=parseBigInt(h,16);this.coeff=parseBigInt(f,16)}else{alert("Invalid RSA private key in RSASetPrivateEx")}}function RSAGenerate(b,i){var a=new SecureRandom();var f=b>>1;this.e=parseInt(i,16);var c=new BigInteger(i,16);for(;;){for(;;){this.p=new BigInteger(b-f,1,a);if(this.p.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE)==0&&this.p.isProbablePrime(10)){break}}for(;;){this.q=new BigInteger(f,1,a);if(this.q.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE)==0&&this.q.isProbablePrime(10)){break}}if(this.p.compareTo(this.q)<=0){var h=this.p;this.p=this.q;this.q=h}var g=this.p.subtract(BigInteger.ONE);var d=this.q.subtract(BigInteger.ONE);var e=g.multiply(d);if(e.gcd(c).compareTo(BigInteger.ONE)==0){this.n=this.p.multiply(this.q);this.d=c.modInverse(e);this.dmp1=this.d.mod(g);this.dmq1=this.d.mod(d);this.coeff=this.q.modInverse(this.p);break}}this.isPrivate=true}function RSADoPrivate(a){if(this.p==null||this.q==null){return a.modPow(this.d,this.n)}var c=a.mod(this.p).modPow(this.dmp1,this.p);var b=a.mod(this.q).modPow(this.dmq1,this.q);while(c.compareTo(b)<0){c=c.add(this.p)}return c.subtract(b).multiply(this.coeff).mod(this.p).multiply(this.q).add(b)}function RSADecrypt(b){var d=parseBigInt(b,16);var a=this.doPrivate(d);if(a==null){return null}return pkcs1unpad2(a,(this.n.bitLength()+7)>>3)}function RSADecryptOAEP(e,d,b){var f=parseBigInt(e,16);var a=this.doPrivate(f);if(a==null){return null}return oaep_unpad(a,(this.n.bitLength()+7)>>3,d,b)}RSAKey.prototype.doPrivate=RSADoPrivate;RSAKey.prototype.setPrivate=RSASetPrivate;RSAKey.prototype.setPrivateEx=RSASetPrivateEx;RSAKey.prototype.generate=RSAGenerate;RSAKey.prototype.decrypt=RSADecrypt;RSAKey.prototype.decryptOAEP=RSADecryptOAEP;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function ECFieldElementFp(b,a){this.x=a;this.q=b}function feFpEquals(a){if(a==this){return true}return(this.q.equals(a.q)&&this.x.equals(a.x))}function feFpToBigInteger(){return this.x}function feFpNegate(){return new ECFieldElementFp(this.q,this.x.negate().mod(this.q))}function feFpAdd(a){return new ECFieldElementFp(this.q,this.x.add(a.toBigInteger()).mod(this.q))}function feFpSubtract(a){return new ECFieldElementFp(this.q,this.x.subtract(a.toBigInteger()).mod(this.q))}function feFpMultiply(a){return new ECFieldElementFp(this.q,this.x.multiply(a.toBigInteger()).mod(this.q))}function feFpSquare(){return new ECFieldElementFp(this.q,this.x.square().mod(this.q))}function feFpDivide(a){return new ECFieldElementFp(this.q,this.x.multiply(a.toBigInteger().modInverse(this.q)).mod(this.q))}ECFieldElementFp.prototype.equals=feFpEquals;ECFieldElementFp.prototype.toBigInteger=feFpToBigInteger;ECFieldElementFp.prototype.negate=feFpNegate;ECFieldElementFp.prototype.add=feFpAdd;ECFieldElementFp.prototype.subtract=feFpSubtract;ECFieldElementFp.prototype.multiply=feFpMultiply;ECFieldElementFp.prototype.square=feFpSquare;ECFieldElementFp.prototype.divide=feFpDivide;function ECPointFp(c,a,d,b){this.curve=c;this.x=a;this.y=d;if(b==null){this.z=BigInteger.ONE}else{this.z=b}this.zinv=null}function pointFpGetX(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q)}return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpGetY(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q)}return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpEquals(a){if(a==this){return true}if(this.isInfinity()){return a.isInfinity()}if(a.isInfinity()){return this.isInfinity()}var c,b;c=a.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(a.z)).mod(this.curve.q);if(!c.equals(BigInteger.ZERO)){return false}b=a.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(a.z)).mod(this.curve.q);return b.equals(BigInteger.ZERO)}function pointFpIsInfinity(){if((this.x==null)&&(this.y==null)){return true}return this.z.equals(BigInteger.ZERO)&&!this.y.toBigInteger().equals(BigInteger.ZERO)}function pointFpNegate(){return new ECPointFp(this.curve,this.x,this.y.negate(),this.z)}function pointFpAdd(l){if(this.isInfinity()){return l}if(l.isInfinity()){return this}var p=l.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(l.z)).mod(this.curve.q);var o=l.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(l.z)).mod(this.curve.q);if(BigInteger.ZERO.equals(o)){if(BigInteger.ZERO.equals(p)){return this.twice()}return this.curve.getInfinity()}var j=new BigInteger("3");var e=this.x.toBigInteger();var n=this.y.toBigInteger();var c=l.x.toBigInteger();var k=l.y.toBigInteger();var m=o.square();var i=m.multiply(o);var d=e.multiply(m);var g=p.square().multiply(this.z);var a=g.subtract(d.shiftLeft(1)).multiply(l.z).subtract(i).multiply(o).mod(this.curve.q);var h=d.multiply(j).multiply(p).subtract(n.multiply(i)).subtract(g.multiply(p)).multiply(l.z).add(p.multiply(i)).mod(this.curve.q);var f=i.multiply(this.z).multiply(l.z).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(a),this.curve.fromBigInteger(h),f)}function pointFpTwice(){if(this.isInfinity()){return this}if(this.y.toBigInteger().signum()==0){return this.curve.getInfinity()}var g=new BigInteger("3");var c=this.x.toBigInteger();var h=this.y.toBigInteger();var e=h.multiply(this.z);var j=e.multiply(h).mod(this.curve.q);var i=this.curve.a.toBigInteger();var k=c.square().multiply(g);if(!BigInteger.ZERO.equals(i)){k=k.add(this.z.square().multiply(i))}k=k.mod(this.curve.q);var b=k.square().subtract(c.shiftLeft(3).multiply(j)).shiftLeft(1).multiply(e).mod(this.curve.q);var f=k.multiply(g).multiply(c).subtract(j.shiftLeft(1)).shiftLeft(2).multiply(j).subtract(k.square().multiply(k)).mod(this.curve.q);var d=e.square().multiply(e).shiftLeft(3).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(b),this.curve.fromBigInteger(f),d)}function pointFpMultiply(b){if(this.isInfinity()){return this}if(b.signum()==0){return this.curve.getInfinity()}var g=b;var f=g.multiply(new BigInteger("3"));var l=this.negate();var d=this;var c;for(c=f.bitLength()-2;c>0;--c){d=d.twice();var a=f.testBit(c);var j=g.testBit(c);if(a!=j){d=d.add(a?this:l)}}return d}function pointFpMultiplyTwo(c,a,b){var d;if(c.bitLength()>b.bitLength()){d=c.bitLength()-1}else{d=b.bitLength()-1}var f=this.curve.getInfinity();var e=this.add(a);while(d>=0){f=f.twice();if(c.testBit(d)){if(b.testBit(d)){f=f.add(e)}else{f=f.add(this)}}else{if(b.testBit(d)){f=f.add(a)}}--d}return f}ECPointFp.prototype.getX=pointFpGetX;ECPointFp.prototype.getY=pointFpGetY;ECPointFp.prototype.equals=pointFpEquals;ECPointFp.prototype.isInfinity=pointFpIsInfinity;ECPointFp.prototype.negate=pointFpNegate;ECPointFp.prototype.add=pointFpAdd;ECPointFp.prototype.twice=pointFpTwice;ECPointFp.prototype.multiply=pointFpMultiply;ECPointFp.prototype.multiplyTwo=pointFpMultiplyTwo;function ECCurveFp(e,d,c){this.q=e;this.a=this.fromBigInteger(d);this.b=this.fromBigInteger(c);this.infinity=new ECPointFp(this,null,null)}function curveFpGetQ(){return this.q}function curveFpGetA(){return this.a}function curveFpGetB(){return this.b}function curveFpEquals(a){if(a==this){return true}return(this.q.equals(a.q)&&this.a.equals(a.a)&&this.b.equals(a.b))}function curveFpGetInfinity(){return this.infinity}function curveFpFromBigInteger(a){return new ECFieldElementFp(this.q,a)}function curveFpDecodePointHex(d){switch(parseInt(d.substr(0,2),16)){case 0:return this.infinity;case 2:case 3:return null;case 4:case 6:case 7:var a=(d.length-2)/2;var c=d.substr(2,a);var b=d.substr(a+2,a);return new ECPointFp(this,this.fromBigInteger(new BigInteger(c,16)),this.fromBigInteger(new BigInteger(b,16)));default:return null}}ECCurveFp.prototype.getQ=curveFpGetQ;ECCurveFp.prototype.getA=curveFpGetA;ECCurveFp.prototype.getB=curveFpGetB;ECCurveFp.prototype.equals=curveFpEquals;ECCurveFp.prototype.getInfinity=curveFpGetInfinity;ECCurveFp.prototype.fromBigInteger=curveFpFromBigInteger;ECCurveFp.prototype.decodePointHex=curveFpDecodePointHex;
/*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
 */
ECFieldElementFp.prototype.getByteLength=function(){return Math.floor((this.toBigInteger().bitLength()+7)/8)};ECPointFp.prototype.getEncoded=function(c){var d=function(h,f){var g=h.toByteArrayUnsigned();if(f<g.length){g=g.slice(g.length-f)}else{while(f>g.length){g.unshift(0)}}return g};var a=this.getX().toBigInteger();var e=this.getY().toBigInteger();var b=d(a,32);if(c){if(e.isEven()){b.unshift(2)}else{b.unshift(3)}}else{b.unshift(4);b=b.concat(d(e,32))}return b};ECPointFp.decodeFrom=function(g,c){var f=c[0];var e=c.length-1;var d=c.slice(1,1+e/2);var b=c.slice(1+e/2,1+e);d.unshift(0);b.unshift(0);var a=new BigInteger(d);var h=new BigInteger(b);return new ECPointFp(g,g.fromBigInteger(a),g.fromBigInteger(h))};ECPointFp.decodeFromHex=function(g,c){var f=c.substr(0,2);var e=c.length-2;var d=c.substr(2,e/2);var b=c.substr(2+e/2,e/2);var a=new BigInteger(d,16);var h=new BigInteger(b,16);return new ECPointFp(g,g.fromBigInteger(a),g.fromBigInteger(h))};ECPointFp.prototype.add2D=function(c){if(this.isInfinity()){return c}if(c.isInfinity()){return this}if(this.x.equals(c.x)){if(this.y.equals(c.y)){return this.twice()}return this.curve.getInfinity()}var g=c.x.subtract(this.x);var e=c.y.subtract(this.y);var a=e.divide(g);var d=a.square().subtract(this.x).subtract(c.x);var f=a.multiply(this.x.subtract(d)).subtract(this.y);return new ECPointFp(this.curve,d,f)};ECPointFp.prototype.twice2D=function(){if(this.isInfinity()){return this}if(this.y.toBigInteger().signum()==0){return this.curve.getInfinity()}var b=this.curve.fromBigInteger(BigInteger.valueOf(2));var e=this.curve.fromBigInteger(BigInteger.valueOf(3));var a=this.x.square().multiply(e).add(this.curve.a).divide(this.y.multiply(b));var c=a.square().subtract(this.x.multiply(b));var d=a.multiply(this.x.subtract(c)).subtract(this.y);return new ECPointFp(this.curve,c,d)};ECPointFp.prototype.multiply2D=function(b){if(this.isInfinity()){return this}if(b.signum()==0){return this.curve.getInfinity()}var g=b;var f=g.multiply(new BigInteger("3"));var l=this.negate();var d=this;var c;for(c=f.bitLength()-2;c>0;--c){d=d.twice();var a=f.testBit(c);var j=g.testBit(c);if(a!=j){d=d.add2D(a?this:l)}}return d};ECPointFp.prototype.isOnCurve=function(){var d=this.getX().toBigInteger();var i=this.getY().toBigInteger();var f=this.curve.getA().toBigInteger();var c=this.curve.getB().toBigInteger();var h=this.curve.getQ();var e=i.multiply(i).mod(h);var g=d.multiply(d).multiply(d).add(f.multiply(d)).add(c).mod(h);return e.equals(g)};ECPointFp.prototype.toString=function(){return"("+this.getX().toBigInteger().toString()+","+this.getY().toBigInteger().toString()+")"};ECPointFp.prototype.validate=function(){var c=this.curve.getQ();if(this.isInfinity()){throw new Error("Point is at infinity.")}var a=this.getX().toBigInteger();var b=this.getY().toBigInteger();if(a.compareTo(BigInteger.ONE)<0||a.compareTo(c.subtract(BigInteger.ONE))>0){throw new Error("x coordinate out of bounds")}if(b.compareTo(BigInteger.ONE)<0||b.compareTo(c.subtract(BigInteger.ONE))>0){throw new Error("y coordinate out of bounds")}if(!this.isOnCurve()){throw new Error("Point is not on the curve.")}if(this.multiply(c).isInfinity()){throw new Error("Point is not a scalar multiple of G.")}return true};
/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
 */
var jsonParse=(function(){var e="(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)";var j='(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';var i='(?:"'+j+'*")';var d=new RegExp("(?:false|true|null|[\\{\\}\\[\\]]|"+e+"|"+i+")","g");var k=new RegExp("\\\\(?:([^u])|u(.{4}))","g");var g={'"':'"',"/":"/","\\":"\\",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"};function h(l,m,n){return m?g[m]:String.fromCharCode(parseInt(n,16))}var c=new String("");var a="\\";var f={"{":Object,"[":Array};var b=Object.hasOwnProperty;return function(u,q){var p=u.match(d);var x;var v=p[0];var l=false;if("{"===v){x={}}else{if("["===v){x=[]}else{x=[];l=true}}var t;var r=[x];for(var o=1-l,m=p.length;o<m;++o){v=p[o];var w;switch(v.charCodeAt(0)){default:w=r[0];w[t||w.length]=+(v);t=void 0;break;case 34:v=v.substring(1,v.length-1);if(v.indexOf(a)!==-1){v=v.replace(k,h)}w=r[0];if(!t){if(w instanceof Array){t=w.length}else{t=v||c;break}}w[t]=v;t=void 0;break;case 91:w=r[0];r.unshift(w[t||w.length]=[]);t=void 0;break;case 93:r.shift();break;case 102:w=r[0];w[t||w.length]=false;t=void 0;break;case 110:w=r[0];w[t||w.length]=null;t=void 0;break;case 116:w=r[0];w[t||w.length]=true;t=void 0;break;case 123:w=r[0];r.unshift(w[t||w.length]={});t=void 0;break;case 125:r.shift();break}}if(l){if(r.length!==1){throw new Error()}x=x[0]}else{if(r.length){throw new Error()}}if(q){var s=function(C,B){var D=C[B];if(D&&typeof D==="object"){var n=null;for(var z in D){if(b.call(D,z)&&D!==C){var y=s(D,z);if(y!==void 0){D[z]=y}else{if(!n){n=[]}n.push(z)}}}if(n){for(var A=n.length;--A>=0;){delete D[n[A]]}}}return q.call(C,B,D)};x=s({"":x},"")}return x}})();
/*! asn1-1.0.12.js (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}KJUR.asn1.ASN1Util=new function(){this.integerToByteHex=function(a){var b=a.toString(16);if((b.length%2)==1){b="0"+b}return b};this.bigIntToMinTwosComplementsHex=function(j){var f=j.toString(16);if(f.substr(0,1)!="-"){if(f.length%2==1){f="0"+f}else{if(!f.match(/^[0-7]/)){f="00"+f}}}else{var a=f.substr(1);var e=a.length;if(e%2==1){e+=1}else{if(!f.match(/^[0-7]/)){e+=2}}var g="";for(var d=0;d<e;d++){g+="f"}var c=new BigInteger(g,16);var b=c.xor(j).add(BigInteger.ONE);f=b.toString(16).replace(/^-/,"")}return f};this.getPEMStringFromHex=function(a,b){var c=hextob64(a);var d=c.replace(/(.{64})/g,"$1\r\n");d=d.replace(/\r\n$/,"");return"-----BEGIN "+b+"-----\r\n"+d+"\r\n-----END "+b+"-----\r\n"};this.newObject=function(b){var g=KJUR.asn1;var k=Object.keys(b);if(k.length!=1){throw"key of param shall be only one."}var j=k[0];if(":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":"+j+":")==-1){throw"undefined key: "+j}if(j=="bool"){return new g.DERBoolean(b[j])}if(j=="int"){return new g.DERInteger(b[j])}if(j=="bitstr"){return new g.DERBitString(b[j])}if(j=="octstr"){return new g.DEROctetString(b[j])}if(j=="null"){return new g.DERNull(b[j])}if(j=="oid"){return new g.DERObjectIdentifier(b[j])}if(j=="enum"){return new g.DEREnumerated(b[j])}if(j=="utf8str"){return new g.DERUTF8String(b[j])}if(j=="numstr"){return new g.DERNumericString(b[j])}if(j=="prnstr"){return new g.DERPrintableString(b[j])}if(j=="telstr"){return new g.DERTeletexString(b[j])}if(j=="ia5str"){return new g.DERIA5String(b[j])}if(j=="utctime"){return new g.DERUTCTime(b[j])}if(j=="gentime"){return new g.DERGeneralizedTime(b[j])}if(j=="seq"){var m=b[j];var h=[];for(var e=0;e<m.length;e++){var l=g.ASN1Util.newObject(m[e]);h.push(l)}return new g.DERSequence({array:h})}if(j=="set"){var m=b[j];var h=[];for(var e=0;e<m.length;e++){var l=g.ASN1Util.newObject(m[e]);h.push(l)}return new g.DERSet({array:h})}if(j=="tag"){var c=b[j];if(Object.prototype.toString.call(c)==="[object Array]"&&c.length==3){var d=g.ASN1Util.newObject(c[2]);return new g.DERTaggedObject({tag:c[0],explicit:c[1],obj:d})}else{var f={};if(c.explicit!==undefined){f.explicit=c.explicit}if(c.tag!==undefined){f.tag=c.tag}if(c.obj===undefined){throw"obj shall be specified for 'tag'."}f.obj=g.ASN1Util.newObject(c.obj);return new g.DERTaggedObject(f)}}};this.jsonToASN1HEX=function(b){var a=this.newObject(b);return a.getEncodedHex()}};KJUR.asn1.ASN1Util.oidHexToInt=function(a){var j="";var k=parseInt(a.substr(0,2),16);var d=Math.floor(k/40);var c=k%40;var j=d+"."+c;var e="";for(var f=2;f<a.length;f+=2){var g=parseInt(a.substr(f,2),16);var h=("00000000"+g.toString(2)).slice(-8);e=e+h.substr(1,7);if(h.substr(0,1)=="0"){var b=new BigInteger(e,2);j=j+"."+b.toString(10);e=""}}return j};KJUR.asn1.ASN1Util.oidIntToHex=function(f){var e=function(a){var k=a.toString(16);if(k.length==1){k="0"+k}return k};var d=function(o){var n="";var k=new BigInteger(o,10);var a=k.toString(2);var l=7-a.length%7;if(l==7){l=0}var q="";for(var m=0;m<l;m++){q+="0"}a=q+a;for(var m=0;m<a.length-1;m+=7){var p=a.substr(m,7);if(m!=a.length-7){p="1"+p}n+=e(parseInt(p,2))}return n};if(!f.match(/^[0-9.]+$/)){throw"malformed oid string: "+f}var g="";var b=f.split(".");var j=parseInt(b[0])*40+parseInt(b[1]);g+=e(j);b.splice(0,2);for(var c=0;c<b.length;c++){g+=d(b[c])}return g};KJUR.asn1.ASN1Object=function(){var c=true;var b=null;var d="00";var e="00";var a="";this.getLengthHexFromValue=function(){if(typeof this.hV=="undefined"||this.hV==null){throw"this.hV is null or undefined."}if(this.hV.length%2==1){throw"value hex must be even length: n="+a.length+",v="+this.hV}var i=this.hV.length/2;var h=i.toString(16);if(h.length%2==1){h="0"+h}if(i<128){return h}else{var g=h.length/2;if(g>15){throw"ASN.1 length too long to represent by 8x: n = "+i.toString(16)}var f=128+g;return f.toString(16)+h}};this.getEncodedHex=function(){if(this.hTLV==null||this.isModified){this.hV=this.getFreshValueHex();this.hL=this.getLengthHexFromValue();this.hTLV=this.hT+this.hL+this.hV;this.isModified=false}return this.hTLV};this.getValueHex=function(){this.getEncodedHex();return this.hV};this.getFreshValueHex=function(){return""}};KJUR.asn1.DERAbstractString=function(c){KJUR.asn1.DERAbstractString.superclass.constructor.call(this);var b=null;var a=null;this.getString=function(){return this.s};this.setString=function(d){this.hTLV=null;this.isModified=true;this.s=d;this.hV=stohex(this.s)};this.setStringHex=function(d){this.hTLV=null;this.isModified=true;this.s=null;this.hV=d};this.getFreshValueHex=function(){return this.hV};if(typeof c!="undefined"){if(typeof c=="string"){this.setString(c)}else{if(typeof c.str!="undefined"){this.setString(c.str)}else{if(typeof c.hex!="undefined"){this.setStringHex(c.hex)}}}}};YAHOO.lang.extend(KJUR.asn1.DERAbstractString,KJUR.asn1.ASN1Object);KJUR.asn1.DERAbstractTime=function(c){KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);var b=null;var a=null;this.localDateToUTC=function(f){utc=f.getTime()+(f.getTimezoneOffset()*60000);var e=new Date(utc);return e};this.formatDate=function(m,o,e){var g=this.zeroPadding;var n=this.localDateToUTC(m);var p=String(n.getFullYear());if(o=="utc"){p=p.substr(2,2)}var l=g(String(n.getMonth()+1),2);var q=g(String(n.getDate()),2);var h=g(String(n.getHours()),2);var i=g(String(n.getMinutes()),2);var j=g(String(n.getSeconds()),2);var r=p+l+q+h+i+j;if(e===true){var f=n.getMilliseconds();if(f!=0){var k=g(String(f),3);k=k.replace(/[0]+$/,"");r=r+"."+k}}return r+"Z"};this.zeroPadding=function(e,d){if(e.length>=d){return e}return new Array(d-e.length+1).join("0")+e};this.getString=function(){return this.s};this.setString=function(d){this.hTLV=null;this.isModified=true;this.s=d;this.hV=stohex(d)};this.setByDateValue=function(h,j,e,d,f,g){var i=new Date(Date.UTC(h,j-1,e,d,f,g,0));this.setByDate(i)};this.getFreshValueHex=function(){return this.hV}};YAHOO.lang.extend(KJUR.asn1.DERAbstractTime,KJUR.asn1.ASN1Object);KJUR.asn1.DERAbstractStructured=function(b){KJUR.asn1.DERAbstractString.superclass.constructor.call(this);var a=null;this.setByASN1ObjectArray=function(c){this.hTLV=null;this.isModified=true;this.asn1Array=c};this.appendASN1Object=function(c){this.hTLV=null;this.isModified=true;this.asn1Array.push(c)};this.asn1Array=new Array();if(typeof b!="undefined"){if(typeof b.array!="undefined"){this.asn1Array=b.array}}};YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured,KJUR.asn1.ASN1Object);KJUR.asn1.DERBoolean=function(){KJUR.asn1.DERBoolean.superclass.constructor.call(this);this.hT="01";this.hTLV="0101ff"};YAHOO.lang.extend(KJUR.asn1.DERBoolean,KJUR.asn1.ASN1Object);KJUR.asn1.DERInteger=function(a){KJUR.asn1.DERInteger.superclass.constructor.call(this);this.hT="02";this.setByBigInteger=function(b){this.hTLV=null;this.isModified=true;this.hV=KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b)};this.setByInteger=function(c){var b=new BigInteger(String(c),10);this.setByBigInteger(b)};this.setValueHex=function(b){this.hV=b};this.getFreshValueHex=function(){return this.hV};if(typeof a!="undefined"){if(typeof a.bigint!="undefined"){this.setByBigInteger(a.bigint)}else{if(typeof a["int"]!="undefined"){this.setByInteger(a["int"])}else{if(typeof a=="number"){this.setByInteger(a)}else{if(typeof a.hex!="undefined"){this.setValueHex(a.hex)}}}}}};YAHOO.lang.extend(KJUR.asn1.DERInteger,KJUR.asn1.ASN1Object);KJUR.asn1.DERBitString=function(b){if(b!==undefined&&typeof b.obj!=="undefined"){var a=KJUR.asn1.ASN1Util.newObject(b.obj);b.hex="00"+a.getEncodedHex()}KJUR.asn1.DERBitString.superclass.constructor.call(this);this.hT="03";this.setHexValueIncludingUnusedBits=function(c){this.hTLV=null;this.isModified=true;this.hV=c};this.setUnusedBitsAndHexValue=function(c,e){if(c<0||7<c){throw"unused bits shall be from 0 to 7: u = "+c}var d="0"+c;this.hTLV=null;this.isModified=true;this.hV=d+e};this.setByBinaryString=function(e){e=e.replace(/0+$/,"");var f=8-e.length%8;if(f==8){f=0}for(var g=0;g<=f;g++){e+="0"}var j="";for(var g=0;g<e.length-1;g+=8){var d=e.substr(g,8);var c=parseInt(d,2).toString(16);if(c.length==1){c="0"+c}j+=c}this.hTLV=null;this.isModified=true;this.hV="0"+f+j};this.setByBooleanArray=function(e){var d="";for(var c=0;c<e.length;c++){if(e[c]==true){d+="1"}else{d+="0"}}this.setByBinaryString(d)};this.newFalseArray=function(e){var c=new Array(e);for(var d=0;d<e;d++){c[d]=false}return c};this.getFreshValueHex=function(){return this.hV};if(typeof b!="undefined"){if(typeof b=="string"&&b.toLowerCase().match(/^[0-9a-f]+$/)){this.setHexValueIncludingUnusedBits(b)}else{if(typeof b.hex!="undefined"){this.setHexValueIncludingUnusedBits(b.hex)}else{if(typeof b.bin!="undefined"){this.setByBinaryString(b.bin)}else{if(typeof b.array!="undefined"){this.setByBooleanArray(b.array)}}}}}};YAHOO.lang.extend(KJUR.asn1.DERBitString,KJUR.asn1.ASN1Object);KJUR.asn1.DEROctetString=function(b){if(b!==undefined&&typeof b.obj!=="undefined"){var a=KJUR.asn1.ASN1Util.newObject(b.obj);b.hex=a.getEncodedHex()}KJUR.asn1.DEROctetString.superclass.constructor.call(this,b);this.hT="04"};YAHOO.lang.extend(KJUR.asn1.DEROctetString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERNull=function(){KJUR.asn1.DERNull.superclass.constructor.call(this);this.hT="05";this.hTLV="0500"};YAHOO.lang.extend(KJUR.asn1.DERNull,KJUR.asn1.ASN1Object);KJUR.asn1.DERObjectIdentifier=function(c){var b=function(d){var e=d.toString(16);if(e.length==1){e="0"+e}return e};var a=function(k){var j="";var e=new BigInteger(k,10);var d=e.toString(2);var f=7-d.length%7;if(f==7){f=0}var m="";for(var g=0;g<f;g++){m+="0"}d=m+d;for(var g=0;g<d.length-1;g+=7){var l=d.substr(g,7);if(g!=d.length-7){l="1"+l}j+=b(parseInt(l,2))}return j};KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);this.hT="06";this.setValueHex=function(d){this.hTLV=null;this.isModified=true;this.s=null;this.hV=d};this.setValueOidString=function(f){if(!f.match(/^[0-9.]+$/)){throw"malformed oid string: "+f}var g="";var d=f.split(".");var j=parseInt(d[0])*40+parseInt(d[1]);g+=b(j);d.splice(0,2);for(var e=0;e<d.length;e++){g+=a(d[e])}this.hTLV=null;this.isModified=true;this.s=null;this.hV=g};this.setValueName=function(e){var d=KJUR.asn1.x509.OID.name2oid(e);if(d!==""){this.setValueOidString(d)}else{throw"DERObjectIdentifier oidName undefined: "+e}};this.getFreshValueHex=function(){return this.hV};if(c!==undefined){if(typeof c==="string"){if(c.match(/^[0-2].[0-9.]+$/)){this.setValueOidString(c)}else{this.setValueName(c)}}else{if(c.oid!==undefined){this.setValueOidString(c.oid)}else{if(c.hex!==undefined){this.setValueHex(c.hex)}else{if(c.name!==undefined){this.setValueName(c.name)}}}}}};YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier,KJUR.asn1.ASN1Object);KJUR.asn1.DEREnumerated=function(a){KJUR.asn1.DEREnumerated.superclass.constructor.call(this);this.hT="0a";this.setByBigInteger=function(b){this.hTLV=null;this.isModified=true;this.hV=KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b)};this.setByInteger=function(c){var b=new BigInteger(String(c),10);this.setByBigInteger(b)};this.setValueHex=function(b){this.hV=b};this.getFreshValueHex=function(){return this.hV};if(typeof a!="undefined"){if(typeof a["int"]!="undefined"){this.setByInteger(a["int"])}else{if(typeof a=="number"){this.setByInteger(a)}else{if(typeof a.hex!="undefined"){this.setValueHex(a.hex)}}}}};YAHOO.lang.extend(KJUR.asn1.DEREnumerated,KJUR.asn1.ASN1Object);KJUR.asn1.DERUTF8String=function(a){KJUR.asn1.DERUTF8String.superclass.constructor.call(this,a);this.hT="0c"};YAHOO.lang.extend(KJUR.asn1.DERUTF8String,KJUR.asn1.DERAbstractString);KJUR.asn1.DERNumericString=function(a){KJUR.asn1.DERNumericString.superclass.constructor.call(this,a);this.hT="12"};YAHOO.lang.extend(KJUR.asn1.DERNumericString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERPrintableString=function(a){KJUR.asn1.DERPrintableString.superclass.constructor.call(this,a);this.hT="13"};YAHOO.lang.extend(KJUR.asn1.DERPrintableString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERTeletexString=function(a){KJUR.asn1.DERTeletexString.superclass.constructor.call(this,a);this.hT="14"};YAHOO.lang.extend(KJUR.asn1.DERTeletexString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERIA5String=function(a){KJUR.asn1.DERIA5String.superclass.constructor.call(this,a);this.hT="16"};YAHOO.lang.extend(KJUR.asn1.DERIA5String,KJUR.asn1.DERAbstractString);KJUR.asn1.DERUTCTime=function(a){KJUR.asn1.DERUTCTime.superclass.constructor.call(this,a);this.hT="17";this.setByDate=function(b){this.hTLV=null;this.isModified=true;this.date=b;this.s=this.formatDate(this.date,"utc");this.hV=stohex(this.s)};this.getFreshValueHex=function(){if(typeof this.date=="undefined"&&typeof this.s=="undefined"){this.date=new Date();this.s=this.formatDate(this.date,"utc");this.hV=stohex(this.s)}return this.hV};if(a!==undefined){if(a.str!==undefined){this.setString(a.str)}else{if(typeof a=="string"&&a.match(/^[0-9]{12}Z$/)){this.setString(a)}else{if(a.hex!==undefined){this.setStringHex(a.hex)}else{if(a.date!==undefined){this.setByDate(a.date)}}}}}};YAHOO.lang.extend(KJUR.asn1.DERUTCTime,KJUR.asn1.DERAbstractTime);KJUR.asn1.DERGeneralizedTime=function(a){KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this,a);this.hT="18";this.withMillis=false;this.setByDate=function(b){this.hTLV=null;this.isModified=true;this.date=b;this.s=this.formatDate(this.date,"gen",this.withMillis);this.hV=stohex(this.s)};this.getFreshValueHex=function(){if(this.date===undefined&&this.s===undefined){this.date=new Date();this.s=this.formatDate(this.date,"gen",this.withMillis);this.hV=stohex(this.s)}return this.hV};if(a!==undefined){if(a.str!==undefined){this.setString(a.str)}else{if(typeof a=="string"&&a.match(/^[0-9]{14}Z$/)){this.setString(a)}else{if(a.hex!==undefined){this.setStringHex(a.hex)}else{if(a.date!==undefined){this.setByDate(a.date)}}}}if(a.millis===true){this.withMillis=true}}};YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime,KJUR.asn1.DERAbstractTime);KJUR.asn1.DERSequence=function(a){KJUR.asn1.DERSequence.superclass.constructor.call(this,a);this.hT="30";this.getFreshValueHex=function(){var c="";for(var b=0;b<this.asn1Array.length;b++){var d=this.asn1Array[b];c+=d.getEncodedHex()}this.hV=c;return this.hV}};YAHOO.lang.extend(KJUR.asn1.DERSequence,KJUR.asn1.DERAbstractStructured);KJUR.asn1.DERSet=function(a){KJUR.asn1.DERSet.superclass.constructor.call(this,a);this.hT="31";this.sortFlag=true;this.getFreshValueHex=function(){var b=new Array();for(var c=0;c<this.asn1Array.length;c++){var d=this.asn1Array[c];b.push(d.getEncodedHex())}if(this.sortFlag==true){b.sort()}this.hV=b.join("");return this.hV};if(typeof a!="undefined"){if(typeof a.sortflag!="undefined"&&a.sortflag==false){this.sortFlag=false}}};YAHOO.lang.extend(KJUR.asn1.DERSet,KJUR.asn1.DERAbstractStructured);KJUR.asn1.DERTaggedObject=function(a){KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);this.hT="a0";this.hV="";this.isExplicit=true;this.asn1Object=null;this.setASN1Object=function(b,c,d){this.hT=c;this.isExplicit=b;this.asn1Object=d;if(this.isExplicit){this.hV=this.asn1Object.getEncodedHex();this.hTLV=null;this.isModified=true}else{this.hV=null;this.hTLV=d.getEncodedHex();this.hTLV=this.hTLV.replace(/^../,c);this.isModified=false}};this.getFreshValueHex=function(){return this.hV};if(typeof a!="undefined"){if(typeof a.tag!="undefined"){this.hT=a.tag}if(typeof a.explicit!="undefined"){this.isExplicit=a.explicit}if(typeof a.obj!="undefined"){this.asn1Object=a.obj;this.setASN1Object(this.isExplicit,this.hT,this.asn1Object)}}};YAHOO.lang.extend(KJUR.asn1.DERTaggedObject,KJUR.asn1.ASN1Object);
/*! asn1hex-1.1.7.js (c) 2012-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
var ASN1HEX=new function(){};ASN1HEX.getByteLengthOfL_AtObj=function(b,c){if(b.substring(c+2,c+3)!="8"){return 1}var a=parseInt(b.substring(c+3,c+4));if(a==0){return -1}if(0<a&&a<10){return a+1}return -2};ASN1HEX.getHexOfL_AtObj=function(b,c){var a=ASN1HEX.getByteLengthOfL_AtObj(b,c);if(a<1){return""}return b.substring(c+2,c+2+a*2)};ASN1HEX.getIntOfL_AtObj=function(c,d){var b=ASN1HEX.getHexOfL_AtObj(c,d);if(b==""){return -1}var a;if(parseInt(b.substring(0,1))<8){a=new BigInteger(b,16)}else{a=new BigInteger(b.substring(2),16)}return a.intValue()};ASN1HEX.getStartPosOfV_AtObj=function(b,c){var a=ASN1HEX.getByteLengthOfL_AtObj(b,c);if(a<0){return a}return c+(a+1)*2};ASN1HEX.getHexOfV_AtObj=function(c,d){var b=ASN1HEX.getStartPosOfV_AtObj(c,d);var a=ASN1HEX.getIntOfL_AtObj(c,d);return c.substring(b,b+a*2)};ASN1HEX.getHexOfTLV_AtObj=function(c,e){var b=c.substr(e,2);var d=ASN1HEX.getHexOfL_AtObj(c,e);var a=ASN1HEX.getHexOfV_AtObj(c,e);return b+d+a};ASN1HEX.getPosOfNextSibling_AtObj=function(c,d){var b=ASN1HEX.getStartPosOfV_AtObj(c,d);var a=ASN1HEX.getIntOfL_AtObj(c,d);return b+a*2};ASN1HEX.getPosArrayOfChildren_AtObj=function(f,j){var c=new Array();var i=ASN1HEX.getStartPosOfV_AtObj(f,j);if(f.substr(j,2)=="03"){c.push(i+2)}else{c.push(i)}var b=ASN1HEX.getIntOfL_AtObj(f,j);var g=i;var d=0;while(1){var e=ASN1HEX.getPosOfNextSibling_AtObj(f,g);if(e==null||(e-i>=(b*2))){break}if(d>=200){break}c.push(e);g=e;d++}return c};ASN1HEX.getNthChildIndex_AtObj=function(d,b,e){var c=ASN1HEX.getPosArrayOfChildren_AtObj(d,b);return c[e]};ASN1HEX.getDecendantIndexByNthList=function(e,d,c){if(c.length==0){return d}var f=c.shift();var b=ASN1HEX.getPosArrayOfChildren_AtObj(e,d);return ASN1HEX.getDecendantIndexByNthList(e,b[f],c)};ASN1HEX.getDecendantHexTLVByNthList=function(d,c,b){var a=ASN1HEX.getDecendantIndexByNthList(d,c,b);return ASN1HEX.getHexOfTLV_AtObj(d,a)};ASN1HEX.getDecendantHexVByNthList=function(d,c,b){var a=ASN1HEX.getDecendantIndexByNthList(d,c,b);return ASN1HEX.getHexOfV_AtObj(d,a)};ASN1HEX.getVbyList=function(d,c,b,e){var a=ASN1HEX.getDecendantIndexByNthList(d,c,b);if(a===undefined){throw"can't find nthList object"}if(e!==undefined){if(d.substr(a,2)!=e){throw"checking tag doesn't match: "+d.substr(a,2)+"!="+e}}return ASN1HEX.getHexOfV_AtObj(d,a)};ASN1HEX.hextooidstr=function(e){var h=function(b,a){if(b.length>=a){return b}return new Array(a-b.length+1).join("0")+b};var l=[];var o=e.substr(0,2);var f=parseInt(o,16);l[0]=new String(Math.floor(f/40));l[1]=new String(f%40);var m=e.substr(2);var k=[];for(var g=0;g<m.length/2;g++){k.push(parseInt(m.substr(g*2,2),16))}var j=[];var d="";for(var g=0;g<k.length;g++){if(k[g]&128){d=d+h((k[g]&127).toString(2),7)}else{d=d+h((k[g]&127).toString(2),7);j.push(new String(parseInt(d,2)));d=""}}var n=l.join(".");if(j.length>0){n=n+"."+j.join(".")}return n};ASN1HEX.dump=function(e,c,k,g){var o=function(w,i){if(w.length<=i*2){return w}else{var v=w.substr(0,i)+"..(total "+w.length/2+"bytes).."+w.substr(w.length-i,i);return v}};if(c===undefined){c={ommit_long_octet:32}}if(k===undefined){k=0}if(g===undefined){g=""}var r=c.ommit_long_octet;if(e.substr(k,2)=="01"){var h=ASN1HEX.getHexOfV_AtObj(e,k);if(h=="00"){return g+"BOOLEAN FALSE\n"}else{return g+"BOOLEAN TRUE\n"}}if(e.substr(k,2)=="02"){var h=ASN1HEX.getHexOfV_AtObj(e,k);return g+"INTEGER "+o(h,r)+"\n"}if(e.substr(k,2)=="03"){var h=ASN1HEX.getHexOfV_AtObj(e,k);return g+"BITSTRING "+o(h,r)+"\n"}if(e.substr(k,2)=="04"){var h=ASN1HEX.getHexOfV_AtObj(e,k);if(ASN1HEX.isASN1HEX(h)){var j=g+"OCTETSTRING, encapsulates\n";j=j+ASN1HEX.dump(h,c,0,g+"  ");return j}else{return g+"OCTETSTRING "+o(h,r)+"\n"}}if(e.substr(k,2)=="05"){return g+"NULL\n"}if(e.substr(k,2)=="06"){var l=ASN1HEX.getHexOfV_AtObj(e,k);var a=KJUR.asn1.ASN1Util.oidHexToInt(l);var n=KJUR.asn1.x509.OID.oid2name(a);var b=a.replace(/\./g," ");if(n!=""){return g+"ObjectIdentifier "+n+" ("+b+")\n"}else{return g+"ObjectIdentifier ("+b+")\n"}}if(e.substr(k,2)=="0c"){return g+"UTF8String '"+hextoutf8(ASN1HEX.getHexOfV_AtObj(e,k))+"'\n"}if(e.substr(k,2)=="13"){return g+"PrintableString '"+hextoutf8(ASN1HEX.getHexOfV_AtObj(e,k))+"'\n"}if(e.substr(k,2)=="14"){return g+"TeletexString '"+hextoutf8(ASN1HEX.getHexOfV_AtObj(e,k))+"'\n"}if(e.substr(k,2)=="16"){return g+"IA5String '"+hextoutf8(ASN1HEX.getHexOfV_AtObj(e,k))+"'\n"}if(e.substr(k,2)=="17"){return g+"UTCTime "+hextoutf8(ASN1HEX.getHexOfV_AtObj(e,k))+"\n"}if(e.substr(k,2)=="18"){return g+"GeneralizedTime "+hextoutf8(ASN1HEX.getHexOfV_AtObj(e,k))+"\n"}if(e.substr(k,2)=="30"){if(e.substr(k,4)=="3000"){return g+"SEQUENCE {}\n"}var j=g+"SEQUENCE\n";var d=ASN1HEX.getPosArrayOfChildren_AtObj(e,k);var f=c;if((d.length==2||d.length==3)&&e.substr(d[0],2)=="06"&&e.substr(d[d.length-1],2)=="04"){var t=ASN1HEX.getHexOfV_AtObj(e,d[0]);var a=KJUR.asn1.ASN1Util.oidHexToInt(t);var n=KJUR.asn1.x509.OID.oid2name(a);var p=JSON.parse(JSON.stringify(c));p.x509ExtName=n;f=p}for(var q=0;q<d.length;q++){j=j+ASN1HEX.dump(e,f,d[q],g+"  ")}return j}if(e.substr(k,2)=="31"){var j=g+"SET\n";var d=ASN1HEX.getPosArrayOfChildren_AtObj(e,k);for(var q=0;q<d.length;q++){j=j+ASN1HEX.dump(e,c,d[q],g+"  ")}return j}var u=parseInt(e.substr(k,2),16);if((u&128)!=0){var m=u&31;if((u&32)!=0){var j=g+"["+m+"]\n";var d=ASN1HEX.getPosArrayOfChildren_AtObj(e,k);for(var q=0;q<d.length;q++){j=j+ASN1HEX.dump(e,c,d[q],g+"  ")}return j}else{var h=ASN1HEX.getHexOfV_AtObj(e,k);if(h.substr(0,8)=="68747470"){h=hextoutf8(h)}if(c.x509ExtName==="subjectAltName"&&m==2){h=hextoutf8(h)}var j=g+"["+m+"] "+h+"\n";return j}}return g+"UNKNOWN("+e.substr(k,2)+") "+ASN1HEX.getHexOfV_AtObj(e,k)+"\n"};ASN1HEX.isASN1HEX=function(d){if(d.length%2==1){return false}var c=ASN1HEX.getIntOfL_AtObj(d,0);var b=d.substr(0,2);var e=ASN1HEX.getHexOfL_AtObj(d,0);var a=d.length-b.length-e.length;if(a==c*2){return true}return false};
/*! asn1x509-1.0.19.js (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}if(typeof KJUR.asn1.x509=="undefined"||!KJUR.asn1.x509){KJUR.asn1.x509={}}KJUR.asn1.x509.Certificate=function(g){KJUR.asn1.x509.Certificate.superclass.constructor.call(this);var b=null;var d=null;var f=null;var c=null;var a=null;var e=null;this.setRsaPrvKeyByPEMandPass=function(i,k){var h=PKCS5PKEY.getDecryptedKeyHex(i,k);var j=new RSAKey();j.readPrivateKeyFromASN1HexString(h);this.prvKey=j};this.sign=function(){this.asn1SignatureAlg=this.asn1TBSCert.asn1SignatureAlg;sig=new KJUR.crypto.Signature({alg:"SHA1withRSA"});sig.init(this.prvKey);sig.updateHex(this.asn1TBSCert.getEncodedHex());this.hexSig=sig.sign();this.asn1Sig=new KJUR.asn1.DERBitString({hex:"00"+this.hexSig});var h=new KJUR.asn1.DERSequence({array:[this.asn1TBSCert,this.asn1SignatureAlg,this.asn1Sig]});this.hTLV=h.getEncodedHex();this.isModified=false};this.setSignatureHex=function(h){this.asn1SignatureAlg=this.asn1TBSCert.asn1SignatureAlg;this.hexSig=h;this.asn1Sig=new KJUR.asn1.DERBitString({hex:"00"+this.hexSig});var i=new KJUR.asn1.DERSequence({array:[this.asn1TBSCert,this.asn1SignatureAlg,this.asn1Sig]});this.hTLV=i.getEncodedHex();this.isModified=false};this.getEncodedHex=function(){if(this.isModified==false&&this.hTLV!=null){return this.hTLV}throw"not signed yet"};this.getPEMString=function(){var j=this.getEncodedHex();var h=CryptoJS.enc.Hex.parse(j);var i=CryptoJS.enc.Base64.stringify(h);var k=i.replace(/(.{64})/g,"$1\r\n");return"-----BEGIN CERTIFICATE-----\r\n"+k+"\r\n-----END CERTIFICATE-----\r\n"};if(typeof g!="undefined"){if(typeof g.tbscertobj!="undefined"){this.asn1TBSCert=g.tbscertobj}if(typeof g.prvkeyobj!="undefined"){this.prvKey=g.prvkeyobj}else{if(typeof g.rsaprvkey!="undefined"){this.prvKey=g.rsaprvkey}else{if((typeof g.rsaprvpem!="undefined")&&(typeof g.rsaprvpas!="undefined")){this.setRsaPrvKeyByPEMandPass(g.rsaprvpem,g.rsaprvpas)}}}}};YAHOO.lang.extend(KJUR.asn1.x509.Certificate,KJUR.asn1.ASN1Object);KJUR.asn1.x509.TBSCertificate=function(a){KJUR.asn1.x509.TBSCertificate.superclass.constructor.call(this);this._initialize=function(){this.asn1Array=new Array();this.asn1Version=new KJUR.asn1.DERTaggedObject({obj:new KJUR.asn1.DERInteger({"int":2})});this.asn1SerialNumber=null;this.asn1SignatureAlg=null;this.asn1Issuer=null;this.asn1NotBefore=null;this.asn1NotAfter=null;this.asn1Subject=null;this.asn1SubjPKey=null;this.extensionsArray=new Array()};this.setSerialNumberByParam=function(b){this.asn1SerialNumber=new KJUR.asn1.DERInteger(b)};this.setSignatureAlgByParam=function(b){this.asn1SignatureAlg=new KJUR.asn1.x509.AlgorithmIdentifier(b)};this.setIssuerByParam=function(b){this.asn1Issuer=new KJUR.asn1.x509.X500Name(b)};this.setNotBeforeByParam=function(b){this.asn1NotBefore=new KJUR.asn1.x509.Time(b)};this.setNotAfterByParam=function(b){this.asn1NotAfter=new KJUR.asn1.x509.Time(b)};this.setSubjectByParam=function(b){this.asn1Subject=new KJUR.asn1.x509.X500Name(b)};this.setSubjectPublicKeyByParam=function(b){this.asn1SubjPKey=new KJUR.asn1.x509.SubjectPublicKeyInfo(b)};this.setSubjectPublicKeyByGetKey=function(c){var b=KEYUTIL.getKey(c);this.asn1SubjPKey=new KJUR.asn1.x509.SubjectPublicKeyInfo(b)};this.appendExtension=function(b){this.extensionsArray.push(b)};this.appendExtensionByName=function(c,b){KJUR.asn1.x509.Extension.appendByNameToArray(c,b,this.extensionsArray)};this.getEncodedHex=function(){if(this.asn1NotBefore==null||this.asn1NotAfter==null){throw"notBefore and/or notAfter not set"}var c=new KJUR.asn1.DERSequence({array:[this.asn1NotBefore,this.asn1NotAfter]});this.asn1Array=new Array();this.asn1Array.push(this.asn1Version);this.asn1Array.push(this.asn1SerialNumber);this.asn1Array.push(this.asn1SignatureAlg);this.asn1Array.push(this.asn1Issuer);this.asn1Array.push(c);this.asn1Array.push(this.asn1Subject);this.asn1Array.push(this.asn1SubjPKey);if(this.extensionsArray.length>0){var d=new KJUR.asn1.DERSequence({array:this.extensionsArray});var b=new KJUR.asn1.DERTaggedObject({explicit:true,tag:"a3",obj:d});this.asn1Array.push(b)}var e=new KJUR.asn1.DERSequence({array:this.asn1Array});this.hTLV=e.getEncodedHex();this.isModified=false;return this.hTLV};this._initialize()};YAHOO.lang.extend(KJUR.asn1.x509.TBSCertificate,KJUR.asn1.ASN1Object);KJUR.asn1.x509.Extension=function(b){KJUR.asn1.x509.Extension.superclass.constructor.call(this);var a=null;this.getEncodedHex=function(){var f=new KJUR.asn1.DERObjectIdentifier({oid:this.oid});var e=new KJUR.asn1.DEROctetString({hex:this.getExtnValueHex()});var d=new Array();d.push(f);if(this.critical){d.push(new KJUR.asn1.DERBoolean())}d.push(e);var c=new KJUR.asn1.DERSequence({array:d});return c.getEncodedHex()};this.critical=false;if(typeof b!="undefined"){if(typeof b.critical!="undefined"){this.critical=b.critical}}};YAHOO.lang.extend(KJUR.asn1.x509.Extension,KJUR.asn1.ASN1Object);KJUR.asn1.x509.Extension.appendByNameToArray=function(e,c,b){if(e.toLowerCase()=="basicconstraints"){var d=new KJUR.asn1.x509.BasicConstraints(c);b.push(d)}else{if(e.toLowerCase()=="keyusage"){var d=new KJUR.asn1.x509.KeyUsage(c);b.push(d)}else{if(e.toLowerCase()=="crldistributionpoints"){var d=new KJUR.asn1.x509.CRLDistributionPoints(c);b.push(d)}else{if(e.toLowerCase()=="extkeyusage"){var d=new KJUR.asn1.x509.ExtKeyUsage(c);b.push(d)}else{if(e.toLowerCase()=="authoritykeyidentifier"){var d=new KJUR.asn1.x509.AuthorityKeyIdentifier(c);b.push(d)}else{if(e.toLowerCase()=="authorityinfoaccess"){var d=new KJUR.asn1.x509.AuthorityInfoAccess(c);b.push(d)}else{if(e.toLowerCase()=="subjectaltname"){var d=new KJUR.asn1.x509.SubjectAltName(c);b.push(d)}else{if(e.toLowerCase()=="issueraltname"){var d=new KJUR.asn1.x509.IssuerAltName(c);b.push(d)}else{throw"unsupported extension name: "+e}}}}}}}}};KJUR.asn1.x509.KeyUsage=function(a){KJUR.asn1.x509.KeyUsage.superclass.constructor.call(this,a);this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.oid="2.5.29.15";if(typeof a!="undefined"){if(typeof a.bin!="undefined"){this.asn1ExtnValue=new KJUR.asn1.DERBitString(a)}}};YAHOO.lang.extend(KJUR.asn1.x509.KeyUsage,KJUR.asn1.x509.Extension);KJUR.asn1.x509.BasicConstraints=function(c){KJUR.asn1.x509.BasicConstraints.superclass.constructor.call(this,c);var a=false;var b=-1;this.getExtnValueHex=function(){var e=new Array();if(this.cA){e.push(new KJUR.asn1.DERBoolean())}if(this.pathLen>-1){e.push(new KJUR.asn1.DERInteger({"int":this.pathLen}))}var d=new KJUR.asn1.DERSequence({array:e});this.asn1ExtnValue=d;return this.asn1ExtnValue.getEncodedHex()};this.oid="2.5.29.19";this.cA=false;this.pathLen=-1;if(typeof c!="undefined"){if(typeof c.cA!="undefined"){this.cA=c.cA}if(typeof c.pathLen!="undefined"){this.pathLen=c.pathLen}}};YAHOO.lang.extend(KJUR.asn1.x509.BasicConstraints,KJUR.asn1.x509.Extension);KJUR.asn1.x509.CRLDistributionPoints=function(a){KJUR.asn1.x509.CRLDistributionPoints.superclass.constructor.call(this,a);this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.setByDPArray=function(b){this.asn1ExtnValue=new KJUR.asn1.DERSequence({array:b})};this.setByOneURI=function(e){var b=new KJUR.asn1.x509.GeneralNames([{uri:e}]);var d=new KJUR.asn1.x509.DistributionPointName(b);var c=new KJUR.asn1.x509.DistributionPoint({dpobj:d});this.setByDPArray([c])};this.oid="2.5.29.31";if(typeof a!="undefined"){if(typeof a.array!="undefined"){this.setByDPArray(a.array)}else{if(typeof a.uri!="undefined"){this.setByOneURI(a.uri)}}}};YAHOO.lang.extend(KJUR.asn1.x509.CRLDistributionPoints,KJUR.asn1.x509.Extension);KJUR.asn1.x509.ExtKeyUsage=function(a){KJUR.asn1.x509.ExtKeyUsage.superclass.constructor.call(this,a);this.setPurposeArray=function(b){this.asn1ExtnValue=new KJUR.asn1.DERSequence();for(var c=0;c<b.length;c++){var d=new KJUR.asn1.DERObjectIdentifier(b[c]);this.asn1ExtnValue.appendASN1Object(d)}};this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.oid="2.5.29.37";if(typeof a!="undefined"){if(typeof a.array!="undefined"){this.setPurposeArray(a.array)}}};YAHOO.lang.extend(KJUR.asn1.x509.ExtKeyUsage,KJUR.asn1.x509.Extension);KJUR.asn1.x509.AuthorityKeyIdentifier=function(a){KJUR.asn1.x509.AuthorityKeyIdentifier.superclass.constructor.call(this,a);this.asn1KID=null;this.asn1CertIssuer=null;this.asn1CertSN=null;this.getExtnValueHex=function(){var c=new Array();if(this.asn1KID){c.push(new KJUR.asn1.DERTaggedObject({explicit:false,tag:"80",obj:this.asn1KID}))}if(this.asn1CertIssuer){c.push(new KJUR.asn1.DERTaggedObject({explicit:false,tag:"a1",obj:this.asn1CertIssuer}))}if(this.asn1CertSN){c.push(new KJUR.asn1.DERTaggedObject({explicit:false,tag:"82",obj:this.asn1CertSN}))}var b=new KJUR.asn1.DERSequence({array:c});this.asn1ExtnValue=b;return this.asn1ExtnValue.getEncodedHex()};this.setKIDByParam=function(b){this.asn1KID=new KJUR.asn1.DEROctetString(b)};this.setCertIssuerByParam=function(b){this.asn1CertIssuer=new KJUR.asn1.x509.X500Name(b)};this.setCertSNByParam=function(b){this.asn1CertSN=new KJUR.asn1.DERInteger(b)};this.oid="2.5.29.35";if(typeof a!="undefined"){if(typeof a.kid!="undefined"){this.setKIDByParam(a.kid)}if(typeof a.issuer!="undefined"){this.setCertIssuerByParam(a.issuer)}if(typeof a.sn!="undefined"){this.setCertSNByParam(a.sn)}}};YAHOO.lang.extend(KJUR.asn1.x509.AuthorityKeyIdentifier,KJUR.asn1.x509.Extension);KJUR.asn1.x509.AuthorityInfoAccess=function(a){KJUR.asn1.x509.AuthorityInfoAccess.superclass.constructor.call(this,a);this.setAccessDescriptionArray=function(c){var g=new Array();for(var b=0;b<c.length;b++){var e=new KJUR.asn1.DERObjectIdentifier(c[b].accessMethod);var d=new KJUR.asn1.x509.GeneralName(c[b].accessLocation);var f=new KJUR.asn1.DERSequence({array:[e,d]});g.push(f)}this.asn1ExtnValue=new KJUR.asn1.DERSequence({array:g})};this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.oid="1.3.6.1.5.5.7.1.1";if(typeof a!="undefined"){if(typeof a.array!="undefined"){this.setAccessDescriptionArray(a.array)}}};YAHOO.lang.extend(KJUR.asn1.x509.AuthorityInfoAccess,KJUR.asn1.x509.Extension);KJUR.asn1.x509.SubjectAltName=function(a){KJUR.asn1.x509.SubjectAltName.superclass.constructor.call(this,a);this.setNameArray=function(b){this.asn1ExtnValue=new KJUR.asn1.x509.GeneralNames(b)};this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.oid="2.5.29.17";if(a!==undefined){if(a.array!==undefined){this.setNameArray(a.array)}}};YAHOO.lang.extend(KJUR.asn1.x509.SubjectAltName,KJUR.asn1.x509.Extension);KJUR.asn1.x509.IssuerAltName=function(a){KJUR.asn1.x509.IssuerAltName.superclass.constructor.call(this,a);this.setNameArray=function(b){this.asn1ExtnValue=new KJUR.asn1.x509.GeneralNames(b)};this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.oid="2.5.29.18";if(a!==undefined){if(a.array!==undefined){this.setNameArray(a.array)}}};YAHOO.lang.extend(KJUR.asn1.x509.IssuerAltName,KJUR.asn1.x509.Extension);KJUR.asn1.x509.CRL=function(f){KJUR.asn1.x509.CRL.superclass.constructor.call(this);var a=null;var c=null;var e=null;var b=null;var d=null;this.setRsaPrvKeyByPEMandPass=function(h,j){var g=PKCS5PKEY.getDecryptedKeyHex(h,j);var i=new RSAKey();i.readPrivateKeyFromASN1HexString(g);this.rsaPrvKey=i};this.sign=function(){this.asn1SignatureAlg=this.asn1TBSCertList.asn1SignatureAlg;sig=new KJUR.crypto.Signature({alg:"SHA1withRSA",prov:"cryptojs/jsrsa"});sig.initSign(this.rsaPrvKey);sig.updateHex(this.asn1TBSCertList.getEncodedHex());this.hexSig=sig.sign();this.asn1Sig=new KJUR.asn1.DERBitString({hex:"00"+this.hexSig});var g=new KJUR.asn1.DERSequence({array:[this.asn1TBSCertList,this.asn1SignatureAlg,this.asn1Sig]});this.hTLV=g.getEncodedHex();this.isModified=false};this.getEncodedHex=function(){if(this.isModified==false&&this.hTLV!=null){return this.hTLV}throw"not signed yet"};this.getPEMString=function(){var i=this.getEncodedHex();var g=CryptoJS.enc.Hex.parse(i);var h=CryptoJS.enc.Base64.stringify(g);var j=h.replace(/(.{64})/g,"$1\r\n");return"-----BEGIN X509 CRL-----\r\n"+j+"\r\n-----END X509 CRL-----\r\n"};if(typeof f!="undefined"){if(typeof f.tbsobj!="undefined"){this.asn1TBSCertList=f.tbsobj}if(typeof f.rsaprvkey!="undefined"){this.rsaPrvKey=f.rsaprvkey}if((typeof f.rsaprvpem!="undefined")&&(typeof f.rsaprvpas!="undefined")){this.setRsaPrvKeyByPEMandPass(f.rsaprvpem,f.rsaprvpas)}}};YAHOO.lang.extend(KJUR.asn1.x509.CRL,KJUR.asn1.ASN1Object);KJUR.asn1.x509.TBSCertList=function(b){KJUR.asn1.x509.TBSCertList.superclass.constructor.call(this);var a=null;this.setSignatureAlgByParam=function(c){this.asn1SignatureAlg=new KJUR.asn1.x509.AlgorithmIdentifier(c)};this.setIssuerByParam=function(c){this.asn1Issuer=new KJUR.asn1.x509.X500Name(c)};this.setThisUpdateByParam=function(c){this.asn1ThisUpdate=new KJUR.asn1.x509.Time(c)};this.setNextUpdateByParam=function(c){this.asn1NextUpdate=new KJUR.asn1.x509.Time(c)};this.addRevokedCert=function(c,d){var f={};if(c!=undefined&&c!=null){f.sn=c}if(d!=undefined&&d!=null){f.time=d}var e=new KJUR.asn1.x509.CRLEntry(f);this.aRevokedCert.push(e)};this.getEncodedHex=function(){this.asn1Array=new Array();if(this.asn1Version!=null){this.asn1Array.push(this.asn1Version)}this.asn1Array.push(this.asn1SignatureAlg);this.asn1Array.push(this.asn1Issuer);this.asn1Array.push(this.asn1ThisUpdate);if(this.asn1NextUpdate!=null){this.asn1Array.push(this.asn1NextUpdate)}if(this.aRevokedCert.length>0){var c=new KJUR.asn1.DERSequence({array:this.aRevokedCert});this.asn1Array.push(c)}var d=new KJUR.asn1.DERSequence({array:this.asn1Array});this.hTLV=d.getEncodedHex();this.isModified=false;return this.hTLV};this._initialize=function(){this.asn1Version=null;this.asn1SignatureAlg=null;this.asn1Issuer=null;this.asn1ThisUpdate=null;this.asn1NextUpdate=null;this.aRevokedCert=new Array()};this._initialize()};YAHOO.lang.extend(KJUR.asn1.x509.TBSCertList,KJUR.asn1.ASN1Object);KJUR.asn1.x509.CRLEntry=function(c){KJUR.asn1.x509.CRLEntry.superclass.constructor.call(this);var b=null;var a=null;this.setCertSerial=function(d){this.sn=new KJUR.asn1.DERInteger(d)};this.setRevocationDate=function(d){this.time=new KJUR.asn1.x509.Time(d)};this.getEncodedHex=function(){var d=new KJUR.asn1.DERSequence({array:[this.sn,this.time]});this.TLV=d.getEncodedHex();return this.TLV};if(typeof c!="undefined"){if(typeof c.time!="undefined"){this.setRevocationDate(c.time)}if(typeof c.sn!="undefined"){this.setCertSerial(c.sn)}}};YAHOO.lang.extend(KJUR.asn1.x509.CRLEntry,KJUR.asn1.ASN1Object);KJUR.asn1.x509.X500Name=function(b){KJUR.asn1.x509.X500Name.superclass.constructor.call(this);this.asn1Array=new Array();this.setByString=function(c){var d=c.split("/");d.shift();for(var e=0;e<d.length;e++){this.asn1Array.push(new KJUR.asn1.x509.RDN({str:d[e]}))}};this.setByLdapString=function(c){var d=KJUR.asn1.x509.X500Name.ldapToOneline(c);this.setByString(d)};this.setByObject=function(e){for(var c in e){if(e.hasOwnProperty(c)){var d=new KJUR.asn1.x509.RDN({str:c+"="+e[c]});this.asn1Array?this.asn1Array.push(d):this.asn1Array=[d]}}};this.getEncodedHex=function(){if(typeof this.hTLV=="string"){return this.hTLV}var c=new KJUR.asn1.DERSequence({array:this.asn1Array});this.hTLV=c.getEncodedHex();return this.hTLV};if(b!==undefined){if(b.str!==undefined){this.setByString(b.str)}else{if(b.ldapstr!==undefined){this.setByLdapString(b.ldapstr)}else{if(typeof b==="object"){this.setByObject(b)}}}if(b.certissuer!==undefined){var a=new X509();a.hex=X509.pemToHex(b.certissuer);this.hTLV=a.getIssuerHex()}if(b.certsubject!==undefined){var a=new X509();a.hex=X509.pemToHex(b.certsubject);this.hTLV=a.getSubjectHex()}}};YAHOO.lang.extend(KJUR.asn1.x509.X500Name,KJUR.asn1.ASN1Object);KJUR.asn1.x509.X500Name.onelineToLDAP=function(d){if(d.substr(0,1)!=="/"){throw"malformed input"}var b="";d=d.substr(1);var c=d.split("/");c.reverse();c=c.map(function(a){return a.replace(/,/,"\\,")});return c.join(",")};KJUR.asn1.x509.X500Name.ldapToOneline=function(g){var c=g.split(",");var e=false;var b=[];for(var f=0;c.length>0;f++){var h=c.shift();if(e===true){var d=b.pop();var j=(d+","+h).replace(/\\,/g,",");b.push(j);e=false}else{b.push(h)}if(h.substr(-1,1)==="\\"){e=true}}b=b.map(function(a){return a.replace("/","\\/")});b.reverse();return"/"+b.join("/")};KJUR.asn1.x509.RDN=function(a){KJUR.asn1.x509.RDN.superclass.constructor.call(this);this.asn1Array=new Array();this.addByString=function(b){this.asn1Array.push(new KJUR.asn1.x509.AttributeTypeAndValue({str:b}))};this.addByMultiValuedString=function(d){var b=KJUR.asn1.x509.RDN.parseString(d);for(var c=0;c<b.length;c++){this.addByString(b[c])}};this.getEncodedHex=function(){var b=new KJUR.asn1.DERSet({array:this.asn1Array});this.TLV=b.getEncodedHex();return this.TLV};if(typeof a!="undefined"){if(typeof a.str!="undefined"){this.addByMultiValuedString(a.str)}}};YAHOO.lang.extend(KJUR.asn1.x509.RDN,KJUR.asn1.ASN1Object);KJUR.asn1.x509.RDN.parseString=function(m){var j=m.split(/\+/);var h=false;var c=[];for(var g=0;j.length>0;g++){var k=j.shift();if(h===true){var f=c.pop();var d=(f+"+"+k).replace(/\\\+/g,"+");c.push(d);h=false}else{c.push(k)}if(k.substr(-1,1)==="\\"){h=true}}var l=false;var b=[];for(var g=0;c.length>0;g++){var k=c.shift();if(l===true){var e=b.pop();if(k.match(/"$/)){var d=(e+"+"+k).replace(/^([^=]+)="(.*)"$/,"$1=$2");b.push(d);l=false}else{b.push(e+"+"+k)}}else{b.push(k)}if(k.match(/^[^=]+="/)){l=true}}return b};KJUR.asn1.x509.AttributeTypeAndValue=function(b){KJUR.asn1.x509.AttributeTypeAndValue.superclass.constructor.call(this);var d=null;var c=null;var a="utf8";this.setByString=function(f){var e=f.match(/^([^=]+)=(.+)$/);if(e){this.setByAttrTypeAndValueStr(e[1],e[2])}else{throw"malformed attrTypeAndValueStr: "+f}};this.setByAttrTypeAndValueStr=function(g,f){this.typeObj=KJUR.asn1.x509.OID.atype2obj(g);var e=a;if(g=="C"){e="prn"}this.valueObj=this.getValueObj(e,f)};this.getValueObj=function(f,e){if(f=="utf8"){return new KJUR.asn1.DERUTF8String({str:e})}if(f=="prn"){return new KJUR.asn1.DERPrintableString({str:e})}if(f=="tel"){return new KJUR.asn1.DERTeletexString({str:e})}if(f=="ia5"){return new KJUR.asn1.DERIA5String({str:e})}throw"unsupported directory string type: type="+f+" value="+e};this.getEncodedHex=function(){var e=new KJUR.asn1.DERSequence({array:[this.typeObj,this.valueObj]});this.TLV=e.getEncodedHex();return this.TLV};if(typeof b!="undefined"){if(typeof b.str!="undefined"){this.setByString(b.str)}}};YAHOO.lang.extend(KJUR.asn1.x509.AttributeTypeAndValue,KJUR.asn1.ASN1Object);KJUR.asn1.x509.SubjectPublicKeyInfo=function(d){KJUR.asn1.x509.SubjectPublicKeyInfo.superclass.constructor.call(this);var b=null;var c=null;var a=null;this.setRSAKey=function(e){if(!RSAKey.prototype.isPrototypeOf(e)){throw"argument is not RSAKey instance"}this.rsaKey=e;var g=new KJUR.asn1.DERInteger({bigint:e.n});var f=new KJUR.asn1.DERInteger({"int":e.e});var i=new KJUR.asn1.DERSequence({array:[g,f]});var h=i.getEncodedHex();this.asn1AlgId=new KJUR.asn1.x509.AlgorithmIdentifier({name:"rsaEncryption"});this.asn1SubjPKey=new KJUR.asn1.DERBitString({hex:"00"+h})};this.setRSAPEM=function(g){if(g.match(/-----BEGIN PUBLIC KEY-----/)){var n=g;n=n.replace(/^-----[^-]+-----/,"");n=n.replace(/-----[^-]+-----\s*$/,"");var m=n.replace(/\s+/g,"");var f=CryptoJS.enc.Base64.parse(m);var i=CryptoJS.enc.Hex.stringify(f);var k=_rsapem_getHexValueArrayOfChildrenFromHex(i);var h=k[1];var l=h.substr(2);var e=_rsapem_getHexValueArrayOfChildrenFromHex(l);var j=new RSAKey();j.setPublic(e[0],e[1]);this.setRSAKey(j)}else{throw"key not supported"}};this.getASN1Object=function(){if(this.asn1AlgId==null||this.asn1SubjPKey==null){throw"algId and/or subjPubKey not set"}var e=new KJUR.asn1.DERSequence({array:[this.asn1AlgId,this.asn1SubjPKey]});return e};this.getEncodedHex=function(){var e=this.getASN1Object();this.hTLV=e.getEncodedHex();return this.hTLV};this._setRSAKey=function(e){var g=KJUR.asn1.ASN1Util.newObject({seq:[{"int":{bigint:e.n}},{"int":{"int":e.e}}]});var f=g.getEncodedHex();this.asn1AlgId=new KJUR.asn1.x509.AlgorithmIdentifier({name:"rsaEncryption"});this.asn1SubjPKey=new KJUR.asn1.DERBitString({hex:"00"+f})};this._setEC=function(e){var f=new KJUR.asn1.DERObjectIdentifier({name:e.curveName});this.asn1AlgId=new KJUR.asn1.x509.AlgorithmIdentifier({name:"ecPublicKey",asn1params:f});this.asn1SubjPKey=new KJUR.asn1.DERBitString({hex:"00"+e.pubKeyHex})};this._setDSA=function(e){var f=new KJUR.asn1.ASN1Util.newObject({seq:[{"int":{bigint:e.p}},{"int":{bigint:e.q}},{"int":{bigint:e.g}}]});this.asn1AlgId=new KJUR.asn1.x509.AlgorithmIdentifier({name:"dsa",asn1params:f});var g=new KJUR.asn1.DERInteger({bigint:e.y});this.asn1SubjPKey=new KJUR.asn1.DERBitString({hex:"00"+g.getEncodedHex()})};if(typeof d!="undefined"){if(typeof RSAKey!="undefined"&&d instanceof RSAKey){this._setRSAKey(d)}else{if(typeof KJUR.crypto.ECDSA!="undefined"&&d instanceof KJUR.crypto.ECDSA){this._setEC(d)}else{if(typeof KJUR.crypto.DSA!="undefined"&&d instanceof KJUR.crypto.DSA){this._setDSA(d)}else{if(typeof d.rsakey!="undefined"){this.setRSAKey(d.rsakey)}else{if(typeof d.rsapem!="undefined"){this.setRSAPEM(d.rsapem)}}}}}}};YAHOO.lang.extend(KJUR.asn1.x509.SubjectPublicKeyInfo,KJUR.asn1.ASN1Object);KJUR.asn1.x509.Time=function(c){KJUR.asn1.x509.Time.superclass.constructor.call(this);var b=null;var a=null;this.setTimeParams=function(d){this.timeParams=d};this.getEncodedHex=function(){var d=null;if(this.timeParams!=null){if(this.type=="utc"){d=new KJUR.asn1.DERUTCTime(this.timeParams)}else{d=new KJUR.asn1.DERGeneralizedTime(this.timeParams)}}else{if(this.type=="utc"){d=new KJUR.asn1.DERUTCTime()}else{d=new KJUR.asn1.DERGeneralizedTime()}}this.TLV=d.getEncodedHex();return this.TLV};this.type="utc";if(typeof c!="undefined"){if(typeof c.type!="undefined"){this.type=c.type}else{if(typeof c.str!="undefined"){if(c.str.match(/^[0-9]{12}Z$/)){this.type="utc"}if(c.str.match(/^[0-9]{14}Z$/)){this.type="gen"}}}this.timeParams=c}};YAHOO.lang.extend(KJUR.asn1.x509.Time,KJUR.asn1.ASN1Object);KJUR.asn1.x509.AlgorithmIdentifier=function(e){KJUR.asn1.x509.AlgorithmIdentifier.superclass.constructor.call(this);var a=null;var d=null;var b=null;var c=false;this.getEncodedHex=function(){if(this.nameAlg==null&&this.asn1Alg==null){throw"algorithm not specified"}if(this.nameAlg!=null&&this.asn1Alg==null){this.asn1Alg=KJUR.asn1.x509.OID.name2obj(this.nameAlg)}var f=[this.asn1Alg];if(!this.paramEmpty){f.push(this.asn1Params)}var g=new KJUR.asn1.DERSequence({array:f});this.hTLV=g.getEncodedHex();return this.hTLV};if(typeof e!="undefined"){if(typeof e.name!="undefined"){this.nameAlg=e.name}if(typeof e.asn1params!="undefined"){this.asn1Params=e.asn1params}if(typeof e.paramempty!="undefined"){this.paramEmpty=e.paramempty}}if(this.asn1Params==null){this.asn1Params=new KJUR.asn1.DERNull()}};YAHOO.lang.extend(KJUR.asn1.x509.AlgorithmIdentifier,KJUR.asn1.ASN1Object);KJUR.asn1.x509.GeneralName=function(d){KJUR.asn1.x509.GeneralName.superclass.constructor.call(this);var c=null;var b=null;var a={rfc822:"81",dns:"82",dn:"a4",uri:"86"};this.explicit=false;this.setByParam=function(k){var j=null;var g=null;if(k===undefined){return}if(k.rfc822!==undefined){this.type="rfc822";g=new KJUR.asn1.DERIA5String({str:k[this.type]})}if(k.dns!==undefined){this.type="dns";g=new KJUR.asn1.DERIA5String({str:k[this.type]})}if(k.uri!==undefined){this.type="uri";g=new KJUR.asn1.DERIA5String({str:k[this.type]})}if(k.dn!==undefined){this.type="dn";g=new KJUR.asn1.x509.X500Name({str:k.dn})}if(k.ldapdn!==undefined){this.type="dn";g=new KJUR.asn1.x509.X500Name({ldapstr:k.ldapdn})}if(k.certissuer!==undefined){this.type="dn";this.explicit=true;var h=k.certissuer;var f=null;if(h.match(/^[0-9A-Fa-f]+$/)){f==h}if(h.indexOf("-----BEGIN ")!=-1){f=X509.pemToHex(h)}if(f==null){throw"certissuer param not cert"}var e=new X509();e.hex=f;var i=e.getIssuerHex();g=new KJUR.asn1.ASN1Object();g.hTLV=i}if(k.certsubj!==undefined){this.type="dn";this.explicit=true;var h=k.certsubj;var f=null;if(h.match(/^[0-9A-Fa-f]+$/)){f==h}if(h.indexOf("-----BEGIN ")!=-1){f=X509.pemToHex(h)}if(f==null){throw"certsubj param not cert"}var e=new X509();e.hex=f;var i=e.getSubjectHex();g=new KJUR.asn1.ASN1Object();g.hTLV=i}if(this.type==null){throw"unsupported type in params="+k}this.asn1Obj=new KJUR.asn1.DERTaggedObject({explicit:this.explicit,tag:a[this.type],obj:g})};this.getEncodedHex=function(){return this.asn1Obj.getEncodedHex()};if(d!==undefined){this.setByParam(d)}};YAHOO.lang.extend(KJUR.asn1.x509.GeneralName,KJUR.asn1.ASN1Object);KJUR.asn1.x509.GeneralNames=function(b){KJUR.asn1.x509.GeneralNames.superclass.constructor.call(this);var a=null;this.setByParamArray=function(e){for(var c=0;c<e.length;c++){var d=new KJUR.asn1.x509.GeneralName(e[c]);this.asn1Array.push(d)}};this.getEncodedHex=function(){var c=new KJUR.asn1.DERSequence({array:this.asn1Array});return c.getEncodedHex()};this.asn1Array=new Array();if(typeof b!="undefined"){this.setByParamArray(b)}};YAHOO.lang.extend(KJUR.asn1.x509.GeneralNames,KJUR.asn1.ASN1Object);KJUR.asn1.x509.DistributionPointName=function(b){KJUR.asn1.x509.DistributionPointName.superclass.constructor.call(this);var e=null;var c=null;var a=null;var d=null;this.getEncodedHex=function(){if(this.type!="full"){throw"currently type shall be 'full': "+this.type}this.asn1Obj=new KJUR.asn1.DERTaggedObject({explicit:false,tag:this.tag,obj:this.asn1V});this.hTLV=this.asn1Obj.getEncodedHex();return this.hTLV};if(typeof b!="undefined"){if(KJUR.asn1.x509.GeneralNames.prototype.isPrototypeOf(b)){this.type="full";this.tag="a0";this.asn1V=b}else{throw"This class supports GeneralNames only as argument"}}};YAHOO.lang.extend(KJUR.asn1.x509.DistributionPointName,KJUR.asn1.ASN1Object);KJUR.asn1.x509.DistributionPoint=function(b){KJUR.asn1.x509.DistributionPoint.superclass.constructor.call(this);var a=null;this.getEncodedHex=function(){var c=new KJUR.asn1.DERSequence();if(this.asn1DP!=null){var d=new KJUR.asn1.DERTaggedObject({explicit:true,tag:"a0",obj:this.asn1DP});c.appendASN1Object(d)}this.hTLV=c.getEncodedHex();return this.hTLV};if(typeof b!="undefined"){if(typeof b.dpobj!="undefined"){this.asn1DP=b.dpobj}}};YAHOO.lang.extend(KJUR.asn1.x509.DistributionPoint,KJUR.asn1.ASN1Object);KJUR.asn1.x509.OID=new function(a){this.atype2oidList={CN:"2.5.4.3",L:"2.5.4.7",ST:"2.5.4.8",O:"2.5.4.10",OU:"2.5.4.11",C:"2.5.4.6",STREET:"2.5.4.9",DC:"0.9.2342.19200300.100.1.25",UID:"0.9.2342.19200300.100.1.1",SN:"2.5.4.4",DN:"2.5.4.49",E:"1.2.840.113549.1.9.1",businessCategory:"2.5.4.15",postalCode:"2.5.4.17",jurisdictionOfIncorporationL:"1.3.6.1.4.1.311.60.2.1.1",jurisdictionOfIncorporationSP:"1.3.6.1.4.1.311.60.2.1.2",jurisdictionOfIncorporationC:"1.3.6.1.4.1.311.60.2.1.3"};this.name2oidList={sha1:"1.3.14.3.2.26",sha256:"2.16.840.1.101.3.4.2.1",sha384:"2.16.840.1.101.3.4.2.2",sha512:"2.16.840.1.101.3.4.2.3",sha224:"2.16.840.1.101.3.4.2.4",md5:"1.2.840.113549.2.5",md2:"1.3.14.7.2.2.1",ripemd160:"1.3.36.3.2.1",MD2withRSA:"1.2.840.113549.1.1.2",MD4withRSA:"1.2.840.113549.1.1.3",MD5withRSA:"1.2.840.113549.1.1.4",SHA1withRSA:"1.2.840.113549.1.1.5",SHA224withRSA:"1.2.840.113549.1.1.14",SHA256withRSA:"1.2.840.113549.1.1.11",SHA384withRSA:"1.2.840.113549.1.1.12",SHA512withRSA:"1.2.840.113549.1.1.13",SHA1withECDSA:"1.2.840.10045.4.1",SHA224withECDSA:"1.2.840.10045.4.3.1",SHA256withECDSA:"1.2.840.10045.4.3.2",SHA384withECDSA:"1.2.840.10045.4.3.3",SHA512withECDSA:"1.2.840.10045.4.3.4",dsa:"1.2.840.10040.4.1",SHA1withDSA:"1.2.840.10040.4.3",SHA224withDSA:"2.16.840.1.101.3.4.3.1",SHA256withDSA:"2.16.840.1.101.3.4.3.2",rsaEncryption:"1.2.840.113549.1.1.1",commonName:"2.5.4.3",localityName:"2.5.4.7",stateOrProvinceName:"2.5.4.8",organizationName:"2.5.4.10",organizationalUnitName:"2.5.4.11",countryName:"2.5.4.6",streetAddress:"2.5.4.9",domainComponent:"0.9.2342.19200300.100.1.25",userId:"0.9.2342.19200300.100.1.1",surname:"2.5.4.4",distinguishedName:"2.5.4.49",emailAddress:"1.2.840.113549.1.9.1",businessCategory:"2.5.4.15",postalCode:"2.5.4.17",jurisdictionOfIncorporationL:"1.3.6.1.4.1.311.60.2.1.1",jurisdictionOfIncorporationSP:"1.3.6.1.4.1.311.60.2.1.2",jurisdictionOfIncorporationC:"1.3.6.1.4.1.311.60.2.1.3",subjectKeyIdentifier:"2.5.29.14",keyUsage:"2.5.29.15",subjectAltName:"2.5.29.17",issuerAltName:"2.5.29.18",basicConstraints:"2.5.29.19",nameConstraints:"2.5.29.30",cRLDistributionPoints:"2.5.29.31",certificatePolicies:"2.5.29.32",authorityKeyIdentifier:"2.5.29.35",policyConstraints:"2.5.29.36",extKeyUsage:"2.5.29.37",authorityInfoAccess:"1.3.6.1.5.5.7.1.1",ocsp:"1.3.6.1.5.5.7.48.1",caIssuers:"1.3.6.1.5.5.7.48.2",anyExtendedKeyUsage:"2.5.29.37.0",serverAuth:"1.3.6.1.5.5.7.3.1",clientAuth:"1.3.6.1.5.5.7.3.2",codeSigning:"1.3.6.1.5.5.7.3.3",emailProtection:"1.3.6.1.5.5.7.3.4",timeStamping:"1.3.6.1.5.5.7.3.8",ocspSigning:"1.3.6.1.5.5.7.3.9",ecPublicKey:"1.2.840.10045.2.1",secp256r1:"1.2.840.10045.3.1.7",secp256k1:"1.3.132.0.10",secp384r1:"1.3.132.0.34",pkcs5PBES2:"1.2.840.113549.1.5.13",pkcs5PBKDF2:"1.2.840.113549.1.5.12","des-EDE3-CBC":"1.2.840.113549.3.7",data:"1.2.840.113549.1.7.1","signed-data":"1.2.840.113549.1.7.2","enveloped-data":"1.2.840.113549.1.7.3","digested-data":"1.2.840.113549.1.7.5","encrypted-data":"1.2.840.113549.1.7.6","authenticated-data":"1.2.840.113549.1.9.16.1.2",tstinfo:"1.2.840.113549.1.9.16.1.4",extensionRequest:"1.2.840.113549.1.9.14",};this.objCache={};this.name2obj=function(b){if(typeof this.objCache[b]!="undefined"){return this.objCache[b]}if(typeof this.name2oidList[b]=="undefined"){throw"Name of ObjectIdentifier not defined: "+b}var c=this.name2oidList[b];var d=new KJUR.asn1.DERObjectIdentifier({oid:c});this.objCache[b]=d;return d};this.atype2obj=function(b){if(typeof this.objCache[b]!="undefined"){return this.objCache[b]}if(typeof this.atype2oidList[b]=="undefined"){throw"AttributeType name undefined: "+b}var c=this.atype2oidList[b];var d=new KJUR.asn1.DERObjectIdentifier({oid:c});this.objCache[b]=d;return d}};KJUR.asn1.x509.OID.oid2name=function(b){var c=KJUR.asn1.x509.OID.name2oidList;for(var a in c){if(c[a]==b){return a}}return""};KJUR.asn1.x509.OID.oid2atype=function(b){var c=KJUR.asn1.x509.OID.atype2oidList;for(var a in c){if(c[a]==b){return a}}return b};KJUR.asn1.x509.OID.name2oid=function(a){var b=KJUR.asn1.x509.OID.name2oidList;if(b[a]===undefined){return""}return b[a]};KJUR.asn1.x509.X509Util=new function(){this.getPKCS8PubKeyPEMfromRSAKey=function(i){var h=null;var f=KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(i.n);var j=KJUR.asn1.ASN1Util.integerToByteHex(i.e);var a=new KJUR.asn1.DERInteger({hex:f});var g=new KJUR.asn1.DERInteger({hex:j});var l=new KJUR.asn1.DERSequence({array:[a,g]});var c=l.getEncodedHex();var d=new KJUR.asn1.x509.AlgorithmIdentifier({name:"rsaEncryption"});var b=new KJUR.asn1.DERBitString({hex:"00"+c});var k=new KJUR.asn1.DERSequence({array:[d,b]});var e=k.getEncodedHex();var h=KJUR.asn1.ASN1Util.getPEMStringFromHex(e,"PUBLIC KEY");return h}};KJUR.asn1.x509.X509Util.newCertPEM=function(f){var c=KJUR.asn1.x509;var e=new c.TBSCertificate();if(f.serial!==undefined){e.setSerialNumberByParam(f.serial)}else{throw"serial number undefined."}if(typeof f.sigalg.name=="string"){e.setSignatureAlgByParam(f.sigalg)}else{throw"unproper signature algorithm name"}if(f.issuer!==undefined){e.setIssuerByParam(f.issuer)}else{throw"issuer name undefined."}if(f.notbefore!==undefined){e.setNotBeforeByParam(f.notbefore)}else{throw"notbefore undefined."}if(f.notafter!==undefined){e.setNotAfterByParam(f.notafter)}else{throw"notafter undefined."}if(f.subject!==undefined){e.setSubjectByParam(f.subject)}else{throw"subject name undefined."}if(f.sbjpubkey!==undefined){e.setSubjectPublicKeyByGetKey(f.sbjpubkey)}else{throw"subject public key undefined."}if(f.ext!==undefined&&f.ext.length!==undefined){for(var b=0;b<f.ext.length;b++){for(key in f.ext[b]){e.appendExtensionByName(key,f.ext[b][key])}}}if(f.cakey===undefined&&f.sighex===undefined){throw"param cakey and sighex undefined."}var d=null;var a=null;if(f.cakey){d=KEYUTIL.getKey.apply(null,f.cakey);a=new c.Certificate({tbscertobj:e,prvkeyobj:d});a.sign()}if(f.sighex){a=new c.Certificate({tbscertobj:e});a.setSignatureHex(f.sighex)}return a.getPEMString()};
/*! asn1cms-1.0.2.js (c) 2013-2014 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}if(typeof KJUR.asn1.cms=="undefined"||!KJUR.asn1.cms){KJUR.asn1.cms={}}KJUR.asn1.cms.Attribute=function(b){KJUR.asn1.cms.Attribute.superclass.constructor.call(this);var a=[];this.getEncodedHex=function(){var f,e,c;f=new KJUR.asn1.DERObjectIdentifier({oid:this.attrTypeOid});e=new KJUR.asn1.DERSet({array:this.valueList});try{e.getEncodedHex()}catch(d){throw"fail valueSet.getEncodedHex in Attribute(1)/"+d}c=new KJUR.asn1.DERSequence({array:[f,e]});try{this.hTLV=c.getEncodedHex()}catch(d){throw"failed seq.getEncodedHex in Attribute(2)/"+d}return this.hTLV}};YAHOO.lang.extend(KJUR.asn1.cms.Attribute,KJUR.asn1.ASN1Object);KJUR.asn1.cms.ContentType=function(b){KJUR.asn1.cms.ContentType.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.3";var a=null;if(typeof b!="undefined"){var a=new KJUR.asn1.DERObjectIdentifier(b);this.valueList=[a]}};YAHOO.lang.extend(KJUR.asn1.cms.ContentType,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.MessageDigest=function(e){KJUR.asn1.cms.MessageDigest.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.4";if(typeof e!="undefined"){if(e.eciObj instanceof KJUR.asn1.cms.EncapsulatedContentInfo&&typeof e.hashAlg=="string"){var b=e.eciObj.eContentValueHex;var a=e.hashAlg;var c=KJUR.crypto.Util.hashHex(b,a);var d=new KJUR.asn1.DEROctetString({hex:c});d.getEncodedHex();this.valueList=[d]}else{var d=new KJUR.asn1.DEROctetString(e);d.getEncodedHex();this.valueList=[d]}}};YAHOO.lang.extend(KJUR.asn1.cms.MessageDigest,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.SigningTime=function(c){KJUR.asn1.cms.SigningTime.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.5";if(typeof c!="undefined"){var a=new KJUR.asn1.x509.Time(c);try{a.getEncodedHex()}catch(b){throw"SigningTime.getEncodedHex() failed/"+b}this.valueList=[a]}};YAHOO.lang.extend(KJUR.asn1.cms.SigningTime,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.SigningCertificate=function(d){KJUR.asn1.cms.SigningCertificate.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.16.2.12";var a=KJUR.asn1;var c=KJUR.asn1.cms;var b=KJUR.crypto;this.setCerts=function(l){var j=[];for(var h=0;h<l.length;h++){var f=KEYUTIL.getHexFromPEM(l[h]);var e=b.Util.hashHex(f,"sha1");var m=new a.DEROctetString({hex:e});m.getEncodedHex();var k=new c.IssuerAndSerialNumber({cert:l[h]});k.getEncodedHex();var n=new a.DERSequence({array:[m,k]});n.getEncodedHex();j.push(n)}var g=new a.DERSequence({array:j});g.getEncodedHex();this.valueList=[g]};if(typeof d!="undefined"){if(typeof d.array=="object"){this.setCerts(d.array)}}};YAHOO.lang.extend(KJUR.asn1.cms.SigningCertificate,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.SigningCertificateV2=function(e){KJUR.asn1.cms.SigningCertificateV2.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.16.2.47";var b=KJUR.asn1;var f=KJUR.asn1.x509;var d=KJUR.asn1.cms;var c=KJUR.crypto;this.setCerts=function(p,h){var n=[];for(var l=0;l<p.length;l++){var j=KEYUTIL.getHexFromPEM(p[l]);var r=[];if(h!="sha256"){r.push(new f.AlgorithmIdentifier({name:h}))}var g=c.Util.hashHex(j,h);var q=new b.DEROctetString({hex:g});q.getEncodedHex();r.push(q);var m=new d.IssuerAndSerialNumber({cert:p[l]});m.getEncodedHex();r.push(m);var o=new b.DERSequence({array:r});o.getEncodedHex();n.push(o)}var k=new b.DERSequence({array:n});k.getEncodedHex();this.valueList=[k]};if(typeof e!="undefined"){if(typeof e.array=="object"){var a="sha256";if(typeof e.hashAlg=="string"){a=e.hashAlg}this.setCerts(e.array,a)}}};YAHOO.lang.extend(KJUR.asn1.cms.SigningCertificateV2,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.IssuerAndSerialNumber=function(c){KJUR.asn1.cms.IssuerAndSerialNumber.superclass.constructor.call(this);var e=null;var b=null;var a=KJUR.asn1;var d=a.x509;this.setByCertPEM=function(i){var g=KEYUTIL.getHexFromPEM(i);var f=new X509();f.hex=g;var j=f.getIssuerHex();this.dIssuer=new d.X500Name();this.dIssuer.hTLV=j;var h=f.getSerialNumberHex();this.dSerial=new a.DERInteger({hex:h})};this.getEncodedHex=function(){var f=new KJUR.asn1.DERSequence({array:[this.dIssuer,this.dSerial]});this.hTLV=f.getEncodedHex();return this.hTLV};if(typeof c!="undefined"){if(typeof c=="string"&&c.indexOf("-----BEGIN ")!=-1){this.setByCertPEM(c)}if(c.issuer&&c.serial){if(c.issuer instanceof KJUR.asn1.x509.X500Name){this.dIssuer=c.issuer}else{this.dIssuer=new KJUR.asn1.x509.X500Name(c.issuer)}if(c.serial instanceof KJUR.asn1.DERInteger){this.dSerial=c.serial}else{this.dSerial=new KJUR.asn1.DERInteger(c.serial)}}if(typeof c.cert=="string"){this.setByCertPEM(c.cert)}}};YAHOO.lang.extend(KJUR.asn1.cms.IssuerAndSerialNumber,KJUR.asn1.ASN1Object);KJUR.asn1.cms.AttributeList=function(a){KJUR.asn1.cms.AttributeList.superclass.constructor.call(this);this.list=new Array();this.sortFlag=true;this.add=function(b){if(b instanceof KJUR.asn1.cms.Attribute){this.list.push(b)}};this.length=function(){return this.list.length};this.clear=function(){this.list=new Array();this.hTLV=null;this.hV=null};this.getEncodedHex=function(){if(typeof this.hTLV=="string"){return this.hTLV}var b=new KJUR.asn1.DERSet({array:this.list,sortflag:this.sortFlag});this.hTLV=b.getEncodedHex();return this.hTLV};if(typeof a!="undefined"){if(typeof a.sortflag!="undefined"&&a.sortflag==false){this.sortFlag=false}}};YAHOO.lang.extend(KJUR.asn1.cms.AttributeList,KJUR.asn1.ASN1Object);KJUR.asn1.cms.SignerInfo=function(c){KJUR.asn1.cms.SignerInfo.superclass.constructor.call(this);var a=KJUR.asn1;var b=KJUR.asn1.cms;var d=KJUR.asn1.x509;this.dCMSVersion=new a.DERInteger({"int":1});this.dSignerIdentifier=null;this.dDigestAlgorithm=null;this.dSignedAttrs=new b.AttributeList();this.dSigAlg=null;this.dSig=null;this.dUnsignedAttrs=new b.AttributeList();this.setSignerIdentifier=function(f){if(typeof f=="string"&&f.indexOf("CERTIFICATE")!=-1&&f.indexOf("BEGIN")!=-1&&f.indexOf("END")!=-1){var e=f;this.dSignerIdentifier=new b.IssuerAndSerialNumber({cert:f})}};this.setForContentAndHash=function(e){if(typeof e!="undefined"){if(e.eciObj instanceof KJUR.asn1.cms.EncapsulatedContentInfo){this.dSignedAttrs.add(new b.ContentType({oid:"1.2.840.113549.1.7.1"}));this.dSignedAttrs.add(new b.MessageDigest({eciObj:e.eciObj,hashAlg:e.hashAlg}))}if(typeof e.sdObj!="undefined"&&e.sdObj instanceof KJUR.asn1.cms.SignedData){if(e.sdObj.digestAlgNameList.join(":").indexOf(e.hashAlg)==-1){e.sdObj.digestAlgNameList.push(e.hashAlg)}}if(typeof e.hashAlg=="string"){this.dDigestAlgorithm=new d.AlgorithmIdentifier({name:e.hashAlg})}}};this.sign=function(j,f){this.dSigAlg=new d.AlgorithmIdentifier({name:f});var g=this.dSignedAttrs.getEncodedHex();var e=KEYUTIL.getKey(j);var i=new KJUR.crypto.Signature({alg:f});i.init(e);i.updateHex(g);var h=i.sign();this.dSig=new a.DEROctetString({hex:h})};this.addUnsigned=function(e){this.hTLV=null;this.dUnsignedAttrs.hTLV=null;this.dUnsignedAttrs.add(e)};this.getEncodedHex=function(){if(this.dSignedAttrs instanceof KJUR.asn1.cms.AttributeList&&this.dSignedAttrs.length()==0){throw"SignedAttrs length = 0 (empty)"}var e=new a.DERTaggedObject({obj:this.dSignedAttrs,tag:"a0",explicit:false});var h=null;if(this.dUnsignedAttrs.length()>0){h=new a.DERTaggedObject({obj:this.dUnsignedAttrs,tag:"a1",explicit:false})}var g=[this.dCMSVersion,this.dSignerIdentifier,this.dDigestAlgorithm,e,this.dSigAlg,this.dSig,];if(h!=null){g.push(h)}var f=new a.DERSequence({array:g});this.hTLV=f.getEncodedHex();return this.hTLV}};YAHOO.lang.extend(KJUR.asn1.cms.SignerInfo,KJUR.asn1.ASN1Object);KJUR.asn1.cms.EncapsulatedContentInfo=function(c){KJUR.asn1.cms.EncapsulatedContentInfo.superclass.constructor.call(this);var a=KJUR.asn1;var b=KJUR.asn1.cms;var d=KJUR.asn1.x509;this.dEContentType=new a.DERObjectIdentifier({name:"data"});this.dEContent=null;this.isDetached=false;this.eContentValueHex=null;this.setContentType=function(e){if(e.match(/^[0-2][.][0-9.]+$/)){this.dEContentType=new a.DERObjectIdentifier({oid:e})}else{this.dEContentType=new a.DERObjectIdentifier({name:e})}};this.setContentValue=function(e){if(typeof e!="undefined"){if(typeof e.hex=="string"){this.eContentValueHex=e.hex}else{if(typeof e.str=="string"){this.eContentValueHex=utf8tohex(e.str)}}}};this.setContentValueHex=function(e){this.eContentValueHex=e};this.setContentValueStr=function(e){this.eContentValueHex=utf8tohex(e)};this.getEncodedHex=function(){if(typeof this.eContentValueHex!="string"){throw"eContentValue not yet set"}var g=new a.DEROctetString({hex:this.eContentValueHex});this.dEContent=new a.DERTaggedObject({obj:g,tag:"a0",explicit:true});var e=[this.dEContentType];if(!this.isDetached){e.push(this.dEContent)}var f=new a.DERSequence({array:e});this.hTLV=f.getEncodedHex();return this.hTLV}};YAHOO.lang.extend(KJUR.asn1.cms.EncapsulatedContentInfo,KJUR.asn1.ASN1Object);KJUR.asn1.cms.ContentInfo=function(c){KJUR.asn1.cms.ContentInfo.superclass.constructor.call(this);var a=KJUR.asn1;var b=KJUR.asn1.cms;var d=KJUR.asn1.x509;this.dContentType=null;this.dContent=null;this.setContentType=function(e){if(typeof e=="string"){this.dContentType=d.OID.name2obj(e)}};this.getEncodedHex=function(){var f=new a.DERTaggedObject({obj:this.dContent,tag:"a0",explicit:true});var e=new a.DERSequence({array:[this.dContentType,f]});this.hTLV=e.getEncodedHex();return this.hTLV};if(typeof c!="undefined"){if(c.type){this.setContentType(c.type)}if(c.obj&&c.obj instanceof a.ASN1Object){this.dContent=c.obj}}};YAHOO.lang.extend(KJUR.asn1.cms.ContentInfo,KJUR.asn1.ASN1Object);KJUR.asn1.cms.SignedData=function(c){KJUR.asn1.cms.SignedData.superclass.constructor.call(this);var a=KJUR.asn1;var b=KJUR.asn1.cms;var d=KJUR.asn1.x509;this.dCMSVersion=new a.DERInteger({"int":1});this.dDigestAlgs=null;this.digestAlgNameList=[];this.dEncapContentInfo=new b.EncapsulatedContentInfo();this.dCerts=null;this.certificateList=[];this.crlList=[];this.signerInfoList=[new b.SignerInfo()];this.addCertificatesByPEM=function(e){var f=KEYUTIL.getHexFromPEM(e);var g=new a.ASN1Object();g.hTLV=f;this.certificateList.push(g)};this.getEncodedHex=function(){if(typeof this.hTLV=="string"){return this.hTLV}if(this.dDigestAlgs==null){var k=[];for(var j=0;j<this.digestAlgNameList.length;j++){var h=this.digestAlgNameList[j];var m=new d.AlgorithmIdentifier({name:h});k.push(m)}this.dDigestAlgs=new a.DERSet({array:k})}var e=[this.dCMSVersion,this.dDigestAlgs,this.dEncapContentInfo];if(this.dCerts==null){if(this.certificateList.length>0){var l=new a.DERSet({array:this.certificateList});this.dCerts=new a.DERTaggedObject({obj:l,tag:"a0",explicit:false})}}if(this.dCerts!=null){e.push(this.dCerts)}var g=new a.DERSet({array:this.signerInfoList});e.push(g);var f=new a.DERSequence({array:e});this.hTLV=f.getEncodedHex();return this.hTLV};this.getContentInfo=function(){this.getEncodedHex();var e=new b.ContentInfo({type:"signed-data",obj:this});return e};this.getContentInfoEncodedHex=function(){var e=this.getContentInfo();var f=e.getEncodedHex();return f};this.getPEM=function(){var e=this.getContentInfoEncodedHex();var f=a.ASN1Util.getPEMStringFromHex(e,"CMS");return f}};YAHOO.lang.extend(KJUR.asn1.cms.SignedData,KJUR.asn1.ASN1Object);KJUR.asn1.cms.CMSUtil=new function(){};KJUR.asn1.cms.CMSUtil.newSignedData=function(a){var h=KJUR.asn1.cms;var g=KJUR.asn1.cades;var f=new h.SignedData();f.dEncapContentInfo.setContentValue(a.content);if(typeof a.certs=="object"){for(var b=0;b<a.certs.length;b++){f.addCertificatesByPEM(a.certs[b])}}f.signerInfoList=[];for(var b=0;b<a.signerInfos.length;b++){var d=a.signerInfos[b];var c=new h.SignerInfo();c.setSignerIdentifier(d.signerCert);c.setForContentAndHash({sdObj:f,eciObj:f.dEncapContentInfo,hashAlg:d.hashAlg});for(attrName in d.sAttr){var j=d.sAttr[attrName];if(attrName=="SigningTime"){var e=new h.SigningTime(j);c.dSignedAttrs.add(e)}if(attrName=="SigningCertificate"){var e=new h.SigningCertificate(j);c.dSignedAttrs.add(e)}if(attrName=="SigningCertificateV2"){var e=new h.SigningCertificateV2(j);c.dSignedAttrs.add(e)}if(attrName=="SignaturePolicyIdentifier"){var e=new g.SignaturePolicyIdentifier(j);c.dSignedAttrs.add(e)}}c.sign(d.signerPrvKey,d.sigAlg);f.signerInfoList.push(c)}return f};
/*! asn1tsp-1.0.1.js (c) 2014 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}if(typeof KJUR.asn1.tsp=="undefined"||!KJUR.asn1.tsp){KJUR.asn1.tsp={}}KJUR.asn1.tsp.Accuracy=function(b){KJUR.asn1.tsp.Accuracy.superclass.constructor.call(this);var a=KJUR.asn1;this.seconds=null;this.millis=null;this.micros=null;this.getEncodedHex=function(){var e=null;var g=null;var i=null;var c=[];if(this.seconds!=null){e=new a.DERInteger({"int":this.seconds});c.push(e)}if(this.millis!=null){var h=new a.DERInteger({"int":this.millis});g=new a.DERTaggedObject({obj:h,tag:"80",explicit:false});c.push(g)}if(this.micros!=null){var f=new a.DERInteger({"int":this.micros});i=new a.DERTaggedObject({obj:f,tag:"81",explicit:false});c.push(i)}var d=new a.DERSequence({array:c});this.hTLV=d.getEncodedHex();return this.hTLV};if(typeof b!="undefined"){if(typeof b.seconds=="number"){this.seconds=b.seconds}if(typeof b.millis=="number"){this.millis=b.millis}if(typeof b.micros=="number"){this.micros=b.micros}}};YAHOO.lang.extend(KJUR.asn1.tsp.Accuracy,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.MessageImprint=function(b){KJUR.asn1.tsp.MessageImprint.superclass.constructor.call(this);var a=KJUR.asn1;var c=KJUR.asn1.x509;this.dHashAlg=null;this.dHashValue=null;this.getEncodedHex=function(){if(typeof this.hTLV=="string"){return this.hTLV}var d=new a.DERSequence({array:[this.dHashAlg,this.dHashValue]});return d.getEncodedHex()};if(typeof b!="undefined"){if(typeof b.hashAlg=="string"){this.dHashAlg=new c.AlgorithmIdentifier({name:b.hashAlg})}if(typeof b.hashValue=="string"){this.dHashValue=new a.DEROctetString({hex:b.hashValue})}}};YAHOO.lang.extend(KJUR.asn1.tsp.MessageImprint,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.TimeStampReq=function(c){KJUR.asn1.tsp.TimeStampReq.superclass.constructor.call(this);var a=KJUR.asn1;var b=KJUR.asn1.tsp;this.dVersion=new a.DERInteger({"int":1});this.dMessageImprint=null;this.dPolicy=null;this.dNonce=null;this.certReq=true;this.setMessageImprint=function(d){if(d instanceof KJUR.asn1.tsp.MessageImprint){this.dMessageImprint=d;return}if(typeof d=="object"){this.dMessageImprint=new b.MessageImprint(d)}};this.getEncodedHex=function(){if(this.dMessageImprint==null){throw"messageImprint shall be specified"}var d=[this.dVersion,this.dMessageImprint];if(this.dPolicy!=null){d.push(this.dPolicy)}if(this.dNonce!=null){d.push(this.dNonce)}if(this.certReq){d.push(new a.DERBoolean())}var e=new a.DERSequence({array:d});this.hTLV=e.getEncodedHex();return this.hTLV};if(typeof c!="undefined"){if(typeof c.mi=="object"){this.setMessageImprint(c.mi)}if(typeof c.policy=="object"){this.dPolicy=new a.DERObjectIdentifier(c.policy)}if(typeof c.nonce=="object"){this.dNonce=new a.DERInteger(c.nonce)}if(typeof c.certreq=="boolean"){this.certReq=c.certreq}}};YAHOO.lang.extend(KJUR.asn1.tsp.TimeStampReq,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.TSTInfo=function(c){KJUR.asn1.tsp.TSTInfo.superclass.constructor.call(this);var a=KJUR.asn1;var d=KJUR.asn1.x509;var b=KJUR.asn1.tsp;this.dVersion=new a.DERInteger({"int":1});this.dPolicy=null;this.dMessageImprint=null;this.dSerialNumber=null;this.dGenTime=null;this.dAccuracy=null;this.dOrdering=null;this.dNonce=null;this.dTsa=null;this.getEncodedHex=function(){var e=[this.dVersion];if(this.dPolicy==null){throw"policy shall be specified."}e.push(this.dPolicy);if(this.dMessageImprint==null){throw"messageImprint shall be specified."}e.push(this.dMessageImprint);if(this.dSerialNumber==null){throw"serialNumber shall be specified."}e.push(this.dSerialNumber);if(this.dGenTime==null){throw"genTime shall be specified."}e.push(this.dGenTime);if(this.dAccuracy!=null){e.push(this.dAccuracy)}if(this.dOrdering!=null){e.push(this.dOrdering)}if(this.dNonce!=null){e.push(this.dNonce)}if(this.dTsa!=null){e.push(this.dTsa)}var f=new a.DERSequence({array:e});this.hTLV=f.getEncodedHex();return this.hTLV};if(typeof c!="undefined"){if(typeof c.policy=="string"){if(!c.policy.match(/^[0-9.]+$/)){throw"policy shall be oid like 0.1.4.134"}this.dPolicy=new a.DERObjectIdentifier({oid:c.policy})}if(typeof c.messageImprint!="undefined"){this.dMessageImprint=new b.MessageImprint(c.messageImprint)}if(typeof c.serialNumber!="undefined"){this.dSerialNumber=new a.DERInteger(c.serialNumber)}if(typeof c.genTime!="undefined"){this.dGenTime=new a.DERGeneralizedTime(c.genTime)}if(typeof c.accuracy!="undefind"){this.dAccuracy=new b.Accuracy(c.accuracy)}if(typeof c.ordering!="undefined"&&c.ordering==true){this.dOrdering=new a.DERBoolean()}if(typeof c.nonce!="undefined"){this.dNonce=new a.DERInteger(c.nonce)}if(typeof c.tsa!="undefined"){this.dTsa=new d.X500Name(c.tsa)}}};YAHOO.lang.extend(KJUR.asn1.tsp.TSTInfo,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.TimeStampResp=function(c){KJUR.asn1.tsp.TimeStampResp.superclass.constructor.call(this);var a=KJUR.asn1;var b=KJUR.asn1.tsp;this.dStatus=null;this.dTST=null;this.getEncodedHex=function(){if(this.dStatus==null){throw"status shall be specified"}var d=[this.dStatus];if(this.dTST!=null){d.push(this.dTST)}var e=new a.DERSequence({array:d});this.hTLV=e.getEncodedHex();return this.hTLV};if(typeof c!="undefined"){if(typeof c.status=="object"){this.dStatus=new b.PKIStatusInfo(c.status)}if(typeof c.tst!="undefined"&&c.tst instanceof KJUR.asn1.ASN1Object){this.dTST=c.tst.getContentInfo()}}};YAHOO.lang.extend(KJUR.asn1.tsp.TimeStampResp,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIStatusInfo=function(c){KJUR.asn1.tsp.PKIStatusInfo.superclass.constructor.call(this);var a=KJUR.asn1;var b=KJUR.asn1.tsp;this.dStatus=null;this.dStatusString=null;this.dFailureInfo=null;this.getEncodedHex=function(){if(this.dStatus==null){throw"status shall be specified"}var d=[this.dStatus];if(this.dStatusString!=null){d.push(this.dStatusString)}if(this.dFailureInfo!=null){d.push(this.dFailureInfo)}var e=new a.DERSequence({array:d});this.hTLV=e.getEncodedHex();return this.hTLV};if(typeof c!="undefined"){if(typeof c.status=="object"){this.dStatus=new b.PKIStatus(c.status)}if(typeof c.statstr=="object"){this.dStatusString=new b.PKIFreeText({array:c.statstr})}if(typeof c.failinfo=="object"){this.dFailureInfo=new b.PKIFailureInfo(c.failinfo)}}};YAHOO.lang.extend(KJUR.asn1.tsp.PKIStatusInfo,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIStatus=function(e){KJUR.asn1.tsp.PKIStatus.superclass.constructor.call(this);var a=KJUR.asn1;var b=KJUR.asn1.tsp;var d=null;this.getEncodedHex=function(){this.hTLV=this.dStatus.getEncodedHex();return this.hTLV};if(typeof e!="undefined"){if(typeof e.name!="undefined"){var c=b.PKIStatus.valueList;if(typeof c[e.name]=="undefined"){throw"name undefined: "+e.name}this.dStatus=new a.DERInteger({"int":c[e.name]})}else{this.dStatus=new a.DERInteger(e)}}};YAHOO.lang.extend(KJUR.asn1.tsp.PKIStatus,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIStatus.valueList={granted:0,grantedWithMods:1,rejection:2,waiting:3,revocationWarning:4,revocationNotification:5};KJUR.asn1.tsp.PKIFreeText=function(b){KJUR.asn1.tsp.PKIFreeText.superclass.constructor.call(this);var a=KJUR.asn1;this.textList=[];this.getEncodedHex=function(){var c=[];for(var e=0;e<this.textList.length;e++){c.push(new a.DERUTF8String({str:this.textList[e]}))}var d=new a.DERSequence({array:c});this.hTLV=d.getEncodedHex();return this.hTLV};if(typeof b!="undefined"){if(typeof b.array=="object"){this.textList=b.array}}};YAHOO.lang.extend(KJUR.asn1.tsp.PKIFreeText,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIFailureInfo=function(d){KJUR.asn1.tsp.PKIFailureInfo.superclass.constructor.call(this);var a=KJUR.asn1;var b=KJUR.asn1.tsp;this.value=null;this.getEncodedHex=function(){if(this.value==null){throw"value shall be specified"}var e=new Number(this.value).toString(2);var f=new a.DERBitString();f.setByBinaryString(e);this.hTLV=f.getEncodedHex();return this.hTLV};if(typeof d!="undefined"){if(typeof d.name=="string"){var c=b.PKIFailureInfo.valueList;if(typeof c[d.name]=="undefined"){throw"name undefined: "+d.name}this.value=c[d.name]}else{if(typeof d["int"]=="number"){this.value=d["int"]}}}};YAHOO.lang.extend(KJUR.asn1.tsp.PKIFailureInfo,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIFailureInfo.valueList={badAlg:0,badRequest:2,badDataFormat:5,timeNotAvailable:14,unacceptedPolicy:15,unacceptedExtension:16,addInfoNotAvailable:17,systemFailure:25};KJUR.asn1.tsp.AbstractTSAAdapter=function(a){this.getTSTHex=function(c,b){throw"not implemented yet"}};KJUR.asn1.tsp.SimpleTSAAdapter=function(a){KJUR.asn1.tsp.SimpleTSAAdapter.superclass.constructor.call(this);this.params=null;this.serial=0;this.getTSTHex=function(c,b){var e=KJUR.crypto.Util.hashHex(c,b);this.params.tstInfo.messageImprint={hashAlg:b,hashValue:e};this.params.tstInfo.serialNumber={"int":this.serial++};var d=Math.floor(Math.random()*1000000000);this.params.tstInfo.nonce={"int":d};var f=KJUR.asn1.tsp.TSPUtil.newTimeStampToken(this.params);return f.getContentInfoEncodedHex()};if(typeof a!="undefined"){this.params=a}};YAHOO.lang.extend(KJUR.asn1.tsp.SimpleTSAAdapter,KJUR.asn1.tsp.AbstractTSAAdapter);KJUR.asn1.tsp.FixedTSAAdapter=function(a){KJUR.asn1.tsp.FixedTSAAdapter.superclass.constructor.call(this);this.params=null;this.getTSTHex=function(c,b){var d=KJUR.crypto.Util.hashHex(c,b);this.params.tstInfo.messageImprint={hashAlg:b,hashValue:d};var e=KJUR.asn1.tsp.TSPUtil.newTimeStampToken(this.params);return e.getContentInfoEncodedHex()};if(typeof a!="undefined"){this.params=a}};YAHOO.lang.extend(KJUR.asn1.tsp.FixedTSAAdapter,KJUR.asn1.tsp.AbstractTSAAdapter);KJUR.asn1.tsp.TSPUtil=new function(){};KJUR.asn1.tsp.TSPUtil.newTimeStampToken=function(b){var j=KJUR.asn1.cms;var a=KJUR.asn1.tsp;var g=new j.SignedData();var e=new a.TSTInfo(b.tstInfo);var f=e.getEncodedHex();g.dEncapContentInfo.setContentValue({hex:f});g.dEncapContentInfo.setContentType("tstinfo");if(typeof b.certs=="object"){for(var c=0;c<b.certs.length;c++){g.addCertificatesByPEM(b.certs[c])}}var d=g.signerInfoList[0];d.setSignerIdentifier(b.signerCert);d.setForContentAndHash({sdObj:g,eciObj:g.dEncapContentInfo,hashAlg:b.hashAlg});var h=new j.SigningCertificate({array:[b.signerCert]});d.dSignedAttrs.add(h);d.sign(b.signerPrvKey,b.sigAlg);return g};KJUR.asn1.tsp.TSPUtil.parseTimeStampReq=function(d){var f={};f.certreq=false;var h=ASN1HEX.getPosArrayOfChildren_AtObj(d,0);if(h.length<2){throw"TimeStampReq must have at least 2 items"}var c=ASN1HEX.getHexOfTLV_AtObj(d,h[1]);f.mi=KJUR.asn1.tsp.TSPUtil.parseMessageImprint(c);for(var e=2;e<h.length;e++){var b=h[e];var a=d.substr(b,2);if(a=="06"){var g=ASN1HEX.getHexOfV_AtObj(d,b);f.policy=ASN1HEX.hextooidstr(g)}if(a=="02"){f.nonce=ASN1HEX.getHexOfV_AtObj(d,b)}if(a=="01"){f.certreq=true}}return f};KJUR.asn1.tsp.TSPUtil.parseMessageImprint=function(c){var h={};if(c.substr(0,2)!="30"){throw"head of messageImprint hex shall be '30'"}var a=ASN1HEX.getPosArrayOfChildren_AtObj(c,0);var i=ASN1HEX.getDecendantIndexByNthList(c,0,[0,0]);var d=ASN1HEX.getHexOfV_AtObj(c,i);var e=ASN1HEX.hextooidstr(d);var g=KJUR.asn1.x509.OID.oid2name(e);if(g==""){throw"hashAlg name undefined: "+e}var b=g;var f=ASN1HEX.getDecendantIndexByNthList(c,0,[1]);h.hashAlg=b;h.hashValue=ASN1HEX.getHexOfV_AtObj(c,f);return h};
/*! asn1cades-1.0.0.js (c) 2013-2014 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}if(typeof KJUR.asn1.cades=="undefined"||!KJUR.asn1.cades){KJUR.asn1.cades={}}KJUR.asn1.cades.SignaturePolicyIdentifier=function(e){KJUR.asn1.cades.SignaturePolicyIdentifier.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.16.2.15";var b=KJUR.asn1;var d=KJUR.asn1.cades;if(typeof e!="undefined"){if(typeof e.oid=="string"&&typeof e.hash=="object"){var f=new b.DERObjectIdentifier({oid:e.oid});var a=new d.OtherHashAlgAndValue(e.hash);var c=new b.DERSequence({array:[f,a]});this.valueList=[c]}}};YAHOO.lang.extend(KJUR.asn1.cades.SignaturePolicyIdentifier,KJUR.asn1.cms.Attribute);KJUR.asn1.cades.OtherHashAlgAndValue=function(b){KJUR.asn1.cades.OtherHashAlgAndValue.superclass.constructor.call(this);var a=KJUR.asn1;var c=KJUR.asn1.x509;this.dAlg=null;this.dHash=null;this.getEncodedHex=function(){var d=new a.DERSequence({array:[this.dAlg,this.dHash]});this.hTLV=d.getEncodedHex();return this.hTLV};if(typeof b!="undefined"){if(typeof b.alg=="string"&&typeof b.hash=="string"){this.dAlg=new c.AlgorithmIdentifier({name:b.alg});this.dHash=new a.DEROctetString({hex:b.hash})}}};YAHOO.lang.extend(KJUR.asn1.cades.OtherHashAlgAndValue,KJUR.asn1.ASN1Object);KJUR.asn1.cades.SignatureTimeStamp=function(c){KJUR.asn1.cades.SignatureTimeStamp.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.16.2.14";this.tstHex=null;var a=KJUR.asn1;if(typeof c!="undefined"){if(typeof c.res!="undefined"){if(typeof c.res=="string"&&c.res.match(/^[0-9A-Fa-f]+$/)){}else{if(c.res instanceof KJUR.asn1.ASN1Object){}else{throw"res param shall be ASN1Object or hex string"}}}if(typeof c.tst!="undefined"){if(typeof c.tst=="string"&&c.tst.match(/^[0-9A-Fa-f]+$/)){var b=new a.ASN1Object();this.tstHex=c.tst;b.hTLV=this.tstHex;b.getEncodedHex();this.valueList=[b]}else{if(c.tst instanceof KJUR.asn1.ASN1Object){}else{throw"tst param shall be ASN1Object or hex string"}}}}};YAHOO.lang.extend(KJUR.asn1.cades.SignatureTimeStamp,KJUR.asn1.cms.Attribute);KJUR.asn1.cades.CompleteCertificateRefs=function(c){KJUR.asn1.cades.CompleteCertificateRefs.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.16.2.21";var a=KJUR.asn1;var b=KJUR.asn1.cades;this.setByArray=function(d){this.valueList=[];for(var e=0;e<d.length;e++){var f=new b.OtherCertID(d[e]);this.valueList.push(f)}};if(typeof c!="undefined"){if(typeof c=="object"&&typeof c.length=="number"){this.setByArray(c)}}};YAHOO.lang.extend(KJUR.asn1.cades.CompleteCertificateRefs,KJUR.asn1.cms.Attribute);KJUR.asn1.cades.OtherCertID=function(d){KJUR.asn1.cades.OtherCertID.superclass.constructor.call(this);var a=KJUR.asn1;var c=KJUR.asn1.cms;var b=KJUR.asn1.cades;this.hasIssuerSerial=true;this.dOtherCertHash=null;this.dIssuerSerial=null;this.setByCertPEM=function(e){this.dOtherCertHash=new b.OtherHash(e);if(this.hasIssuerSerial){this.dIssuerSerial=new c.IssuerAndSerialNumber(e)}};this.getEncodedHex=function(){if(this.hTLV!=null){return this.hTLV}if(this.dOtherCertHash==null){throw"otherCertHash not set"}var e=[this.dOtherCertHash];if(this.dIssuerSerial!=null){e.push(this.dIssuerSerial)}var f=new a.DERSequence({array:e});this.hTLV=f.getEncodedHex();return this.hTLV};if(typeof d!="undefined"){if(typeof d=="string"&&d.indexOf("-----BEGIN ")!=-1){this.setByCertPEM(d)}if(typeof d=="object"){if(d.hasis===false){this.hasIssuerSerial=false}if(typeof d.cert=="string"){this.setByCertPEM(d.cert)}}}};YAHOO.lang.extend(KJUR.asn1.cades.OtherCertID,KJUR.asn1.ASN1Object);KJUR.asn1.cades.OtherHash=function(c){KJUR.asn1.cades.OtherHash.superclass.constructor.call(this);var a=KJUR.asn1;var b=KJUR.asn1.cades;this.alg="sha256";this.dOtherHash=null;this.setByCertPEM=function(d){if(d.indexOf("-----BEGIN ")==-1){throw"certPEM not to seem PEM format"}var e=X509.pemToHex(d);var f=KJUR.crypto.Util.hashHex(e,this.alg);this.dOtherHash=new b.OtherHashAlgAndValue({alg:this.alg,hash:f})};this.getEncodedHex=function(){if(this.dOtherHash==null){throw"OtherHash not set"}return this.dOtherHash.getEncodedHex()};if(typeof c!="undefined"){if(typeof c=="string"){if(c.indexOf("-----BEGIN ")!=-1){this.setByCertPEM(c)}else{if(c.match(/^[0-9A-Fa-f]+$/)){this.dOtherHash=new a.DEROctetString({hex:c})}else{throw"unsupported string value for params"}}}else{if(typeof c=="object"){if(typeof c.cert=="string"){if(typeof c.alg=="string"){this.alg=c.alg}this.setByCertPEM(c.cert)}else{this.dOtherHash=new b.OtherHashAlgAndValue(c)}}}}};YAHOO.lang.extend(KJUR.asn1.cades.OtherHash,KJUR.asn1.ASN1Object);KJUR.asn1.cades.CAdESUtil=new function(){};KJUR.asn1.cades.CAdESUtil.addSigTS=function(c,b,a){};KJUR.asn1.cades.CAdESUtil.parseSignedDataForAddingUnsigned=function(d){var q=KJUR.asn1;var p=KJUR.asn1.cms;var c=KJUR.asn1.cades.CAdESUtil;var a={};if(ASN1HEX.getDecendantHexTLVByNthList(d,0,[0])!="06092a864886f70d010702"){throw"hex is not CMS SignedData"}var s=ASN1HEX.getDecendantIndexByNthList(d,0,[1,0]);var b=ASN1HEX.getPosArrayOfChildren_AtObj(d,s);if(b.length<4){throw"num of SignedData elem shall be 4 at least"}var f=b.shift();a.version=ASN1HEX.getHexOfTLV_AtObj(d,f);var l=b.shift();a.algs=ASN1HEX.getHexOfTLV_AtObj(d,l);var m=b.shift();a.encapcontent=ASN1HEX.getHexOfTLV_AtObj(d,m);a.certs=null;a.revs=null;a.si=[];var n=b.shift();if(d.substr(n,2)=="a0"){a.certs=ASN1HEX.getHexOfTLV_AtObj(d,n);n=b.shift()}if(d.substr(n,2)=="a1"){a.revs=ASN1HEX.getHexOfTLV_AtObj(d,n);n=b.shift()}var k=n;if(d.substr(k,2)!="31"){throw"Can't find signerInfos"}var j=ASN1HEX.getPosArrayOfChildren_AtObj(d,k);for(var h=0;h<j.length;h++){var o=j[h];var e=c.parseSignerInfoForAddingUnsigned(d,o,h);a.si[h]=e}var g=null;a.obj=new p.SignedData();g=new q.ASN1Object();g.hTLV=a.version;a.obj.dCMSVersion=g;g=new q.ASN1Object();g.hTLV=a.algs;a.obj.dDigestAlgs=g;g=new q.ASN1Object();g.hTLV=a.encapcontent;a.obj.dEncapContentInfo=g;g=new q.ASN1Object();g.hTLV=a.certs;a.obj.dCerts=g;a.obj.signerInfoList=[];for(var h=0;h<a.si.length;h++){a.obj.signerInfoList.push(a.si[h].obj)}return a};KJUR.asn1.cades.CAdESUtil.parseSignerInfoForAddingUnsigned=function(d,k,a){var m=KJUR.asn1;var l=KJUR.asn1.cms;var b={};var e=ASN1HEX.getPosArrayOfChildren_AtObj(d,k);if(e.length!=6){throw"not supported items for SignerInfo (!=6)"}var f=e.shift();b.version=ASN1HEX.getHexOfTLV_AtObj(d,f);var n=e.shift();b.si=ASN1HEX.getHexOfTLV_AtObj(d,n);var h=e.shift();b.digalg=ASN1HEX.getHexOfTLV_AtObj(d,h);var c=e.shift();b.sattrs=ASN1HEX.getHexOfTLV_AtObj(d,c);var i=e.shift();b.sigalg=ASN1HEX.getHexOfTLV_AtObj(d,i);var j=e.shift();b.sig=ASN1HEX.getHexOfTLV_AtObj(d,j);b.sigval=ASN1HEX.getHexOfV_AtObj(d,j);var g=null;b.obj=new l.SignerInfo();g=new m.ASN1Object();g.hTLV=b.version;b.obj.dCMSVersion=g;g=new m.ASN1Object();g.hTLV=b.si;b.obj.dSignerIdentifier=g;g=new m.ASN1Object();g.hTLV=b.digalg;b.obj.dDigestAlgorithm=g;g=new m.ASN1Object();g.hTLV=b.sattrs;b.obj.dSignedAttrs=g;g=new m.ASN1Object();g.hTLV=b.sigalg;b.obj.dSigAlg=g;g=new m.ASN1Object();g.hTLV=b.sig;b.obj.dSig=g;b.obj.dUnsignedAttrs=new l.AttributeList();return b};
/*! asn1csr-1.0.2.js (c) 2015-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR.asn1.csr=="undefined"||!KJUR.asn1.csr){KJUR.asn1.csr={}}KJUR.asn1.csr.CertificationRequest=function(f){KJUR.asn1.csr.CertificationRequest.superclass.constructor.call(this);var b=null;var d=null;var e=null;var c=null;var a=null;this.sign=function(i,h){if(this.prvKey==null){this.prvKey=h}this.asn1SignatureAlg=new KJUR.asn1.x509.AlgorithmIdentifier({name:i});sig=new KJUR.crypto.Signature({alg:i});sig.initSign(this.prvKey);sig.updateHex(this.asn1CSRInfo.getEncodedHex());this.hexSig=sig.sign();this.asn1Sig=new KJUR.asn1.DERBitString({hex:"00"+this.hexSig});var g=new KJUR.asn1.DERSequence({array:[this.asn1CSRInfo,this.asn1SignatureAlg,this.asn1Sig]});this.hTLV=g.getEncodedHex();this.isModified=false};this.getPEMString=function(){var g=KJUR.asn1.ASN1Util.getPEMStringFromHex(this.getEncodedHex(),"CERTIFICATE REQUEST");return g};this.getEncodedHex=function(){if(this.isModified==false&&this.hTLV!=null){return this.hTLV}throw"not signed yet"};if(typeof f!="undefined"){if(typeof f.csrinfo!="undefined"){this.asn1CSRInfo=f.csrinfo}}};YAHOO.lang.extend(KJUR.asn1.csr.CertificationRequest,KJUR.asn1.ASN1Object);KJUR.asn1.csr.CertificationRequestInfo=function(a){KJUR.asn1.csr.CertificationRequestInfo.superclass.constructor.call(this);this._initialize=function(){this.asn1Array=new Array();this.asn1Version=new KJUR.asn1.DERInteger({"int":0});this.asn1Subject=null;this.asn1SubjPKey=null;this.extensionsArray=new Array()};this.setSubjectByParam=function(b){this.asn1Subject=new KJUR.asn1.x509.X500Name(b)};this.setSubjectPublicKeyByGetKey=function(c){var b=KEYUTIL.getKey(c);this.asn1SubjPKey=new KJUR.asn1.x509.SubjectPublicKeyInfo(b)};this.appendExtensionByName=function(c,b){KJUR.asn1.x509.Extension.appendByNameToArray(c,b,this.extensionsArray)};this.getEncodedHex=function(){this.asn1Array=new Array();this.asn1Array.push(this.asn1Version);this.asn1Array.push(this.asn1Subject);this.asn1Array.push(this.asn1SubjPKey);if(this.extensionsArray.length>0){var e=new KJUR.asn1.DERSequence({array:this.extensionsArray});var d=new KJUR.asn1.DERSet({array:[e]});var c=new KJUR.asn1.DERSequence({array:[new KJUR.asn1.DERObjectIdentifier({oid:"1.2.840.113549.1.9.14"}),d]});var b=new KJUR.asn1.DERTaggedObject({explicit:true,tag:"a0",obj:c});this.asn1Array.push(b)}else{var b=new KJUR.asn1.DERTaggedObject({explicit:false,tag:"a0",obj:new KJUR.asn1.DERNull()});this.asn1Array.push(b)}var f=new KJUR.asn1.DERSequence({array:this.asn1Array});this.hTLV=f.getEncodedHex();this.isModified=false;return this.hTLV};this._initialize()};YAHOO.lang.extend(KJUR.asn1.csr.CertificationRequestInfo,KJUR.asn1.ASN1Object);KJUR.asn1.csr.CSRUtil=new function(){};KJUR.asn1.csr.CSRUtil.newCSRPEM=function(g){var d=KJUR.asn1.csr;if(g.subject===undefined){throw"parameter subject undefined"}if(g.sbjpubkey===undefined){throw"parameter sbjpubkey undefined"}if(g.sigalg===undefined){throw"parameter sigalg undefined"}if(g.sbjprvkey===undefined){throw"parameter sbjpubkey undefined"}var b=new d.CertificationRequestInfo();b.setSubjectByParam(g.subject);b.setSubjectPublicKeyByGetKey(g.sbjpubkey);if(g.ext!==undefined&&g.ext.length!==undefined){for(var c=0;c<g.ext.length;c++){for(key in g.ext[c]){b.appendExtensionByName(key,g.ext[c][key])}}}var e=new d.CertificationRequest({csrinfo:b});var a=KEYUTIL.getKey(g.sbjprvkey);e.sign(g.sigalg,a);var f=e.getPEMString();return f};KJUR.asn1.csr.CSRUtil.getInfo=function(b){var a={};a.subject={};a.pubkey={};if(b.indexOf("-----BEGIN CERTIFICATE REQUEST")==-1){throw"argument is not PEM file"}var c=KEYUTIL.getHexFromPEM(b,"CERTIFICATE REQUEST");a.subject.hex=ASN1HEX.getDecendantHexTLVByNthList(c,0,[0,1]);a.subject.name=X509.hex2dn(a.subject.hex);a.pubkey.hex=ASN1HEX.getDecendantHexTLVByNthList(c,0,[0,2]);a.pubkey.obj=KEYUTIL.getKey(a.pubkey.hex,null,"pkcs8pub");return a};
/*! asn1ocsp-1.0.1.js (c) 2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}if(typeof KJUR.asn1.ocsp=="undefined"||!KJUR.asn1.ocsp){KJUR.asn1.ocsp={}}KJUR.asn1.ocsp.DEFAULT_HASH="sha1";KJUR.asn1.ocsp.CertID=function(c){KJUR.asn1.ocsp.CertID.superclass.constructor.call(this);var a=KJUR.asn1;var e=KJUR.asn1.x509;this.dHashAlg=null;this.dIssuerNameHash=null;this.dIssuerKeyHash=null;this.dSerialNumber=null;this.setByValue=function(i,h,f,g){if(g===undefined){g=KJUR.asn1.ocsp.DEFAULT_HASH}this.dHashAlg=new e.AlgorithmIdentifier({name:g});this.dIssuerNameHash=new a.DEROctetString({hex:i});this.dIssuerKeyHash=new a.DEROctetString({hex:h});this.dSerialNumber=new a.DERInteger({hex:f})};this.setByCert=function(m,i,k){if(k===undefined){k=KJUR.asn1.ocsp.DEFAULT_HASH}var f=new X509();f.readCertPEM(i);var n=new X509();n.readCertPEM(m);var o=X509.getPublicKeyInfoPropOfCertPEM(m);var l=o.keyhex;var g=f.getSerialNumberHex();var h=KJUR.crypto.Util.hashHex(n.getSubjectHex(),k);var j=KJUR.crypto.Util.hashHex(l,k);this.setByValue(h,j,g,k);this.hoge=f.getSerialNumberHex()};this.getEncodedHex=function(){if(this.dHashAlg===null&&this.dIssuerNameHash===null&&this.dIssuerKeyHash===null&&this.dSerialNumber===null){throw"not yet set values"}var f=[this.dHashAlg,this.dIssuerNameHash,this.dIssuerKeyHash,this.dSerialNumber];var g=new a.DERSequence({array:f});this.hTLV=g.getEncodedHex();return this.hTLV};if(typeof c!=="undefined"){var b=c;if(typeof b.issuerCert!=="undefined"&&typeof b.subjectCert!=="undefined"){var d=KJUR.asn1.ocsp.DEFAULT_HASH;if(typeof b.alg==="undefined"){d=undefined}this.setByCert(b.issuerCert,b.subjectCert,d)}else{if(typeof b.namehash!=="undefined"&&typeof b.keyhash!=="undefined"&&typeof b.serial!=="undefined"){var d=KJUR.asn1.ocsp.DEFAULT_HASH;if(typeof b.alg==="undefined"){d=undefined}this.setByValue(b.namehash,b.keyhash,b.serial,d)}else{throw"invalid constructor arguments"}}}};YAHOO.lang.extend(KJUR.asn1.ocsp.CertID,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.Request=function(b){KJUR.asn1.ocsp.Request.superclass.constructor.call(this);this.dReqCert=null;this.dExt=null;this.getEncodedHex=function(){var c=[];if(this.dReqCert===null){throw"reqCert not set"}c.push(this.dReqCert);var d=new KJUR.asn1.DERSequence({array:c});this.hTLV=d.getEncodedHex();return this.hTLV};if(typeof b!=="undefined"){var a=new KJUR.asn1.ocsp.CertID(b);this.dReqCert=a}};YAHOO.lang.extend(KJUR.asn1.ocsp.Request,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.TBSRequest=function(a){KJUR.asn1.ocsp.TBSRequest.superclass.constructor.call(this);this.version=0;this.dRequestorName=null;this.dRequestList=[];this.dRequestExt=null;this.setRequestListByParam=function(d){var b=[];for(var c=0;c<d.length;c++){var e=new KJUR.asn1.ocsp.Request(d[0]);b.push(e)}this.dRequestList=b};this.getEncodedHex=function(){var b=[];if(this.version!==0){throw"not supported version: "+this.version}if(this.dRequestorName!==null){throw"requestorName not supported"}var d=new KJUR.asn1.DERSequence({array:this.dRequestList});b.push(d);if(this.dRequestExt!==null){throw"requestExtensions not supported"}var c=new KJUR.asn1.DERSequence({array:b});this.hTLV=c.getEncodedHex();return this.hTLV};if(typeof a!=="undefined"){if(typeof a.reqList!=="undefined"){this.setRequestListByParam(a.reqList)}}};YAHOO.lang.extend(KJUR.asn1.ocsp.TBSRequest,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.OCSPRequest=function(b){KJUR.asn1.ocsp.OCSPRequest.superclass.constructor.call(this);this.dTbsRequest=null;this.dOptionalSignature=null;this.getEncodedHex=function(){var c=[];if(this.dTbsRequest!==null){c.push(this.dTbsRequest)}else{throw"tbsRequest not set"}if(this.dOptionalSignature!==null){throw"optionalSignature not supported"}var d=new KJUR.asn1.DERSequence({array:c});this.hTLV=d.getEncodedHex();return this.hTLV};if(typeof b!=="undefined"){if(typeof b.reqList!=="undefined"){var a=new KJUR.asn1.ocsp.TBSRequest(b);this.dTbsRequest=a}}};YAHOO.lang.extend(KJUR.asn1.ocsp.OCSPRequest,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.OCSPUtil={};KJUR.asn1.ocsp.OCSPUtil.getRequestHex=function(a,b,e){if(e===undefined){e=KJUR.asn1.ocsp.DEFAULT_HASH}var d={alg:e,issuerCert:a,subjectCert:b};var c=new KJUR.asn1.ocsp.OCSPRequest({reqList:[d]});return c.getEncodedHex()};KJUR.asn1.ocsp.OCSPUtil.getOCSPResponseInfo=function(f){var a={};try{var b=ASN1HEX.getVbyList(f,0,[0],"0a");a.responseStatus=parseInt(b,16)}catch(d){}if(a.responseStatus!==0){return a}try{var e=ASN1HEX.getDecendantIndexByNthList(f,0,[1,0,1,0,0,2,0,1]);if(f.substr(e,2)==="80"){a.certStatus="good"}else{if(f.substr(e,2)==="a1"){a.certStatus="revoked";a.revocationTime=hextoutf8(ASN1HEX.getDecendantHexVByNthList(f,e,[0]))}else{if(f.substr(e,2)==="82"){a.certStatus="unknown"}}}}catch(d){}try{var c=ASN1HEX.getDecendantIndexByNthList(f,0,[1,0,1,0,0,2,0,2]);a.thisUpdate=hextoutf8(ASN1HEX.getHexOfV_AtObj(f,c))}catch(d){}try{var g=ASN1HEX.getDecendantIndexByNthList(f,0,[1,0,1,0,0,2,0,3]);if(f.substr(g,2)==="a0"){a.nextUpdate=hextoutf8(ASN1HEX.getDecendantHexVByNthList(f,g,[0]))}}catch(d){}return a};
/*! base64x-1.1.8 (c) 2012-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
var KJUR;if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.lang=="undefined"||!KJUR.lang){KJUR.lang={}}KJUR.lang.String=function(){};function Base64x(){}function stoBA(d){var b=new Array();for(var c=0;c<d.length;c++){b[c]=d.charCodeAt(c)}return b}function BAtos(b){var d="";for(var c=0;c<b.length;c++){d=d+String.fromCharCode(b[c])}return d}function BAtohex(b){var e="";for(var d=0;d<b.length;d++){var c=b[d].toString(16);if(c.length==1){c="0"+c}e=e+c}return e}function stohex(a){return BAtohex(stoBA(a))}function stob64(a){return hex2b64(stohex(a))}function stob64u(a){return b64tob64u(hex2b64(stohex(a)))}function b64utos(a){return BAtos(b64toBA(b64utob64(a)))}function b64tob64u(a){a=a.replace(/\=/g,"");a=a.replace(/\+/g,"-");a=a.replace(/\//g,"_");return a}function b64utob64(a){if(a.length%4==2){a=a+"=="}else{if(a.length%4==3){a=a+"="}}a=a.replace(/-/g,"+");a=a.replace(/_/g,"/");return a}function hextob64u(a){if(a.length%2==1){a="0"+a}return b64tob64u(hex2b64(a))}function b64utohex(a){return b64tohex(b64utob64(a))}var utf8tob64u,b64utoutf8;if(typeof Buffer==="function"){utf8tob64u=function(a){return b64tob64u(new Buffer(a,"utf8").toString("base64"))};b64utoutf8=function(a){return new Buffer(b64utob64(a),"base64").toString("utf8")}}else{utf8tob64u=function(a){return hextob64u(uricmptohex(encodeURIComponentAll(a)))};b64utoutf8=function(a){return decodeURIComponent(hextouricmp(b64utohex(a)))}}function utf8tob64(a){return hex2b64(uricmptohex(encodeURIComponentAll(a)))}function b64toutf8(a){return decodeURIComponent(hextouricmp(b64tohex(a)))}function utf8tohex(a){return uricmptohex(encodeURIComponentAll(a))}function hextoutf8(a){return decodeURIComponent(hextouricmp(a))}function hextorstr(c){var b="";for(var a=0;a<c.length-1;a+=2){b+=String.fromCharCode(parseInt(c.substr(a,2),16))}return b}function rstrtohex(c){var a="";for(var b=0;b<c.length;b++){a+=("0"+c.charCodeAt(b).toString(16)).slice(-2)}return a}function hextob64(a){return hex2b64(a)}function hextob64nl(b){var a=hextob64(b);var c=a.replace(/(.{64})/g,"$1\r\n");c=c.replace(/\r\n$/,"");return c}function b64nltohex(b){var a=b.replace(/[^0-9A-Za-z\/+=]*/g,"");var c=b64tohex(a);return c}function hextoArrayBuffer(d){if(d.length%2!=0){throw"input is not even length"}if(d.match(/^[0-9A-Fa-f]+$/)==null){throw"input is not hexadecimal"}var b=new ArrayBuffer(d.length/2);var a=new DataView(b);for(var c=0;c<d.length/2;c++){a.setUint8(c,parseInt(d.substr(c*2,2),16))}return b}function ArrayBuffertohex(b){var d="";var a=new DataView(b);for(var c=0;c<b.byteLength;c++){d+=("00"+a.getUint8(c).toString(16)).slice(-2)}return d}function uricmptohex(a){return a.replace(/%/g,"")}function hextouricmp(a){return a.replace(/(..)/g,"%$1")}function encodeURIComponentAll(a){var d=encodeURIComponent(a);var b="";for(var c=0;c<d.length;c++){if(d[c]=="%"){b=b+d.substr(c,3);c=c+2}else{b=b+"%"+stohex(d[c])}}return b}function newline_toUnix(a){a=a.replace(/\r\n/mg,"\n");return a}function newline_toDos(a){a=a.replace(/\r\n/mg,"\n");a=a.replace(/\n/mg,"\r\n");return a}KJUR.lang.String.isInteger=function(a){if(a.match(/^[0-9]+$/)){return true}else{if(a.match(/^-[0-9]+$/)){return true}else{return false}}};KJUR.lang.String.isHex=function(a){if(a.length%2==0&&(a.match(/^[0-9a-f]+$/)||a.match(/^[0-9A-F]+$/))){return true}else{return false}};KJUR.lang.String.isBase64=function(a){a=a.replace(/\s+/g,"");if(a.match(/^[0-9A-Za-z+\/]+={0,3}$/)&&a.length%4==0){return true}else{return false}};KJUR.lang.String.isBase64URL=function(a){if(a.match(/[+/=]/)){return false}a=b64utob64(a);return KJUR.lang.String.isBase64(a)};KJUR.lang.String.isIntegerArray=function(a){a=a.replace(/\s+/g,"");if(a.match(/^\[[0-9,]+\]$/)){return true}else{return false}};function intarystrtohex(b){b=b.replace(/^\s*\[\s*/,"");b=b.replace(/\s*\]\s*$/,"");b=b.replace(/\s*/g,"");try{var c=b.split(/,/).map(function(g,e,h){var f=parseInt(g);if(f<0||255<f){throw"integer not in range 0-255"}var d=("00"+f.toString(16)).slice(-2);return d}).join("");return c}catch(a){throw"malformed integer array string: "+a}}var strdiffidx=function(c,a){var d=c.length;if(c.length>a.length){d=a.length}for(var b=0;b<d;b++){if(c.charCodeAt(b)!=a.charCodeAt(b)){return b}}if(c.length!=a.length){return d}return -1};
/*! crypto-1.1.10.js (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={}}KJUR.crypto.Util=new function(){this.DIGESTINFOHEAD={sha1:"3021300906052b0e03021a05000414",sha224:"302d300d06096086480165030402040500041c",sha256:"3031300d060960864801650304020105000420",sha384:"3041300d060960864801650304020205000430",sha512:"3051300d060960864801650304020305000440",md2:"3020300c06082a864886f70d020205000410",md5:"3020300c06082a864886f70d020505000410",ripemd160:"3021300906052b2403020105000414",};this.DEFAULTPROVIDER={md5:"cryptojs",sha1:"cryptojs",sha224:"cryptojs",sha256:"cryptojs",sha384:"cryptojs",sha512:"cryptojs",ripemd160:"cryptojs",hmacmd5:"cryptojs",hmacsha1:"cryptojs",hmacsha224:"cryptojs",hmacsha256:"cryptojs",hmacsha384:"cryptojs",hmacsha512:"cryptojs",hmacripemd160:"cryptojs",MD5withRSA:"cryptojs/jsrsa",SHA1withRSA:"cryptojs/jsrsa",SHA224withRSA:"cryptojs/jsrsa",SHA256withRSA:"cryptojs/jsrsa",SHA384withRSA:"cryptojs/jsrsa",SHA512withRSA:"cryptojs/jsrsa",RIPEMD160withRSA:"cryptojs/jsrsa",MD5withECDSA:"cryptojs/jsrsa",SHA1withECDSA:"cryptojs/jsrsa",SHA224withECDSA:"cryptojs/jsrsa",SHA256withECDSA:"cryptojs/jsrsa",SHA384withECDSA:"cryptojs/jsrsa",SHA512withECDSA:"cryptojs/jsrsa",RIPEMD160withECDSA:"cryptojs/jsrsa",SHA1withDSA:"cryptojs/jsrsa",SHA224withDSA:"cryptojs/jsrsa",SHA256withDSA:"cryptojs/jsrsa",MD5withRSAandMGF1:"cryptojs/jsrsa",SHA1withRSAandMGF1:"cryptojs/jsrsa",SHA224withRSAandMGF1:"cryptojs/jsrsa",SHA256withRSAandMGF1:"cryptojs/jsrsa",SHA384withRSAandMGF1:"cryptojs/jsrsa",SHA512withRSAandMGF1:"cryptojs/jsrsa",RIPEMD160withRSAandMGF1:"cryptojs/jsrsa",};this.CRYPTOJSMESSAGEDIGESTNAME={md5:CryptoJS.algo.MD5,sha1:CryptoJS.algo.SHA1,sha224:CryptoJS.algo.SHA224,sha256:CryptoJS.algo.SHA256,sha384:CryptoJS.algo.SHA384,sha512:CryptoJS.algo.SHA512,ripemd160:CryptoJS.algo.RIPEMD160};this.getDigestInfoHex=function(a,b){if(typeof this.DIGESTINFOHEAD[b]=="undefined"){throw"alg not supported in Util.DIGESTINFOHEAD: "+b}return this.DIGESTINFOHEAD[b]+a};this.getPaddedDigestInfoHex=function(h,a,j){var c=this.getDigestInfoHex(h,a);var d=j/4;if(c.length+22>d){throw"key is too short for SigAlg: keylen="+j+","+a}var b="0001";var k="00"+c;var g="";var l=d-b.length-k.length;for(var f=0;f<l;f+=2){g+="ff"}var e=b+g+k;return e};this.hashString=function(a,c){var b=new KJUR.crypto.MessageDigest({alg:c});return b.digestString(a)};this.hashHex=function(b,c){var a=new KJUR.crypto.MessageDigest({alg:c});return a.digestHex(b)};this.sha1=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha1",prov:"cryptojs"});return b.digestString(a)};this.sha256=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha256",prov:"cryptojs"});return b.digestString(a)};this.sha256Hex=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha256",prov:"cryptojs"});return b.digestHex(a)};this.sha512=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha512",prov:"cryptojs"});return b.digestString(a)};this.sha512Hex=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha512",prov:"cryptojs"});return b.digestHex(a)};this.md5=function(a){var b=new KJUR.crypto.MessageDigest({alg:"md5",prov:"cryptojs"});return b.digestString(a)};this.ripemd160=function(a){var b=new KJUR.crypto.MessageDigest({alg:"ripemd160",prov:"cryptojs"});return b.digestString(a)};this.getCryptoJSMDByName=function(a){}};KJUR.crypto.MessageDigest=function(c){var b=null;var a=null;var d=null;this.setAlgAndProvider=function(g,f){g=KJUR.crypto.MessageDigest.getCanonicalAlgName(g);if(g!==null&&f===undefined){f=KJUR.crypto.Util.DEFAULTPROVIDER[g]}if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g)!=-1&&f=="cryptojs"){try{this.md=KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g].create()}catch(e){throw"setAlgAndProvider hash alg set fail alg="+g+"/"+e}this.updateString=function(h){this.md.update(h)};this.updateHex=function(h){var i=CryptoJS.enc.Hex.parse(h);this.md.update(i)};this.digest=function(){var h=this.md.finalize();return h.toString(CryptoJS.enc.Hex)};this.digestString=function(h){this.updateString(h);return this.digest()};this.digestHex=function(h){this.updateHex(h);return this.digest()}}if(":sha256:".indexOf(g)!=-1&&f=="sjcl"){try{this.md=new sjcl.hash.sha256()}catch(e){throw"setAlgAndProvider hash alg set fail alg="+g+"/"+e}this.updateString=function(h){this.md.update(h)};this.updateHex=function(i){var h=sjcl.codec.hex.toBits(i);this.md.update(h)};this.digest=function(){var h=this.md.finalize();return sjcl.codec.hex.fromBits(h)};this.digestString=function(h){this.updateString(h);return this.digest()};this.digestHex=function(h){this.updateHex(h);return this.digest()}}};this.updateString=function(e){throw"updateString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.updateHex=function(e){throw"updateHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digest=function(){throw"digest() not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digestString=function(e){throw"digestString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digestHex=function(e){throw"digestHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName};if(c!==undefined){if(c.alg!==undefined){this.algName=c.alg;if(c.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}this.setAlgAndProvider(this.algName,this.provName)}}};KJUR.crypto.MessageDigest.getCanonicalAlgName=function(a){if(typeof a==="string"){a=a.toLowerCase();a=a.replace(/-/,"")}return a};KJUR.crypto.MessageDigest.getHashLength=function(c){var b=KJUR.crypto.MessageDigest;var a=b.getCanonicalAlgName(c);if(b.HASHLENGTH[a]===undefined){throw"not supported algorithm: "+c}return b.HASHLENGTH[a]};KJUR.crypto.MessageDigest.HASHLENGTH={md5:16,sha1:20,sha224:28,sha256:32,sha384:48,sha512:64,ripemd160:20};KJUR.crypto.Mac=function(d){var f=null;var c=null;var a=null;var e=null;var b=null;this.setAlgAndProvider=function(k,i){k=k.toLowerCase();if(k==null){k="hmacsha1"}k=k.toLowerCase();if(k.substr(0,4)!="hmac"){throw"setAlgAndProvider unsupported HMAC alg: "+k}if(i===undefined){i=KJUR.crypto.Util.DEFAULTPROVIDER[k]}this.algProv=k+"/"+i;var g=k.substr(4);if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g)!=-1&&i=="cryptojs"){try{var j=KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g];this.mac=CryptoJS.algo.HMAC.create(j,this.pass)}catch(h){throw"setAlgAndProvider hash alg set fail hashAlg="+g+"/"+h}this.updateString=function(l){this.mac.update(l)};this.updateHex=function(l){var m=CryptoJS.enc.Hex.parse(l);this.mac.update(m)};this.doFinal=function(){var l=this.mac.finalize();return l.toString(CryptoJS.enc.Hex)};this.doFinalString=function(l){this.updateString(l);return this.doFinal()};this.doFinalHex=function(l){this.updateHex(l);return this.doFinal()}}};this.updateString=function(g){throw"updateString(str) not supported for this alg/prov: "+this.algProv};this.updateHex=function(g){throw"updateHex(hex) not supported for this alg/prov: "+this.algProv};this.doFinal=function(){throw"digest() not supported for this alg/prov: "+this.algProv};this.doFinalString=function(g){throw"digestString(str) not supported for this alg/prov: "+this.algProv};this.doFinalHex=function(g){throw"digestHex(hex) not supported for this alg/prov: "+this.algProv};this.setPassword=function(h){if(typeof h=="string"){var g=h;if(h.length%2==1||!h.match(/^[0-9A-Fa-f]+$/)){g=rstrtohex(h)}this.pass=CryptoJS.enc.Hex.parse(g);return}if(typeof h!="object"){throw"KJUR.crypto.Mac unsupported password type: "+h}var g=null;if(h.hex!==undefined){if(h.hex.length%2!=0||!h.hex.match(/^[0-9A-Fa-f]+$/)){throw"Mac: wrong hex password: "+h.hex}g=h.hex}if(h.utf8!==undefined){g=utf8tohex(h.utf8)}if(h.rstr!==undefined){g=rstrtohex(h.rstr)}if(h.b64!==undefined){g=b64tohex(h.b64)}if(h.b64u!==undefined){g=b64utohex(h.b64u)}if(g==null){throw"KJUR.crypto.Mac unsupported password type: "+h}this.pass=CryptoJS.enc.Hex.parse(g)};if(d!==undefined){if(d.pass!==undefined){this.setPassword(d.pass)}if(d.alg!==undefined){this.algName=d.alg;if(d.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}this.setAlgAndProvider(this.algName,this.provName)}}};KJUR.crypto.Signature=function(o){var q=null;var n=null;var r=null;var c=null;var l=null;var d=null;var k=null;var h=null;var p=null;var e=null;var b=-1;var g=null;var j=null;var a=null;var i=null;var f=null;this._setAlgNames=function(){var s=this.algName.match(/^(.+)with(.+)$/);if(s){this.mdAlgName=s[1].toLowerCase();this.pubkeyAlgName=s[2].toLowerCase()}};this._zeroPaddingOfSignature=function(x,w){var v="";var t=w/4-x.length;for(var u=0;u<t;u++){v=v+"0"}return v+x};this.setAlgAndProvider=function(u,t){this._setAlgNames();if(t!="cryptojs/jsrsa"){throw"provider not supported: "+t}if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName)!=-1){try{this.md=new KJUR.crypto.MessageDigest({alg:this.mdAlgName})}catch(s){throw"setAlgAndProvider hash alg set fail alg="+this.mdAlgName+"/"+s}this.init=function(w,x){var y=null;try{if(x===undefined){y=KEYUTIL.getKey(w)}else{y=KEYUTIL.getKey(w,x)}}catch(v){throw"init failed:"+v}if(y.isPrivate===true){this.prvKey=y;this.state="SIGN"}else{if(y.isPublic===true){this.pubKey=y;this.state="VERIFY"}else{throw"init failed.:"+y}}};this.initSign=function(v){if(typeof v.ecprvhex=="string"&&typeof v.eccurvename=="string"){this.ecprvhex=v.ecprvhex;this.eccurvename=v.eccurvename}else{this.prvKey=v}this.state="SIGN"};this.initVerifyByPublicKey=function(v){if(typeof v.ecpubhex=="string"&&typeof v.eccurvename=="string"){this.ecpubhex=v.ecpubhex;this.eccurvename=v.eccurvename}else{if(v instanceof KJUR.crypto.ECDSA){this.pubKey=v}else{if(v instanceof RSAKey){this.pubKey=v}}}this.state="VERIFY"};this.initVerifyByCertificatePEM=function(v){var w=new X509();w.readCertPEM(v);this.pubKey=w.subjectPublicKeyRSA;this.state="VERIFY"};this.updateString=function(v){this.md.updateString(v)};this.updateHex=function(v){this.md.updateHex(v)};this.sign=function(){this.sHashHex=this.md.digest();if(typeof this.ecprvhex!="undefined"&&typeof this.eccurvename!="undefined"){var v=new KJUR.crypto.ECDSA({curve:this.eccurvename});this.hSign=v.signHex(this.sHashHex,this.ecprvhex)}else{if(this.prvKey instanceof RSAKey&&this.pubkeyAlgName=="rsaandmgf1"){this.hSign=this.prvKey.signWithMessageHashPSS(this.sHashHex,this.mdAlgName,this.pssSaltLen)}else{if(this.prvKey instanceof RSAKey&&this.pubkeyAlgName=="rsa"){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex,this.mdAlgName)}else{if(this.prvKey instanceof KJUR.crypto.ECDSA){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex)}else{if(this.prvKey instanceof KJUR.crypto.DSA){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex)}else{throw"Signature: unsupported public key alg: "+this.pubkeyAlgName}}}}}return this.hSign};this.signString=function(v){this.updateString(v);return this.sign()};this.signHex=function(v){this.updateHex(v);return this.sign()};this.verify=function(v){this.sHashHex=this.md.digest();if(typeof this.ecpubhex!="undefined"&&typeof this.eccurvename!="undefined"){var w=new KJUR.crypto.ECDSA({curve:this.eccurvename});return w.verifyHex(this.sHashHex,v,this.ecpubhex)}else{if(this.pubKey instanceof RSAKey&&this.pubkeyAlgName=="rsaandmgf1"){return this.pubKey.verifyWithMessageHashPSS(this.sHashHex,v,this.mdAlgName,this.pssSaltLen)}else{if(this.pubKey instanceof RSAKey&&this.pubkeyAlgName=="rsa"){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{if(this.pubKey instanceof KJUR.crypto.ECDSA){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{if(this.pubKey instanceof KJUR.crypto.DSA){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{throw"Signature: unsupported public key alg: "+this.pubkeyAlgName}}}}}}}};this.init=function(s,t){throw"init(key, pass) not supported for this alg:prov="+this.algProvName};this.initVerifyByPublicKey=function(s){throw"initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov="+this.algProvName};this.initVerifyByCertificatePEM=function(s){throw"initVerifyByCertificatePEM(certPEM) not supported for this alg:prov="+this.algProvName};this.initSign=function(s){throw"initSign(prvKey) not supported for this alg:prov="+this.algProvName};this.updateString=function(s){throw"updateString(str) not supported for this alg:prov="+this.algProvName};this.updateHex=function(s){throw"updateHex(hex) not supported for this alg:prov="+this.algProvName};this.sign=function(){throw"sign() not supported for this alg:prov="+this.algProvName};this.signString=function(s){throw"digestString(str) not supported for this alg:prov="+this.algProvName};this.signHex=function(s){throw"digestHex(hex) not supported for this alg:prov="+this.algProvName};this.verify=function(s){throw"verify(hSigVal) not supported for this alg:prov="+this.algProvName};this.initParams=o;if(o!==undefined){if(o.alg!==undefined){this.algName=o.alg;if(o.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}else{this.provName=o.prov}this.algProvName=this.algName+":"+this.provName;this.setAlgAndProvider(this.algName,this.provName);this._setAlgNames()}if(o.psssaltlen!==undefined){this.pssSaltLen=o.psssaltlen}if(o.prvkeypem!==undefined){if(o.prvkeypas!==undefined){throw"both prvkeypem and prvkeypas parameters not supported"}else{try{var q=new RSAKey();q.readPrivateKeyFromPEMString(o.prvkeypem);this.initSign(q)}catch(m){throw"fatal error to load pem private key: "+m}}}}};KJUR.crypto.Cipher=function(a){};KJUR.crypto.Cipher.encrypt=function(e,f,d){if(f instanceof RSAKey&&f.isPublic){var c=KJUR.crypto.Cipher.getAlgByKeyAndName(f,d);if(c==="RSA"){return f.encrypt(e)}if(c==="RSAOAEP"){return f.encryptOAEP(e,"sha1")}var b=c.match(/^RSAOAEP(\d+)$/);if(b!==null){return f.encryptOAEP(e,"sha"+b[1])}throw"Cipher.encrypt: unsupported algorithm for RSAKey: "+d}else{throw"Cipher.encrypt: unsupported key or algorithm"}};KJUR.crypto.Cipher.decrypt=function(e,f,d){if(f instanceof RSAKey&&f.isPrivate){var c=KJUR.crypto.Cipher.getAlgByKeyAndName(f,d);if(c==="RSA"){return f.decrypt(e)}if(c==="RSAOAEP"){return f.decryptOAEP(e,"sha1")}var b=c.match(/^RSAOAEP(\d+)$/);if(b!==null){return f.decryptOAEP(e,"sha"+b[1])}throw"Cipher.decrypt: unsupported algorithm for RSAKey: "+d}else{throw"Cipher.decrypt: unsupported key or algorithm"}};KJUR.crypto.Cipher.getAlgByKeyAndName=function(b,a){if(b instanceof RSAKey){if(":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(a)!=-1){return a}if(a===null||a===undefined){return"RSA"}throw"getAlgByKeyAndName: not supported algorithm name for RSAKey: "+a}throw"getAlgByKeyAndName: not supported algorithm name: "+a};KJUR.crypto.OID=new function(){this.oidhex2name={"2a864886f70d010101":"rsaEncryption","2a8648ce3d0201":"ecPublicKey","2a8648ce380401":"dsa","2a8648ce3d030107":"secp256r1","2b8104001f":"secp192k1","2b81040021":"secp224r1","2b8104000a":"secp256k1","2b81040023":"secp521r1","2b81040022":"secp384r1","2a8648ce380403":"SHA1withDSA","608648016503040301":"SHA224withDSA","608648016503040302":"SHA256withDSA",}};
/*! ecdsa-modified-1.0.5.js (c) Stephan Thomas, Kenji Urushima | github.com/bitcoinjs/bitcoinjs-lib/blob/master/LICENSE
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={}}KJUR.crypto.ECDSA=function(h){var e="secp256r1";var g=null;var b=null;var f=null;var a=new SecureRandom();var d=null;this.type="EC";function c(s,o,r,n){var j=Math.max(o.bitLength(),n.bitLength());var t=s.add2D(r);var q=s.curve.getInfinity();for(var p=j-1;p>=0;--p){q=q.twice2D();q.z=BigInteger.ONE;if(o.testBit(p)){if(n.testBit(p)){q=q.add2D(t)}else{q=q.add2D(s)}}else{if(n.testBit(p)){q=q.add2D(r)}}}return q}this.getBigRandom=function(i){return new BigInteger(i.bitLength(),a).mod(i.subtract(BigInteger.ONE)).add(BigInteger.ONE)};this.setNamedCurve=function(i){this.ecparams=KJUR.crypto.ECParameterDB.getByName(i);this.prvKeyHex=null;this.pubKeyHex=null;this.curveName=i};this.setPrivateKeyHex=function(i){this.isPrivate=true;this.prvKeyHex=i};this.setPublicKeyHex=function(i){this.isPublic=true;this.pubKeyHex=i};this.getPublicKeyXYHex=function(){var k=this.pubKeyHex;if(k.substr(0,2)!=="04"){throw"this method supports uncompressed format(04) only"}var j=this.ecparams.keylen/4;if(k.length!==2+j*2){throw"malformed public key hex length"}var i={};i.x=k.substr(2,j);i.y=k.substr(2+j);return i};this.getShortNISTPCurveName=function(){var i=this.curveName;if(i==="secp256r1"||i==="NIST P-256"||i==="P-256"||i==="prime256v1"){return"P-256"}if(i==="secp384r1"||i==="NIST P-384"||i==="P-384"){return"P-384"}return null};this.generateKeyPairHex=function(){var k=this.ecparams.n;var n=this.getBigRandom(k);var l=this.ecparams.G.multiply(n);var q=l.getX().toBigInteger();var o=l.getY().toBigInteger();var i=this.ecparams.keylen/4;var m=("0000000000"+n.toString(16)).slice(-i);var r=("0000000000"+q.toString(16)).slice(-i);var p=("0000000000"+o.toString(16)).slice(-i);var j="04"+r+p;this.setPrivateKeyHex(m);this.setPublicKeyHex(j);return{ecprvhex:m,ecpubhex:j}};this.signWithMessageHash=function(i){return this.signHex(i,this.prvKeyHex)};this.signHex=function(o,j){var t=new BigInteger(j,16);var l=this.ecparams.n;var q=new BigInteger(o,16);do{var m=this.getBigRandom(l);var u=this.ecparams.G;var p=u.multiply(m);var i=p.getX().toBigInteger().mod(l)}while(i.compareTo(BigInteger.ZERO)<=0);var v=m.modInverse(l).multiply(q.add(t.multiply(i))).mod(l);return KJUR.crypto.ECDSA.biRSSigToASN1Sig(i,v)};this.sign=function(m,u){var q=u;var j=this.ecparams.n;var p=BigInteger.fromByteArrayUnsigned(m);do{var l=this.getBigRandom(j);var t=this.ecparams.G;var o=t.multiply(l);var i=o.getX().toBigInteger().mod(j)}while(i.compareTo(BigInteger.ZERO)<=0);var v=l.modInverse(j).multiply(p.add(q.multiply(i))).mod(j);return this.serializeSig(i,v)};this.verifyWithMessageHash=function(j,i){return this.verifyHex(j,i,this.pubKeyHex)};this.verifyHex=function(m,i,p){var l,j;var o=KJUR.crypto.ECDSA.parseSigHex(i);l=o.r;j=o.s;var k;k=ECPointFp.decodeFromHex(this.ecparams.curve,p);var n=new BigInteger(m,16);return this.verifyRaw(n,l,j,k)};this.verify=function(o,p,j){var l,i;if(Bitcoin.Util.isArray(p)){var n=this.parseSig(p);l=n.r;i=n.s}else{if("object"===typeof p&&p.r&&p.s){l=p.r;i=p.s}else{throw"Invalid value for signature"}}var k;if(j instanceof ECPointFp){k=j}else{if(Bitcoin.Util.isArray(j)){k=ECPointFp.decodeFrom(this.ecparams.curve,j)}else{throw"Invalid format for pubkey value, must be byte array or ECPointFp"}}var m=BigInteger.fromByteArrayUnsigned(o);return this.verifyRaw(m,l,i,k)};this.verifyRaw=function(o,i,w,m){var l=this.ecparams.n;var u=this.ecparams.G;if(i.compareTo(BigInteger.ONE)<0||i.compareTo(l)>=0){return false}if(w.compareTo(BigInteger.ONE)<0||w.compareTo(l)>=0){return false}var p=w.modInverse(l);var k=o.multiply(p).mod(l);var j=i.multiply(p).mod(l);var q=u.multiply(k).add(m.multiply(j));var t=q.getX().toBigInteger().mod(l);return t.equals(i)};this.serializeSig=function(k,j){var l=k.toByteArraySigned();var i=j.toByteArraySigned();var m=[];m.push(2);m.push(l.length);m=m.concat(l);m.push(2);m.push(i.length);m=m.concat(i);m.unshift(m.length);m.unshift(48);return m};this.parseSig=function(n){var m;if(n[0]!=48){throw new Error("Signature not a valid DERSequence")}m=2;if(n[m]!=2){throw new Error("First element in signature must be a DERInteger")}var l=n.slice(m+2,m+2+n[m+1]);m+=2+n[m+1];if(n[m]!=2){throw new Error("Second element in signature must be a DERInteger")}var i=n.slice(m+2,m+2+n[m+1]);m+=2+n[m+1];var k=BigInteger.fromByteArrayUnsigned(l);var j=BigInteger.fromByteArrayUnsigned(i);return{r:k,s:j}};this.parseSigCompact=function(m){if(m.length!==65){throw"Signature has the wrong length"}var j=m[0]-27;if(j<0||j>7){throw"Invalid signature type"}var o=this.ecparams.n;var l=BigInteger.fromByteArrayUnsigned(m.slice(1,33)).mod(o);var k=BigInteger.fromByteArrayUnsigned(m.slice(33,65)).mod(o);return{r:l,s:k,i:j}};if(h!==undefined){if(h.curve!==undefined){this.curveName=h.curve}}if(this.curveName===undefined){this.curveName=e}this.setNamedCurve(this.curveName);if(h!==undefined){if(h.prv!==undefined){this.setPrivateKeyHex(h.prv)}if(h.pub!==undefined){this.setPublicKeyHex(h.pub)}}};KJUR.crypto.ECDSA.parseSigHex=function(a){var b=KJUR.crypto.ECDSA.parseSigHexInHexRS(a);var d=new BigInteger(b.r,16);var c=new BigInteger(b.s,16);return{r:d,s:c}};KJUR.crypto.ECDSA.parseSigHexInHexRS=function(c){if(c.substr(0,2)!="30"){throw"signature is not a ASN.1 sequence"}var b=ASN1HEX.getPosArrayOfChildren_AtObj(c,0);if(b.length!=2){throw"number of signature ASN.1 sequence elements seem wrong"}var g=b[0];var f=b[1];if(c.substr(g,2)!="02"){throw"1st item of sequene of signature is not ASN.1 integer"}if(c.substr(f,2)!="02"){throw"2nd item of sequene of signature is not ASN.1 integer"}var e=ASN1HEX.getHexOfV_AtObj(c,g);var d=ASN1HEX.getHexOfV_AtObj(c,f);return{r:e,s:d}};KJUR.crypto.ECDSA.asn1SigToConcatSig=function(c){var d=KJUR.crypto.ECDSA.parseSigHexInHexRS(c);var b=d.r;var a=d.s;if(b.substr(0,2)=="00"&&(((b.length/2)*8)%(16*8))==8){b=b.substr(2)}if(a.substr(0,2)=="00"&&(((a.length/2)*8)%(16*8))==8){a=a.substr(2)}if((((b.length/2)*8)%(16*8))!=0){throw"unknown ECDSA sig r length error"}if((((a.length/2)*8)%(16*8))!=0){throw"unknown ECDSA sig s length error"}return b+a};KJUR.crypto.ECDSA.concatSigToASN1Sig=function(a){if((((a.length/2)*8)%(16*8))!=0){throw"unknown ECDSA concatinated r-s sig  length error"}var c=a.substr(0,a.length/2);var b=a.substr(a.length/2);return KJUR.crypto.ECDSA.hexRSSigToASN1Sig(c,b)};KJUR.crypto.ECDSA.hexRSSigToASN1Sig=function(b,a){var d=new BigInteger(b,16);var c=new BigInteger(a,16);return KJUR.crypto.ECDSA.biRSSigToASN1Sig(d,c)};KJUR.crypto.ECDSA.biRSSigToASN1Sig=function(e,c){var b=new KJUR.asn1.DERInteger({bigint:e});var a=new KJUR.asn1.DERInteger({bigint:c});var d=new KJUR.asn1.DERSequence({array:[b,a]});return d.getEncodedHex()};
/*! ecparam-1.0.0.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={}}KJUR.crypto.ECParameterDB=new function(){var b={};var c={};function a(d){return new BigInteger(d,16)}this.getByName=function(e){var d=e;if(typeof c[d]!="undefined"){d=c[e]}if(typeof b[d]!="undefined"){return b[d]}throw"unregistered EC curve name: "+d};this.regist=function(A,l,o,g,m,e,j,f,k,u,d,x){b[A]={};var s=a(o);var z=a(g);var y=a(m);var t=a(e);var w=a(j);var r=new ECCurveFp(s,z,y);var q=r.decodePointHex("04"+f+k);b[A]["name"]=A;b[A]["keylen"]=l;b[A]["curve"]=r;b[A]["G"]=q;b[A]["n"]=t;b[A]["h"]=w;b[A]["oid"]=d;b[A]["info"]=x;for(var v=0;v<u.length;v++){c[u[v]]=A}}};KJUR.crypto.ECParameterDB.regist("secp128r1",128,"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF","FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC","E87579C11079F43DD824993C2CEE5ED3","FFFFFFFE0000000075A30D1B9038A115","1","161FF7528B899B2D0C28607CA52C5B86","CF5AC8395BAFEB13C02DA292DDED7A83",[],"","secp128r1 : SECG curve over a 128 bit prime field");KJUR.crypto.ECParameterDB.regist("secp160k1",160,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73","0","7","0100000000000000000001B8FA16DFAB9ACA16B6B3","1","3B4C382CE37AA192A4019E763036F4F5DD4D7EBB","938CF935318FDCED6BC28286531733C3F03C4FEE",[],"","secp160k1 : SECG curve over a 160 bit prime field");KJUR.crypto.ECParameterDB.regist("secp160r1",160,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC","1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45","0100000000000000000001F4C8F927AED3CA752257","1","4A96B5688EF573284664698968C38BB913CBFC82","23A628553168947D59DCC912042351377AC5FB32",[],"","secp160r1 : SECG curve over a 160 bit prime field");KJUR.crypto.ECParameterDB.regist("secp192k1",192,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37","0","3","FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D","1","DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D","9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D",[]);KJUR.crypto.ECParameterDB.regist("secp192r1",192,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC","64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1","FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831","1","188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012","07192B95FFC8DA78631011ED6B24CDD573F977A11E794811",[]);KJUR.crypto.ECParameterDB.regist("secp224r1",224,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE","B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4","FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D","1","B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21","BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34",[]);KJUR.crypto.ECParameterDB.regist("secp256k1",256,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F","0","7","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141","1","79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798","483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8",[]);KJUR.crypto.ECParameterDB.regist("secp256r1",256,"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF","FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC","5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B","FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551","1","6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296","4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5",["NIST P-256","P-256","prime256v1"]);KJUR.crypto.ECParameterDB.regist("secp384r1",384,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC","B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973","1","AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7","3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f",["NIST P-384","P-384"]);KJUR.crypto.ECParameterDB.regist("secp521r1",521,"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC","051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00","1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409","1","C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66","011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650",["NIST P-521","P-521"]);
/*! dsa-modified-1.0.1.js (c) Recurity Labs GmbH, Kenji Urushimma | github.com/openpgpjs/openpgpjs/blob/master/LICENSE
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={}}KJUR.crypto.DSA=function(){this.p=null;this.q=null;this.g=null;this.y=null;this.x=null;this.type="DSA";this.setPrivate=function(z,w,v,A,u){this.isPrivate=true;this.p=z;this.q=w;this.g=v;this.y=A;this.x=u};this.setPublic=function(w,v,u,z){this.isPublic=true;this.p=w;this.q=v;this.g=u;this.y=z;this.x=null};this.signWithMessageHash=function(z){var v=this.p;var u=this.q;var C=this.g;var D=this.y;var E=this.x;var A=z.substr(0,u.bitLength()/4);var B=new BigInteger(z,16);var w=n(BigInteger.ONE.add(BigInteger.ONE),u.subtract(BigInteger.ONE));var G=(C.modPow(w,v)).mod(u);var F=(w.modInverse(u).multiply(B.add(E.multiply(G)))).mod(u);var H=KJUR.asn1.ASN1Util.jsonToASN1HEX({seq:[{"int":{bigint:G}},{"int":{bigint:F}}]});return H};this.verifyWithMessageHash=function(C,B){var z=this.p;var u=this.q;var G=this.g;var H=this.y;var E=this.parseASN1Signature(B);var K=E[0];var J=E[1];var C=C.substr(0,u.bitLength()/4);var D=new BigInteger(C,16);if(BigInteger.ZERO.compareTo(K)>0||K.compareTo(u)>0||BigInteger.ZERO.compareTo(J)>0||J.compareTo(u)>0){throw"invalid DSA signature"}var I=J.modInverse(u);var A=D.multiply(I).mod(u);var v=K.multiply(I).mod(u);var F=G.modPow(A,z).multiply(H.modPow(v,z)).mod(z).mod(u);return F.compareTo(K)==0};this.parseASN1Signature=function(u){try{var y=new BigInteger(ASN1HEX.getVbyList(u,0,[0],"02"),16);var v=new BigInteger(ASN1HEX.getVbyList(u,0,[1],"02"),16);return[y,v]}catch(w){throw"malformed DSA signature"}};function d(E,w,B,v,u,C){var z=KJUR.crypto.Util.hashString(w,E.toLowerCase());var z=z.substr(0,u.bitLength()/4);var A=new BigInteger(z,16);var y=n(BigInteger.ONE.add(BigInteger.ONE),u.subtract(BigInteger.ONE));var F=(B.modPow(y,v)).mod(u);var D=(y.modInverse(u).multiply(A.add(C.multiply(F)))).mod(u);var G=new Array();G[0]=F;G[1]=D;return G}function r(v){var u=openpgp.config.config.prefer_hash_algorithm;switch(Math.round(v.bitLength()/8)){case 20:if(u!=2&&u>11&&u!=10&&u<8){return 2}return u;case 28:if(u>11&&u<8){return 11}return u;case 32:if(u>10&&u<8){return 8}return u;default:util.print_debug("DSA select hash algorithm: returning null for an unknown length of q");return null}}this.select_hash_algorithm=r;function m(I,K,J,B,z,u,F,G){var C=KJUR.crypto.Util.hashString(B,I.toLowerCase());var C=C.substr(0,u.bitLength()/4);var D=new BigInteger(C,16);if(BigInteger.ZERO.compareTo(K)>0||K.compareTo(u)>0||BigInteger.ZERO.compareTo(J)>0||J.compareTo(u)>0){util.print_error("invalid DSA Signature");return null}var H=J.modInverse(u);var A=D.multiply(H).mod(u);var v=K.multiply(H).mod(u);var E=F.modPow(A,z).multiply(G.modPow(v,z)).mod(z).mod(u);return E.compareTo(K)==0}function a(z){var A=new BigInteger(z,primeCenterie);var y=j(q,512);var u=t(p,q,z);var v;do{v=new BigInteger(q.bitCount(),rand)}while(x.compareTo(BigInteger.ZERO)!=1&&x.compareTo(q)!=-1);var w=g.modPow(x,p);return{x:v,q:A,p:y,g:u,y:w}}function j(y,z,w){if(z%64!=0){return false}var u;var v;do{u=w(bitcount,true);v=u.subtract(BigInteger.ONE);u=u.subtract(v.remainder(y))}while(!u.isProbablePrime(primeCenterie)||u.bitLength()!=l);return u}function t(B,z,A,w){var u=B.subtract(BigInteger.ONE);var y=u.divide(z);var v;do{v=w(A)}while(v.compareTo(u)!=-1&&v.compareTo(BigInteger.ONE)!=1);return v.modPow(y,B)}function o(w,y,u){var v;do{v=u(y,false)}while(v.compareTo(w)!=-1&&v.compareTo(BigInteger.ZERO)!=1);return v}function i(v,w){k=o(v);var u=g.modPow(k,w).mod(v);return u}function h(B,w,y,v,z,u){var A=B(v);s=(w.modInverse(z).multiply(A.add(u.multiply(y)))).mod(z);return s}this.sign=d;this.verify=m;function n(w,u){if(u.compareTo(w)<=0){return}var v=u.subtract(w);var y=e(v.bitLength());while(y>v){y=e(v.bitLength())}return w.add(y)}function e(w){if(w<0){return null}var u=Math.floor((w+7)/8);var v=c(u);if(w%8>0){v=String.fromCharCode((Math.pow(2,w%8)-1)&v.charCodeAt(0))+v.substring(1)}return new BigInteger(f(v),16)}function c(w){var u="";for(var v=0;v<w;v++){u+=String.fromCharCode(b())}return u}function b(){var u=new Uint32Array(1);window.crypto.getRandomValues(u);return u[0]&255}function f(y){if(y==null){return""}var v=[];var w=y.length;var z=0;var u;while(z<w){u=y[z++].charCodeAt().toString(16);while(u.length<2){u="0"+u}v.push(""+u)}return v.join("")}this.getRandomBigIntegerInRange=n;this.getRandomBigInteger=e;this.getRandomBytes=c};
/*! pkcs5pkey-1.0.7.js (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
var PKCS5PKEY=function(){var c=function(n,p,o){return i(CryptoJS.AES,n,p,o)};var d=function(n,p,o){return i(CryptoJS.TripleDES,n,p,o)};var i=function(q,v,s,o){var p=CryptoJS.enc.Hex.parse(v);var u=CryptoJS.enc.Hex.parse(s);var n=CryptoJS.enc.Hex.parse(o);var r={};r.key=u;r.iv=n;r.ciphertext=p;var t=q.decrypt(r,u,{iv:n});return CryptoJS.enc.Hex.stringify(t)};var j=function(n,p,o){return e(CryptoJS.AES,n,p,o)};var m=function(n,p,o){return e(CryptoJS.TripleDES,n,p,o)};var e=function(s,x,v,p){var r=CryptoJS.enc.Hex.parse(x);var w=CryptoJS.enc.Hex.parse(v);var o=CryptoJS.enc.Hex.parse(p);var n={};var u=s.encrypt(r,w,{iv:o});var q=CryptoJS.enc.Hex.parse(u.toString());var t=CryptoJS.enc.Base64.stringify(q);return t};var g={"AES-256-CBC":{proc:c,eproc:j,keylen:32,ivlen:16},"AES-192-CBC":{proc:c,eproc:j,keylen:24,ivlen:16},"AES-128-CBC":{proc:c,eproc:j,keylen:16,ivlen:16},"DES-EDE3-CBC":{proc:d,eproc:m,keylen:24,ivlen:8}};var b=function(n){return g[n]["proc"]};var k=function(n){var p=CryptoJS.lib.WordArray.random(n);var o=CryptoJS.enc.Hex.stringify(p);return o};var l=function(t){var u={};var o=t.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)","m"));if(o){u.cipher=o[1];u.ivsalt=o[2]}var n=t.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));if(n){u.type=n[1]}var r=-1;var v=0;if(t.indexOf("\r\n\r\n")!=-1){r=t.indexOf("\r\n\r\n");v=2}if(t.indexOf("\n\n")!=-1){r=t.indexOf("\n\n");v=1}var q=t.indexOf("-----END");if(r!=-1&&q!=-1){var p=t.substring(r+v*2,q-v);p=p.replace(/\s+/g,"");u.data=p}return u};var h=function(o,w,n){var t=n.substring(0,16);var r=CryptoJS.enc.Hex.parse(t);var p=CryptoJS.enc.Utf8.parse(w);var s=g[o]["keylen"]+g[o]["ivlen"];var v="";var u=null;for(;;){var q=CryptoJS.algo.MD5.create();if(u!=null){q.update(u)}q.update(p);q.update(r);u=q.finalize();v=v+CryptoJS.enc.Hex.stringify(u);if(v.length>=s*2){break}}var x={};x.keyhex=v.substr(0,g[o]["keylen"]*2);x.ivhex=v.substr(g[o]["keylen"]*2,g[o]["ivlen"]*2);return x};var a=function(n,t,p,u){var q=CryptoJS.enc.Base64.parse(n);var o=CryptoJS.enc.Hex.stringify(q);var s=g[t]["proc"];var r=s(o,p,u);return r};var f=function(n,q,o,s){var p=g[q]["eproc"];var r=p(n,o,s);return r};return{version:"1.0.5",getHexFromPEM:function(o,r){var p=o;if(p.indexOf("BEGIN "+r)==-1){throw"can't find PEM header: "+r}p=p.replace("-----BEGIN "+r+"-----","");p=p.replace("-----END "+r+"-----","");var q=p.replace(/\s+/g,"");var n=b64tohex(q);return n},getDecryptedKeyHexByKeyIV:function(o,r,q,p){var n=b(r);return n(o,q,p)},parsePKCS5PEM:function(n){return l(n)},getKeyAndUnusedIvByPasscodeAndIvsalt:function(o,n,p){return h(o,n,p)},decryptKeyB64:function(n,p,o,q){return a(n,p,o,q)},getDecryptedKeyHex:function(w,v){var o=l(w);var r=o.type;var p=o.cipher;var n=o.ivsalt;var q=o.data;var u=h(p,v,n);var t=u.keyhex;var s=a(q,p,t,n);return s},getRSAKeyFromEncryptedPKCS5PEM:function(p,o){var q=this.getDecryptedKeyHex(p,o);var n=new RSAKey();n.readPrivateKeyFromASN1HexString(q);return n},getEryptedPKCS5PEMFromPrvKeyHex:function(q,x,r,p){var n="";if(typeof r=="undefined"||r==null){r="AES-256-CBC"}if(typeof g[r]=="undefined"){throw"PKCS5PKEY unsupported algorithm: "+r}if(typeof p=="undefined"||p==null){var t=g[r]["ivlen"];var s=k(t);p=s.toUpperCase()}var w=h(r,x,p);var v=w.keyhex;var u=f(q,r,v,p);var o=u.replace(/(.{64})/g,"$1\r\n");var n="-----BEGIN RSA PRIVATE KEY-----\r\n";n+="Proc-Type: 4,ENCRYPTED\r\n";n+="DEK-Info: "+r+","+p+"\r\n";n+="\r\n";n+=o;n+="\r\n-----END RSA PRIVATE KEY-----\r\n";return n},getEryptedPKCS5PEMFromRSAKey:function(C,D,o,s){var A=new KJUR.asn1.DERInteger({"int":0});var v=new KJUR.asn1.DERInteger({bigint:C.n});var z=new KJUR.asn1.DERInteger({"int":C.e});var B=new KJUR.asn1.DERInteger({bigint:C.d});var t=new KJUR.asn1.DERInteger({bigint:C.p});var r=new KJUR.asn1.DERInteger({bigint:C.q});var y=new KJUR.asn1.DERInteger({bigint:C.dmp1});var u=new KJUR.asn1.DERInteger({bigint:C.dmq1});var x=new KJUR.asn1.DERInteger({bigint:C.coeff});var E=new KJUR.asn1.DERSequence({array:[A,v,z,B,t,r,y,u,x]});var w=E.getEncodedHex();return this.getEryptedPKCS5PEMFromPrvKeyHex(w,D,o,s)},newEncryptedPKCS5PEM:function(n,o,r,s){if(typeof o=="undefined"||o==null){o=1024}if(typeof r=="undefined"||r==null){r="10001"}var p=new RSAKey();p.generate(o,r);var q=null;if(typeof s=="undefined"||s==null){q=this.getEncryptedPKCS5PEMFromRSAKey(pkey,n)}else{q=this.getEncryptedPKCS5PEMFromRSAKey(pkey,n,s)}return q},getRSAKeyFromPlainPKCS8PEM:function(p){if(p.match(/ENCRYPTED/)){throw"pem shall be not ENCRYPTED"}var o=this.getHexFromPEM(p,"PRIVATE KEY");var n=this.getRSAKeyFromPlainPKCS8Hex(o);return n},getRSAKeyFromPlainPKCS8Hex:function(q){var p=ASN1HEX.getPosArrayOfChildren_AtObj(q,0);if(p.length!=3){throw"outer DERSequence shall have 3 elements: "+p.length}var o=ASN1HEX.getHexOfTLV_AtObj(q,p[1]);if(o!="300d06092a864886f70d0101010500"){throw"PKCS8 AlgorithmIdentifier is not rsaEnc: "+o}var o=ASN1HEX.getHexOfTLV_AtObj(q,p[1]);var r=ASN1HEX.getHexOfTLV_AtObj(q,p[2]);var s=ASN1HEX.getHexOfV_AtObj(r,0);var n=new RSAKey();n.readPrivateKeyFromASN1HexString(s);return n},parseHexOfEncryptedPKCS8:function(u){var q={};var p=ASN1HEX.getPosArrayOfChildren_AtObj(u,0);if(p.length!=2){throw"malformed format: SEQUENCE(0).items != 2: "+p.length}q.ciphertext=ASN1HEX.getHexOfV_AtObj(u,p[1]);var w=ASN1HEX.getPosArrayOfChildren_AtObj(u,p[0]);if(w.length!=2){throw"malformed format: SEQUENCE(0.0).items != 2: "+w.length}if(ASN1HEX.getHexOfV_AtObj(u,w[0])!="2a864886f70d01050d"){throw"this only supports pkcs5PBES2"}var n=ASN1HEX.getPosArrayOfChildren_AtObj(u,w[1]);if(w.length!=2){throw"malformed format: SEQUENCE(0.0.1).items != 2: "+n.length}var o=ASN1HEX.getPosArrayOfChildren_AtObj(u,n[1]);if(o.length!=2){throw"malformed format: SEQUENCE(0.0.1.1).items != 2: "+o.length}if(ASN1HEX.getHexOfV_AtObj(u,o[0])!="2a864886f70d0307"){throw"this only supports TripleDES"}q.encryptionSchemeAlg="TripleDES";q.encryptionSchemeIV=ASN1HEX.getHexOfV_AtObj(u,o[1]);var r=ASN1HEX.getPosArrayOfChildren_AtObj(u,n[0]);if(r.length!=2){throw"malformed format: SEQUENCE(0.0.1.0).items != 2: "+r.length}if(ASN1HEX.getHexOfV_AtObj(u,r[0])!="2a864886f70d01050c"){throw"this only supports pkcs5PBKDF2"}var v=ASN1HEX.getPosArrayOfChildren_AtObj(u,r[1]);if(v.length<2){throw"malformed format: SEQUENCE(0.0.1.0.1).items < 2: "+v.length}q.pbkdf2Salt=ASN1HEX.getHexOfV_AtObj(u,v[0]);var s=ASN1HEX.getHexOfV_AtObj(u,v[1]);try{q.pbkdf2Iter=parseInt(s,16)}catch(t){throw"malformed format pbkdf2Iter: "+s}return q},getPBKDF2KeyHexFromParam:function(s,n){var r=CryptoJS.enc.Hex.parse(s.pbkdf2Salt);var o=s.pbkdf2Iter;var q=CryptoJS.PBKDF2(n,r,{keySize:192/32,iterations:o});var p=CryptoJS.enc.Hex.stringify(q);return p},getPlainPKCS8HexFromEncryptedPKCS8PEM:function(v,w){var p=this.getHexFromPEM(v,"ENCRYPTED PRIVATE KEY");var n=this.parseHexOfEncryptedPKCS8(p);var s=PKCS5PKEY.getPBKDF2KeyHexFromParam(n,w);var t={};t.ciphertext=CryptoJS.enc.Hex.parse(n.ciphertext);var r=CryptoJS.enc.Hex.parse(s);var q=CryptoJS.enc.Hex.parse(n.encryptionSchemeIV);var u=CryptoJS.TripleDES.decrypt(t,r,{iv:q});var o=CryptoJS.enc.Hex.stringify(u);return o},getRSAKeyFromEncryptedPKCS8PEM:function(q,p){var o=this.getPlainPKCS8HexFromEncryptedPKCS8PEM(q,p);var n=this.getRSAKeyFromPlainPKCS8Hex(o);return n},getKeyFromEncryptedPKCS8PEM:function(q,o){var n=this.getPlainPKCS8HexFromEncryptedPKCS8PEM(q,o);var p=this.getKeyFromPlainPrivatePKCS8Hex(n);return p},parsePlainPrivatePKCS8Hex:function(q){var o={};o.algparam=null;if(q.substr(0,2)!="30"){throw"malformed plain PKCS8 private key(code:001)"}var p=ASN1HEX.getPosArrayOfChildren_AtObj(q,0);if(p.length!=3){throw"malformed plain PKCS8 private key(code:002)"}if(q.substr(p[1],2)!="30"){throw"malformed PKCS8 private key(code:003)"}var n=ASN1HEX.getPosArrayOfChildren_AtObj(q,p[1]);if(n.length!=2){throw"malformed PKCS8 private key(code:004)"}if(q.substr(n[0],2)!="06"){throw"malformed PKCS8 private key(code:005)"}o.algoid=ASN1HEX.getHexOfV_AtObj(q,n[0]);if(q.substr(n[1],2)=="06"){o.algparam=ASN1HEX.getHexOfV_AtObj(q,n[1])}if(q.substr(p[2],2)!="04"){throw"malformed PKCS8 private key(code:006)"}o.keyidx=ASN1HEX.getStartPosOfV_AtObj(q,p[2]);return o},getKeyFromPlainPrivatePKCS8PEM:function(o){var n=this.getHexFromPEM(o,"PRIVATE KEY");var p=this.getKeyFromPlainPrivatePKCS8Hex(n);return p},getKeyFromPlainPrivatePKCS8Hex:function(n){var p=this.parsePlainPrivatePKCS8Hex(n);if(p.algoid=="2a864886f70d010101"){this.parsePrivateRawRSAKeyHexAtObj(n,p);var o=p.key;var q=new RSAKey();q.setPrivateEx(o.n,o.e,o.d,o.p,o.q,o.dp,o.dq,o.co);return q}else{if(p.algoid=="2a8648ce3d0201"){this.parsePrivateRawECKeyHexAtObj(n,p);if(KJUR.crypto.OID.oidhex2name[p.algparam]===undefined){throw"KJUR.crypto.OID.oidhex2name undefined: "+p.algparam}var r=KJUR.crypto.OID.oidhex2name[p.algparam];var q=new KJUR.crypto.ECDSA({curve:r,prv:p.key});return q}else{throw"unsupported private key algorithm"}}},getRSAKeyFromPublicPKCS8PEM:function(o){var p=this.getHexFromPEM(o,"PUBLIC KEY");var n=this.getRSAKeyFromPublicPKCS8Hex(p);return n},getKeyFromPublicPKCS8PEM:function(o){var p=this.getHexFromPEM(o,"PUBLIC KEY");var n=this.getKeyFromPublicPKCS8Hex(p);return n},getKeyFromPublicPKCS8Hex:function(o){var n=this.parsePublicPKCS8Hex(o);if(n.algoid=="2a864886f70d010101"){var r=this.parsePublicRawRSAKeyHex(n.key);var p=new RSAKey();p.setPublic(r.n,r.e);return p}else{if(n.algoid=="2a8648ce3d0201"){if(KJUR.crypto.OID.oidhex2name[n.algparam]===undefined){throw"KJUR.crypto.OID.oidhex2name undefined: "+n.algparam}var q=KJUR.crypto.OID.oidhex2name[n.algparam];var p=new KJUR.crypto.ECDSA({curve:q,pub:n.key});return p}else{throw"unsupported public key algorithm"}}},parsePublicRawRSAKeyHex:function(p){var n={};if(p.substr(0,2)!="30"){throw"malformed RSA key(code:001)"}var o=ASN1HEX.getPosArrayOfChildren_AtObj(p,0);if(o.length!=2){throw"malformed RSA key(code:002)"}if(p.substr(o[0],2)!="02"){throw"malformed RSA key(code:003)"}n.n=ASN1HEX.getHexOfV_AtObj(p,o[0]);if(p.substr(o[1],2)!="02"){throw"malformed RSA key(code:004)"}n.e=ASN1HEX.getHexOfV_AtObj(p,o[1]);return n},parsePrivateRawRSAKeyHexAtObj:function(o,q){var p=q.keyidx;if(o.substr(p,2)!="30"){throw"malformed RSA private key(code:001)"}var n=ASN1HEX.getPosArrayOfChildren_AtObj(o,p);if(n.length!=9){throw"malformed RSA private key(code:002)"}q.key={};q.key.n=ASN1HEX.getHexOfV_AtObj(o,n[1]);q.key.e=ASN1HEX.getHexOfV_AtObj(o,n[2]);q.key.d=ASN1HEX.getHexOfV_AtObj(o,n[3]);q.key.p=ASN1HEX.getHexOfV_AtObj(o,n[4]);q.key.q=ASN1HEX.getHexOfV_AtObj(o,n[5]);q.key.dp=ASN1HEX.getHexOfV_AtObj(o,n[6]);q.key.dq=ASN1HEX.getHexOfV_AtObj(o,n[7]);q.key.co=ASN1HEX.getHexOfV_AtObj(o,n[8])},parsePrivateRawECKeyHexAtObj:function(o,q){var p=q.keyidx;if(o.substr(p,2)!="30"){throw"malformed ECC private key(code:001)"}var n=ASN1HEX.getPosArrayOfChildren_AtObj(o,p);if(n.length!=3){throw"malformed ECC private key(code:002)"}if(o.substr(n[1],2)!="04"){throw"malformed ECC private key(code:003)"}q.key=ASN1HEX.getHexOfV_AtObj(o,n[1])},parsePublicPKCS8Hex:function(q){var o={};o.algparam=null;var p=ASN1HEX.getPosArrayOfChildren_AtObj(q,0);if(p.length!=2){throw"outer DERSequence shall have 2 elements: "+p.length}var r=p[0];if(q.substr(r,2)!="30"){throw"malformed PKCS8 public key(code:001)"}var n=ASN1HEX.getPosArrayOfChildren_AtObj(q,r);if(n.length!=2){throw"malformed PKCS8 public key(code:002)"}if(q.substr(n[0],2)!="06"){throw"malformed PKCS8 public key(code:003)"}o.algoid=ASN1HEX.getHexOfV_AtObj(q,n[0]);if(q.substr(n[1],2)=="06"){o.algparam=ASN1HEX.getHexOfV_AtObj(q,n[1])}if(q.substr(p[1],2)!="03"){throw"malformed PKCS8 public key(code:004)"}o.key=ASN1HEX.getHexOfV_AtObj(q,p[1]).substr(2);return o},getRSAKeyFromPublicPKCS8Hex:function(r){var q=ASN1HEX.getPosArrayOfChildren_AtObj(r,0);if(q.length!=2){throw"outer DERSequence shall have 2 elements: "+q.length}var p=ASN1HEX.getHexOfTLV_AtObj(r,q[0]);if(p!="300d06092a864886f70d0101010500"){throw"PKCS8 AlgorithmId is not rsaEncryption"}if(r.substr(q[1],2)!="03"){throw"PKCS8 Public Key is not BITSTRING encapslated."}var t=ASN1HEX.getStartPosOfV_AtObj(r,q[1])+2;if(r.substr(t,2)!="30"){throw"PKCS8 Public Key is not SEQUENCE."}var n=ASN1HEX.getPosArrayOfChildren_AtObj(r,t);if(n.length!=2){throw"inner DERSequence shall have 2 elements: "+n.length}if(r.substr(n[0],2)!="02"){throw"N is not ASN.1 INTEGER"}if(r.substr(n[1],2)!="02"){throw"E is not ASN.1 INTEGER"}var u=ASN1HEX.getHexOfV_AtObj(r,n[0]);var s=ASN1HEX.getHexOfV_AtObj(r,n[1]);var o=new RSAKey();o.setPublic(u,s);return o},}}();
/*! keyutil-1.0.14.js (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
var KEYUTIL=function(){var d=function(p,r,q){return k(CryptoJS.AES,p,r,q)};var e=function(p,r,q){return k(CryptoJS.TripleDES,p,r,q)};var a=function(p,r,q){return k(CryptoJS.DES,p,r,q)};var k=function(s,x,u,q){var r=CryptoJS.enc.Hex.parse(x);var w=CryptoJS.enc.Hex.parse(u);var p=CryptoJS.enc.Hex.parse(q);var t={};t.key=w;t.iv=p;t.ciphertext=r;var v=s.decrypt(t,w,{iv:p});return CryptoJS.enc.Hex.stringify(v)};var l=function(p,r,q){return g(CryptoJS.AES,p,r,q)};var o=function(p,r,q){return g(CryptoJS.TripleDES,p,r,q)};var f=function(p,r,q){return g(CryptoJS.DES,p,r,q)};var g=function(t,y,v,q){var s=CryptoJS.enc.Hex.parse(y);var x=CryptoJS.enc.Hex.parse(v);var p=CryptoJS.enc.Hex.parse(q);var w=t.encrypt(s,x,{iv:p});var r=CryptoJS.enc.Hex.parse(w.toString());var u=CryptoJS.enc.Base64.stringify(r);return u};var i={"AES-256-CBC":{proc:d,eproc:l,keylen:32,ivlen:16},"AES-192-CBC":{proc:d,eproc:l,keylen:24,ivlen:16},"AES-128-CBC":{proc:d,eproc:l,keylen:16,ivlen:16},"DES-EDE3-CBC":{proc:e,eproc:o,keylen:24,ivlen:8},"DES-CBC":{proc:a,eproc:f,keylen:8,ivlen:8}};var c=function(p){return i[p]["proc"]};var m=function(p){var r=CryptoJS.lib.WordArray.random(p);var q=CryptoJS.enc.Hex.stringify(r);return q};var n=function(v){var w={};var q=v.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)","m"));if(q){w.cipher=q[1];w.ivsalt=q[2]}var p=v.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));if(p){w.type=p[1]}var u=-1;var x=0;if(v.indexOf("\r\n\r\n")!=-1){u=v.indexOf("\r\n\r\n");x=2}if(v.indexOf("\n\n")!=-1){u=v.indexOf("\n\n");x=1}var t=v.indexOf("-----END");if(u!=-1&&t!=-1){var r=v.substring(u+x*2,t-x);r=r.replace(/\s+/g,"");w.data=r}return w};var j=function(q,y,p){var v=p.substring(0,16);var t=CryptoJS.enc.Hex.parse(v);var r=CryptoJS.enc.Utf8.parse(y);var u=i[q]["keylen"]+i[q]["ivlen"];var x="";var w=null;for(;;){var s=CryptoJS.algo.MD5.create();if(w!=null){s.update(w)}s.update(r);s.update(t);w=s.finalize();x=x+CryptoJS.enc.Hex.stringify(w);if(x.length>=u*2){break}}var z={};z.keyhex=x.substr(0,i[q]["keylen"]*2);z.ivhex=x.substr(i[q]["keylen"]*2,i[q]["ivlen"]*2);return z};var b=function(p,v,r,w){var s=CryptoJS.enc.Base64.parse(p);var q=CryptoJS.enc.Hex.stringify(s);var u=i[v]["proc"];var t=u(q,r,w);return t};var h=function(p,s,q,u){var r=i[s]["eproc"];var t=r(p,q,u);return t};return{version:"1.0.0",getHexFromPEM:function(q,u){var r=q;if(r.indexOf("-----BEGIN ")==-1){throw"can't find PEM header: "+u}if(typeof u=="string"&&u!=""){r=r.replace("-----BEGIN "+u+"-----","");r=r.replace("-----END "+u+"-----","")}else{r=r.replace(/-----BEGIN [^-]+-----/,"");r=r.replace(/-----END [^-]+-----/,"")}var t=r.replace(/\s+/g,"");var p=b64tohex(t);return p},getDecryptedKeyHexByKeyIV:function(q,t,s,r){var p=c(t);return p(q,s,r)},parsePKCS5PEM:function(p){return n(p)},getKeyAndUnusedIvByPasscodeAndIvsalt:function(q,p,r){return j(q,p,r)},decryptKeyB64:function(p,r,q,s){return b(p,r,q,s)},getDecryptedKeyHex:function(y,x){var q=n(y);var t=q.type;var r=q.cipher;var p=q.ivsalt;var s=q.data;var w=j(r,x,p);var v=w.keyhex;var u=b(s,r,v,p);return u},getRSAKeyFromEncryptedPKCS5PEM:function(r,q){var s=this.getDecryptedKeyHex(r,q);var p=new RSAKey();p.readPrivateKeyFromASN1HexString(s);return p},getEncryptedPKCS5PEMFromPrvKeyHex:function(x,s,A,t,r){var p="";if(typeof t=="undefined"||t==null){t="AES-256-CBC"}if(typeof i[t]=="undefined"){throw"KEYUTIL unsupported algorithm: "+t}if(typeof r=="undefined"||r==null){var v=i[t]["ivlen"];var u=m(v);r=u.toUpperCase()}var z=j(t,A,r);var y=z.keyhex;var w=h(s,t,y,r);var q=w.replace(/(.{64})/g,"$1\r\n");var p="-----BEGIN "+x+" PRIVATE KEY-----\r\n";p+="Proc-Type: 4,ENCRYPTED\r\n";p+="DEK-Info: "+t+","+r+"\r\n";p+="\r\n";p+=q;p+="\r\n-----END "+x+" PRIVATE KEY-----\r\n";return p},getEncryptedPKCS5PEMFromRSAKey:function(D,E,r,t){var B=new KJUR.asn1.DERInteger({"int":0});var w=new KJUR.asn1.DERInteger({bigint:D.n});var A=new KJUR.asn1.DERInteger({"int":D.e});var C=new KJUR.asn1.DERInteger({bigint:D.d});var u=new KJUR.asn1.DERInteger({bigint:D.p});var s=new KJUR.asn1.DERInteger({bigint:D.q});var z=new KJUR.asn1.DERInteger({bigint:D.dmp1});var v=new KJUR.asn1.DERInteger({bigint:D.dmq1});var y=new KJUR.asn1.DERInteger({bigint:D.coeff});var F=new KJUR.asn1.DERSequence({array:[B,w,A,C,u,s,z,v,y]});var x=F.getEncodedHex();return this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA",x,E,r,t)},newEncryptedPKCS5PEM:function(p,q,t,u){if(typeof q=="undefined"||q==null){q=1024}if(typeof t=="undefined"||t==null){t="10001"}var r=new RSAKey();r.generate(q,t);var s=null;if(typeof u=="undefined"||u==null){s=this.getEncryptedPKCS5PEMFromRSAKey(r,p)}else{s=this.getEncryptedPKCS5PEMFromRSAKey(r,p,u)}return s},getRSAKeyFromPlainPKCS8PEM:function(r){if(r.match(/ENCRYPTED/)){throw"pem shall be not ENCRYPTED"}var q=this.getHexFromPEM(r,"PRIVATE KEY");var p=this.getRSAKeyFromPlainPKCS8Hex(q);return p},getRSAKeyFromPlainPKCS8Hex:function(s){var r=ASN1HEX.getPosArrayOfChildren_AtObj(s,0);if(r.length!=3){throw"outer DERSequence shall have 3 elements: "+r.length}var q=ASN1HEX.getHexOfTLV_AtObj(s,r[1]);if(q!="300d06092a864886f70d0101010500"){throw"PKCS8 AlgorithmIdentifier is not rsaEnc: "+q}var q=ASN1HEX.getHexOfTLV_AtObj(s,r[1]);var t=ASN1HEX.getHexOfTLV_AtObj(s,r[2]);var u=ASN1HEX.getHexOfV_AtObj(t,0);var p=new RSAKey();p.readPrivateKeyFromASN1HexString(u);return p},parseHexOfEncryptedPKCS8:function(w){var s={};var r=ASN1HEX.getPosArrayOfChildren_AtObj(w,0);if(r.length!=2){throw"malformed format: SEQUENCE(0).items != 2: "+r.length}s.ciphertext=ASN1HEX.getHexOfV_AtObj(w,r[1]);var y=ASN1HEX.getPosArrayOfChildren_AtObj(w,r[0]);if(y.length!=2){throw"malformed format: SEQUENCE(0.0).items != 2: "+y.length}if(ASN1HEX.getHexOfV_AtObj(w,y[0])!="2a864886f70d01050d"){throw"this only supports pkcs5PBES2"}var p=ASN1HEX.getPosArrayOfChildren_AtObj(w,y[1]);if(y.length!=2){throw"malformed format: SEQUENCE(0.0.1).items != 2: "+p.length}var q=ASN1HEX.getPosArrayOfChildren_AtObj(w,p[1]);if(q.length!=2){throw"malformed format: SEQUENCE(0.0.1.1).items != 2: "+q.length}if(ASN1HEX.getHexOfV_AtObj(w,q[0])!="2a864886f70d0307"){throw"this only supports TripleDES"}s.encryptionSchemeAlg="TripleDES";s.encryptionSchemeIV=ASN1HEX.getHexOfV_AtObj(w,q[1]);var t=ASN1HEX.getPosArrayOfChildren_AtObj(w,p[0]);if(t.length!=2){throw"malformed format: SEQUENCE(0.0.1.0).items != 2: "+t.length}if(ASN1HEX.getHexOfV_AtObj(w,t[0])!="2a864886f70d01050c"){throw"this only supports pkcs5PBKDF2"}var x=ASN1HEX.getPosArrayOfChildren_AtObj(w,t[1]);if(x.length<2){throw"malformed format: SEQUENCE(0.0.1.0.1).items < 2: "+x.length}s.pbkdf2Salt=ASN1HEX.getHexOfV_AtObj(w,x[0]);var u=ASN1HEX.getHexOfV_AtObj(w,x[1]);try{s.pbkdf2Iter=parseInt(u,16)}catch(v){throw"malformed format pbkdf2Iter: "+u}return s},getPBKDF2KeyHexFromParam:function(u,p){var t=CryptoJS.enc.Hex.parse(u.pbkdf2Salt);var q=u.pbkdf2Iter;var s=CryptoJS.PBKDF2(p,t,{keySize:192/32,iterations:q});var r=CryptoJS.enc.Hex.stringify(s);return r},getPlainPKCS8HexFromEncryptedPKCS8PEM:function(x,y){var r=this.getHexFromPEM(x,"ENCRYPTED PRIVATE KEY");var p=this.parseHexOfEncryptedPKCS8(r);var u=KEYUTIL.getPBKDF2KeyHexFromParam(p,y);var v={};v.ciphertext=CryptoJS.enc.Hex.parse(p.ciphertext);var t=CryptoJS.enc.Hex.parse(u);var s=CryptoJS.enc.Hex.parse(p.encryptionSchemeIV);var w=CryptoJS.TripleDES.decrypt(v,t,{iv:s});var q=CryptoJS.enc.Hex.stringify(w);return q},getRSAKeyFromEncryptedPKCS8PEM:function(s,r){var q=this.getPlainPKCS8HexFromEncryptedPKCS8PEM(s,r);var p=this.getRSAKeyFromPlainPKCS8Hex(q);return p},getKeyFromEncryptedPKCS8PEM:function(s,q){var p=this.getPlainPKCS8HexFromEncryptedPKCS8PEM(s,q);var r=this.getKeyFromPlainPrivatePKCS8Hex(p);return r},parsePlainPrivatePKCS8Hex:function(s){var q={};q.algparam=null;if(s.substr(0,2)!="30"){throw"malformed plain PKCS8 private key(code:001)"}var r=ASN1HEX.getPosArrayOfChildren_AtObj(s,0);if(r.length!=3){throw"malformed plain PKCS8 private key(code:002)"}if(s.substr(r[1],2)!="30"){throw"malformed PKCS8 private key(code:003)"}var p=ASN1HEX.getPosArrayOfChildren_AtObj(s,r[1]);if(p.length!=2){throw"malformed PKCS8 private key(code:004)"}if(s.substr(p[0],2)!="06"){throw"malformed PKCS8 private key(code:005)"}q.algoid=ASN1HEX.getHexOfV_AtObj(s,p[0]);if(s.substr(p[1],2)=="06"){q.algparam=ASN1HEX.getHexOfV_AtObj(s,p[1])}if(s.substr(r[2],2)!="04"){throw"malformed PKCS8 private key(code:006)"}q.keyidx=ASN1HEX.getStartPosOfV_AtObj(s,r[2]);return q},getKeyFromPlainPrivatePKCS8PEM:function(q){var p=this.getHexFromPEM(q,"PRIVATE KEY");var r=this.getKeyFromPlainPrivatePKCS8Hex(p);return r},getKeyFromPlainPrivatePKCS8Hex:function(p){var w=this.parsePlainPrivatePKCS8Hex(p);if(w.algoid=="2a864886f70d010101"){this.parsePrivateRawRSAKeyHexAtObj(p,w);var u=w.key;var z=new RSAKey();z.setPrivateEx(u.n,u.e,u.d,u.p,u.q,u.dp,u.dq,u.co);return z}else{if(w.algoid=="2a8648ce3d0201"){this.parsePrivateRawECKeyHexAtObj(p,w);if(KJUR.crypto.OID.oidhex2name[w.algparam]===undefined){throw"KJUR.crypto.OID.oidhex2name undefined: "+w.algparam}var v=KJUR.crypto.OID.oidhex2name[w.algparam];var z=new KJUR.crypto.ECDSA({curve:v});z.setPublicKeyHex(w.pubkey);z.setPrivateKeyHex(w.key);z.isPublic=false;return z}else{if(w.algoid=="2a8648ce380401"){var t=ASN1HEX.getVbyList(p,0,[1,1,0],"02");var s=ASN1HEX.getVbyList(p,0,[1,1,1],"02");var y=ASN1HEX.getVbyList(p,0,[1,1,2],"02");var B=ASN1HEX.getVbyList(p,0,[2,0],"02");var r=new BigInteger(t,16);var q=new BigInteger(s,16);var x=new BigInteger(y,16);var A=new BigInteger(B,16);var z=new KJUR.crypto.DSA();z.setPrivate(r,q,x,null,A);return z}else{throw"unsupported private key algorithm"}}}},getRSAKeyFromPublicPKCS8PEM:function(q){var r=this.getHexFromPEM(q,"PUBLIC KEY");var p=this.getRSAKeyFromPublicPKCS8Hex(r);return p},getKeyFromPublicPKCS8PEM:function(q){var r=this.getHexFromPEM(q,"PUBLIC KEY");var p=this.getKeyFromPublicPKCS8Hex(r);return p},getKeyFromPublicPKCS8Hex:function(q){var p=this.parsePublicPKCS8Hex(q);if(p.algoid=="2a864886f70d010101"){var u=this.parsePublicRawRSAKeyHex(p.key);var r=new RSAKey();r.setPublic(u.n,u.e);return r}else{if(p.algoid=="2a8648ce3d0201"){if(KJUR.crypto.OID.oidhex2name[p.algparam]===undefined){throw"KJUR.crypto.OID.oidhex2name undefined: "+p.algparam}var s=KJUR.crypto.OID.oidhex2name[p.algparam];var r=new KJUR.crypto.ECDSA({curve:s,pub:p.key});return r}else{if(p.algoid=="2a8648ce380401"){var t=p.algparam;var v=ASN1HEX.getHexOfV_AtObj(p.key,0);var r=new KJUR.crypto.DSA();r.setPublic(new BigInteger(t.p,16),new BigInteger(t.q,16),new BigInteger(t.g,16),new BigInteger(v,16));return r}else{throw"unsupported public key algorithm"}}}},parsePublicRawRSAKeyHex:function(r){var p={};if(r.substr(0,2)!="30"){throw"malformed RSA key(code:001)"}var q=ASN1HEX.getPosArrayOfChildren_AtObj(r,0);if(q.length!=2){throw"malformed RSA key(code:002)"}if(r.substr(q[0],2)!="02"){throw"malformed RSA key(code:003)"}p.n=ASN1HEX.getHexOfV_AtObj(r,q[0]);if(r.substr(q[1],2)!="02"){throw"malformed RSA key(code:004)"}p.e=ASN1HEX.getHexOfV_AtObj(r,q[1]);return p},parsePrivateRawRSAKeyHexAtObj:function(q,s){var r=s.keyidx;if(q.substr(r,2)!="30"){throw"malformed RSA private key(code:001)"}var p=ASN1HEX.getPosArrayOfChildren_AtObj(q,r);if(p.length!=9){throw"malformed RSA private key(code:002)"}s.key={};s.key.n=ASN1HEX.getHexOfV_AtObj(q,p[1]);s.key.e=ASN1HEX.getHexOfV_AtObj(q,p[2]);s.key.d=ASN1HEX.getHexOfV_AtObj(q,p[3]);s.key.p=ASN1HEX.getHexOfV_AtObj(q,p[4]);s.key.q=ASN1HEX.getHexOfV_AtObj(q,p[5]);s.key.dp=ASN1HEX.getHexOfV_AtObj(q,p[6]);s.key.dq=ASN1HEX.getHexOfV_AtObj(q,p[7]);s.key.co=ASN1HEX.getHexOfV_AtObj(q,p[8])},parsePrivateRawECKeyHexAtObj:function(p,t){var q=t.keyidx;var r=ASN1HEX.getVbyList(p,q,[1],"04");var s=ASN1HEX.getVbyList(p,q,[2,0],"03").substr(2);t.key=r;t.pubkey=s},parsePublicPKCS8Hex:function(s){var q={};q.algparam=null;var r=ASN1HEX.getPosArrayOfChildren_AtObj(s,0);if(r.length!=2){throw"outer DERSequence shall have 2 elements: "+r.length}var t=r[0];if(s.substr(t,2)!="30"){throw"malformed PKCS8 public key(code:001)"}var p=ASN1HEX.getPosArrayOfChildren_AtObj(s,t);if(p.length!=2){throw"malformed PKCS8 public key(code:002)"}if(s.substr(p[0],2)!="06"){throw"malformed PKCS8 public key(code:003)"}q.algoid=ASN1HEX.getHexOfV_AtObj(s,p[0]);if(s.substr(p[1],2)=="06"){q.algparam=ASN1HEX.getHexOfV_AtObj(s,p[1])}else{if(s.substr(p[1],2)=="30"){q.algparam={};q.algparam.p=ASN1HEX.getVbyList(s,p[1],[0],"02");q.algparam.q=ASN1HEX.getVbyList(s,p[1],[1],"02");q.algparam.g=ASN1HEX.getVbyList(s,p[1],[2],"02")}}if(s.substr(r[1],2)!="03"){throw"malformed PKCS8 public key(code:004)"}q.key=ASN1HEX.getHexOfV_AtObj(s,r[1]).substr(2);return q},getRSAKeyFromPublicPKCS8Hex:function(t){var s=ASN1HEX.getPosArrayOfChildren_AtObj(t,0);if(s.length!=2){throw"outer DERSequence shall have 2 elements: "+s.length}var r=ASN1HEX.getHexOfTLV_AtObj(t,s[0]);if(r!="300d06092a864886f70d0101010500"){throw"PKCS8 AlgorithmId is not rsaEncryption"}if(t.substr(s[1],2)!="03"){throw"PKCS8 Public Key is not BITSTRING encapslated."}var v=ASN1HEX.getStartPosOfV_AtObj(t,s[1])+2;if(t.substr(v,2)!="30"){throw"PKCS8 Public Key is not SEQUENCE."}var p=ASN1HEX.getPosArrayOfChildren_AtObj(t,v);if(p.length!=2){throw"inner DERSequence shall have 2 elements: "+p.length}if(t.substr(p[0],2)!="02"){throw"N is not ASN.1 INTEGER"}if(t.substr(p[1],2)!="02"){throw"E is not ASN.1 INTEGER"}var w=ASN1HEX.getHexOfV_AtObj(t,p[0]);var u=ASN1HEX.getHexOfV_AtObj(t,p[1]);var q=new RSAKey();q.setPublic(w,u);return q},}}();KEYUTIL.getKey=function(f,e,h){if(typeof RSAKey!="undefined"&&f instanceof RSAKey){return f}if(typeof KJUR.crypto.ECDSA!="undefined"&&f instanceof KJUR.crypto.ECDSA){return f}if(typeof KJUR.crypto.DSA!="undefined"&&f instanceof KJUR.crypto.DSA){return f}if(f.curve!==undefined&&f.xy!==undefined&&f.d===undefined){return new KJUR.crypto.ECDSA({pub:f.xy,curve:f.curve})}if(f.curve!==undefined&&f.d!==undefined){return new KJUR.crypto.ECDSA({prv:f.d,curve:f.curve})}if(f.kty===undefined&&f.n!==undefined&&f.e!==undefined&&f.d===undefined){var w=new RSAKey();w.setPublic(f.n,f.e);return w}if(f.kty===undefined&&f.n!==undefined&&f.e!==undefined&&f.d!==undefined&&f.p!==undefined&&f.q!==undefined&&f.dp!==undefined&&f.dq!==undefined&&f.co!==undefined&&f.qi===undefined){var w=new RSAKey();w.setPrivateEx(f.n,f.e,f.d,f.p,f.q,f.dp,f.dq,f.co);return w}if(f.kty===undefined&&f.n!==undefined&&f.e!==undefined&&f.d!==undefined&&f.p===undefined){var w=new RSAKey();w.setPrivate(f.n,f.e,f.d);return w}if(f.p!==undefined&&f.q!==undefined&&f.g!==undefined&&f.y!==undefined&&f.x===undefined){var w=new KJUR.crypto.DSA();w.setPublic(f.p,f.q,f.g,f.y);return w}if(f.p!==undefined&&f.q!==undefined&&f.g!==undefined&&f.y!==undefined&&f.x!==undefined){var w=new KJUR.crypto.DSA();w.setPrivate(f.p,f.q,f.g,f.y,f.x);return w}if(f.kty==="RSA"&&f.n!==undefined&&f.e!==undefined&&f.d===undefined){var w=new RSAKey();w.setPublic(b64utohex(f.n),b64utohex(f.e));return w}if(f.kty==="RSA"&&f.n!==undefined&&f.e!==undefined&&f.d!==undefined&&f.p!==undefined&&f.q!==undefined&&f.dp!==undefined&&f.dq!==undefined&&f.qi!==undefined){var w=new RSAKey();w.setPrivateEx(b64utohex(f.n),b64utohex(f.e),b64utohex(f.d),b64utohex(f.p),b64utohex(f.q),b64utohex(f.dp),b64utohex(f.dq),b64utohex(f.qi));return w}if(f.kty==="RSA"&&f.n!==undefined&&f.e!==undefined&&f.d!==undefined){var w=new RSAKey();w.setPrivate(b64utohex(f.n),b64utohex(f.e),b64utohex(f.d));return w}if(f.kty==="EC"&&f.crv!==undefined&&f.x!==undefined&&f.y!==undefined&&f.d===undefined){var d=new KJUR.crypto.ECDSA({curve:f.crv});var l=d.ecparams.keylen/4;var r=("0000000000"+b64utohex(f.x)).slice(-l);var n=("0000000000"+b64utohex(f.y)).slice(-l);var m="04"+r+n;d.setPublicKeyHex(m);return d}if(f.kty==="EC"&&f.crv!==undefined&&f.x!==undefined&&f.y!==undefined&&f.d!==undefined){var d=new KJUR.crypto.ECDSA({curve:f.crv});var l=d.ecparams.keylen/4;var r=("0000000000"+b64utohex(f.x)).slice(-l);var n=("0000000000"+b64utohex(f.y)).slice(-l);var m="04"+r+n;var a=("0000000000"+b64utohex(f.d)).slice(-l);d.setPublicKeyHex(m);d.setPrivateKeyHex(a);return d}if(f.indexOf("-END CERTIFICATE-",0)!=-1||f.indexOf("-END X509 CERTIFICATE-",0)!=-1||f.indexOf("-END TRUSTED CERTIFICATE-",0)!=-1){return X509.getPublicKeyFromCertPEM(f)}if(h==="pkcs8pub"){return KEYUTIL.getKeyFromPublicPKCS8Hex(f)}if(f.indexOf("-END PUBLIC KEY-")!=-1){return KEYUTIL.getKeyFromPublicPKCS8PEM(f)}if(h==="pkcs5prv"){var w=new RSAKey();w.readPrivateKeyFromASN1HexString(f);return w}if(h==="pkcs5prv"){var w=new RSAKey();w.readPrivateKeyFromASN1HexString(f);return w}if(f.indexOf("-END RSA PRIVATE KEY-")!=-1&&f.indexOf("4,ENCRYPTED")==-1){var i=KEYUTIL.getHexFromPEM(f,"RSA PRIVATE KEY");return KEYUTIL.getKey(i,null,"pkcs5prv")}if(f.indexOf("-END DSA PRIVATE KEY-")!=-1&&f.indexOf("4,ENCRYPTED")==-1){var u=this.getHexFromPEM(f,"DSA PRIVATE KEY");var t=ASN1HEX.getVbyList(u,0,[1],"02");var s=ASN1HEX.getVbyList(u,0,[2],"02");var v=ASN1HEX.getVbyList(u,0,[3],"02");var j=ASN1HEX.getVbyList(u,0,[4],"02");var k=ASN1HEX.getVbyList(u,0,[5],"02");var w=new KJUR.crypto.DSA();w.setPrivate(new BigInteger(t,16),new BigInteger(s,16),new BigInteger(v,16),new BigInteger(j,16),new BigInteger(k,16));return w}if(f.indexOf("-END PRIVATE KEY-")!=-1){return KEYUTIL.getKeyFromPlainPrivatePKCS8PEM(f)}if(f.indexOf("-END RSA PRIVATE KEY-")!=-1&&f.indexOf("4,ENCRYPTED")!=-1){return KEYUTIL.getRSAKeyFromEncryptedPKCS5PEM(f,e)}if(f.indexOf("-END EC PRIVATE KEY-")!=-1&&f.indexOf("4,ENCRYPTED")!=-1){var u=KEYUTIL.getDecryptedKeyHex(f,e);var w=ASN1HEX.getVbyList(u,0,[1],"04");var c=ASN1HEX.getVbyList(u,0,[2,0],"06");var o=ASN1HEX.getVbyList(u,0,[3,0],"03").substr(2);var b="";if(KJUR.crypto.OID.oidhex2name[c]!==undefined){b=KJUR.crypto.OID.oidhex2name[c]}else{throw"undefined OID(hex) in KJUR.crypto.OID: "+c}var d=new KJUR.crypto.ECDSA({name:b});d.setPublicKeyHex(o);d.setPrivateKeyHex(w);d.isPublic=false;return d}if(f.indexOf("-END DSA PRIVATE KEY-")!=-1&&f.indexOf("4,ENCRYPTED")!=-1){var u=KEYUTIL.getDecryptedKeyHex(f,e);var t=ASN1HEX.getVbyList(u,0,[1],"02");var s=ASN1HEX.getVbyList(u,0,[2],"02");var v=ASN1HEX.getVbyList(u,0,[3],"02");var j=ASN1HEX.getVbyList(u,0,[4],"02");var k=ASN1HEX.getVbyList(u,0,[5],"02");var w=new KJUR.crypto.DSA();w.setPrivate(new BigInteger(t,16),new BigInteger(s,16),new BigInteger(v,16),new BigInteger(j,16),new BigInteger(k,16));return w}if(f.indexOf("-END ENCRYPTED PRIVATE KEY-")!=-1){return KEYUTIL.getKeyFromEncryptedPKCS8PEM(f,e)}throw"not supported argument"};KEYUTIL.generateKeypair=function(a,c){if(a=="RSA"){var b=c;var h=new RSAKey();h.generate(b,"10001");h.isPrivate=true;h.isPublic=true;var f=new RSAKey();var e=h.n.toString(16);var i=h.e.toString(16);f.setPublic(e,i);f.isPrivate=false;f.isPublic=true;var k={};k.prvKeyObj=h;k.pubKeyObj=f;return k}else{if(a=="EC"){var d=c;var g=new KJUR.crypto.ECDSA({curve:d});var j=g.generateKeyPairHex();var h=new KJUR.crypto.ECDSA({curve:d});h.setPublicKeyHex(j.ecpubhex);h.setPrivateKeyHex(j.ecprvhex);h.isPrivate=true;h.isPublic=false;var f=new KJUR.crypto.ECDSA({curve:d});f.setPublicKeyHex(j.ecpubhex);f.isPrivate=false;f.isPublic=true;var k={};k.prvKeyObj=h;k.pubKeyObj=f;return k}else{throw"unknown algorithm: "+a}}};KEYUTIL.getPEM=function(a,r,o,g,j){var v=KJUR.asn1;var u=KJUR.crypto;function p(s){var w=KJUR.asn1.ASN1Util.newObject({seq:[{"int":0},{"int":{bigint:s.n}},{"int":s.e},{"int":{bigint:s.d}},{"int":{bigint:s.p}},{"int":{bigint:s.q}},{"int":{bigint:s.dmp1}},{"int":{bigint:s.dmq1}},{"int":{bigint:s.coeff}}]});return w}function q(w){var s=KJUR.asn1.ASN1Util.newObject({seq:[{"int":1},{octstr:{hex:w.prvKeyHex}},{tag:["a0",true,{oid:{name:w.curveName}}]},{tag:["a1",true,{bitstr:{hex:"00"+w.pubKeyHex}}]}]});return s}function n(s){var w=KJUR.asn1.ASN1Util.newObject({seq:[{"int":0},{"int":{bigint:s.p}},{"int":{bigint:s.q}},{"int":{bigint:s.g}},{"int":{bigint:s.y}},{"int":{bigint:s.x}}]});return w}if(((typeof RSAKey!="undefined"&&a instanceof RSAKey)||(typeof u.DSA!="undefined"&&a instanceof u.DSA)||(typeof u.ECDSA!="undefined"&&a instanceof u.ECDSA))&&a.isPublic==true&&(r===undefined||r=="PKCS8PUB")){var t=new KJUR.asn1.x509.SubjectPublicKeyInfo(a);var m=t.getEncodedHex();return v.ASN1Util.getPEMStringFromHex(m,"PUBLIC KEY")}if(r=="PKCS1PRV"&&typeof RSAKey!="undefined"&&a instanceof RSAKey&&(o===undefined||o==null)&&a.isPrivate==true){var t=p(a);var m=t.getEncodedHex();return v.ASN1Util.getPEMStringFromHex(m,"RSA PRIVATE KEY")}if(r=="PKCS1PRV"&&typeof RSAKey!="undefined"&&a instanceof KJUR.crypto.ECDSA&&(o===undefined||o==null)&&a.isPrivate==true){var f=new KJUR.asn1.DERObjectIdentifier({name:a.curveName});var l=f.getEncodedHex();var e=q(a);var k=e.getEncodedHex();var i="";i+=v.ASN1Util.getPEMStringFromHex(l,"EC PARAMETERS");i+=v.ASN1Util.getPEMStringFromHex(k,"EC PRIVATE KEY");return i}if(r=="PKCS1PRV"&&typeof KJUR.crypto.DSA!="undefined"&&a instanceof KJUR.crypto.DSA&&(o===undefined||o==null)&&a.isPrivate==true){var t=n(a);var m=t.getEncodedHex();return v.ASN1Util.getPEMStringFromHex(m,"DSA PRIVATE KEY")}if(r=="PKCS5PRV"&&typeof RSAKey!="undefined"&&a instanceof RSAKey&&(o!==undefined&&o!=null)&&a.isPrivate==true){var t=p(a);var m=t.getEncodedHex();if(g===undefined){g="DES-EDE3-CBC"}return this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA",m,o,g)}if(r=="PKCS5PRV"&&typeof KJUR.crypto.ECDSA!="undefined"&&a instanceof KJUR.crypto.ECDSA&&(o!==undefined&&o!=null)&&a.isPrivate==true){var t=q(a);var m=t.getEncodedHex();if(g===undefined){g="DES-EDE3-CBC"}return this.getEncryptedPKCS5PEMFromPrvKeyHex("EC",m,o,g)}if(r=="PKCS5PRV"&&typeof KJUR.crypto.DSA!="undefined"&&a instanceof KJUR.crypto.DSA&&(o!==undefined&&o!=null)&&a.isPrivate==true){var t=n(a);var m=t.getEncodedHex();if(g===undefined){g="DES-EDE3-CBC"}return this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA",m,o,g)}var h=function(w,s){var y=b(w,s);var x=new KJUR.asn1.ASN1Util.newObject({seq:[{seq:[{oid:{name:"pkcs5PBES2"}},{seq:[{seq:[{oid:{name:"pkcs5PBKDF2"}},{seq:[{octstr:{hex:y.pbkdf2Salt}},{"int":y.pbkdf2Iter}]}]},{seq:[{oid:{name:"des-EDE3-CBC"}},{octstr:{hex:y.encryptionSchemeIV}}]}]}]},{octstr:{hex:y.ciphertext}}]});return x.getEncodedHex()};var b=function(D,E){var x=100;var C=CryptoJS.lib.WordArray.random(8);var B="DES-EDE3-CBC";var s=CryptoJS.lib.WordArray.random(8);var y=CryptoJS.PBKDF2(E,C,{keySize:192/32,iterations:x});var z=CryptoJS.enc.Hex.parse(D);var A=CryptoJS.TripleDES.encrypt(z,y,{iv:s})+"";var w={};w.ciphertext=A;w.pbkdf2Salt=CryptoJS.enc.Hex.stringify(C);w.pbkdf2Iter=x;w.encryptionSchemeAlg=B;w.encryptionSchemeIV=CryptoJS.enc.Hex.stringify(s);return w};if(r=="PKCS8PRV"&&typeof RSAKey!="undefined"&&a instanceof RSAKey&&a.isPrivate==true){var d=p(a);var c=d.getEncodedHex();var t=KJUR.asn1.ASN1Util.newObject({seq:[{"int":0},{seq:[{oid:{name:"rsaEncryption"}},{"null":true}]},{octstr:{hex:c}}]});var m=t.getEncodedHex();if(o===undefined||o==null){return v.ASN1Util.getPEMStringFromHex(m,"PRIVATE KEY")}else{var k=h(m,o);return v.ASN1Util.getPEMStringFromHex(k,"ENCRYPTED PRIVATE KEY")}}if(r=="PKCS8PRV"&&typeof KJUR.crypto.ECDSA!="undefined"&&a instanceof KJUR.crypto.ECDSA&&a.isPrivate==true){var d=new KJUR.asn1.ASN1Util.newObject({seq:[{"int":1},{octstr:{hex:a.prvKeyHex}},{tag:["a1",true,{bitstr:{hex:"00"+a.pubKeyHex}}]}]});var c=d.getEncodedHex();var t=KJUR.asn1.ASN1Util.newObject({seq:[{"int":0},{seq:[{oid:{name:"ecPublicKey"}},{oid:{name:a.curveName}}]},{octstr:{hex:c}}]});var m=t.getEncodedHex();if(o===undefined||o==null){return v.ASN1Util.getPEMStringFromHex(m,"PRIVATE KEY")}else{var k=h(m,o);return v.ASN1Util.getPEMStringFromHex(k,"ENCRYPTED PRIVATE KEY")}}if(r=="PKCS8PRV"&&typeof KJUR.crypto.DSA!="undefined"&&a instanceof KJUR.crypto.DSA&&a.isPrivate==true){var d=new KJUR.asn1.DERInteger({bigint:a.x});var c=d.getEncodedHex();var t=KJUR.asn1.ASN1Util.newObject({seq:[{"int":0},{seq:[{oid:{name:"dsa"}},{seq:[{"int":{bigint:a.p}},{"int":{bigint:a.q}},{"int":{bigint:a.g}}]}]},{octstr:{hex:c}}]});var m=t.getEncodedHex();if(o===undefined||o==null){return v.ASN1Util.getPEMStringFromHex(m,"PRIVATE KEY")}else{var k=h(m,o);return v.ASN1Util.getPEMStringFromHex(k,"ENCRYPTED PRIVATE KEY")}}throw"unsupported object nor format"};KEYUTIL.getKeyFromCSRPEM=function(b){var a=KEYUTIL.getHexFromPEM(b,"CERTIFICATE REQUEST");var c=KEYUTIL.getKeyFromCSRHex(a);return c};KEYUTIL.getKeyFromCSRHex=function(a){var c=KEYUTIL.parseCSRHex(a);var b=KEYUTIL.getKey(c.p8pubkeyhex,null,"pkcs8pub");return b};KEYUTIL.parseCSRHex=function(c){var b={};var e=c;if(e.substr(0,2)!="30"){throw"malformed CSR(code:001)"}var d=ASN1HEX.getPosArrayOfChildren_AtObj(e,0);if(d.length<1){throw"malformed CSR(code:002)"}if(e.substr(d[0],2)!="30"){throw"malformed CSR(code:003)"}var a=ASN1HEX.getPosArrayOfChildren_AtObj(e,d[0]);if(a.length<3){throw"malformed CSR(code:004)"}b.p8pubkeyhex=ASN1HEX.getHexOfTLV_AtObj(e,a[2]);return b};KEYUTIL.getJWKFromKey=function(d){var b={};if(d instanceof RSAKey&&d.isPrivate){b.kty="RSA";b.n=hextob64u(d.n.toString(16));b.e=hextob64u(d.e.toString(16));b.d=hextob64u(d.d.toString(16));b.p=hextob64u(d.p.toString(16));b.q=hextob64u(d.q.toString(16));b.dp=hextob64u(d.dmp1.toString(16));b.dq=hextob64u(d.dmq1.toString(16));b.qi=hextob64u(d.coeff.toString(16));return b}else{if(d instanceof RSAKey&&d.isPublic){b.kty="RSA";b.n=hextob64u(d.n.toString(16));b.e=hextob64u(d.e.toString(16));return b}else{if(d instanceof KJUR.crypto.ECDSA&&d.isPrivate){var a=d.getShortNISTPCurveName();if(a!=="P-256"&&a!=="P-384"){throw"unsupported curve name for JWT: "+a}var c=d.getPublicKeyXYHex();b.kty="EC";b.crv=a;b.x=hextob64u(c.x);b.y=hextob64u(c.y);b.d=hextob64u(d.prvKeyHex);return b}else{if(d instanceof KJUR.crypto.ECDSA&&d.isPublic){var a=d.getShortNISTPCurveName();if(a!=="P-256"&&a!=="P-384"){throw"unsupported curve name for JWT: "+a}var c=d.getPublicKeyXYHex();b.kty="EC";b.crv=a;b.x=hextob64u(c.x);b.y=hextob64u(c.y);return b}}}}throw"not supported key object"};
/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
function _rsapem_pemToBase64(b){var a=b;a=a.replace("-----BEGIN RSA PRIVATE KEY-----","");a=a.replace("-----END RSA PRIVATE KEY-----","");a=a.replace(/[ \n]+/g,"");return a}function _rsapem_getPosArrayOfChildrenFromHex(d){var j=new Array();var k=ASN1HEX.getStartPosOfV_AtObj(d,0);var f=ASN1HEX.getPosOfNextSibling_AtObj(d,k);var h=ASN1HEX.getPosOfNextSibling_AtObj(d,f);var b=ASN1HEX.getPosOfNextSibling_AtObj(d,h);var l=ASN1HEX.getPosOfNextSibling_AtObj(d,b);var e=ASN1HEX.getPosOfNextSibling_AtObj(d,l);var g=ASN1HEX.getPosOfNextSibling_AtObj(d,e);var c=ASN1HEX.getPosOfNextSibling_AtObj(d,g);var i=ASN1HEX.getPosOfNextSibling_AtObj(d,c);j.push(k,f,h,b,l,e,g,c,i);return j}function _rsapem_getHexValueArrayOfChildrenFromHex(i){var o=_rsapem_getPosArrayOfChildrenFromHex(i);var r=ASN1HEX.getHexOfV_AtObj(i,o[0]);var f=ASN1HEX.getHexOfV_AtObj(i,o[1]);var j=ASN1HEX.getHexOfV_AtObj(i,o[2]);var k=ASN1HEX.getHexOfV_AtObj(i,o[3]);var c=ASN1HEX.getHexOfV_AtObj(i,o[4]);var b=ASN1HEX.getHexOfV_AtObj(i,o[5]);var h=ASN1HEX.getHexOfV_AtObj(i,o[6]);var g=ASN1HEX.getHexOfV_AtObj(i,o[7]);var l=ASN1HEX.getHexOfV_AtObj(i,o[8]);var m=new Array();m.push(r,f,j,k,c,b,h,g,l);return m}function _rsapem_readPrivateKeyFromASN1HexString(c){var b=_rsapem_getHexValueArrayOfChildrenFromHex(c);this.setPrivateEx(b[1],b[2],b[3],b[4],b[5],b[6],b[7],b[8])}function _rsapem_readPrivateKeyFromPEMString(e){var c=_rsapem_pemToBase64(e);var d=b64tohex(c);var b=_rsapem_getHexValueArrayOfChildrenFromHex(d);this.setPrivateEx(b[1],b[2],b[3],b[4],b[5],b[6],b[7],b[8])}RSAKey.prototype.readPrivateKeyFromPEMString=_rsapem_readPrivateKeyFromPEMString;RSAKey.prototype.readPrivateKeyFromASN1HexString=_rsapem_readPrivateKeyFromASN1HexString;
/*! rsasign-1.2.7.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
var _RE_HEXDECONLY=new RegExp("");_RE_HEXDECONLY.compile("[^0-9a-f]","gi");function _rsasign_getHexPaddedDigestInfoForString(d,e,a){var b=function(f){return KJUR.crypto.Util.hashString(f,a)};var c=b(d);return KJUR.crypto.Util.getPaddedDigestInfoHex(c,a,e)}function _zeroPaddingOfSignature(e,d){var c="";var a=d/4-e.length;for(var b=0;b<a;b++){c=c+"0"}return c+e}function _rsasign_signString(d,a){var b=function(e){return KJUR.crypto.Util.hashString(e,a)};var c=b(d);return this.signWithMessageHash(c,a)}function _rsasign_signWithMessageHash(e,c){var f=KJUR.crypto.Util.getPaddedDigestInfoHex(e,c,this.n.bitLength());var b=parseBigInt(f,16);var d=this.doPrivate(b);var a=d.toString(16);return _zeroPaddingOfSignature(a,this.n.bitLength())}function _rsasign_signStringWithSHA1(a){return _rsasign_signString.call(this,a,"sha1")}function _rsasign_signStringWithSHA256(a){return _rsasign_signString.call(this,a,"sha256")}function pss_mgf1_str(c,a,e){var b="",d=0;while(b.length<a){b+=hextorstr(e(rstrtohex(c+String.fromCharCode.apply(String,[(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255]))));d+=1}return b}function _rsasign_signStringPSS(e,a,d){var c=function(f){return KJUR.crypto.Util.hashHex(f,a)};var b=c(rstrtohex(e));if(d===undefined){d=-1}return this.signWithMessageHashPSS(b,a,d)}function _rsasign_signWithMessageHashPSS(l,a,k){var b=hextorstr(l);var g=b.length;var m=this.n.bitLength()-1;var c=Math.ceil(m/8);var d;var o=function(i){return KJUR.crypto.Util.hashHex(i,a)};if(k===-1||k===undefined){k=g}else{if(k===-2){k=c-g-2}else{if(k<-2){throw"invalid salt length"}}}if(c<(g+k+2)){throw"data too long"}var f="";if(k>0){f=new Array(k);new SecureRandom().nextBytes(f);f=String.fromCharCode.apply(String,f)}var n=hextorstr(o(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00"+b+f)));var j=[];for(d=0;d<c-k-g-2;d+=1){j[d]=0}var e=String.fromCharCode.apply(String,j)+"\x01"+f;var h=pss_mgf1_str(n,e.length,o);var q=[];for(d=0;d<e.length;d+=1){q[d]=e.charCodeAt(d)^h.charCodeAt(d)}var p=(65280>>(8*c-m))&255;q[0]&=~p;for(d=0;d<g;d++){q.push(n.charCodeAt(d))}q.push(188);return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(q)).toString(16),this.n.bitLength())}function _rsasign_getDecryptSignatureBI(a,d,c){var b=new RSAKey();b.setPublic(d,c);var e=b.doPublic(a);return e}function _rsasign_getHexDigestInfoFromSig(a,c,b){var e=_rsasign_getDecryptSignatureBI(a,c,b);var d=e.toString(16).replace(/^1f+00/,"");return d}function _rsasign_getAlgNameAndHashFromHexDisgestInfo(f){for(var e in KJUR.crypto.Util.DIGESTINFOHEAD){var d=KJUR.crypto.Util.DIGESTINFOHEAD[e];var b=d.length;if(f.substring(0,b)==d){var c=[e,f.substring(b)];return c}}return[]}function _rsasign_verifySignatureWithArgs(f,b,g,j){var e=_rsasign_getHexDigestInfoFromSig(b,g,j);var h=_rsasign_getAlgNameAndHashFromHexDisgestInfo(e);if(h.length==0){return false}var d=h[0];var i=h[1];var a=function(k){return KJUR.crypto.Util.hashString(k,d)};var c=a(f);return(i==c)}function _rsasign_verifyHexSignatureForMessage(c,b){var d=parseBigInt(c,16);var a=_rsasign_verifySignatureWithArgs(b,d,this.n.toString(16),this.e.toString(16));return a}function _rsasign_verifyString(f,j){j=j.replace(_RE_HEXDECONLY,"");j=j.replace(/[ \n]+/g,"");var b=parseBigInt(j,16);if(b.bitLength()>this.n.bitLength()){return 0}var i=this.doPublic(b);var e=i.toString(16).replace(/^1f+00/,"");var g=_rsasign_getAlgNameAndHashFromHexDisgestInfo(e);if(g.length==0){return false}var d=g[0];var h=g[1];var a=function(k){return KJUR.crypto.Util.hashString(k,d)};var c=a(f);return(h==c)}function _rsasign_verifyWithMessageHash(e,a){a=a.replace(_RE_HEXDECONLY,"");a=a.replace(/[ \n]+/g,"");var b=parseBigInt(a,16);if(b.bitLength()>this.n.bitLength()){return 0}var h=this.doPublic(b);var g=h.toString(16).replace(/^1f+00/,"");var c=_rsasign_getAlgNameAndHashFromHexDisgestInfo(g);if(c.length==0){return false}var d=c[0];var f=c[1];return(f==e)}function _rsasign_verifyStringPSS(c,b,a,f){var e=function(g){return KJUR.crypto.Util.hashHex(g,a)};var d=e(rstrtohex(c));if(f===undefined){f=-1}return this.verifyWithMessageHashPSS(d,b,a,f)}function _rsasign_verifyWithMessageHashPSS(f,s,l,c){var k=new BigInteger(s,16);if(k.bitLength()>this.n.bitLength()){return false}var r=function(i){return KJUR.crypto.Util.hashHex(i,l)};var j=hextorstr(f);var h=j.length;var g=this.n.bitLength()-1;var m=Math.ceil(g/8);var q;if(c===-1||c===undefined){c=h}else{if(c===-2){c=m-h-2}else{if(c<-2){throw"invalid salt length"}}}if(m<(h+c+2)){throw"data too long"}var a=this.doPublic(k).toByteArray();for(q=0;q<a.length;q+=1){a[q]&=255}while(a.length<m){a.unshift(0)}if(a[m-1]!==188){throw"encoded message does not end in 0xbc"}a=String.fromCharCode.apply(String,a);var d=a.substr(0,m-h-1);var e=a.substr(d.length,h);var p=(65280>>(8*m-g))&255;if((d.charCodeAt(0)&p)!==0){throw"bits beyond keysize not zero"}var n=pss_mgf1_str(e,d.length,r);var o=[];for(q=0;q<d.length;q+=1){o[q]=d.charCodeAt(q)^n.charCodeAt(q)}o[0]&=~p;var b=m-h-c-2;for(q=0;q<b;q+=1){if(o[q]!==0){throw"leftmost octets not zero"}}if(o[b]!==1){throw"0x01 marker not found"}return e===hextorstr(r(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00"+j+String.fromCharCode.apply(String,o.slice(-c)))))}RSAKey.prototype.signWithMessageHash=_rsasign_signWithMessageHash;RSAKey.prototype.signString=_rsasign_signString;RSAKey.prototype.signStringWithSHA1=_rsasign_signStringWithSHA1;RSAKey.prototype.signStringWithSHA256=_rsasign_signStringWithSHA256;RSAKey.prototype.sign=_rsasign_signString;RSAKey.prototype.signWithSHA1=_rsasign_signStringWithSHA1;RSAKey.prototype.signWithSHA256=_rsasign_signStringWithSHA256;RSAKey.prototype.signWithMessageHashPSS=_rsasign_signWithMessageHashPSS;RSAKey.prototype.signStringPSS=_rsasign_signStringPSS;RSAKey.prototype.signPSS=_rsasign_signStringPSS;RSAKey.SALT_LEN_HLEN=-1;RSAKey.SALT_LEN_MAX=-2;RSAKey.prototype.verifyWithMessageHash=_rsasign_verifyWithMessageHash;RSAKey.prototype.verifyString=_rsasign_verifyString;RSAKey.prototype.verifyHexSignatureForMessage=_rsasign_verifyHexSignatureForMessage;RSAKey.prototype.verify=_rsasign_verifyString;RSAKey.prototype.verifyHexSignatureForByteArrayMessage=_rsasign_verifyHexSignatureForMessage;RSAKey.prototype.verifyWithMessageHashPSS=_rsasign_verifyWithMessageHashPSS;RSAKey.prototype.verifyStringPSS=_rsasign_verifyStringPSS;RSAKey.prototype.verifyPSS=_rsasign_verifyStringPSS;RSAKey.SALT_LEN_RECOVER=-2;
/*! x509-1.1.10.js (c) 2012-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
function X509(){this.subjectPublicKeyRSA=null;this.subjectPublicKeyRSA_hN=null;this.subjectPublicKeyRSA_hE=null;this.hex=null;this.getSerialNumberHex=function(){return ASN1HEX.getDecendantHexVByNthList(this.hex,0,[0,1])};this.getSignatureAlgorithmField=function(){var b=ASN1HEX.getDecendantHexVByNthList(this.hex,0,[0,2,0]);var a=KJUR.asn1.ASN1Util.oidHexToInt(b);var c=KJUR.asn1.x509.OID.oid2name(a);return c};this.getIssuerHex=function(){return ASN1HEX.getDecendantHexTLVByNthList(this.hex,0,[0,3])};this.getIssuerString=function(){return X509.hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex,0,[0,3]))};this.getSubjectHex=function(){return ASN1HEX.getDecendantHexTLVByNthList(this.hex,0,[0,5])};this.getSubjectString=function(){return X509.hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex,0,[0,5]))};this.getNotBefore=function(){var a=ASN1HEX.getDecendantHexVByNthList(this.hex,0,[0,4,0]);a=a.replace(/(..)/g,"%$1");a=decodeURIComponent(a);return a};this.getNotAfter=function(){var a=ASN1HEX.getDecendantHexVByNthList(this.hex,0,[0,4,1]);a=a.replace(/(..)/g,"%$1");a=decodeURIComponent(a);return a};this.readCertPEM=function(c){var e=X509.pemToHex(c);var b=X509.getPublicKeyHexArrayFromCertHex(e);var d=new RSAKey();d.setPublic(b[0],b[1]);this.subjectPublicKeyRSA=d;this.subjectPublicKeyRSA_hN=b[0];this.subjectPublicKeyRSA_hE=b[1];this.hex=e};this.readCertPEMWithoutRSAInit=function(c){var d=X509.pemToHex(c);var b=X509.getPublicKeyHexArrayFromCertHex(d);if(typeof this.subjectPublicKeyRSA.setPublic==="function"){this.subjectPublicKeyRSA.setPublic(b[0],b[1])}this.subjectPublicKeyRSA_hN=b[0];this.subjectPublicKeyRSA_hE=b[1];this.hex=d};this.getInfo=function(){var p="Basic Fields\n";p+="  serial number: "+this.getSerialNumberHex()+"\n";p+="  signature algorithm: "+this.getSignatureAlgorithmField()+"\n";p+="  issuer: "+this.getIssuerString()+"\n";p+="  notBefore: "+this.getNotBefore()+"\n";p+="  notAfter: "+this.getNotAfter()+"\n";p+="  subject: "+this.getSubjectString()+"\n";p+="  subject public key info: \n";var j=X509.getSubjectPublicKeyInfoPosFromCertHex(this.hex);var d=ASN1HEX.getHexOfTLV_AtObj(this.hex,j);var n=KEYUTIL.getKey(d,null,"pkcs8pub");if(n instanceof RSAKey){p+="    key algorithm: RSA\n";p+="    n="+n.n.toString(16).substr(0,16)+"...\n";p+="    e="+n.e.toString(16)+"\n"}p+="X509v3 Extensions:\n";var m=X509.getV3ExtInfoListOfCertHex(this.hex);for(var e=0;e<m.length;e++){var b=m[e];var o=KJUR.asn1.x509.OID.oid2name(b.oid);if(o===""){o=b.oid}var k="";if(b.critical===true){k="CRITICAL"}p+="  "+o+" "+k+":\n";if(o==="basicConstraints"){var g=X509.getExtBasicConstraints(this.hex);if(g.cA===undefined){p+="    {}\n"}else{p+="    cA=true";if(g.pathLen!==undefined){p+=", pathLen="+g.pathLen}p+="\n"}}else{if(o==="keyUsage"){p+="    "+X509.getExtKeyUsageString(this.hex)+"\n"}else{if(o==="subjectKeyIdentifier"){p+="    "+X509.getExtSubjectKeyIdentifier(this.hex)+"\n"}else{if(o==="authorityKeyIdentifier"){var a=X509.getExtAuthorityKeyIdentifier(this.hex);if(a.kid!==undefined){p+="    kid="+a.kid+"\n"}}else{if(o==="extKeyUsage"){var h=X509.getExtExtKeyUsageName(this.hex);p+="    "+h.join(", ")+"\n"}else{if(o==="subjectAltName"){var f=X509.getExtSubjectAltName(this.hex);p+="    "+f.join(", ")+"\n"}else{if(o==="cRLDistributionPoints"){var l=X509.getExtCRLDistributionPointsURI(this.hex);p+="    "+l+"\n"}else{if(o==="authorityInfoAccess"){var c=X509.getExtAIAInfo(this.hex);if(c.ocsp!==undefined){p+="    ocsp: "+c.ocsp.join(",")+"\n"}if(c.caissuer!==undefined){p+="    caissuer: "+c.caissuer.join(",")+"\n"}}}}}}}}}}p+="signature algorithm: "+X509.getSignatureAlgorithmName(this.hex)+"\n";p+="signature: "+X509.getSignatureValueHex(this.hex).substr(0,16)+"...\n";return p}}X509.pemToBase64=function(a){var b=a;b=b.replace("-----BEGIN CERTIFICATE-----","");b=b.replace("-----END CERTIFICATE-----","");b=b.replace(/[ \n]+/g,"");return b};X509.pemToHex=function(a){var c=X509.pemToBase64(a);var b=b64tohex(c);return b};X509.getSubjectPublicKeyPosFromCertHex=function(f){var e=X509.getSubjectPublicKeyInfoPosFromCertHex(f);if(e==-1){return -1}var b=ASN1HEX.getPosArrayOfChildren_AtObj(f,e);if(b.length!=2){return -1}var d=b[1];if(f.substring(d,d+2)!="03"){return -1}var c=ASN1HEX.getStartPosOfV_AtObj(f,d);if(f.substring(c,c+2)!="00"){return -1}return c+2};X509.getSubjectPublicKeyInfoPosFromCertHex=function(d){var c=ASN1HEX.getStartPosOfV_AtObj(d,0);var b=ASN1HEX.getPosArrayOfChildren_AtObj(d,c);if(b.length<1){return -1}if(d.substring(b[0],b[0]+10)=="a003020102"){if(b.length<6){return -1}return b[6]}else{if(b.length<5){return -1}return b[5]}};X509.getPublicKeyHexArrayFromCertHex=function(f){var e=X509.getSubjectPublicKeyPosFromCertHex(f);var b=ASN1HEX.getPosArrayOfChildren_AtObj(f,e);if(b.length!=2){return[]}var d=ASN1HEX.getHexOfV_AtObj(f,b[0]);var c=ASN1HEX.getHexOfV_AtObj(f,b[1]);if(d!=null&&c!=null){return[d,c]}else{return[]}};X509.getHexTbsCertificateFromCert=function(b){var a=ASN1HEX.getStartPosOfV_AtObj(b,0);return a};X509.getPublicKeyHexArrayFromCertPEM=function(c){var d=X509.pemToHex(c);var b=X509.getPublicKeyHexArrayFromCertHex(d);return b};X509.hex2dn=function(f,b){if(b===undefined){b=0}if(f.substr(b,2)!=="30"){throw"malformed DN"}var c=new Array();var d=ASN1HEX.getPosArrayOfChildren_AtObj(f,b);for(var e=0;e<d.length;e++){c.push(X509.hex2rdn(f,d[e]))}c=c.map(function(a){return a.replace("/","\\/")});return"/"+c.join("/")};X509.hex2rdn=function(f,b){if(b===undefined){b=0}if(f.substr(b,2)!=="31"){throw"malformed RDN"}var c=new Array();var d=ASN1HEX.getPosArrayOfChildren_AtObj(f,b);for(var e=0;e<d.length;e++){c.push(X509.hex2attrTypeValue(f,d[e]))}c=c.map(function(a){return a.replace("+","\\+")});return c.join("+")};X509.hex2attrTypeValue=function(g,b){if(b===undefined){b=0}if(g.substr(b,2)!=="30"){throw"malformed attribute type and value"}var c=ASN1HEX.getPosArrayOfChildren_AtObj(g,b);if(c.length!==2||g.substr(c[0],2)!=="06"){"malformed attribute type and value"}var d=ASN1HEX.getHexOfV_AtObj(g,c[0]);var h=KJUR.asn1.ASN1Util.oidHexToInt(d);var f=KJUR.asn1.x509.OID.oid2atype(h);var a=ASN1HEX.getHexOfV_AtObj(g,c[1]);var e=hextorstr(a);return f+"="+e};X509.getPublicKeyFromCertPEM=function(f){var c=X509.getPublicKeyInfoPropOfCertPEM(f);if(c.algoid=="2a864886f70d010101"){var i=KEYUTIL.parsePublicRawRSAKeyHex(c.keyhex);var j=new RSAKey();j.setPublic(i.n,i.e);return j}else{if(c.algoid=="2a8648ce3d0201"){var e=KJUR.crypto.OID.oidhex2name[c.algparam];var j=new KJUR.crypto.ECDSA({curve:e,info:c.keyhex});j.setPublicKeyHex(c.keyhex);return j}else{if(c.algoid=="2a8648ce380401"){var b=ASN1HEX.getVbyList(c.algparam,0,[0],"02");var a=ASN1HEX.getVbyList(c.algparam,0,[1],"02");var d=ASN1HEX.getVbyList(c.algparam,0,[2],"02");var h=ASN1HEX.getHexOfV_AtObj(c.keyhex,0);h=h.substr(2);var j=new KJUR.crypto.DSA();j.setPublic(new BigInteger(b,16),new BigInteger(a,16),new BigInteger(d,16),new BigInteger(h,16));return j}else{throw"unsupported key"}}}};X509.getPublicKeyInfoPropOfCertPEM=function(e){var i={};i.algparam=null;var f=X509.pemToHex(e);var d=ASN1HEX.getPosArrayOfChildren_AtObj(f,0);if(d.length!=3){throw"malformed X.509 certificate PEM (code:001)"}if(f.substr(d[0],2)!="30"){throw"malformed X.509 certificate PEM (code:002)"}var c=ASN1HEX.getPosArrayOfChildren_AtObj(f,d[0]);var g=6;if(f.substr(c[0],2)!=="a0"){g=5}if(c.length<g+1){throw"malformed X.509 certificate PEM (code:003)"}var a=ASN1HEX.getPosArrayOfChildren_AtObj(f,c[g]);if(a.length!=2){throw"malformed X.509 certificate PEM (code:004)"}var h=ASN1HEX.getPosArrayOfChildren_AtObj(f,a[0]);if(h.length!=2){throw"malformed X.509 certificate PEM (code:005)"}i.algoid=ASN1HEX.getHexOfV_AtObj(f,h[0]);if(f.substr(h[1],2)=="06"){i.algparam=ASN1HEX.getHexOfV_AtObj(f,h[1])}else{if(f.substr(h[1],2)=="30"){i.algparam=ASN1HEX.getHexOfTLV_AtObj(f,h[1])}}if(f.substr(a[1],2)!="03"){throw"malformed X.509 certificate PEM (code:006)"}var b=ASN1HEX.getHexOfV_AtObj(f,a[1]);i.keyhex=b.substr(2);return i};X509.getPublicKeyInfoPosOfCertHEX=function(c){var b=ASN1HEX.getPosArrayOfChildren_AtObj(c,0);if(b.length!=3){throw"malformed X.509 certificate PEM (code:001)"}if(c.substr(b[0],2)!="30"){throw"malformed X.509 certificate PEM (code:002)"}var a=ASN1HEX.getPosArrayOfChildren_AtObj(c,b[0]);if(a.length<7){throw"malformed X.509 certificate PEM (code:003)"}return a[6]};X509.getV3ExtInfoListOfCertHex=function(g){var b=ASN1HEX.getPosArrayOfChildren_AtObj(g,0);if(b.length!=3){throw"malformed X.509 certificate PEM (code:001)"}if(g.substr(b[0],2)!="30"){throw"malformed X.509 certificate PEM (code:002)"}var a=ASN1HEX.getPosArrayOfChildren_AtObj(g,b[0]);if(a.length<8){throw"malformed X.509 certificate PEM (code:003)"}if(g.substr(a[7],2)!="a3"){throw"malformed X.509 certificate PEM (code:004)"}var h=ASN1HEX.getPosArrayOfChildren_AtObj(g,a[7]);if(h.length!=1){throw"malformed X.509 certificate PEM (code:005)"}if(g.substr(h[0],2)!="30"){throw"malformed X.509 certificate PEM (code:006)"}var f=ASN1HEX.getPosArrayOfChildren_AtObj(g,h[0]);var e=f.length;var d=new Array(e);for(var c=0;c<e;c++){d[c]=X509.getV3ExtItemInfo_AtObj(g,f[c])}return d};X509.getV3ExtItemInfo_AtObj=function(f,g){var e={};e.posTLV=g;var b=ASN1HEX.getPosArrayOfChildren_AtObj(f,g);if(b.length!=2&&b.length!=3){throw"malformed X.509v3 Ext (code:001)"}if(f.substr(b[0],2)!="06"){throw"malformed X.509v3 Ext (code:002)"}var d=ASN1HEX.getHexOfV_AtObj(f,b[0]);e.oid=ASN1HEX.hextooidstr(d);e.critical=false;if(b.length==3){e.critical=true}var c=b[b.length-1];if(f.substr(c,2)!="04"){throw"malformed X.509v3 Ext (code:003)"}e.posV=ASN1HEX.getStartPosOfV_AtObj(f,c);return e};X509.getHexOfTLV_V3ExtValue=function(b,a){var c=X509.getPosOfTLV_V3ExtValue(b,a);if(c==-1){return null}return ASN1HEX.getHexOfTLV_AtObj(b,c)};X509.getHexOfV_V3ExtValue=function(b,a){var c=X509.getPosOfTLV_V3ExtValue(b,a);if(c==-1){return null}return ASN1HEX.getHexOfV_AtObj(b,c)};X509.getPosOfTLV_V3ExtValue=function(f,b){var d=b;if(!b.match(/^[0-9.]+$/)){d=KJUR.asn1.x509.OID.name2oid(b)}if(d==""){return -1}var c=X509.getV3ExtInfoListOfCertHex(f);for(var a=0;a<c.length;a++){var e=c[a];if(e.oid==d){return e.posV}}return -1};X509.getExtBasicConstraints=function(d){var a=X509.getHexOfV_V3ExtValue(d,"basicConstraints");if(a===null){return null}if(a===""){return{}}if(a==="0101ff"){return{cA:true}}if(a.substr(0,8)==="0101ff02"){var c=ASN1HEX.getHexOfV_AtObj(a,6);var b=parseInt(c,16);return{cA:true,pathLen:b}}throw"unknown error"};X509.KEYUSAGE_NAME=["digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","keyAgreement","keyCertSign","cRLSign","encipherOnly","decipherOnly"];X509.getExtKeyUsageBin=function(d){var b=X509.getHexOfV_V3ExtValue(d,"keyUsage");if(b==""){return""}if(b.length%2!=0||b.length<=2){throw"malformed key usage value"}var a=parseInt(b.substr(0,2));var c=parseInt(b.substr(2),16).toString(2);return c.substr(0,c.length-a)};X509.getExtKeyUsageString=function(e){var d=X509.getExtKeyUsageBin(e);var b=new Array();for(var c=0;c<d.length;c++){if(d.substr(c,1)=="1"){b.push(X509.KEYUSAGE_NAME[c])}}return b.join(",")};X509.getExtSubjectKeyIdentifier=function(b){var a=X509.getHexOfV_V3ExtValue(b,"subjectKeyIdentifier");return a};X509.getExtAuthorityKeyIdentifier=function(f){var b={};var e=X509.getHexOfTLV_V3ExtValue(f,"authorityKeyIdentifier");if(e===null){return null}var c=ASN1HEX.getPosArrayOfChildren_AtObj(e,0);for(var d=0;d<c.length;d++){if(e.substr(c[d],2)==="80"){b.kid=ASN1HEX.getHexOfV_AtObj(e,c[d])}}return b};X509.getExtExtKeyUsageName=function(k){var b=new Array();var f=X509.getHexOfTLV_V3ExtValue(k,"extKeyUsage");if(f===null){return null}var c=ASN1HEX.getPosArrayOfChildren_AtObj(f,0);for(var e=0;e<c.length;e++){var j=ASN1HEX.getHexOfV_AtObj(f,c[e]);var g=KJUR.asn1.ASN1Util.oidHexToInt(j);var d=KJUR.asn1.x509.OID.oid2name(g);b.push(d)}return b};X509.getExtSubjectAltName=function(g){var b=new Array();var f=X509.getHexOfTLV_V3ExtValue(g,"subjectAltName");var c=ASN1HEX.getPosArrayOfChildren_AtObj(f,0);for(var e=0;e<c.length;e++){if(f.substr(c[e],2)==="82"){var d=hextoutf8(ASN1HEX.getHexOfV_AtObj(f,c[e]));b.push(d)}}return b};X509.getExtCRLDistributionPointsURI=function(n){var p=new Array();var k=X509.getHexOfTLV_V3ExtValue(n,"cRLDistributionPoints");var o=ASN1HEX.getPosArrayOfChildren_AtObj(k,0);for(var g=0;g<o.length;g++){var l=ASN1HEX.getHexOfTLV_AtObj(k,o[g]);var b=ASN1HEX.getPosArrayOfChildren_AtObj(l,0);for(var e=0;e<b.length;e++){if(l.substr(b[e],2)==="a0"){var f=ASN1HEX.getHexOfV_AtObj(l,b[e]);if(f.substr(0,2)==="a0"){var c=ASN1HEX.getHexOfV_AtObj(f,0);if(c.substr(0,2)==="86"){var m=ASN1HEX.getHexOfV_AtObj(c,0);var d=hextoutf8(m);p.push(d)}}}}}return p};X509.getExtAIAInfo=function(g){var j={};j.ocsp=[];j.caissuer=[];var h=X509.getPosOfTLV_V3ExtValue(g,"authorityInfoAccess");if(h==-1){return null}if(g.substr(h,2)!="30"){throw"malformed AIA Extn Value"}var d=ASN1HEX.getPosArrayOfChildren_AtObj(g,h);for(var c=0;c<d.length;c++){var a=d[c];var b=ASN1HEX.getPosArrayOfChildren_AtObj(g,a);if(b.length!=2){throw"malformed AccessDescription of AIA Extn"}var e=b[0];var f=b[1];if(ASN1HEX.getHexOfV_AtObj(g,e)=="2b06010505073001"){if(g.substr(f,2)=="86"){j.ocsp.push(hextoutf8(ASN1HEX.getHexOfV_AtObj(g,f)))}}if(ASN1HEX.getHexOfV_AtObj(g,e)=="2b06010505073002"){if(g.substr(f,2)=="86"){j.caissuer.push(hextoutf8(ASN1HEX.getHexOfV_AtObj(g,f)))}}}return j};X509.getSignatureAlgorithmName=function(d){var b=ASN1HEX.getDecendantHexVByNthList(d,0,[1,0]);var a=KJUR.asn1.ASN1Util.oidHexToInt(b);var c=KJUR.asn1.x509.OID.oid2name(a);return c};X509.getSignatureValueHex=function(b){var a=ASN1HEX.getDecendantHexVByNthList(b,0,[2]);if(a.substr(0,2)!=="00"){throw"can't get signature value"}return a.substr(2)};X509.getSerialNumberHex=function(a){return ASN1HEX.getDecendantHexVByNthList(a,0,[0,1])};
/*! jws-3.3.5 (c) 2013-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.jws=="undefined"||!KJUR.jws){KJUR.jws={}}KJUR.jws.JWS=function(){var a=KJUR.jws.JWS;this.parseJWS=function(e,h){if((this.parsedJWS!==undefined)&&(h||(this.parsedJWS.sigvalH!==undefined))){return}var g=e.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);if(g==null){throw"JWS signature is not a form of 'Head.Payload.SigValue'."}var i=g[1];var c=g[2];var j=g[3];var l=i+"."+c;this.parsedJWS={};this.parsedJWS.headB64U=i;this.parsedJWS.payloadB64U=c;this.parsedJWS.sigvalB64U=j;this.parsedJWS.si=l;if(!h){var f=b64utohex(j);var d=parseBigInt(f,16);this.parsedJWS.sigvalH=f;this.parsedJWS.sigvalBI=d}var b=b64utoutf8(i);var k=b64utoutf8(c);this.parsedJWS.headS=b;this.parsedJWS.payloadS=k;if(!a.isSafeJSONString(b,this.parsedJWS,"headP")){throw"malformed JSON string for JWS Head: "+b}}};KJUR.jws.JWS.sign=function(a,i,c,m,l){var k=KJUR.jws.JWS;var q,e,j;if(typeof i!="string"&&typeof i!="object"){throw"spHeader must be JSON string or object: "+i}if(typeof i=="object"){e=i;q=JSON.stringify(e)}if(typeof i=="string"){q=i;if(!k.isSafeJSONString(q)){throw"JWS Head is not safe JSON string: "+q}e=k.readSafeJSONString(q)}j=c;if(typeof c=="object"){j=JSON.stringify(c)}if((a==""||a==null)&&e.alg!==undefined){a=e.alg}if((a!=""&&a!=null)&&e.alg===undefined){e.alg=a;q=JSON.stringify(e)}if(a!==e.alg){throw"alg and sHeader.alg doesn't match: "+a+"!="+e.alg}var d=null;if(k.jwsalg2sigalg[a]===undefined){throw"unsupported alg name: "+a}else{d=k.jwsalg2sigalg[a]}var b=utf8tob64u(q);var g=utf8tob64u(j);var o=b+"."+g;var n="";if(d.substr(0,4)=="Hmac"){if(m===undefined){throw"mac key shall be specified for HS* alg"}var h=new KJUR.crypto.Mac({alg:d,prov:"cryptojs",pass:m});h.updateString(o);n=h.doFinal()}else{if(d.indexOf("withECDSA")!=-1){var p=new KJUR.crypto.Signature({alg:d});p.init(m,l);p.updateString(o);hASN1Sig=p.sign();n=KJUR.crypto.ECDSA.asn1SigToConcatSig(hASN1Sig)}else{if(d!="none"){var p=new KJUR.crypto.Signature({alg:d});p.init(m,l);p.updateString(o);n=p.sign()}}}var f=hextob64u(n);return o+"."+f};KJUR.jws.JWS.verify=function(p,t,j){var m=KJUR.jws.JWS;var q=p.split(".");var d=q[0];var l=q[1];var b=d+"."+l;var r=b64utohex(q[2]);var i=m.readSafeJSONString(b64utoutf8(q[0]));var h=null;var s=null;if(i.alg===undefined){throw"algorithm not specified in header"}else{h=i.alg;s=h.substr(0,2)}if(j!=null&&Object.prototype.toString.call(j)==="[object Array]"&&j.length>0){var c=":"+j.join(":")+":";if(c.indexOf(":"+h+":")==-1){throw"algorithm '"+h+"' not accepted in the list"}}if(h!="none"&&t===null){throw"key shall be specified to verify."}if(typeof t=="string"&&t.indexOf("-----BEGIN ")!=-1){t=KEYUTIL.getKey(t)}if(s=="RS"||s=="PS"){if(!(t instanceof RSAKey)){throw"key shall be a RSAKey obj for RS* and PS* algs"}}if(s=="ES"){if(!(t instanceof KJUR.crypto.ECDSA)){throw"key shall be a ECDSA obj for ES* algs"}}if(h=="none"){}var n=null;if(m.jwsalg2sigalg[i.alg]===undefined){throw"unsupported alg name: "+h}else{n=m.jwsalg2sigalg[h]}if(n=="none"){throw"not supported"}else{if(n.substr(0,4)=="Hmac"){var k=null;if(t===undefined){throw"hexadecimal key shall be specified for HMAC"}var g=new KJUR.crypto.Mac({alg:n,pass:t});g.updateString(b);k=g.doFinal();return r==k}else{if(n.indexOf("withECDSA")!=-1){var f=null;try{f=KJUR.crypto.ECDSA.concatSigToASN1Sig(r)}catch(o){return false}var e=new KJUR.crypto.Signature({alg:n});e.init(t);e.updateString(b);return e.verify(f)}else{var e=new KJUR.crypto.Signature({alg:n});e.init(t);e.updateString(b);return e.verify(r)}}}};KJUR.jws.JWS.parse=function(g){var c=g.split(".");var b={};var f,e,d;if(c.length!=2&&c.length!=3){throw"malformed sJWS: wrong number of '.' splitted elements"}f=c[0];e=c[1];if(c.length==3){d=c[2]}b.headerObj=KJUR.jws.JWS.readSafeJSONString(b64utoutf8(f));b.payloadObj=KJUR.jws.JWS.readSafeJSONString(b64utoutf8(e));b.headerPP=JSON.stringify(b.headerObj,null,"  ");if(b.payloadObj==null){b.payloadPP=b64utoutf8(e)}else{b.payloadPP=JSON.stringify(b.payloadObj,null,"  ")}if(d!==undefined){b.sigHex=b64utohex(d)}return b};KJUR.jws.JWS.verifyJWT=function(d,j,l){var h=KJUR.jws.JWS;var i=d.split(".");var c=i[0];var g=i[1];var m=c+"."+g;var k=b64utohex(i[2]);var f=h.readSafeJSONString(b64utoutf8(c));var e=h.readSafeJSONString(b64utoutf8(g));if(f.alg===undefined){return false}if(l.alg===undefined){throw"acceptField.alg shall be specified"}if(!h.inArray(f.alg,l.alg)){return false}if(e.iss!==undefined&&typeof l.iss==="object"){if(!h.inArray(e.iss,l.iss)){return false}}if(e.sub!==undefined&&typeof l.sub==="object"){if(!h.inArray(e.sub,l.sub)){return false}}if(e.aud!==undefined&&typeof l.aud==="object"){if(typeof e.aud=="string"){if(!h.inArray(e.aud,l.aud)){return false}}else{if(typeof e.aud=="object"){if(!h.includedArray(e.aud,l.aud)){return false}}}}var b=KJUR.jws.IntDate.getNow();if(l.verifyAt!==undefined&&typeof l.verifyAt==="number"){b=l.verifyAt}if(l.gracePeriod===undefined||typeof l.gracePeriod!=="number"){l.gracePeriod=0}if(e.exp!==undefined&&typeof e.exp=="number"){if(e.exp+l.gracePeriod<b){return false}}if(e.nbf!==undefined&&typeof e.nbf=="number"){if(b<e.nbf-l.gracePeriod){return false}}if(e.iat!==undefined&&typeof e.iat=="number"){if(b<e.iat-l.gracePeriod){return false}}if(e.jti!==undefined&&l.jti!==undefined){if(e.jti!==l.jti){return false}}if(!KJUR.jws.JWS.verify(d,j,l.alg)){return false}return true};KJUR.jws.JWS.includedArray=function(b,a){var d=KJUR.jws.JWS.inArray;if(b===null){return false}if(typeof b!=="object"){return false}if(typeof b.length!=="number"){return false}for(var c=0;c<b.length;c++){if(!d(b[c],a)){return false}}return true};KJUR.jws.JWS.inArray=function(d,b){if(b===null){return false}if(typeof b!=="object"){return false}if(typeof b.length!=="number"){return false}for(var c=0;c<b.length;c++){if(b[c]==d){return true}}return false};KJUR.jws.JWS.jwsalg2sigalg={HS256:"HmacSHA256",HS384:"HmacSHA384",HS512:"HmacSHA512",RS256:"SHA256withRSA",RS384:"SHA384withRSA",RS512:"SHA512withRSA",ES256:"SHA256withECDSA",ES384:"SHA384withECDSA",PS256:"SHA256withRSAandMGF1",PS384:"SHA384withRSAandMGF1",PS512:"SHA512withRSAandMGF1",none:"none",};KJUR.jws.JWS.isSafeJSONString=function(c,b,d){var e=null;try{e=jsonParse(c);if(typeof e!="object"){return 0}if(e.constructor===Array){return 0}if(b){b[d]=e}return 1}catch(a){return 0}};KJUR.jws.JWS.readSafeJSONString=function(b){var c=null;try{c=jsonParse(b);if(typeof c!="object"){return null}if(c.constructor===Array){return null}return c}catch(a){return null}};KJUR.jws.JWS.getEncodedSignatureValueFromJWS=function(b){var a=b.match(/^[^.]+\.[^.]+\.([^.]+)$/);if(a==null){throw"JWS signature is not a form of 'Head.Payload.SigValue'."}return a[1]};KJUR.jws.JWS.getJWKthumbprint=function(d){if(d.kty!=="RSA"&&d.kty!=="EC"&&d.kty!=="oct"){throw"unsupported algorithm for JWK Thumprint"}var a="{";if(d.kty==="RSA"){if(typeof d.n!="string"||typeof d.e!="string"){throw"wrong n and e value for RSA key"}a+='"e":"'+d.e+'",';a+='"kty":"'+d.kty+'",';a+='"n":"'+d.n+'"}'}else{if(d.kty==="EC"){if(typeof d.crv!="string"||typeof d.x!="string"||typeof d.y!="string"){throw"wrong crv, x and y value for EC key"}a+='"crv":"'+d.crv+'",';a+='"kty":"'+d.kty+'",';a+='"x":"'+d.x+'",';a+='"y":"'+d.y+'"}'}else{if(d.kty==="oct"){if(typeof d.k!="string"){throw"wrong k value for oct(symmetric) key"}a+='"kty":"'+d.kty+'",';a+='"k":"'+d.k+'"}'}}}var b=rstrtohex(a);var c=KJUR.crypto.Util.hashHex(b,"sha256");var e=hextob64u(c);return e};KJUR.jws.IntDate={};KJUR.jws.IntDate.get=function(a){if(a=="now"){return KJUR.jws.IntDate.getNow()}else{if(a=="now + 1hour"){return KJUR.jws.IntDate.getNow()+60*60}else{if(a=="now + 1day"){return KJUR.jws.IntDate.getNow()+60*60*24}else{if(a=="now + 1month"){return KJUR.jws.IntDate.getNow()+60*60*24*30}else{if(a=="now + 1year"){return KJUR.jws.IntDate.getNow()+60*60*24*365}else{if(a.match(/Z$/)){return KJUR.jws.IntDate.getZulu(a)}else{if(a.match(/^[0-9]+$/)){return parseInt(a)}}}}}}}throw"unsupported format: "+a};KJUR.jws.IntDate.getZulu=function(k){var b=k.match(/(\d+)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)Z/);if(b){var a=b[1];var i=parseInt(a);if(a.length==4){}else{if(a.length==2){if(50<=i&&i<100){i=1900+i}else{if(0<=i&&i<50){i=2000+i}else{throw"malformed year string for UTCTime"}}}else{throw"malformed year string"}}var g=parseInt(b[2])-1;var j=parseInt(b[3]);var c=parseInt(b[4]);var e=parseInt(b[5]);var f=parseInt(b[6]);var h=new Date(Date.UTC(i,g,j,c,e,f));return ~~(h/1000)}throw"unsupported format: "+k};KJUR.jws.IntDate.getNow=function(){var a=~~(new Date()/1000);return a};KJUR.jws.IntDate.intDate2UTCString=function(a){var b=new Date(a*1000);return b.toUTCString()};KJUR.jws.IntDate.intDate2Zulu=function(e){var i=new Date(e*1000);var h=("0000"+i.getUTCFullYear()).slice(-4);var g=("00"+(i.getUTCMonth()+1)).slice(-2);var b=("00"+i.getUTCDate()).slice(-2);var a=("00"+i.getUTCHours()).slice(-2);var c=("00"+i.getUTCMinutes()).slice(-2);var f=("00"+i.getUTCSeconds()).slice(-2);return h+g+b+a+c+f+"Z"};
/*! jwsjs-2.1.0 (c) 2010-2016 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.jws=="undefined"||!KJUR.jws){KJUR.jws={}}KJUR.jws.JWSJS=function(){var b=KJUR.jws.JWS;var a=KJUR.jws.JWS;this.aHeader=[];this.sPayload="";this.aSignature=[];this.init=function(){this.aHeader=[];this.sPayload=undefined;this.aSignature=[]};this.initWithJWS=function(d){this.init();var c=d.split(".");if(c.length!=3){throw"malformed input JWS"}this.aHeader.push(c[0]);this.sPayload=c[1];this.aSignature.push(c[2])};this.addSignature=function(c,f,k,i){if(this.sPayload===undefined||this.sPayload===null){throw"there's no JSON-JS signature to add."}var j=this.aHeader.length;if(this.aHeader.length!=this.aSignature.length){throw"aHeader.length != aSignature.length"}try{var d=KJUR.jws.JWS.sign(c,f,this.sPayload,k,i);var h=d.split(".");var l=h[0];var e=h[2];this.aHeader.push(h[0]);this.aSignature.push(h[2])}catch(g){if(this.aHeader.length>j){this.aHeader.pop()}if(this.aSignature.length>j){this.aSignature.pop()}throw"addSignature failed: "+g}};this.addSignatureByHeaderKey=function(f,c){var e=b64utoutf8(this.sPayload);var d=new KJUR.jws.JWS();var g=d.generateJWSByP1PrvKey(f,e,c);this.aHeader.push(d.parsedJWS.headB64U);this.aSignature.push(d.parsedJWS.sigvalB64U)};this.addSignatureByHeaderPayloadKey=function(f,e,c){var d=new KJUR.jws.JWS();var g=d.generateJWSByP1PrvKey(f,e,c);this.aHeader.push(d.parsedJWS.headB64U);this.sPayload=d.parsedJWS.payloadB64U;this.aSignature.push(d.parsedJWS.sigvalB64U)};this.verifyAll=function(f){if(this.aHeader.length!==f.length||this.aSignature.length!==f.length){return false}for(var e=0;e<f.length;e++){var d=f[e];if(d.length!==2){return false}var c=this.verifyNth(e,d[0],d[1]);if(c===false){return false}}return true};this.verifyNth=function(d,h,e){if(this.aHeader.length<=d||this.aSignature.length<=d){return false}var f=this.aHeader[d];var i=this.aSignature[d];var j=f+"."+this.sPayload+"."+i;var c=false;try{c=a.verify(j,h,e)}catch(g){return false}return c};this.verifyWithCerts=function(d){if(this.aHeader.length!=d.length){throw"num headers does not match with num certs"}if(this.aSignature.length!=d.length){throw"num signatures does not match with num certs"}var l=this.sPayload;var h="";for(var e=0;e<d.length;e++){var f=d[e];var g=this.aHeader[e];var n=this.aSignature[e];var c=g+"."+l+"."+n;var k=new KJUR.jws.JWS();try{var m=k.verifyJWSByPemX509Cert(c,f);if(m!=1){h+=(e+1)+"th signature unmatch. "}}catch(j){h+=(e+1)+"th signature fail("+j+"). "}}if(h==""){return 1}else{throw h}};this.readJWSJS=function(e){if(typeof e==="string"){var d=b.readSafeJSONString(e);if(d==null){throw"argument is not safe JSON object string"}this.aHeader=d.headers;this.sPayload=d.payload;this.aSignature=d.signatures}else{try{if(e.headers.length>0){this.aHeader=e.headers}else{throw"malformed header"}if(typeof e.payload==="string"){this.sPayload=e.payload}else{throw"malformed signatures"}if(e.signatures.length>0){this.signatures=e.signatures}else{throw"malformed signatures"}}catch(c){throw"malformed JWS-JS JSON object: "+c}}};this.getJSON=function(){return{headers:this.aHeader,payload:this.sPayload,signatures:this.aSignature}};this.isEmpty=function(){if(this.aHeader.length==0){return 1}return 0}};

"use strict";function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_createClass=function(){function t(t,e){for(var a=0;a<e.length;a++){var i=e[a];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,a,i){return a&&t(e.prototype,a),i&&t(e,i),e}}();!function(){customElements.define("ct-data-grid",function(t){function e(t){var a,i;return _classCallCheck(this,e),t=a=_possibleConstructorReturn(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t)),t.localData=null,t.model={cols:[],data:[]},t.isReady=!1,i=t,_possibleConstructorReturn(a,i)}return _inherits(e,t),_createClass(e,[{key:"injectStyles",value:function(){var t=document.head.querySelector("style[rel="+this.tagName.toLowerCase()+"]");t||(t=document.createElement("style"),t.setAttribute("rel",this.tagName.toLowerCase()),t.textContent='@keyframes ctDataGridSpin {\n                  0% {\n                    transform: rotate(0deg); }\n                  100% {\n                    transform: rotate(360deg); } }\n                \n                ct-data-grid {\n                  display: flex;\n                  position: relative;\n                  flex: 1; }\n                  ct-data-grid ct-data-col {\n                    display: none;\n                    position: absolute;\n                    top: -9999px;\n                    left: -9999px;\n                    width: 0;\n                    height: 0; }\n                  ct-data-grid .ct-data-grid {\n                    position: relative;\n                    top: 0;\n                    left: 0;\n                    width: 100%;\n                    height: auto;\n                    max-height: 100%;\n                    display: flex;\n                    flex-direction: column; }\n                    ct-data-grid .ct-data-grid .search-area {\n                      display: none;\n                      flex: 0 0 auto;\n                      margin: 0 0 20px 0; }\n                    ct-data-grid .ct-data-grid .table-area {\n                      position: relative;\n                      min-height: .01%;\n                      overflow-x: auto;\n                      -webkit-overflow-scrolling: touch; }\n                      ct-data-grid .ct-data-grid .table-area .table-container table {\n                        margin: 0;\n                        width: 100%; }\n                        ct-data-grid .ct-data-grid .table-area .table-container table td,\n                        ct-data-grid .ct-data-grid .table-area .table-container table th {\n                          position: relative; }\n                        ct-data-grid .ct-data-grid .table-area .table-container table th {\n                          user-select: none;\n                          white-space: nowrap; }\n                          ct-data-grid .ct-data-grid .table-area .table-container table th.sortable {\n                            cursor: pointer; }\n                            ct-data-grid .ct-data-grid .table-area .table-container table th.sortable:after {\n                              content: "\\f0dc";\n                              font-family: "FontAwesome";\n                              display: inline-block;\n                              vertical-align: middle;\n                              font-size: 0.8em;\n                              width: 20px;\n                              text-align: right;\n                              opacity: 0.3; }\n                            ct-data-grid .ct-data-grid .table-area .table-container table th.sortable.sort-asc:after {\n                              content: "\\f0de";\n                              opacity: 1; }\n                            ct-data-grid .ct-data-grid .table-area .table-container table th.sortable.sort-desc:after {\n                              content: "\\f0dd";\n                              opacity: 1; }\n                        ct-data-grid .ct-data-grid .table-area .table-container table td {\n                          padding: 0; }\n                          ct-data-grid .ct-data-grid .table-area .table-container table td .content {\n                            display: block;\n                            padding: 8px; }\n                          ct-data-grid .ct-data-grid .table-area .table-container table td .control {\n                            display: block;\n                            padding: 5px; }\n                            ct-data-grid .ct-data-grid .table-area .table-container table td .control input {\n                              line-height: normal; }\n                          ct-data-grid .ct-data-grid .table-area .table-container table td .edit-controls {\n                            display: block;\n                            padding: 7px; }\n                            ct-data-grid .ct-data-grid .table-area .table-container table td .edit-controls button {\n                              margin: 0 0 0 5px; }\n                              ct-data-grid .ct-data-grid .table-area .table-container table td .edit-controls button:first-child {\n                                margin: 0; }\n                          ct-data-grid .ct-data-grid .table-area .table-container table td .message-detail {\n                            font-size: 0.8em; }\n                          ct-data-grid .ct-data-grid .table-area .table-container table td .edit-control {\n                            width: 100%; }\n                          ct-data-grid .ct-data-grid .table-area .table-container table td.message-info {\n                            padding-left: 30px; }\n                            ct-data-grid .ct-data-grid .table-area .table-container table td.message-info:before {\n                              content: "\\f05a";\n                              font-family: "FontAwesome";\n                              display: block;\n                              position: absolute;\n                              top: 9px;\n                              left: 9px; }\n                          ct-data-grid .ct-data-grid .table-area .table-container table td.message-error {\n                            background: #f2dede;\n                            padding-left: 30px; }\n                            ct-data-grid .ct-data-grid .table-area .table-container table td.message-error:before {\n                              content: "\\f06a";\n                              font-family: "FontAwesome";\n                              display: block;\n                              position: absolute;\n                              top: 9px;\n                              left: 9px; }\n                        ct-data-grid .ct-data-grid .table-area .table-container table.selection-mode-row tr.selected, ct-data-grid .ct-data-grid .table-area .table-container table.selection-mode-cell tr.selected {\n                          background-color: #d9edf7; }\n                        ct-data-grid .ct-data-grid .table-area .table-container table.selection-mode-row td, ct-data-grid .ct-data-grid .table-area .table-container table.selection-mode-cell td {\n                          cursor: pointer; }\n                        ct-data-grid .ct-data-grid .table-area .table-container table.selection-mode-cell td.selected {\n                          background-color: rgba(0, 0, 0, 0.05); }\n                      ct-data-grid .ct-data-grid .table-area.fixed-headers {\n                        display: flex; }\n                        ct-data-grid .ct-data-grid .table-area.fixed-headers .table-container {\n                          display: flex;\n                          flex: 1; }\n                          ct-data-grid .ct-data-grid .table-area.fixed-headers .table-container table {\n                            display: flex;\n                            flex-direction: column;\n                            table-layout: fixed;\n                            flex: 1; }\n                            ct-data-grid .ct-data-grid .table-area.fixed-headers .table-container table thead {\n                              display: block;\n                              flex: 0 0 auto; }\n                              ct-data-grid .ct-data-grid .table-area.fixed-headers .table-container table thead tr {\n                                display: flex; }\n                            ct-data-grid .ct-data-grid .table-area.fixed-headers .table-container table tbody {\n                              display: block;\n                              flex: 1 1 auto;\n                              overflow: auto; }\n                              ct-data-grid .ct-data-grid .table-area.fixed-headers .table-container table tbody tr {\n                                display: flex; }\n                              ct-data-grid .ct-data-grid .table-area.fixed-headers .table-container table tbody tr:first-child td {\n                                border-top: 0; }\n                            ct-data-grid .ct-data-grid .table-area.fixed-headers .table-container table td,\n                            ct-data-grid .ct-data-grid .table-area.fixed-headers .table-container table th {\n                              flex: 1;\n                              overflow: hidden; }\n                              ct-data-grid .ct-data-grid .table-area.fixed-headers .table-container table td .content,\n                              ct-data-grid .ct-data-grid .table-area.fixed-headers .table-container table th .content {\n                                text-overflow: ellipsis;\n                                overflow: hidden; }\n                    ct-data-grid .ct-data-grid .pagination-area {\n                      flex: 0 0 auto;\n                      display: none;\n                      user-select: none;\n                      margin: 20px 0 0 0; }\n                    ct-data-grid .ct-data-grid .loading {\n                      position: absolute;\n                      top: 0;\n                      left: 0;\n                      width: 100%;\n                      height: 100%;\n                      display: none; }\n                    ct-data-grid .ct-data-grid.has-search .search-area {\n                      display: flex;\n                      justify-content: flex-end; }\n                      ct-data-grid .ct-data-grid.has-search .search-area .search-bar .search-box {\n                        position: relative;\n                        width: 400px; }\n                        ct-data-grid .ct-data-grid.has-search .search-area .search-bar .search-box input.form-control {\n                          z-index: 1;\n                          padding-right: 24px; }\n                        ct-data-grid .ct-data-grid.has-search .search-area .search-bar .search-box .clear-button {\n                          position: absolute;\n                          top: 0;\n                          right: 34px;\n                          width: 24px;\n                          height: 100%;\n                          padding: 8px 0 0 0;\n                          text-align: center;\n                          z-index: 2;\n                          cursor: pointer;\n                          opacity: 0.5;\n                          font-size: 0.8em; }\n                        ct-data-grid .ct-data-grid.has-search .search-area .search-bar .search-box .clear-button:hover {\n                          opacity: 1; }\n                    ct-data-grid .ct-data-grid.has-pagination .pagination-area {\n                      display: flex;\n                      justify-content: center; }\n                      ct-data-grid .ct-data-grid.has-pagination .pagination-area ul.pagination {\n                        display: block;\n                        margin: 0; }\n                        ct-data-grid .ct-data-grid.has-pagination .pagination-area ul.pagination .page-bookend .page-label {\n                          display: none; }\n                        ct-data-grid .ct-data-grid.has-pagination .pagination-area ul.pagination li > a {\n                          min-width: 40px;\n                          text-align: center;\n                          cursor: pointer; }\n                    ct-data-grid .ct-data-grid.loading-data .loading {\n                      display: block; }\n                      ct-data-grid .ct-data-grid.loading-data .loading .bg {\n                        width: 100%;\n                        height: 100%;\n                        background: #ffffff;\n                        opacity: 0.5; }\n                      ct-data-grid .ct-data-grid.loading-data .loading .spinner {\n                        position: absolute;\n                        top: 50%;\n                        left: 50%;\n                        width: 32px;\n                        height: 32px;\n                        border: 1px solid #cccccc;\n                        border-radius: 50%;\n                        margin: -16px 0 0 -16px;\n                        background: #ffffff; }\n                        ct-data-grid .ct-data-grid.loading-data .loading .spinner:after {\n                          content: "";\n                          display: block;\n                          position: absolute;\n                          width: 24px;\n                          height: 24px;\n                          top: 50%;\n                          left: 50%;\n                          margin: -12px 0 0 -12px;\n                          border: 3px solid rgba(0, 0, 0, 0.2);\n                          border-left-color: #000000;\n                          border-radius: 50%;\n                          transform: translateZ(0);\n                          animation: ctDataGridSpin 1.1s infinite linear; }\n                ',document.head.appendChild(t))}},{key:"generateHtml",value:function(){return'<div class="ct-data-grid">\n                <div class="search-area"></div>\n                <div class="table-area">\n                    <div class="table-container"></div>\n                    <div class="loading"></div>\n                </div>\n                <div class="pagination-area"></div>\n            </div>'}}]),_createClass(e,[{key:"connectedCallback",value:function(){var t=this,e=this.getAttribute("id")||"autoid"+(new Date).getTime(),a=Array.from(this.querySelectorAll("ct-data-col"));a.forEach(function(e){t.model.cols.push({key:e.getAttribute("key"),classes:e.getAttribute("class")||"",displayKey:e.getAttribute("display-key"),cssKey:e.getAttribute("css-key"),heading:e.textContent,dataType:e.getAttribute("data-type")||"string",sortable:e.hasAttribute("sortable")&&"false"!==e.getAttribute("sortable"),sort:e.getAttribute("sort"),width:e.getAttribute("width"),editable:e.hasAttribute("editable")&&"false"!==e.getAttribute("editable"),isControls:"controls"===e.getAttribute("data-type"),editButtonLabel:e.getAttribute("edit-button-label")||"Edit",saveButtonLabel:e.getAttribute("save-button-label")||"Save",cancelButtonLabel:e.getAttribute("cancel-button-label")||"Cancel"})}),this.id=e,this.injectStyles(),this.innerHTML=this.generateHtml(),a.forEach(function(e){t.appendChild(e)}),this.$element=this.querySelector(".ct-data-grid"),this.$searchArea=this.querySelector(".search-area"),this.$tableArea=this.querySelector(".table-area"),this.$tableContainer=this.querySelector(".table-container"),this.$paginationArea=this.querySelector(".pagination-area"),this.$loading=this.querySelector(".loading"),this._initialize(),this._raiseEvent("ready"),this.isReady=!0}},{key:"attributeChangedCallback",value:function(t,e,a){if(this.isReady&&e!==a){var i=!1,n=!1,r=!1;switch(t.toLowerCase()){case"data-source":case"data-source-method":case"data-source-page-param":case"data-source-page-size-param":case"data-source-search-param":case"data-source-sort-column-param":case"data-source-sort-direction-param":case"data-results-property":case"data-results-total-property":this._processDataSourceAttributes(),this._processInteractionAttributes(),r=!0;break;case"show-search":this._processSearchAttributes(),i=!0,n=!0;break;case"show-pagination":this._processPaginationAttributes(),i=!0,r=!0;break;case"page-size":this._processPaginationAttributes(),r=!0;break;case"use-local-interaction":this._processInteractionAttributes(),r=!0;break;case"fixed-headers":this._processPresentationAttributes(),i=!0,n=!0;break;case"row-css-key":this._processPresentationAttributes(),n=!0;break;case"selection-mode":this._processInteractionAttributes(),i=!0,n=!0}if(i&&this._render(!0),n||r){var s=!r;this._buildDataRows(s)}}}},{key:"_initialize",value:function(){this._processDataSourceAttributes(),this._processSearchAttributes(),this._processPaginationAttributes(),this._processInteractionAttributes(),this._processPresentationAttributes(),this.searchQuery="",this.sortBy=null,this.sortDirection=null,this.pageNumber=1,this.unfilteredTotalResults=0,this.totalResults=0,this.selectedValue=null,this._render()}},{key:"_processDataSourceAttributes",value:function(){this.dataSourceUrl=this.getAttribute("data-source"),this.dataSourceMethod=this.getAttribute("data-source-method")||"GET",this.dataSourcePageParam=this.getAttribute("data-source-page-param")||"page",this.dataSourcePageSizeParam=this.getAttribute("data-source-page-size-param")||"limit",this.dataSourceSearchParam=this.getAttribute("data-source-search-param")||"query",this.dataSourceSortColumnParam=this.getAttribute("data-source-sort-column-param")||"sort",this.dataSourceSortDirectionParam=this.getAttribute("data-source-sort-direction-param")||"dir",this.dataResultsProperty=this.getAttribute("data-results-property")||"data",this.dataResultsTotalProperty=this.getAttribute("data-results-total-property")||"totalResults",this.useDataSource=!!this.dataSourceUrl,this.dataSourceParams=null}},{key:"_processInteractionAttributes",value:function(){this.useLocalInteraction=!this.useDataSource||this.hasAttribute("use-local-interaction")&&"false"!==this.getAttribute("use-local-interaction").toLowerCase(),this.selectionMode=(this.getAttribute("selection-mode")||"none").toLowerCase()}},{key:"_processSearchAttributes",value:function(){this.showSearch=this.hasAttribute("show-search")&&"false"!==this.getAttribute("show-search").toLowerCase()}},{key:"_processPaginationAttributes",value:function(){this.showPagination=!this.hasAttribute("show-pagination")||"false"!==this.getAttribute("show-pagination").toLowerCase(),this.pageSize=parseInt(this.getAttribute("page-size"))||0}},{key:"_processPresentationAttributes",value:function(){this.fixedHeaders=this.hasAttribute("fixed-headers")&&"false"!==this.getAttribute("fixed-headers").toLowerCase(),this.rowCssKey=this.getAttribute("row-css-key")||"",this.$tableArea&&this.$tableArea.classList.toggle("fixed-headers",this.fixedHeaders)}},{key:"_render",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];e._removeChildren(this.$tableContainer),this._buildSearchArea(),this._buildTable(t),this.$tableContainer.appendChild(this.$table)}},{key:"_loadDataFromUrl",value:function(){var t=this,a=this;return new Promise(function(i){a._setLoading(!0),a.dataSourceParams={},t.useLocalInteraction||(a.searchQuery&&(a.dataSourceParams[a.dataSourceSearchParam]=a.searchQuery),null!==a.sortBy&&(a.dataSourceParams[a.dataSourceSortColumnParam]=a.sortBy,a.dataSourceParams[a.dataSourceSortDirectionParam]=a.sortDirection),a.pageSize&&a.pageNumber&&(a.dataSourceParams[a.dataSourcePageSizeParam]=a.pageSize,a.dataSourceParams[a.dataSourcePageParam]=a.pageNumber)),a._sendRequest(a.dataSourceMethod,a.dataSourceUrl,a.dataSourceParams).then(function(t){var n=e._getProperty(t,a.dataResultsProperty);Array.isArray(n)||(a._setLoading(!1),a._setMessage("error","Incorrect data retrieved, must be array; was "+("undefined"==typeof n?"undefined":_typeof(n))),a._raiseEvent("data-error"),i(!1));var r=e._getProperty(t,a.dataResultsTotalProperty);a.unfilteredTotalResults=r||n.length,a.totalResults=r||n.length,a._setLoading(!1),a._setData(n),i(!0)},function(t){a._setLoading(!1),a._setMessage("error","Error loading data...",t),a._raiseEvent("data-error"),i(!1)})})}},{key:"_prepareLocalData",value:function(){var t=this;return new Promise(function(e){var a=Array.from(t.localData||[]);a=t._searchLocal(a),t.totalResults=a.length,a=t._sortLocal(a),a=t._paginateLocal(a),t._setData(a),e(!0)})}},{key:"_buildTable",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];switch(this.$table=document.createElement("table"),this.$table.classList.add("table","table-striped","table-hover"),this.selectionMode){case"row":this.$table.classList.add("selection-mode-row");break;case"cell":this.$table.classList.add("selection-mode-cell")}this.fixedHeaders&&this.$tableArea.classList.add("fixed-headers"),this.$thead=document.createElement("thead"),this.$table.appendChild(this.$thead);var a=document.createElement("tr");this.model.cols.forEach(function(e){return t._buildColumnHeader(a,e)}),this.$thead.appendChild(a),this.$tbody=document.createElement("tbody"),this.$table.appendChild(this.$tbody),this.useDataSource&&e===!1&&this._buildDataRows()}},{key:"_buildColumnHeader",value:function(t,e){var a=this,i=document.createElement("th");e.key&&i.setAttribute("key",e.key),void 0!==e.classes&&null!==e.classes&&e.classes.toString().split(" ").forEach(function(t){t&&i.classList.add(t)}),e.isControls&&i.classList.add("edit-controls"),null!==e.width&&(this.fixedHeaders?i.style.flex="1 1 "+e.width:i.style.width=e.width),e.sortable&&!e.isControls&&(i.classList.add("sortable"),e.key===this.sortBy?this._changeSort(i,this.sortDirection,!0):this.sortBy||(e.sort&&"asc"===e.sort.toString().toLowerCase()&&this._changeSort(i,"asc",!0),e.sort&&"desc"===e.sort.toString().toLowerCase()&&this._changeSort(i,"desc",!0)),i.addEventListener("click",function(){a._changeSort(i)})),i.textContent=e.heading,t.appendChild(i)}},{key:"_buildDataRows",value:function(){var t=this,a=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=void 0;i=a?Promise.resolve(!!this.model.data):this.useDataSource&&this.useLocalInteraction&&null===this.localData?this._loadDataFromUrl().then(function(){return t.localData=t.model.data,t.unfilteredTotalResults=t.localData.length,t.totalResults=t.localData.length,t._prepareLocalData()}):this.useLocalInteraction?this._prepareLocalData():this._loadDataFromUrl(),i.then(function(a){a&&(e._removeChildren(t.$tbody),t.model.data.length>0?t.model.data.forEach(function(e,a){return t._buildDataRow(e,a)}):t._setMessage("info","No data to display..."),t._buildPagination(),t._raiseEvent("data-rendered"))})}},{key:"_buildDataRow",value:function(t,e){var a=this,i=this._applyIndexes(t).__idx,n=document.createElement("tr");if(this.rowCssKey&&t.hasOwnProperty(this.rowCssKey)&&void 0!==t[this.rowCssKey]&&null!==t[this.rowCssKey]){var r=t[this.rowCssKey].toString().split(" ");r.forEach(function(t){t&&n.classList.add(t)})}this._isEditItem(i)&&n.classList.add("editing"),this.model.cols.forEach(function(r,s){a._buildDataCell(n,r,s,t,e,i)}),"row"===this.selectionMode&&n.addEventListener("click",function(){return a.__handleRowClick(n,t,e)}),this.$tbody.appendChild(n)}},{key:"_buildDataCell",value:function(t,a,i,n,r,s){var o=this,l=document.createElement("td");if(void 0!==a.classes&&null!==a.classes&&a.classes.toString().split(" ").forEach(function(t){t&&l.classList.add(t)}),a.cssKey&&n.hasOwnProperty(a.cssKey)&&void 0!==n[a.cssKey]&&null!==n[a.cssKey]){var d=n[a.cssKey].toString().split(" ");d.forEach(function(t){t&&l.classList.add(t)})}void 0!==a.width&&(this.fixedHeaders?l.style.flex="1 1 "+a.width:l.style.width=a.width),t.appendChild(l),"cell"!==this.selectionMode||a.isControls||l.addEventListener("click",function(){return o.__handleCellClick(l,n,r,a,i)});var c=document.createElement("div"),u=!1;this.editManifest&&this.editManifest.itemIndexes.length&&(a.editable||a.isControls)&&(u=this.editManifest.itemIndexes.includes(s));var h=a.isControls?"edit-controls":u?"control":"content";c.classList.add(h),u?(e._removeChildren(c),a.isControls?this._buildEditButtons(c,a,!1,s):this._buildEditControl(c,a,n[a.key],this.editManifest[s])):a.isControls?this._buildEditButtons(c,a,!0,s):a.displayKey?c.innerHTML=n[a.displayKey]||"":c.innerHTML=this._formatData(a,n[a.key]),l.appendChild(c)}},{key:"_formatData",value:function(t,a){var i=this,n="";switch((t.dataType||"").toLowerCase()){case"string":!function(){n=a||""}();break;case"number":!function(){var t=parseFloat(a);isNaN(t)||(n=t.toString())}();break;case"date":!function(){if(void 0!==a&&null!==a&&""!==a){var t=e._parseDate(a);t&&(n=e._renderDate(t))}}();break;case"datetime":!function(){if(void 0!==a&&null!==a&&""!==a){var t=isNaN(a)?a.substring(0,19):a,i=e._parseDate(t);i&&(n=e._renderDate(i)+" "+e._renderTime(i))}}();break;case"boolean":!function(){a===!0?n="Yes":a===!1&&(n="No")}();break;case"url":!function(){a&&(n='<a href="'+a+'" target="_'+i.id+"_"+t.key+'_link">Link</a>')}()}return n}},{key:"_buildEditButtons",value:function(t,e,a,i){var n=this;if(a){var r=document.createElement("button");r.classList.add("btn","btn-xs","btn-default","edit-button"),r.innerHTML='<span class="text">'+e.editButtonLabel+"</span>",r.addEventListener("click",function(t){t.stopPropagation(),n._addEditModeItems([i])}),t.appendChild(r)}else{var s=document.createElement("button");s.classList.add("btn","btn-xs","btn-default","save-button"),s.innerHTML='<span class="text">'+e.saveButtonLabel+"</span>",s.addEventListener("click",function(t){t.stopPropagation();var e=n._getEditChanges([i]);n._removeEditModeItems([i]),e&&e.length&&n._raiseEvent("data-change",e[0])}),t.appendChild(s);var o=document.createElement("button");o.classList.add("btn","btn-xs","btn-default","cancel-button"),o.innerHTML='<span class="text">'+e.cancelButtonLabel+"</span>",o.addEventListener("click",function(t){t.stopPropagation(),n._removeEditModeItems([i])}),t.appendChild(o)}}},{key:"_buildEditControl",value:function(t,a,i,n){var r=void 0;switch((a.dataType||"").toLowerCase()){default:case"string":case"url":!function(){var e=document.createElement("input");e.setAttribute("type","text"),e.value=i,e.classList.add("edit-control","edit-control-"+(a.dataType||"string")),t.appendChild(e),r=function(){return e.value}}();break;case"number":!function(){var e=document.createElement("input");e.setAttribute("type","number"),e.value=i,e.classList.add("edit-control","edit-control-number"),t.appendChild(e),r=function(){return parseInt(e.value)||0}}();break;case"date":!function(){var a=e._parseDate(i),n=document.createElement("input");n.setAttribute("type","date"),a&&(n.value=a.toISOString().substr(0,10)),n.classList.add("edit-control","edit-control-date"),t.appendChild(n),r=function(){return n.value}}();break;case"datetime":!function(){var a=isNaN(i)?i.substring(0,19):i,n=e._parseDate(a),s=document.createElement("input");s.setAttribute("type","date"),n&&(s.value=n.toISOString().substr(0,10)),s.classList.add("edit-control","edit-control-datetime","edit-control-datetime-date"),t.appendChild(s);var o=document.createElement("input");o.setAttribute("type","time"),n&&(o.value=e._renderTime(n)),o.classList.add("edit-control","edit-control-datetime","edit-control-datetime-time"),t.appendChild(o),r=function(){return s.value+"T"+o.value}}();break;case"boolean":!function(){var e=document.createElement("input");e.setAttribute("type","checkbox"),e.checked=i===!0,e.classList.add("edit-control","edit-control-boolean"),t.appendChild(e),r=function(){return e.checked}}()}"function"==typeof r&&(n[a.key]=r)}},{key:"_addEditModeItems",value:function(t){var e=this,a=this.model.cols.filter(function(t){return t.editable});if(0===a.length)throw new Error("You cannot put a grid into edit mode which has no columns that are editable");var i=!1;this.editManifest||(this.editManifest={itemIndexes:[]}),t.forEach(function(t){e._isEditItem(t)||(e.editManifest.itemIndexes.push(t),e.editManifest[t]={},i=!0)}),i&&this._buildDataRows(!0)}},{key:"_isEditItem",value:function(t){return!!this.editManifest&&this.editManifest.itemIndexes.includes(t)}},{key:"_getEditChanges",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(!this.editManifest)return[];var a=[];return this.editManifest.itemIndexes.forEach(function(i){if(null===e||e.includes(i)){var n=Object.assign({},(t.localData||t.model.data)[i]),r=Object.assign({},n),s=t.editManifest[i];for(var o in s)s.hasOwnProperty(o)&&(r[o]=s[o]());var l=JSON.stringify(n)!==JSON.stringify(r);a.push({__idx:i,oldValue:n,newValue:r,hasChanged:l})}}),a}},{key:"_removeEditModeItems",value:function(t){var e=this;if(this.editManifest){var a=!1;t.forEach(function(t){e._isEditItem(t)&&(delete e.editManifest[t],a=!0)}),a&&(this.editManifest.itemIndexes=this.editManifest.itemIndexes.filter(function(e){return!t.includes(e)}),this._buildDataRows(!0))}}},{key:"_removeAllEditModeItems",value:function(){this.editManifest&&this._removeEditModeItems(this.editManifest.itemIndexes)}},{key:"__handleRowClick",value:function(t,e,a){var i=this._applyIndexes(e);if(!this._isEditItem(i.__idx)){var n=Array.from(this.$table.querySelectorAll(".selected"));n.forEach(function(t){t.classList.remove("selected")}),t.classList.add("selected"),this.selectedValue={rowData:i,rowIndex:a},this._raiseEvent("selection",this.selectedValue)}}},{key:"__handleCellClick",value:function(t,e,a,i,n){var r=this._applyIndexes(e);if(!this._isEditItem(r.__idx)){var s=Array.from(this.$table.querySelectorAll(".selected"));s.forEach(function(t){t.classList.remove("selected")}),t.parentNode.classList.add("selected"),t.classList.add("selected"),this.selectedValue={rowData:r,rowIndex:a,columnKey:i.key,columnIndex:n,cellData:e[i.key]},this._raiseEvent("selection",this.selectedValue)}}},{key:"_buildSearchArea",value:function(){var t=this;if(e._removeChildren(this.$searchArea),this.showSearch){this.$element.classList.add("has-search"),this.$searchArea.innerHTML='\n                    <div class="search-bar">\n                        <div class="search-box">\n                            <div class="input-group">\n                                <input type="text" class="form-control" placeholder="Search..." />\n                                <span class="input-group-btn">\n                                    <button class="btn btn-default search-button" type="button"><i class="fa fa-search"></i></button>                        \n                                </span>\n                            </div>\n                            <span class="clear-button">\n                                <i class="fa fa-remove"></i>\n                            </span>\n                        </div>\n                    </div>\n                ';var a=this.$searchArea.querySelector("input.form-control"),i=this.$searchArea.querySelector("button.search-button"),n=this.$searchArea.querySelector("span.clear-button");n.style.display="none";var r=function(){var e=a.value;t._changeSearch(e)};a.addEventListener("keyup",function(t){13===t.keyCode&&r(),n.style.display=0===a.value.length?"none":"inline"}),n.addEventListener("click",function(){a.value="",n.style.display="none",r()}),i.addEventListener("click",function(){r()})}else this.$element.classList.remove("has-search")}},{key:"_changeSearch",
value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.searchQuery=t,this.pageNumber=1,e&&this.showSearch){var a=this.$searchArea.querySelector("input.form-control");a&&(a.value=t)}this._buildDataRows()}},{key:"_searchLocal",value:function(t){var e=this,a=(this.searchQuery||"").trim().toUpperCase();if(a.length>0){var i={};this.model.cols.forEach(function(t){i[t.key]=t}),t=t.filter(function(t){for(var n in t)if(t.hasOwnProperty(n)){var r=i[n];if(r){var s=e._formatData(r,t[n]||"");if(s.toUpperCase().indexOf(a)>-1)return!0}}return!1})}return t}},{key:"_changeSort",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"switch",a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=Array.from(this.$table.querySelectorAll("th.sortable.sort-asc, th.sortable.sort-desc")),n="";null===t?i.forEach(function(t){return t.classList.remove("sort-asc","sort-desc")}):(n=t.getAttribute("key"),"switch"===e&&(e=t.classList.contains("sort-asc")?"desc":"asc"),i.forEach(function(t){return t.classList.remove("sort-asc","sort-desc")}),e&&"asc"===e.toString().toLowerCase()&&t.classList.add("sort-asc"),e&&"desc"===e.toString().toLowerCase()&&t.classList.add("sort-desc")),this.sortBy=n,this.sortDirection=e,a!==!0&&this._buildDataRows()}},{key:"_sortLocal",value:function(t){var a=this.sortBy,i="desc"===this.sortDirection,n=this.model.cols.find(function(t){return t.key===a});if(n&&n.sortable&&!n.isControls){switch((n.dataType||"").toLowerCase()){case"string":case"url":default:t.sort(function(t,e){var i=(t[a]||"").toString().toUpperCase(),n=(e[a]||"").toString().toUpperCase();return i.localeCompare(n)});break;case"number":t.sort(function(t,e){var i=t[a]||0,n=e[a]||0;return i<n?-1:i>n?1:0});break;case"date":case"datetime":t.sort(function(t,i){var n=void 0===t[a]||null===t[a]||""===t[a]?Number.MIN_SAFE_INTEGER:e._parseDate(t[a]).getTime(),r=void 0===i[a]||null===i[a]||""===i[a]?Number.MIN_SAFE_INTEGER:e._parseDate(i[a]).getTime();return isNaN(n)&&(n=Number.MIN_SAFE_INTEGER),isNaN(r)&&(r=Number.MIN_SAFE_INTEGER),n<r?-1:n>r?1:0});break;case"boolean":var r=function(t){return t===!0?0:t===!1?1:i?-1:2};t.sort(function(t,e){var i=r(t[a]),n=r(e[a]);return i<n?-1:i>n?1:0})}i&&t.reverse()}return t}},{key:"_buildPagination",value:function(){var t=this;if(e._removeChildren(this.$paginationArea),this.showPagination&&this.pageSize>0&&this.totalResults>0){this.$element.classList.add("has-pagination");var a=5,i=this._getTotalPages(),n=1,r=Math.min(a,i);if(i>a){var s=Math.ceil(a/2),o=s-1;this.pageNumber>s&&(n=this.pageNumber-o,r=this.pageNumber+o,r>i&&(r=i,n=r-a+1))}if(this.$paginationArea.innerHTML='\n                    <nav>\n                        <ul class="pagination pagination-sm"></ul>\n                    </nav>\n                ',i>1){var l=this.$paginationArea.querySelector(".pagination"),d=function(t){var e=t.html,a=t.active,i=void 0!==a&&a,n=t.enabled,r=void 0===n||n,s=t.handler,o=void 0===s?null:s,d=t.css,c=void 0===d?null:d,u=document.createElement("li");i&&u.classList.add("active"),r||u.classList.add("disabled"),c&&c.split(" ").forEach(function(t){return u.classList.add(t)});var h=document.createElement("a");return h.innerHTML=e,r&&"function"==typeof o&&h.addEventListener("click",o),u.appendChild(h),l.appendChild(u),h};d({html:'<span class="page-icon fa fa-step-backward"></span><span class="page-label"> First</span>',enabled:this.pageNumber>1,handler:function(){return t._changePage(1)},css:"page-first page-bookend"}),d({html:'<span class="page-icon fa fa-chevron-left"></span><span class="page-label"> Previous</span>',enabled:this.pageNumber>1,handler:function(){return t._changePage(t.pageNumber-1)},css:"page-prev page-bookend"});for(var c=function(e){d({html:'<span class="page-label">'+e+"</span>",active:t.pageNumber===e,handler:function(){return t._changePage(e)}})},u=n;u<=r;u++)c(u);d({html:'<span class="page-label">Next </span><span class="page-icon fa fa-chevron-right"></span>',enabled:this.pageNumber<i,handler:function(){return t._changePage(t.pageNumber+1)},css:"page-next page-bookend"}),d({html:'<span class="page-label">Last </span><span class="page-icon fa fa-step-forward"></span>',enabled:this.pageNumber<i,handler:function(){return t._changePage(i)},css:"page-last page-bookend"})}}else this.$element.classList.remove("has-pagination")}},{key:"_changePage",value:function(t){var e=this._getTotalPages();if(isNaN(t)||(t=parseInt(t)),"string"==typeof t)switch(t.toLowerCase()){case"first":t=1;break;case"previous":t=this.pageNumber-1;break;case"next":t=this.pageNumber+1;break;case"last":t=e}if("number"!=typeof t)throw new Error('Invalid page number: "'+t+'"');t<1&&(t=1),t>e&&e>0&&(t=e),this.pageNumber=t,this._buildDataRows(),this.fixedHeaders&&(this.$table.querySelector("tbody").scrollTop=0)}},{key:"_paginateLocal",value:function(t){if(0===this.pageSize)return t;this.totalResults=t.length;var e=this._getTotalPages();e>0&&(this.pageNumber<1&&(this.pageNumber=1),this.pageNumber>e&&(this.pageNumber=e));var a=this.pageSize*(this.pageNumber-1),i=a+this.pageSize;return t.slice(a,Math.min(i,this.totalResults))}},{key:"_getTotalPages",value:function(){return Math.ceil(this.totalResults/this.pageSize)}},{key:"_sendRequest",value:function(t,e,a){return new Promise(function(i,n){var r=(t||"GET").toUpperCase(),s=e,o=new XMLHttpRequest;if(o.onreadystatechange=function(){if(4===o.readyState)if(200===o.status){var t=JSON.parse(o.response.toString());i(t)}else n(0===o.status?"Could not access "+e:"Error code "+o.status+' on "'+e+'"')},o.onerror=function(){n("There was a problem accessing "+e)},"GET"===r){var l=s.indexOf("?")===-1?"?":"&";Object.keys(a).filter(function(t){return a[t]}).forEach(function(t){s+=""+l+t+"="+encodeURIComponent(a[t]),l="&"})}o.open(r,s,!0),"GET"===r?o.send():(o.setRequestHeader("Content-Type","application/json;charset=UTF-8"),o.send(JSON.stringify(a)))})}},{key:"_setData",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.model.data=t}},{key:"_applyIndexes",value:function(t){var e=t instanceof Array==!1;e&&(t=[t]);var a=JSON.parse(JSON.stringify(t)),i=this.localData||this.model.data||[];return t.forEach(function(t,e){var n=i.indexOf(t);n!==-1&&(a[e].__idx=n)}),e?a[0]:a}},{key:"_setLoading",value:function(t){t?(this.$element.classList.add("loading-data"),this.$loading.innerHTML='<div class="bg"></div><div class="spinner"></div>'):(this.$element.classList.remove("loading-data"),e._removeChildren(this.$loading))}},{key:"_setMessage",value:function(t,a,i){e._removeChildren(this.$tbody);var n=document.createElement("tr");this.$tbody.appendChild(n);var r=document.createElement("td");r.classList.add("message-"+t),r.setAttribute("colspan",this.model.cols.length.toString()),n.appendChild(r);var s=document.createElement("div");s.classList.add("content"),s.textContent=a,i&&(s.innerHTML+='<div class="message-detail">'+i+"</div>"),r.appendChild(s)}},{key:"_raiseEvent",value:function(t,e){var a=this,i=e?{detail:e}:null,n=new CustomEvent(t,i);setTimeout(function(){a.dispatchEvent(n)},0)}},{key:"setData",value:function(t){if(this.useDataSource)throw new Error("Cannot set data on a data grid which uses a data source");Array.isArray(t)&&(this.localData=t,this.unfilteredTotalResults=t.length,this.totalResults=t.length,this._setData(t),this._buildDataRows())}},{key:"getSearch",value:function(){return{query:this.searchQuery||"",totalResults:this.totalResults,unfilteredTotalResults:this.unfilteredTotalResults}}},{key:"setSearch",value:function(t){null===t&&(t=""),this._changeSearch(t,!0)}},{key:"getSort",value:function(){return{column:this.sortBy,direction:this.sortDirection}}},{key:"setSort",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"switch";if(null===t){var a=this.model.cols.find(function(t){return!!t.sort});a&&(t=a.key,e=a.sort)}if(t){var i=this.model.cols.filter(function(e){return e.key===t})[0];if(!i)throw new Error('Unable to sort by column "'+t+'" - data grid does not have a column with that key');if(!i.sortable)throw new Error('Unable to sort by column "'+t+'" - that column is not defined as sortable');var n=this.$table.querySelector('th[key="'+t+'"]');this._changeSort(n,e)}else this._changeSort(null)}},{key:"getPage",value:function(){if(!this.pageSize)return null;var t=this._getTotalPages();return{number:this.pageNumber,total:this._getTotalPages(),pageSize:this.pageSize,isFirst:1===this.pageNumber,hasPrevious:this.pageNumber>1,hasNext:this.pageNumber<t,isLast:this.pageNumber===t}}},{key:"setPage",value:function(t){if(!this.pageSize)throw new Error("Cannot change page on a data grid which doesn't use pagination");null===t&&(t=1),this._changePage(t)}},{key:"getVisibleData",value:function(){return this._applyIndexes(this.model.data||[])}},{key:"edit",value:function(t){var e=this;if(void 0===t||null===t)throw new Error("You must specify the indexes or items of data to put into edit mode");t instanceof Array==!1&&(t=[t]);var a=t.map(function(t){return"number"==typeof t?t:(e.localData||e.model.data||[]).indexOf(t)}).filter(function(t){return t!==-1});this._addEditModeItems(a)}},{key:"finishedEdit",value:function(){var t=this._getEditChanges();return this._removeAllEditModeItems(),t}},{key:"value",get:function(){return this.selectedValue}}],[{key:"_parseDate",value:function(t){var e=null;if(/[0-9]{4}-[0-9]{2}-[0-9]{2}/.test(t)){if(e=new Date(t),isNaN(e.valueOf())){var a=t.replace(/-/g,"/").replace("T"," ");e=new Date(a)}}else e=new Date(t);return!e||isNaN(e.valueOf())?null:e}},{key:"_renderDate",value:function(t){return!t||isNaN(t.valueOf())?"":new Date(t.getTime()+60*t.getTimezoneOffset()*1e3).toLocaleDateString("en-GB")}},{key:"_renderTime",value:function(t){return!t||isNaN(t.valueOf())?"":new Date(t.getTime()+60*t.getTimezoneOffset()*1e3).toLocaleTimeString("en-GB")}},{key:"_getProperty",value:function(t,e){e=e.replace(/\[(\w+)]/g,".$1").replace(/^\./,"");for(var a=t,i=e;a&&i.length>0;){var n=i.indexOf(".");if(n>-1){var r=i.substring(0,n);a=a[r],i=i.substring(n+1)}else a=a[i],i=""}return a}},{key:"_removeChildren",value:function(t){for(;t.firstChild;)t.removeChild(t.firstChild)}},{key:"observedAttributes",get:function(){return["data-source","data-source-method","data-source-page-param","data-source-page-size-param","data-source-search-param","data-source-sort-column-param","data-source-sort-direction-param","data-results-property","data-results-total-property","show-search","show-pagination","page-size","use-local-interaction","fixed-headers","row-css-key","selection-mode"]}}]),e}(HTMLElement))}();
"use strict";function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}!function(){customElements.define("ct-data-col",function(t){function e(t){var n,o;return _classCallCheck(this,e),t=n=_possibleConstructorReturn(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t)),o=t,_possibleConstructorReturn(n,o)}return _inherits(e,t),e}(HTMLElement))}();